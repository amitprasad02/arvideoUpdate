(function(){const eu=document.createElement("link").relList;if(eu&&eu.supports&&eu.supports("modulepreload"))return;for(const au of document.querySelectorAll('link[rel="modulepreload"]'))su(au);new MutationObserver(au=>{for(const uu of au)if(uu.type==="childList")for(const du of uu.addedNodes)du.tagName==="LINK"&&du.rel==="modulepreload"&&su(du)}).observe(document,{childList:!0,subtree:!0});function tu(au){const uu={};return au.integrity&&(uu.integrity=au.integrity),au.referrerPolicy&&(uu.referrerPolicy=au.referrerPolicy),au.crossOrigin==="use-credentials"?uu.credentials="include":au.crossOrigin==="anonymous"?uu.credentials="omit":uu.credentials="same-origin",uu}function su(au){if(au.ep)return;au.ep=!0;const uu=tu(au);fetch(au.href,uu)}})();var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$2=Symbol.for("react.element"),n$2=Symbol.for("react.portal"),p$3=Symbol.for("react.fragment"),q$2=Symbol.for("react.strict_mode"),r$1=Symbol.for("react.profiler"),t$1=Symbol.for("react.provider"),u$1=Symbol.for("react.context"),v$2=Symbol.for("react.forward_ref"),w$1=Symbol.for("react.suspense"),x$1=Symbol.for("react.memo"),y$1=Symbol.for("react.lazy"),z$2=Symbol.iterator;function A$2(iu){return iu===null||typeof iu!="object"?null:(iu=z$2&&iu[z$2]||iu["@@iterator"],typeof iu=="function"?iu:null)}var B$2={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$2=Object.assign,D$2={};function E$2(iu,eu,tu){this.props=iu,this.context=eu,this.refs=D$2,this.updater=tu||B$2}E$2.prototype.isReactComponent={};E$2.prototype.setState=function(iu,eu){if(typeof iu!="object"&&typeof iu!="function"&&iu!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,iu,eu,"setState")};E$2.prototype.forceUpdate=function(iu){this.updater.enqueueForceUpdate(this,iu,"forceUpdate")};function F$1(){}F$1.prototype=E$2.prototype;function G$2(iu,eu,tu){this.props=iu,this.context=eu,this.refs=D$2,this.updater=tu||B$2}var H$2=G$2.prototype=new F$1;H$2.constructor=G$2;C$2(H$2,E$2.prototype);H$2.isPureReactComponent=!0;var I$2=Array.isArray,J$1=Object.prototype.hasOwnProperty,K$2={current:null},L$2={key:!0,ref:!0,__self:!0,__source:!0};function M$2(iu,eu,tu){var su,au={},uu=null,du=null;if(eu!=null)for(su in eu.ref!==void 0&&(du=eu.ref),eu.key!==void 0&&(uu=""+eu.key),eu)J$1.call(eu,su)&&!L$2.hasOwnProperty(su)&&(au[su]=eu[su]);var fu=arguments.length-2;if(fu===1)au.children=tu;else if(1<fu){for(var gu=Array(fu),yu=0;yu<fu;yu++)gu[yu]=arguments[yu+2];au.children=gu}if(iu&&iu.defaultProps)for(su in fu=iu.defaultProps,fu)au[su]===void 0&&(au[su]=fu[su]);return{$$typeof:l$2,type:iu,key:uu,ref:du,props:au,_owner:K$2.current}}function N$2(iu,eu){return{$$typeof:l$2,type:iu.type,key:eu,ref:iu.ref,props:iu.props,_owner:iu._owner}}function O$2(iu){return typeof iu=="object"&&iu!==null&&iu.$$typeof===l$2}function escape$1(iu){var eu={"=":"=0",":":"=2"};return"$"+iu.replace(/[=:]/g,function(tu){return eu[tu]})}var P$2=/\/+/g;function Q$2(iu,eu){return typeof iu=="object"&&iu!==null&&iu.key!=null?escape$1(""+iu.key):eu.toString(36)}function R$2(iu,eu,tu,su,au){var uu=typeof iu;(uu==="undefined"||uu==="boolean")&&(iu=null);var du=!1;if(iu===null)du=!0;else switch(uu){case"string":case"number":du=!0;break;case"object":switch(iu.$$typeof){case l$2:case n$2:du=!0}}if(du)return du=iu,au=au(du),iu=su===""?"."+Q$2(du,0):su,I$2(au)?(tu="",iu!=null&&(tu=iu.replace(P$2,"$&/")+"/"),R$2(au,eu,tu,"",function(yu){return yu})):au!=null&&(O$2(au)&&(au=N$2(au,tu+(!au.key||du&&du.key===au.key?"":(""+au.key).replace(P$2,"$&/")+"/")+iu)),eu.push(au)),1;if(du=0,su=su===""?".":su+":",I$2(iu))for(var fu=0;fu<iu.length;fu++){uu=iu[fu];var gu=su+Q$2(uu,fu);du+=R$2(uu,eu,tu,gu,au)}else if(gu=A$2(iu),typeof gu=="function")for(iu=gu.call(iu),fu=0;!(uu=iu.next()).done;)uu=uu.value,gu=su+Q$2(uu,fu++),du+=R$2(uu,eu,tu,gu,au);else if(uu==="object")throw eu=String(iu),Error("Objects are not valid as a React child (found: "+(eu==="[object Object]"?"object with keys {"+Object.keys(iu).join(", ")+"}":eu)+"). If you meant to render a collection of children, use an array instead.");return du}function S$2(iu,eu,tu){if(iu==null)return iu;var su=[],au=0;return R$2(iu,su,"","",function(uu){return eu.call(tu,uu,au++)}),su}function T$2(iu){if(iu._status===-1){var eu=iu._result;eu=eu(),eu.then(function(tu){(iu._status===0||iu._status===-1)&&(iu._status=1,iu._result=tu)},function(tu){(iu._status===0||iu._status===-1)&&(iu._status=2,iu._result=tu)}),iu._status===-1&&(iu._status=0,iu._result=eu)}if(iu._status===1)return iu._result.default;throw iu._result}var U$2={current:null},V$2={transition:null},W$2={ReactCurrentDispatcher:U$2,ReactCurrentBatchConfig:V$2,ReactCurrentOwner:K$2};function X$2(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$2,forEach:function(iu,eu,tu){S$2(iu,function(){eu.apply(this,arguments)},tu)},count:function(iu){var eu=0;return S$2(iu,function(){eu++}),eu},toArray:function(iu){return S$2(iu,function(eu){return eu})||[]},only:function(iu){if(!O$2(iu))throw Error("React.Children.only expected to receive a single React element child.");return iu}};react_production_min.Component=E$2;react_production_min.Fragment=p$3;react_production_min.Profiler=r$1;react_production_min.PureComponent=G$2;react_production_min.StrictMode=q$2;react_production_min.Suspense=w$1;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$2;react_production_min.act=X$2;react_production_min.cloneElement=function(iu,eu,tu){if(iu==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+iu+".");var su=C$2({},iu.props),au=iu.key,uu=iu.ref,du=iu._owner;if(eu!=null){if(eu.ref!==void 0&&(uu=eu.ref,du=K$2.current),eu.key!==void 0&&(au=""+eu.key),iu.type&&iu.type.defaultProps)var fu=iu.type.defaultProps;for(gu in eu)J$1.call(eu,gu)&&!L$2.hasOwnProperty(gu)&&(su[gu]=eu[gu]===void 0&&fu!==void 0?fu[gu]:eu[gu])}var gu=arguments.length-2;if(gu===1)su.children=tu;else if(1<gu){fu=Array(gu);for(var yu=0;yu<gu;yu++)fu[yu]=arguments[yu+2];su.children=fu}return{$$typeof:l$2,type:iu.type,key:au,ref:uu,props:su,_owner:du}};react_production_min.createContext=function(iu){return iu={$$typeof:u$1,_currentValue:iu,_currentValue2:iu,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},iu.Provider={$$typeof:t$1,_context:iu},iu.Consumer=iu};react_production_min.createElement=M$2;react_production_min.createFactory=function(iu){var eu=M$2.bind(null,iu);return eu.type=iu,eu};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(iu){return{$$typeof:v$2,render:iu}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(iu){return{$$typeof:y$1,_payload:{_status:-1,_result:iu},_init:T$2}};react_production_min.memo=function(iu,eu){return{$$typeof:x$1,type:iu,compare:eu===void 0?null:eu}};react_production_min.startTransition=function(iu){var eu=V$2.transition;V$2.transition={};try{iu()}finally{V$2.transition=eu}};react_production_min.unstable_act=X$2;react_production_min.useCallback=function(iu,eu){return U$2.current.useCallback(iu,eu)};react_production_min.useContext=function(iu){return U$2.current.useContext(iu)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(iu){return U$2.current.useDeferredValue(iu)};react_production_min.useEffect=function(iu,eu){return U$2.current.useEffect(iu,eu)};react_production_min.useId=function(){return U$2.current.useId()};react_production_min.useImperativeHandle=function(iu,eu,tu){return U$2.current.useImperativeHandle(iu,eu,tu)};react_production_min.useInsertionEffect=function(iu,eu){return U$2.current.useInsertionEffect(iu,eu)};react_production_min.useLayoutEffect=function(iu,eu){return U$2.current.useLayoutEffect(iu,eu)};react_production_min.useMemo=function(iu,eu){return U$2.current.useMemo(iu,eu)};react_production_min.useReducer=function(iu,eu,tu){return U$2.current.useReducer(iu,eu,tu)};react_production_min.useRef=function(iu){return U$2.current.useRef(iu)};react_production_min.useState=function(iu){return U$2.current.useState(iu)};react_production_min.useSyncExternalStore=function(iu,eu,tu){return U$2.current.useSyncExternalStore(iu,eu,tu)};react_production_min.useTransition=function(){return U$2.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f$1=reactExports,k$1=Symbol.for("react.element"),l$1=Symbol.for("react.fragment"),m$2=Object.prototype.hasOwnProperty,n$1=f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$2={key:!0,ref:!0,__self:!0,__source:!0};function q$1(iu,eu,tu){var su,au={},uu=null,du=null;tu!==void 0&&(uu=""+tu),eu.key!==void 0&&(uu=""+eu.key),eu.ref!==void 0&&(du=eu.ref);for(su in eu)m$2.call(eu,su)&&!p$2.hasOwnProperty(su)&&(au[su]=eu[su]);if(iu&&iu.defaultProps)for(su in eu=iu.defaultProps,eu)au[su]===void 0&&(au[su]=eu[su]);return{$$typeof:k$1,type:iu,key:uu,ref:du,props:au,_owner:n$1.current}}reactJsxRuntime_production_min.Fragment=l$1;reactJsxRuntime_production_min.jsx=q$1;reactJsxRuntime_production_min.jsxs=q$1;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,reactDom={exports:{}},reactDom_production_min={},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(iu){function eu(dp,Rp){var xp=dp.length;dp.push(Rp);e:for(;0<xp;){var cm=xp-1>>>1,lm=dp[cm];if(0<au(lm,Rp))dp[cm]=Rp,dp[xp]=lm,xp=cm;else break e}}function tu(dp){return dp.length===0?null:dp[0]}function su(dp){if(dp.length===0)return null;var Rp=dp[0],xp=dp.pop();if(xp!==Rp){dp[0]=xp;e:for(var cm=0,lm=dp.length,vp=lm>>>1;cm<vp;){var bp=2*(cm+1)-1,kp=dp[bp],dm=bp+1,nm=dp[dm];if(0>au(kp,xp))dm<lm&&0>au(nm,kp)?(dp[cm]=nm,dp[dm]=xp,cm=dm):(dp[cm]=kp,dp[bp]=xp,cm=bp);else if(dm<lm&&0>au(nm,xp))dp[cm]=nm,dp[dm]=xp,cm=dm;else break e}}return Rp}function au(dp,Rp){var xp=dp.sortIndex-Rp.sortIndex;return xp!==0?xp:dp.id-Rp.id}if(typeof performance=="object"&&typeof performance.now=="function"){var uu=performance;iu.unstable_now=function(){return uu.now()}}else{var du=Date,fu=du.now();iu.unstable_now=function(){return du.now()-fu}}var gu=[],yu=[],xu=1,vu=null,Su=3,Iu=!1,Mu=!1,ku=!1,Bu=typeof setTimeout=="function"?setTimeout:null,_u=typeof clearTimeout=="function"?clearTimeout:null,Lu=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function Du(dp){for(var Rp=tu(yu);Rp!==null;){if(Rp.callback===null)su(yu);else if(Rp.startTime<=dp)su(yu),Rp.sortIndex=Rp.expirationTime,eu(gu,Rp);else break;Rp=tu(yu)}}function Ou(dp){if(ku=!1,Du(dp),!Mu)if(tu(gu)!==null)Mu=!0,wp(Wu);else{var Rp=tu(yu);Rp!==null&&Dp(Ou,Rp.startTime-dp)}}function Wu(dp,Rp){Mu=!1,ku&&(ku=!1,_u(Yu),Yu=-1),Iu=!0;var xp=Su;try{for(Du(Rp),vu=tu(gu);vu!==null&&(!(vu.expirationTime>Rp)||dp&&!tp());){var cm=vu.callback;if(typeof cm=="function"){vu.callback=null,Su=vu.priorityLevel;var lm=cm(vu.expirationTime<=Rp);Rp=iu.unstable_now(),typeof lm=="function"?vu.callback=lm:vu===tu(gu)&&su(gu),Du(Rp)}else su(gu);vu=tu(gu)}if(vu!==null)var vp=!0;else{var bp=tu(yu);bp!==null&&Dp(Ou,bp.startTime-Rp),vp=!1}return vp}finally{vu=null,Su=xp,Iu=!1}}var Zu=!1,Hu=null,Yu=-1,Ku=5,ju=-1;function tp(){return!(iu.unstable_now()-ju<Ku)}function gp(){if(Hu!==null){var dp=iu.unstable_now();ju=dp;var Rp=!0;try{Rp=Hu(!0,dp)}finally{Rp?yp():(Zu=!1,Hu=null)}}else Zu=!1}var yp;if(typeof Lu=="function")yp=function(){Lu(gp)};else if(typeof MessageChannel<"u"){var Cp=new MessageChannel,Hp=Cp.port2;Cp.port1.onmessage=gp,yp=function(){Hp.postMessage(null)}}else yp=function(){Bu(gp,0)};function wp(dp){Hu=dp,Zu||(Zu=!0,yp())}function Dp(dp,Rp){Yu=Bu(function(){dp(iu.unstable_now())},Rp)}iu.unstable_IdlePriority=5,iu.unstable_ImmediatePriority=1,iu.unstable_LowPriority=4,iu.unstable_NormalPriority=3,iu.unstable_Profiling=null,iu.unstable_UserBlockingPriority=2,iu.unstable_cancelCallback=function(dp){dp.callback=null},iu.unstable_continueExecution=function(){Mu||Iu||(Mu=!0,wp(Wu))},iu.unstable_forceFrameRate=function(dp){0>dp||125<dp?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Ku=0<dp?Math.floor(1e3/dp):5},iu.unstable_getCurrentPriorityLevel=function(){return Su},iu.unstable_getFirstCallbackNode=function(){return tu(gu)},iu.unstable_next=function(dp){switch(Su){case 1:case 2:case 3:var Rp=3;break;default:Rp=Su}var xp=Su;Su=Rp;try{return dp()}finally{Su=xp}},iu.unstable_pauseExecution=function(){},iu.unstable_requestPaint=function(){},iu.unstable_runWithPriority=function(dp,Rp){switch(dp){case 1:case 2:case 3:case 4:case 5:break;default:dp=3}var xp=Su;Su=dp;try{return Rp()}finally{Su=xp}},iu.unstable_scheduleCallback=function(dp,Rp,xp){var cm=iu.unstable_now();switch(typeof xp=="object"&&xp!==null?(xp=xp.delay,xp=typeof xp=="number"&&0<xp?cm+xp:cm):xp=cm,dp){case 1:var lm=-1;break;case 2:lm=250;break;case 5:lm=1073741823;break;case 4:lm=1e4;break;default:lm=5e3}return lm=xp+lm,dp={id:xu++,callback:Rp,priorityLevel:dp,startTime:xp,expirationTime:lm,sortIndex:-1},xp>cm?(dp.sortIndex=xp,eu(yu,dp),tu(gu)===null&&dp===tu(yu)&&(ku?(_u(Yu),Yu=-1):ku=!0,Dp(Ou,xp-cm))):(dp.sortIndex=lm,eu(gu,dp),Mu||Iu||(Mu=!0,wp(Wu))),dp},iu.unstable_shouldYield=tp,iu.unstable_wrapCallback=function(dp){var Rp=Su;return function(){var xp=Su;Su=Rp;try{return dp.apply(this,arguments)}finally{Su=xp}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa$1=reactExports,ca$1=schedulerExports;function p$1(iu){for(var eu="https://reactjs.org/docs/error-decoder.html?invariant="+iu,tu=1;tu<arguments.length;tu++)eu+="&args[]="+encodeURIComponent(arguments[tu]);return"Minified React error #"+iu+"; visit "+eu+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da$1=new Set,ea$1={};function fa$1(iu,eu){ha$1(iu,eu),ha$1(iu+"Capture",eu)}function ha$1(iu,eu){for(ea$1[iu]=eu,iu=0;iu<eu.length;iu++)da$1.add(eu[iu])}var ia$1=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja$1=Object.prototype.hasOwnProperty,ka$1=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la$1={},ma$1={};function oa$1(iu){return ja$1.call(ma$1,iu)?!0:ja$1.call(la$1,iu)?!1:ka$1.test(iu)?ma$1[iu]=!0:(la$1[iu]=!0,!1)}function pa$1(iu,eu,tu,su){if(tu!==null&&tu.type===0)return!1;switch(typeof eu){case"function":case"symbol":return!0;case"boolean":return su?!1:tu!==null?!tu.acceptsBooleans:(iu=iu.toLowerCase().slice(0,5),iu!=="data-"&&iu!=="aria-");default:return!1}}function qa$1(iu,eu,tu,su){if(eu===null||typeof eu>"u"||pa$1(iu,eu,tu,su))return!0;if(su)return!1;if(tu!==null)switch(tu.type){case 3:return!eu;case 4:return eu===!1;case 5:return isNaN(eu);case 6:return isNaN(eu)||1>eu}return!1}function v$1(iu,eu,tu,su,au,uu,du){this.acceptsBooleans=eu===2||eu===3||eu===4,this.attributeName=su,this.attributeNamespace=au,this.mustUseProperty=tu,this.propertyName=iu,this.type=eu,this.sanitizeURL=uu,this.removeEmptyString=du}var z$1={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(iu){z$1[iu]=new v$1(iu,0,!1,iu,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(iu){var eu=iu[0];z$1[eu]=new v$1(eu,1,!1,iu[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(iu){z$1[iu]=new v$1(iu,2,!1,iu.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(iu){z$1[iu]=new v$1(iu,2,!1,iu,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(iu){z$1[iu]=new v$1(iu,3,!1,iu.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(iu){z$1[iu]=new v$1(iu,3,!0,iu,null,!1,!1)});["capture","download"].forEach(function(iu){z$1[iu]=new v$1(iu,4,!1,iu,null,!1,!1)});["cols","rows","size","span"].forEach(function(iu){z$1[iu]=new v$1(iu,6,!1,iu,null,!1,!1)});["rowSpan","start"].forEach(function(iu){z$1[iu]=new v$1(iu,5,!1,iu.toLowerCase(),null,!1,!1)});var ra$1=/[\-:]([a-z])/g;function sa$1(iu){return iu[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(iu){var eu=iu.replace(ra$1,sa$1);z$1[eu]=new v$1(eu,1,!1,iu,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(iu){var eu=iu.replace(ra$1,sa$1);z$1[eu]=new v$1(eu,1,!1,iu,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(iu){var eu=iu.replace(ra$1,sa$1);z$1[eu]=new v$1(eu,1,!1,iu,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(iu){z$1[iu]=new v$1(iu,1,!1,iu.toLowerCase(),null,!1,!1)});z$1.xlinkHref=new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(iu){z$1[iu]=new v$1(iu,1,!1,iu.toLowerCase(),null,!0,!0)});function ta$1(iu,eu,tu,su){var au=z$1.hasOwnProperty(eu)?z$1[eu]:null;(au!==null?au.type!==0:su||!(2<eu.length)||eu[0]!=="o"&&eu[0]!=="O"||eu[1]!=="n"&&eu[1]!=="N")&&(qa$1(eu,tu,au,su)&&(tu=null),su||au===null?oa$1(eu)&&(tu===null?iu.removeAttribute(eu):iu.setAttribute(eu,""+tu)):au.mustUseProperty?iu[au.propertyName]=tu===null?au.type===3?!1:"":tu:(eu=au.attributeName,su=au.attributeNamespace,tu===null?iu.removeAttribute(eu):(au=au.type,tu=au===3||au===4&&tu===!0?"":""+tu,su?iu.setAttributeNS(su,eu,tu):iu.setAttribute(eu,tu))))}var ua$1=aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va$1=Symbol.for("react.element"),wa$1=Symbol.for("react.portal"),ya$1=Symbol.for("react.fragment"),za$1=Symbol.for("react.strict_mode"),Aa$1=Symbol.for("react.profiler"),Ba$1=Symbol.for("react.provider"),Ca$1=Symbol.for("react.context"),Da$1=Symbol.for("react.forward_ref"),Ea$1=Symbol.for("react.suspense"),Fa$1=Symbol.for("react.suspense_list"),Ga$1=Symbol.for("react.memo"),Ha$1=Symbol.for("react.lazy"),Ia$1=Symbol.for("react.offscreen"),Ja$1=Symbol.iterator;function Ka$1(iu){return iu===null||typeof iu!="object"?null:(iu=Ja$1&&iu[Ja$1]||iu["@@iterator"],typeof iu=="function"?iu:null)}var A$1=Object.assign,La$1;function Ma$1(iu){if(La$1===void 0)try{throw Error()}catch(tu){var eu=tu.stack.trim().match(/\n( *(at )?)/);La$1=eu&&eu[1]||""}return`
`+La$1+iu}var Na$1=!1;function Oa$1(iu,eu){if(!iu||Na$1)return"";Na$1=!0;var tu=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(eu)if(eu=function(){throw Error()},Object.defineProperty(eu.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(eu,[])}catch(yu){var su=yu}Reflect.construct(iu,[],eu)}else{try{eu.call()}catch(yu){su=yu}iu.call(eu.prototype)}else{try{throw Error()}catch(yu){su=yu}iu()}}catch(yu){if(yu&&su&&typeof yu.stack=="string"){for(var au=yu.stack.split(`
`),uu=su.stack.split(`
`),du=au.length-1,fu=uu.length-1;1<=du&&0<=fu&&au[du]!==uu[fu];)fu--;for(;1<=du&&0<=fu;du--,fu--)if(au[du]!==uu[fu]){if(du!==1||fu!==1)do if(du--,fu--,0>fu||au[du]!==uu[fu]){var gu=`
`+au[du].replace(" at new "," at ");return iu.displayName&&gu.includes("<anonymous>")&&(gu=gu.replace("<anonymous>",iu.displayName)),gu}while(1<=du&&0<=fu);break}}}finally{Na$1=!1,Error.prepareStackTrace=tu}return(iu=iu?iu.displayName||iu.name:"")?Ma$1(iu):""}function Pa$1(iu){switch(iu.tag){case 5:return Ma$1(iu.type);case 16:return Ma$1("Lazy");case 13:return Ma$1("Suspense");case 19:return Ma$1("SuspenseList");case 0:case 2:case 15:return iu=Oa$1(iu.type,!1),iu;case 11:return iu=Oa$1(iu.type.render,!1),iu;case 1:return iu=Oa$1(iu.type,!0),iu;default:return""}}function Qa$1(iu){if(iu==null)return null;if(typeof iu=="function")return iu.displayName||iu.name||null;if(typeof iu=="string")return iu;switch(iu){case ya$1:return"Fragment";case wa$1:return"Portal";case Aa$1:return"Profiler";case za$1:return"StrictMode";case Ea$1:return"Suspense";case Fa$1:return"SuspenseList"}if(typeof iu=="object")switch(iu.$$typeof){case Ca$1:return(iu.displayName||"Context")+".Consumer";case Ba$1:return(iu._context.displayName||"Context")+".Provider";case Da$1:var eu=iu.render;return iu=iu.displayName,iu||(iu=eu.displayName||eu.name||"",iu=iu!==""?"ForwardRef("+iu+")":"ForwardRef"),iu;case Ga$1:return eu=iu.displayName||null,eu!==null?eu:Qa$1(iu.type)||"Memo";case Ha$1:eu=iu._payload,iu=iu._init;try{return Qa$1(iu(eu))}catch{}}return null}function Ra$1(iu){var eu=iu.type;switch(iu.tag){case 24:return"Cache";case 9:return(eu.displayName||"Context")+".Consumer";case 10:return(eu._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return iu=eu.render,iu=iu.displayName||iu.name||"",eu.displayName||(iu!==""?"ForwardRef("+iu+")":"ForwardRef");case 7:return"Fragment";case 5:return eu;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa$1(eu);case 8:return eu===za$1?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof eu=="function")return eu.displayName||eu.name||null;if(typeof eu=="string")return eu}return null}function Sa$1(iu){switch(typeof iu){case"boolean":case"number":case"string":case"undefined":return iu;case"object":return iu;default:return""}}function Ta$1(iu){var eu=iu.type;return(iu=iu.nodeName)&&iu.toLowerCase()==="input"&&(eu==="checkbox"||eu==="radio")}function Ua$1(iu){var eu=Ta$1(iu)?"checked":"value",tu=Object.getOwnPropertyDescriptor(iu.constructor.prototype,eu),su=""+iu[eu];if(!iu.hasOwnProperty(eu)&&typeof tu<"u"&&typeof tu.get=="function"&&typeof tu.set=="function"){var au=tu.get,uu=tu.set;return Object.defineProperty(iu,eu,{configurable:!0,get:function(){return au.call(this)},set:function(du){su=""+du,uu.call(this,du)}}),Object.defineProperty(iu,eu,{enumerable:tu.enumerable}),{getValue:function(){return su},setValue:function(du){su=""+du},stopTracking:function(){iu._valueTracker=null,delete iu[eu]}}}}function Va$1(iu){iu._valueTracker||(iu._valueTracker=Ua$1(iu))}function Wa$1(iu){if(!iu)return!1;var eu=iu._valueTracker;if(!eu)return!0;var tu=eu.getValue(),su="";return iu&&(su=Ta$1(iu)?iu.checked?"true":"false":iu.value),iu=su,iu!==tu?(eu.setValue(iu),!0):!1}function Xa$1(iu){if(iu=iu||(typeof document<"u"?document:void 0),typeof iu>"u")return null;try{return iu.activeElement||iu.body}catch{return iu.body}}function Ya$1(iu,eu){var tu=eu.checked;return A$1({},eu,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:tu??iu._wrapperState.initialChecked})}function Za$1(iu,eu){var tu=eu.defaultValue==null?"":eu.defaultValue,su=eu.checked!=null?eu.checked:eu.defaultChecked;tu=Sa$1(eu.value!=null?eu.value:tu),iu._wrapperState={initialChecked:su,initialValue:tu,controlled:eu.type==="checkbox"||eu.type==="radio"?eu.checked!=null:eu.value!=null}}function ab(iu,eu){eu=eu.checked,eu!=null&&ta$1(iu,"checked",eu,!1)}function bb(iu,eu){ab(iu,eu);var tu=Sa$1(eu.value),su=eu.type;if(tu!=null)su==="number"?(tu===0&&iu.value===""||iu.value!=tu)&&(iu.value=""+tu):iu.value!==""+tu&&(iu.value=""+tu);else if(su==="submit"||su==="reset"){iu.removeAttribute("value");return}eu.hasOwnProperty("value")?cb(iu,eu.type,tu):eu.hasOwnProperty("defaultValue")&&cb(iu,eu.type,Sa$1(eu.defaultValue)),eu.checked==null&&eu.defaultChecked!=null&&(iu.defaultChecked=!!eu.defaultChecked)}function db(iu,eu,tu){if(eu.hasOwnProperty("value")||eu.hasOwnProperty("defaultValue")){var su=eu.type;if(!(su!=="submit"&&su!=="reset"||eu.value!==void 0&&eu.value!==null))return;eu=""+iu._wrapperState.initialValue,tu||eu===iu.value||(iu.value=eu),iu.defaultValue=eu}tu=iu.name,tu!==""&&(iu.name=""),iu.defaultChecked=!!iu._wrapperState.initialChecked,tu!==""&&(iu.name=tu)}function cb(iu,eu,tu){(eu!=="number"||Xa$1(iu.ownerDocument)!==iu)&&(tu==null?iu.defaultValue=""+iu._wrapperState.initialValue:iu.defaultValue!==""+tu&&(iu.defaultValue=""+tu))}var eb=Array.isArray;function fb(iu,eu,tu,su){if(iu=iu.options,eu){eu={};for(var au=0;au<tu.length;au++)eu["$"+tu[au]]=!0;for(tu=0;tu<iu.length;tu++)au=eu.hasOwnProperty("$"+iu[tu].value),iu[tu].selected!==au&&(iu[tu].selected=au),au&&su&&(iu[tu].defaultSelected=!0)}else{for(tu=""+Sa$1(tu),eu=null,au=0;au<iu.length;au++){if(iu[au].value===tu){iu[au].selected=!0,su&&(iu[au].defaultSelected=!0);return}eu!==null||iu[au].disabled||(eu=iu[au])}eu!==null&&(eu.selected=!0)}}function gb(iu,eu){if(eu.dangerouslySetInnerHTML!=null)throw Error(p$1(91));return A$1({},eu,{value:void 0,defaultValue:void 0,children:""+iu._wrapperState.initialValue})}function hb(iu,eu){var tu=eu.value;if(tu==null){if(tu=eu.children,eu=eu.defaultValue,tu!=null){if(eu!=null)throw Error(p$1(92));if(eb(tu)){if(1<tu.length)throw Error(p$1(93));tu=tu[0]}eu=tu}eu==null&&(eu=""),tu=eu}iu._wrapperState={initialValue:Sa$1(tu)}}function ib(iu,eu){var tu=Sa$1(eu.value),su=Sa$1(eu.defaultValue);tu!=null&&(tu=""+tu,tu!==iu.value&&(iu.value=tu),eu.defaultValue==null&&iu.defaultValue!==tu&&(iu.defaultValue=tu)),su!=null&&(iu.defaultValue=""+su)}function jb(iu){var eu=iu.textContent;eu===iu._wrapperState.initialValue&&eu!==""&&eu!==null&&(iu.value=eu)}function kb(iu){switch(iu){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb(iu,eu){return iu==null||iu==="http://www.w3.org/1999/xhtml"?kb(eu):iu==="http://www.w3.org/2000/svg"&&eu==="foreignObject"?"http://www.w3.org/1999/xhtml":iu}var mb,nb=function(iu){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(eu,tu,su,au){MSApp.execUnsafeLocalFunction(function(){return iu(eu,tu,su,au)})}:iu}(function(iu,eu){if(iu.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in iu)iu.innerHTML=eu;else{for(mb=mb||document.createElement("div"),mb.innerHTML="<svg>"+eu.valueOf().toString()+"</svg>",eu=mb.firstChild;iu.firstChild;)iu.removeChild(iu.firstChild);for(;eu.firstChild;)iu.appendChild(eu.firstChild)}});function ob(iu,eu){if(eu){var tu=iu.firstChild;if(tu&&tu===iu.lastChild&&tu.nodeType===3){tu.nodeValue=eu;return}}iu.textContent=eu}var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(iu){qb.forEach(function(eu){eu=eu+iu.charAt(0).toUpperCase()+iu.substring(1),pb[eu]=pb[iu]})});function rb(iu,eu,tu){return eu==null||typeof eu=="boolean"||eu===""?"":tu||typeof eu!="number"||eu===0||pb.hasOwnProperty(iu)&&pb[iu]?(""+eu).trim():eu+"px"}function sb(iu,eu){iu=iu.style;for(var tu in eu)if(eu.hasOwnProperty(tu)){var su=tu.indexOf("--")===0,au=rb(tu,eu[tu],su);tu==="float"&&(tu="cssFloat"),su?iu.setProperty(tu,au):iu[tu]=au}}var tb=A$1({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub(iu,eu){if(eu){if(tb[iu]&&(eu.children!=null||eu.dangerouslySetInnerHTML!=null))throw Error(p$1(137,iu));if(eu.dangerouslySetInnerHTML!=null){if(eu.children!=null)throw Error(p$1(60));if(typeof eu.dangerouslySetInnerHTML!="object"||!("__html"in eu.dangerouslySetInnerHTML))throw Error(p$1(61))}if(eu.style!=null&&typeof eu.style!="object")throw Error(p$1(62))}}function vb(iu,eu){if(iu.indexOf("-")===-1)return typeof eu.is=="string";switch(iu){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb=null;function xb(iu){return iu=iu.target||iu.srcElement||window,iu.correspondingUseElement&&(iu=iu.correspondingUseElement),iu.nodeType===3?iu.parentNode:iu}var yb=null,zb=null,Ab=null;function Bb(iu){if(iu=Cb(iu)){if(typeof yb!="function")throw Error(p$1(280));var eu=iu.stateNode;eu&&(eu=Db(eu),yb(iu.stateNode,iu.type,eu))}}function Eb(iu){zb?Ab?Ab.push(iu):Ab=[iu]:zb=iu}function Fb(){if(zb){var iu=zb,eu=Ab;if(Ab=zb=null,Bb(iu),eu)for(iu=0;iu<eu.length;iu++)Bb(eu[iu])}}function Gb(iu,eu){return iu(eu)}function Hb(){}var Ib=!1;function Jb(iu,eu,tu){if(Ib)return iu(eu,tu);Ib=!0;try{return Gb(iu,eu,tu)}finally{Ib=!1,(zb!==null||Ab!==null)&&(Hb(),Fb())}}function Kb(iu,eu){var tu=iu.stateNode;if(tu===null)return null;var su=Db(tu);if(su===null)return null;tu=su[eu];e:switch(eu){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(su=!su.disabled)||(iu=iu.type,su=!(iu==="button"||iu==="input"||iu==="select"||iu==="textarea")),iu=!su;break e;default:iu=!1}if(iu)return null;if(tu&&typeof tu!="function")throw Error(p$1(231,eu,typeof tu));return tu}var Lb=!1;if(ia$1)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}}),window.addEventListener("test",Mb,Mb),window.removeEventListener("test",Mb,Mb)}catch{Lb=!1}function Nb(iu,eu,tu,su,au,uu,du,fu,gu){var yu=Array.prototype.slice.call(arguments,3);try{eu.apply(tu,yu)}catch(xu){this.onError(xu)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(iu){Ob=!0,Pb=iu}};function Tb(iu,eu,tu,su,au,uu,du,fu,gu){Ob=!1,Pb=null,Nb.apply(Sb,arguments)}function Ub(iu,eu,tu,su,au,uu,du,fu,gu){if(Tb.apply(this,arguments),Ob){if(Ob){var yu=Pb;Ob=!1,Pb=null}else throw Error(p$1(198));Qb||(Qb=!0,Rb=yu)}}function Vb(iu){var eu=iu,tu=iu;if(iu.alternate)for(;eu.return;)eu=eu.return;else{iu=eu;do eu=iu,eu.flags&4098&&(tu=eu.return),iu=eu.return;while(iu)}return eu.tag===3?tu:null}function Wb(iu){if(iu.tag===13){var eu=iu.memoizedState;if(eu===null&&(iu=iu.alternate,iu!==null&&(eu=iu.memoizedState)),eu!==null)return eu.dehydrated}return null}function Xb(iu){if(Vb(iu)!==iu)throw Error(p$1(188))}function Yb(iu){var eu=iu.alternate;if(!eu){if(eu=Vb(iu),eu===null)throw Error(p$1(188));return eu!==iu?null:iu}for(var tu=iu,su=eu;;){var au=tu.return;if(au===null)break;var uu=au.alternate;if(uu===null){if(su=au.return,su!==null){tu=su;continue}break}if(au.child===uu.child){for(uu=au.child;uu;){if(uu===tu)return Xb(au),iu;if(uu===su)return Xb(au),eu;uu=uu.sibling}throw Error(p$1(188))}if(tu.return!==su.return)tu=au,su=uu;else{for(var du=!1,fu=au.child;fu;){if(fu===tu){du=!0,tu=au,su=uu;break}if(fu===su){du=!0,su=au,tu=uu;break}fu=fu.sibling}if(!du){for(fu=uu.child;fu;){if(fu===tu){du=!0,tu=uu,su=au;break}if(fu===su){du=!0,su=uu,tu=au;break}fu=fu.sibling}if(!du)throw Error(p$1(189))}}if(tu.alternate!==su)throw Error(p$1(190))}if(tu.tag!==3)throw Error(p$1(188));return tu.stateNode.current===tu?iu:eu}function Zb(iu){return iu=Yb(iu),iu!==null?$b(iu):null}function $b(iu){if(iu.tag===5||iu.tag===6)return iu;for(iu=iu.child;iu!==null;){var eu=$b(iu);if(eu!==null)return eu;iu=iu.sibling}return null}var ac$1=ca$1.unstable_scheduleCallback,bc$1=ca$1.unstable_cancelCallback,cc$1=ca$1.unstable_shouldYield,dc$1=ca$1.unstable_requestPaint,B$1=ca$1.unstable_now,ec$1=ca$1.unstable_getCurrentPriorityLevel,fc$1=ca$1.unstable_ImmediatePriority,gc$1=ca$1.unstable_UserBlockingPriority,hc$1=ca$1.unstable_NormalPriority,ic$1=ca$1.unstable_LowPriority,jc$1=ca$1.unstable_IdlePriority,kc$1=null,lc$1=null;function mc$1(iu){if(lc$1&&typeof lc$1.onCommitFiberRoot=="function")try{lc$1.onCommitFiberRoot(kc$1,iu,void 0,(iu.current.flags&128)===128)}catch{}}var oc$1=Math.clz32?Math.clz32:nc$1,pc$1=Math.log,qc$1=Math.LN2;function nc$1(iu){return iu>>>=0,iu===0?32:31-(pc$1(iu)/qc$1|0)|0}var rc$1=64,sc$1=4194304;function tc$1(iu){switch(iu&-iu){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return iu&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return iu&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return iu}}function uc$1(iu,eu){var tu=iu.pendingLanes;if(tu===0)return 0;var su=0,au=iu.suspendedLanes,uu=iu.pingedLanes,du=tu&268435455;if(du!==0){var fu=du&~au;fu!==0?su=tc$1(fu):(uu&=du,uu!==0&&(su=tc$1(uu)))}else du=tu&~au,du!==0?su=tc$1(du):uu!==0&&(su=tc$1(uu));if(su===0)return 0;if(eu!==0&&eu!==su&&!(eu&au)&&(au=su&-su,uu=eu&-eu,au>=uu||au===16&&(uu&4194240)!==0))return eu;if(su&4&&(su|=tu&16),eu=iu.entangledLanes,eu!==0)for(iu=iu.entanglements,eu&=su;0<eu;)tu=31-oc$1(eu),au=1<<tu,su|=iu[tu],eu&=~au;return su}function vc$1(iu,eu){switch(iu){case 1:case 2:case 4:return eu+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return eu+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc$1(iu,eu){for(var tu=iu.suspendedLanes,su=iu.pingedLanes,au=iu.expirationTimes,uu=iu.pendingLanes;0<uu;){var du=31-oc$1(uu),fu=1<<du,gu=au[du];gu===-1?(!(fu&tu)||fu&su)&&(au[du]=vc$1(fu,eu)):gu<=eu&&(iu.expiredLanes|=fu),uu&=~fu}}function xc$1(iu){return iu=iu.pendingLanes&-1073741825,iu!==0?iu:iu&1073741824?1073741824:0}function yc$1(){var iu=rc$1;return rc$1<<=1,!(rc$1&4194240)&&(rc$1=64),iu}function zc(iu){for(var eu=[],tu=0;31>tu;tu++)eu.push(iu);return eu}function Ac$1(iu,eu,tu){iu.pendingLanes|=eu,eu!==536870912&&(iu.suspendedLanes=0,iu.pingedLanes=0),iu=iu.eventTimes,eu=31-oc$1(eu),iu[eu]=tu}function Bc$1(iu,eu){var tu=iu.pendingLanes&~eu;iu.pendingLanes=eu,iu.suspendedLanes=0,iu.pingedLanes=0,iu.expiredLanes&=eu,iu.mutableReadLanes&=eu,iu.entangledLanes&=eu,eu=iu.entanglements;var su=iu.eventTimes;for(iu=iu.expirationTimes;0<tu;){var au=31-oc$1(tu),uu=1<<au;eu[au]=0,su[au]=-1,iu[au]=-1,tu&=~uu}}function Cc$1(iu,eu){var tu=iu.entangledLanes|=eu;for(iu=iu.entanglements;tu;){var su=31-oc$1(tu),au=1<<su;au&eu|iu[su]&eu&&(iu[su]|=eu),tu&=~au}}var C$1=0;function Dc$1(iu){return iu&=-iu,1<iu?4<iu?iu&268435455?16:536870912:4:1}var Ec$1,Fc$1,Gc$1,Hc$1,Ic$1,Jc=!1,Kc=[],Lc$1=null,Mc$1=null,Nc$1=null,Oc$1=new Map,Pc$1=new Map,Qc$1=[],Rc$1="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc$1(iu,eu){switch(iu){case"focusin":case"focusout":Lc$1=null;break;case"dragenter":case"dragleave":Mc$1=null;break;case"mouseover":case"mouseout":Nc$1=null;break;case"pointerover":case"pointerout":Oc$1.delete(eu.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc$1.delete(eu.pointerId)}}function Tc$1(iu,eu,tu,su,au,uu){return iu===null||iu.nativeEvent!==uu?(iu={blockedOn:eu,domEventName:tu,eventSystemFlags:su,nativeEvent:uu,targetContainers:[au]},eu!==null&&(eu=Cb(eu),eu!==null&&Fc$1(eu)),iu):(iu.eventSystemFlags|=su,eu=iu.targetContainers,au!==null&&eu.indexOf(au)===-1&&eu.push(au),iu)}function Uc$1(iu,eu,tu,su,au){switch(eu){case"focusin":return Lc$1=Tc$1(Lc$1,iu,eu,tu,su,au),!0;case"dragenter":return Mc$1=Tc$1(Mc$1,iu,eu,tu,su,au),!0;case"mouseover":return Nc$1=Tc$1(Nc$1,iu,eu,tu,su,au),!0;case"pointerover":var uu=au.pointerId;return Oc$1.set(uu,Tc$1(Oc$1.get(uu)||null,iu,eu,tu,su,au)),!0;case"gotpointercapture":return uu=au.pointerId,Pc$1.set(uu,Tc$1(Pc$1.get(uu)||null,iu,eu,tu,su,au)),!0}return!1}function Vc(iu){var eu=Wc(iu.target);if(eu!==null){var tu=Vb(eu);if(tu!==null){if(eu=tu.tag,eu===13){if(eu=Wb(tu),eu!==null){iu.blockedOn=eu,Ic$1(iu.priority,function(){Gc$1(tu)});return}}else if(eu===3&&tu.stateNode.current.memoizedState.isDehydrated){iu.blockedOn=tu.tag===3?tu.stateNode.containerInfo:null;return}}}iu.blockedOn=null}function Xc(iu){if(iu.blockedOn!==null)return!1;for(var eu=iu.targetContainers;0<eu.length;){var tu=Yc(iu.domEventName,iu.eventSystemFlags,eu[0],iu.nativeEvent);if(tu===null){tu=iu.nativeEvent;var su=new tu.constructor(tu.type,tu);wb=su,tu.target.dispatchEvent(su),wb=null}else return eu=Cb(tu),eu!==null&&Fc$1(eu),iu.blockedOn=tu,!1;eu.shift()}return!0}function Zc(iu,eu,tu){Xc(iu)&&tu.delete(eu)}function $c(){Jc=!1,Lc$1!==null&&Xc(Lc$1)&&(Lc$1=null),Mc$1!==null&&Xc(Mc$1)&&(Mc$1=null),Nc$1!==null&&Xc(Nc$1)&&(Nc$1=null),Oc$1.forEach(Zc),Pc$1.forEach(Zc)}function ad(iu,eu){iu.blockedOn===eu&&(iu.blockedOn=null,Jc||(Jc=!0,ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority,$c)))}function bd(iu){function eu(au){return ad(au,iu)}if(0<Kc.length){ad(Kc[0],iu);for(var tu=1;tu<Kc.length;tu++){var su=Kc[tu];su.blockedOn===iu&&(su.blockedOn=null)}}for(Lc$1!==null&&ad(Lc$1,iu),Mc$1!==null&&ad(Mc$1,iu),Nc$1!==null&&ad(Nc$1,iu),Oc$1.forEach(eu),Pc$1.forEach(eu),tu=0;tu<Qc$1.length;tu++)su=Qc$1[tu],su.blockedOn===iu&&(su.blockedOn=null);for(;0<Qc$1.length&&(tu=Qc$1[0],tu.blockedOn===null);)Vc(tu),tu.blockedOn===null&&Qc$1.shift()}var cd=ua$1.ReactCurrentBatchConfig,dd=!0;function ed(iu,eu,tu,su){var au=C$1,uu=cd.transition;cd.transition=null;try{C$1=1,fd(iu,eu,tu,su)}finally{C$1=au,cd.transition=uu}}function gd(iu,eu,tu,su){var au=C$1,uu=cd.transition;cd.transition=null;try{C$1=4,fd(iu,eu,tu,su)}finally{C$1=au,cd.transition=uu}}function fd(iu,eu,tu,su){if(dd){var au=Yc(iu,eu,tu,su);if(au===null)hd(iu,eu,su,id,tu),Sc$1(iu,su);else if(Uc$1(au,iu,eu,tu,su))su.stopPropagation();else if(Sc$1(iu,su),eu&4&&-1<Rc$1.indexOf(iu)){for(;au!==null;){var uu=Cb(au);if(uu!==null&&Ec$1(uu),uu=Yc(iu,eu,tu,su),uu===null&&hd(iu,eu,su,id,tu),uu===au)break;au=uu}au!==null&&su.stopPropagation()}else hd(iu,eu,su,null,tu)}}var id=null;function Yc(iu,eu,tu,su){if(id=null,iu=xb(su),iu=Wc(iu),iu!==null)if(eu=Vb(iu),eu===null)iu=null;else if(tu=eu.tag,tu===13){if(iu=Wb(eu),iu!==null)return iu;iu=null}else if(tu===3){if(eu.stateNode.current.memoizedState.isDehydrated)return eu.tag===3?eu.stateNode.containerInfo:null;iu=null}else eu!==iu&&(iu=null);return id=iu,null}function jd(iu){switch(iu){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec$1()){case fc$1:return 1;case gc$1:return 4;case hc$1:case ic$1:return 16;case jc$1:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var iu,eu=ld,tu=eu.length,su,au="value"in kd?kd.value:kd.textContent,uu=au.length;for(iu=0;iu<tu&&eu[iu]===au[iu];iu++);var du=tu-iu;for(su=1;su<=du&&eu[tu-su]===au[uu-su];su++);return md=au.slice(iu,1<su?1-su:void 0)}function od(iu){var eu=iu.keyCode;return"charCode"in iu?(iu=iu.charCode,iu===0&&eu===13&&(iu=13)):iu=eu,iu===10&&(iu=13),32<=iu||iu===13?iu:0}function pd(){return!0}function qd(){return!1}function rd(iu){function eu(tu,su,au,uu,du){this._reactName=tu,this._targetInst=au,this.type=su,this.nativeEvent=uu,this.target=du,this.currentTarget=null;for(var fu in iu)iu.hasOwnProperty(fu)&&(tu=iu[fu],this[fu]=tu?tu(uu):uu[fu]);return this.isDefaultPrevented=(uu.defaultPrevented!=null?uu.defaultPrevented:uu.returnValue===!1)?pd:qd,this.isPropagationStopped=qd,this}return A$1(eu.prototype,{preventDefault:function(){this.defaultPrevented=!0;var tu=this.nativeEvent;tu&&(tu.preventDefault?tu.preventDefault():typeof tu.returnValue!="unknown"&&(tu.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var tu=this.nativeEvent;tu&&(tu.stopPropagation?tu.stopPropagation():typeof tu.cancelBubble!="unknown"&&(tu.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd}),eu}var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(iu){return iu.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A$1({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A$1({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(iu){return iu.relatedTarget===void 0?iu.fromElement===iu.srcElement?iu.toElement:iu.fromElement:iu.relatedTarget},movementX:function(iu){return"movementX"in iu?iu.movementX:(iu!==yd&&(yd&&iu.type==="mousemove"?(wd=iu.screenX-yd.screenX,xd=iu.screenY-yd.screenY):xd=wd=0,yd=iu),wd)},movementY:function(iu){return"movementY"in iu?iu.movementY:xd}}),Bd=rd(Ad),Cd=A$1({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A$1({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A$1({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A$1({},sd,{clipboardData:function(iu){return"clipboardData"in iu?iu.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A$1({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(iu){var eu=this.nativeEvent;return eu.getModifierState?eu.getModifierState(iu):(iu=Od[iu])?!!eu[iu]:!1}function zd(){return Pd}var Qd=A$1({},ud,{key:function(iu){if(iu.key){var eu=Md[iu.key]||iu.key;if(eu!=="Unidentified")return eu}return iu.type==="keypress"?(iu=od(iu),iu===13?"Enter":String.fromCharCode(iu)):iu.type==="keydown"||iu.type==="keyup"?Nd[iu.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(iu){return iu.type==="keypress"?od(iu):0},keyCode:function(iu){return iu.type==="keydown"||iu.type==="keyup"?iu.keyCode:0},which:function(iu){return iu.type==="keypress"?od(iu):iu.type==="keydown"||iu.type==="keyup"?iu.keyCode:0}}),Rd=rd(Qd),Sd=A$1({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A$1({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A$1({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A$1({},Ad,{deltaX:function(iu){return"deltaX"in iu?iu.deltaX:"wheelDeltaX"in iu?-iu.wheelDeltaX:0},deltaY:function(iu){return"deltaY"in iu?iu.deltaY:"wheelDeltaY"in iu?-iu.wheelDeltaY:"wheelDelta"in iu?-iu.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae$1=ia$1&&"CompositionEvent"in window,be$1=null;ia$1&&"documentMode"in document&&(be$1=document.documentMode);var ce$1=ia$1&&"TextEvent"in window&&!be$1,de$1=ia$1&&(!ae$1||be$1&&8<be$1&&11>=be$1),ee$1=" ",fe$1=!1;function ge$1(iu,eu){switch(iu){case"keyup":return $d.indexOf(eu.keyCode)!==-1;case"keydown":return eu.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he$1(iu){return iu=iu.detail,typeof iu=="object"&&"data"in iu?iu.data:null}var ie$1=!1;function je$1(iu,eu){switch(iu){case"compositionend":return he$1(eu);case"keypress":return eu.which!==32?null:(fe$1=!0,ee$1);case"textInput":return iu=eu.data,iu===ee$1&&fe$1?null:iu;default:return null}}function ke$1(iu,eu){if(ie$1)return iu==="compositionend"||!ae$1&&ge$1(iu,eu)?(iu=nd(),md=ld=kd=null,ie$1=!1,iu):null;switch(iu){case"paste":return null;case"keypress":if(!(eu.ctrlKey||eu.altKey||eu.metaKey)||eu.ctrlKey&&eu.altKey){if(eu.char&&1<eu.char.length)return eu.char;if(eu.which)return String.fromCharCode(eu.which)}return null;case"compositionend":return de$1&&eu.locale!=="ko"?null:eu.data;default:return null}}var le$1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me$1(iu){var eu=iu&&iu.nodeName&&iu.nodeName.toLowerCase();return eu==="input"?!!le$1[iu.type]:eu==="textarea"}function ne$1(iu,eu,tu,su){Eb(su),eu=oe$1(eu,"onChange"),0<eu.length&&(tu=new td("onChange","change",null,tu,su),iu.push({event:tu,listeners:eu}))}var pe$1=null,qe$1=null;function re$1(iu){se$1(iu,0)}function te$1(iu){var eu=ue$1(iu);if(Wa$1(eu))return iu}function ve$1(iu,eu){if(iu==="change")return eu}var we$1=!1;if(ia$1){var xe$1;if(ia$1){var ye$1="oninput"in document;if(!ye$1){var ze$1=document.createElement("div");ze$1.setAttribute("oninput","return;"),ye$1=typeof ze$1.oninput=="function"}xe$1=ye$1}else xe$1=!1;we$1=xe$1&&(!document.documentMode||9<document.documentMode)}function Ae$1(){pe$1&&(pe$1.detachEvent("onpropertychange",Be$1),qe$1=pe$1=null)}function Be$1(iu){if(iu.propertyName==="value"&&te$1(qe$1)){var eu=[];ne$1(eu,qe$1,iu,xb(iu)),Jb(re$1,eu)}}function Ce$1(iu,eu,tu){iu==="focusin"?(Ae$1(),pe$1=eu,qe$1=tu,pe$1.attachEvent("onpropertychange",Be$1)):iu==="focusout"&&Ae$1()}function De$1(iu){if(iu==="selectionchange"||iu==="keyup"||iu==="keydown")return te$1(qe$1)}function Ee$1(iu,eu){if(iu==="click")return te$1(eu)}function Fe$1(iu,eu){if(iu==="input"||iu==="change")return te$1(eu)}function Ge$1(iu,eu){return iu===eu&&(iu!==0||1/iu===1/eu)||iu!==iu&&eu!==eu}var He$1=typeof Object.is=="function"?Object.is:Ge$1;function Ie$1(iu,eu){if(He$1(iu,eu))return!0;if(typeof iu!="object"||iu===null||typeof eu!="object"||eu===null)return!1;var tu=Object.keys(iu),su=Object.keys(eu);if(tu.length!==su.length)return!1;for(su=0;su<tu.length;su++){var au=tu[su];if(!ja$1.call(eu,au)||!He$1(iu[au],eu[au]))return!1}return!0}function Je$1(iu){for(;iu&&iu.firstChild;)iu=iu.firstChild;return iu}function Ke$1(iu,eu){var tu=Je$1(iu);iu=0;for(var su;tu;){if(tu.nodeType===3){if(su=iu+tu.textContent.length,iu<=eu&&su>=eu)return{node:tu,offset:eu-iu};iu=su}e:{for(;tu;){if(tu.nextSibling){tu=tu.nextSibling;break e}tu=tu.parentNode}tu=void 0}tu=Je$1(tu)}}function Le$1(iu,eu){return iu&&eu?iu===eu?!0:iu&&iu.nodeType===3?!1:eu&&eu.nodeType===3?Le$1(iu,eu.parentNode):"contains"in iu?iu.contains(eu):iu.compareDocumentPosition?!!(iu.compareDocumentPosition(eu)&16):!1:!1}function Me$1(){for(var iu=window,eu=Xa$1();eu instanceof iu.HTMLIFrameElement;){try{var tu=typeof eu.contentWindow.location.href=="string"}catch{tu=!1}if(tu)iu=eu.contentWindow;else break;eu=Xa$1(iu.document)}return eu}function Ne$1(iu){var eu=iu&&iu.nodeName&&iu.nodeName.toLowerCase();return eu&&(eu==="input"&&(iu.type==="text"||iu.type==="search"||iu.type==="tel"||iu.type==="url"||iu.type==="password")||eu==="textarea"||iu.contentEditable==="true")}function Oe$1(iu){var eu=Me$1(),tu=iu.focusedElem,su=iu.selectionRange;if(eu!==tu&&tu&&tu.ownerDocument&&Le$1(tu.ownerDocument.documentElement,tu)){if(su!==null&&Ne$1(tu)){if(eu=su.start,iu=su.end,iu===void 0&&(iu=eu),"selectionStart"in tu)tu.selectionStart=eu,tu.selectionEnd=Math.min(iu,tu.value.length);else if(iu=(eu=tu.ownerDocument||document)&&eu.defaultView||window,iu.getSelection){iu=iu.getSelection();var au=tu.textContent.length,uu=Math.min(su.start,au);su=su.end===void 0?uu:Math.min(su.end,au),!iu.extend&&uu>su&&(au=su,su=uu,uu=au),au=Ke$1(tu,uu);var du=Ke$1(tu,su);au&&du&&(iu.rangeCount!==1||iu.anchorNode!==au.node||iu.anchorOffset!==au.offset||iu.focusNode!==du.node||iu.focusOffset!==du.offset)&&(eu=eu.createRange(),eu.setStart(au.node,au.offset),iu.removeAllRanges(),uu>su?(iu.addRange(eu),iu.extend(du.node,du.offset)):(eu.setEnd(du.node,du.offset),iu.addRange(eu)))}}for(eu=[],iu=tu;iu=iu.parentNode;)iu.nodeType===1&&eu.push({element:iu,left:iu.scrollLeft,top:iu.scrollTop});for(typeof tu.focus=="function"&&tu.focus(),tu=0;tu<eu.length;tu++)iu=eu[tu],iu.element.scrollLeft=iu.left,iu.element.scrollTop=iu.top}}var Pe$1=ia$1&&"documentMode"in document&&11>=document.documentMode,Qe$1=null,Re$1=null,Se$1=null,Te$1=!1;function Ue$1(iu,eu,tu){var su=tu.window===tu?tu.document:tu.nodeType===9?tu:tu.ownerDocument;Te$1||Qe$1==null||Qe$1!==Xa$1(su)||(su=Qe$1,"selectionStart"in su&&Ne$1(su)?su={start:su.selectionStart,end:su.selectionEnd}:(su=(su.ownerDocument&&su.ownerDocument.defaultView||window).getSelection(),su={anchorNode:su.anchorNode,anchorOffset:su.anchorOffset,focusNode:su.focusNode,focusOffset:su.focusOffset}),Se$1&&Ie$1(Se$1,su)||(Se$1=su,su=oe$1(Re$1,"onSelect"),0<su.length&&(eu=new td("onSelect","select",null,eu,tu),iu.push({event:eu,listeners:su}),eu.target=Qe$1)))}function Ve$1(iu,eu){var tu={};return tu[iu.toLowerCase()]=eu.toLowerCase(),tu["Webkit"+iu]="webkit"+eu,tu["Moz"+iu]="moz"+eu,tu}var We$1={animationend:Ve$1("Animation","AnimationEnd"),animationiteration:Ve$1("Animation","AnimationIteration"),animationstart:Ve$1("Animation","AnimationStart"),transitionend:Ve$1("Transition","TransitionEnd")},Xe$1={},Ye$1={};ia$1&&(Ye$1=document.createElement("div").style,"AnimationEvent"in window||(delete We$1.animationend.animation,delete We$1.animationiteration.animation,delete We$1.animationstart.animation),"TransitionEvent"in window||delete We$1.transitionend.transition);function Ze$1(iu){if(Xe$1[iu])return Xe$1[iu];if(!We$1[iu])return iu;var eu=We$1[iu],tu;for(tu in eu)if(eu.hasOwnProperty(tu)&&tu in Ye$1)return Xe$1[iu]=eu[tu];return iu}var $e$1=Ze$1("animationend"),af=Ze$1("animationiteration"),bf=Ze$1("animationstart"),cf=Ze$1("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff(iu,eu){df.set(iu,eu),fa$1(eu,[iu])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e$1,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha$1("onMouseEnter",["mouseout","mouseover"]);ha$1("onMouseLeave",["mouseout","mouseover"]);ha$1("onPointerEnter",["pointerout","pointerover"]);ha$1("onPointerLeave",["pointerout","pointerover"]);fa$1("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa$1("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa$1("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa$1("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));function nf(iu,eu,tu){var su=iu.type||"unknown-event";iu.currentTarget=tu,Ub(su,eu,void 0,iu),iu.currentTarget=null}function se$1(iu,eu){eu=(eu&4)!==0;for(var tu=0;tu<iu.length;tu++){var su=iu[tu],au=su.event;su=su.listeners;e:{var uu=void 0;if(eu)for(var du=su.length-1;0<=du;du--){var fu=su[du],gu=fu.instance,yu=fu.currentTarget;if(fu=fu.listener,gu!==uu&&au.isPropagationStopped())break e;nf(au,fu,yu),uu=gu}else for(du=0;du<su.length;du++){if(fu=su[du],gu=fu.instance,yu=fu.currentTarget,fu=fu.listener,gu!==uu&&au.isPropagationStopped())break e;nf(au,fu,yu),uu=gu}}}if(Qb)throw iu=Rb,Qb=!1,Rb=null,iu}function D$1(iu,eu){var tu=eu[of];tu===void 0&&(tu=eu[of]=new Set);var su=iu+"__bubble";tu.has(su)||(pf(eu,iu,2,!1),tu.add(su))}function qf(iu,eu,tu){var su=0;eu&&(su|=4),pf(tu,iu,su,eu)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(iu){if(!iu[rf]){iu[rf]=!0,da$1.forEach(function(tu){tu!=="selectionchange"&&(mf.has(tu)||qf(tu,!1,iu),qf(tu,!0,iu))});var eu=iu.nodeType===9?iu:iu.ownerDocument;eu===null||eu[rf]||(eu[rf]=!0,qf("selectionchange",!1,eu))}}function pf(iu,eu,tu,su){switch(jd(eu)){case 1:var au=ed;break;case 4:au=gd;break;default:au=fd}tu=au.bind(null,eu,tu,iu),au=void 0,!Lb||eu!=="touchstart"&&eu!=="touchmove"&&eu!=="wheel"||(au=!0),su?au!==void 0?iu.addEventListener(eu,tu,{capture:!0,passive:au}):iu.addEventListener(eu,tu,!0):au!==void 0?iu.addEventListener(eu,tu,{passive:au}):iu.addEventListener(eu,tu,!1)}function hd(iu,eu,tu,su,au){var uu=su;if(!(eu&1)&&!(eu&2)&&su!==null)e:for(;;){if(su===null)return;var du=su.tag;if(du===3||du===4){var fu=su.stateNode.containerInfo;if(fu===au||fu.nodeType===8&&fu.parentNode===au)break;if(du===4)for(du=su.return;du!==null;){var gu=du.tag;if((gu===3||gu===4)&&(gu=du.stateNode.containerInfo,gu===au||gu.nodeType===8&&gu.parentNode===au))return;du=du.return}for(;fu!==null;){if(du=Wc(fu),du===null)return;if(gu=du.tag,gu===5||gu===6){su=uu=du;continue e}fu=fu.parentNode}}su=su.return}Jb(function(){var yu=uu,xu=xb(tu),vu=[];e:{var Su=df.get(iu);if(Su!==void 0){var Iu=td,Mu=iu;switch(iu){case"keypress":if(od(tu)===0)break e;case"keydown":case"keyup":Iu=Rd;break;case"focusin":Mu="focus",Iu=Fd;break;case"focusout":Mu="blur",Iu=Fd;break;case"beforeblur":case"afterblur":Iu=Fd;break;case"click":if(tu.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Iu=Bd;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Iu=Dd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Iu=Vd;break;case $e$1:case af:case bf:Iu=Hd;break;case cf:Iu=Xd;break;case"scroll":Iu=vd;break;case"wheel":Iu=Zd;break;case"copy":case"cut":case"paste":Iu=Jd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Iu=Td}var ku=(eu&4)!==0,Bu=!ku&&iu==="scroll",_u=ku?Su!==null?Su+"Capture":null:Su;ku=[];for(var Lu=yu,Du;Lu!==null;){Du=Lu;var Ou=Du.stateNode;if(Du.tag===5&&Ou!==null&&(Du=Ou,_u!==null&&(Ou=Kb(Lu,_u),Ou!=null&&ku.push(tf(Lu,Ou,Du)))),Bu)break;Lu=Lu.return}0<ku.length&&(Su=new Iu(Su,Mu,null,tu,xu),vu.push({event:Su,listeners:ku}))}}if(!(eu&7)){e:{if(Su=iu==="mouseover"||iu==="pointerover",Iu=iu==="mouseout"||iu==="pointerout",Su&&tu!==wb&&(Mu=tu.relatedTarget||tu.fromElement)&&(Wc(Mu)||Mu[uf]))break e;if((Iu||Su)&&(Su=xu.window===xu?xu:(Su=xu.ownerDocument)?Su.defaultView||Su.parentWindow:window,Iu?(Mu=tu.relatedTarget||tu.toElement,Iu=yu,Mu=Mu?Wc(Mu):null,Mu!==null&&(Bu=Vb(Mu),Mu!==Bu||Mu.tag!==5&&Mu.tag!==6)&&(Mu=null)):(Iu=null,Mu=yu),Iu!==Mu)){if(ku=Bd,Ou="onMouseLeave",_u="onMouseEnter",Lu="mouse",(iu==="pointerout"||iu==="pointerover")&&(ku=Td,Ou="onPointerLeave",_u="onPointerEnter",Lu="pointer"),Bu=Iu==null?Su:ue$1(Iu),Du=Mu==null?Su:ue$1(Mu),Su=new ku(Ou,Lu+"leave",Iu,tu,xu),Su.target=Bu,Su.relatedTarget=Du,Ou=null,Wc(xu)===yu&&(ku=new ku(_u,Lu+"enter",Mu,tu,xu),ku.target=Du,ku.relatedTarget=Bu,Ou=ku),Bu=Ou,Iu&&Mu)t:{for(ku=Iu,_u=Mu,Lu=0,Du=ku;Du;Du=vf(Du))Lu++;for(Du=0,Ou=_u;Ou;Ou=vf(Ou))Du++;for(;0<Lu-Du;)ku=vf(ku),Lu--;for(;0<Du-Lu;)_u=vf(_u),Du--;for(;Lu--;){if(ku===_u||_u!==null&&ku===_u.alternate)break t;ku=vf(ku),_u=vf(_u)}ku=null}else ku=null;Iu!==null&&wf(vu,Su,Iu,ku,!1),Mu!==null&&Bu!==null&&wf(vu,Bu,Mu,ku,!0)}}e:{if(Su=yu?ue$1(yu):window,Iu=Su.nodeName&&Su.nodeName.toLowerCase(),Iu==="select"||Iu==="input"&&Su.type==="file")var Wu=ve$1;else if(me$1(Su))if(we$1)Wu=Fe$1;else{Wu=De$1;var Zu=Ce$1}else(Iu=Su.nodeName)&&Iu.toLowerCase()==="input"&&(Su.type==="checkbox"||Su.type==="radio")&&(Wu=Ee$1);if(Wu&&(Wu=Wu(iu,yu))){ne$1(vu,Wu,tu,xu);break e}Zu&&Zu(iu,Su,yu),iu==="focusout"&&(Zu=Su._wrapperState)&&Zu.controlled&&Su.type==="number"&&cb(Su,"number",Su.value)}switch(Zu=yu?ue$1(yu):window,iu){case"focusin":(me$1(Zu)||Zu.contentEditable==="true")&&(Qe$1=Zu,Re$1=yu,Se$1=null);break;case"focusout":Se$1=Re$1=Qe$1=null;break;case"mousedown":Te$1=!0;break;case"contextmenu":case"mouseup":case"dragend":Te$1=!1,Ue$1(vu,tu,xu);break;case"selectionchange":if(Pe$1)break;case"keydown":case"keyup":Ue$1(vu,tu,xu)}var Hu;if(ae$1)e:{switch(iu){case"compositionstart":var Yu="onCompositionStart";break e;case"compositionend":Yu="onCompositionEnd";break e;case"compositionupdate":Yu="onCompositionUpdate";break e}Yu=void 0}else ie$1?ge$1(iu,tu)&&(Yu="onCompositionEnd"):iu==="keydown"&&tu.keyCode===229&&(Yu="onCompositionStart");Yu&&(de$1&&tu.locale!=="ko"&&(ie$1||Yu!=="onCompositionStart"?Yu==="onCompositionEnd"&&ie$1&&(Hu=nd()):(kd=xu,ld="value"in kd?kd.value:kd.textContent,ie$1=!0)),Zu=oe$1(yu,Yu),0<Zu.length&&(Yu=new Ld(Yu,iu,null,tu,xu),vu.push({event:Yu,listeners:Zu}),Hu?Yu.data=Hu:(Hu=he$1(tu),Hu!==null&&(Yu.data=Hu)))),(Hu=ce$1?je$1(iu,tu):ke$1(iu,tu))&&(yu=oe$1(yu,"onBeforeInput"),0<yu.length&&(xu=new Ld("onBeforeInput","beforeinput",null,tu,xu),vu.push({event:xu,listeners:yu}),xu.data=Hu))}se$1(vu,eu)})}function tf(iu,eu,tu){return{instance:iu,listener:eu,currentTarget:tu}}function oe$1(iu,eu){for(var tu=eu+"Capture",su=[];iu!==null;){var au=iu,uu=au.stateNode;au.tag===5&&uu!==null&&(au=uu,uu=Kb(iu,tu),uu!=null&&su.unshift(tf(iu,uu,au)),uu=Kb(iu,eu),uu!=null&&su.push(tf(iu,uu,au))),iu=iu.return}return su}function vf(iu){if(iu===null)return null;do iu=iu.return;while(iu&&iu.tag!==5);return iu||null}function wf(iu,eu,tu,su,au){for(var uu=eu._reactName,du=[];tu!==null&&tu!==su;){var fu=tu,gu=fu.alternate,yu=fu.stateNode;if(gu!==null&&gu===su)break;fu.tag===5&&yu!==null&&(fu=yu,au?(gu=Kb(tu,uu),gu!=null&&du.unshift(tf(tu,gu,fu))):au||(gu=Kb(tu,uu),gu!=null&&du.push(tf(tu,gu,fu)))),tu=tu.return}du.length!==0&&iu.push({event:eu,listeners:du})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(iu){return(typeof iu=="string"?iu:""+iu).replace(xf,`
`).replace(yf,"")}function Af(iu,eu,tu){if(eu=zf(eu),zf(iu)!==eu&&tu)throw Error(p$1(425))}function Bf(){}var Cf=null,Df=null;function Ef(iu,eu){return iu==="textarea"||iu==="noscript"||typeof eu.children=="string"||typeof eu.children=="number"||typeof eu.dangerouslySetInnerHTML=="object"&&eu.dangerouslySetInnerHTML!==null&&eu.dangerouslySetInnerHTML.__html!=null}var Ff=typeof setTimeout=="function"?setTimeout:void 0,Gf=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Jf=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(iu){return Hf.resolve(null).then(iu).catch(If)}:Ff;function If(iu){setTimeout(function(){throw iu})}function Kf(iu,eu){var tu=eu,su=0;do{var au=tu.nextSibling;if(iu.removeChild(tu),au&&au.nodeType===8)if(tu=au.data,tu==="/$"){if(su===0){iu.removeChild(au),bd(eu);return}su--}else tu!=="$"&&tu!=="$?"&&tu!=="$!"||su++;tu=au}while(tu);bd(eu)}function Lf(iu){for(;iu!=null;iu=iu.nextSibling){var eu=iu.nodeType;if(eu===1||eu===3)break;if(eu===8){if(eu=iu.data,eu==="$"||eu==="$!"||eu==="$?")break;if(eu==="/$")return null}}return iu}function Mf(iu){iu=iu.previousSibling;for(var eu=0;iu;){if(iu.nodeType===8){var tu=iu.data;if(tu==="$"||tu==="$!"||tu==="$?"){if(eu===0)return iu;eu--}else tu==="/$"&&eu++}iu=iu.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;function Wc(iu){var eu=iu[Of];if(eu)return eu;for(var tu=iu.parentNode;tu;){if(eu=tu[uf]||tu[Of]){if(tu=eu.alternate,eu.child!==null||tu!==null&&tu.child!==null)for(iu=Mf(iu);iu!==null;){if(tu=iu[Of])return tu;iu=Mf(iu)}return eu}iu=tu,tu=iu.parentNode}return null}function Cb(iu){return iu=iu[Of]||iu[uf],!iu||iu.tag!==5&&iu.tag!==6&&iu.tag!==13&&iu.tag!==3?null:iu}function ue$1(iu){if(iu.tag===5||iu.tag===6)return iu.stateNode;throw Error(p$1(33))}function Db(iu){return iu[Pf]||null}var Sf=[],Tf=-1;function Uf(iu){return{current:iu}}function E$1(iu){0>Tf||(iu.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G$1(iu,eu){Tf++,Sf[Tf]=iu.current,iu.current=eu}var Vf={},H$1=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(iu,eu){var tu=iu.type.contextTypes;if(!tu)return Vf;var su=iu.stateNode;if(su&&su.__reactInternalMemoizedUnmaskedChildContext===eu)return su.__reactInternalMemoizedMaskedChildContext;var au={},uu;for(uu in tu)au[uu]=eu[uu];return su&&(iu=iu.stateNode,iu.__reactInternalMemoizedUnmaskedChildContext=eu,iu.__reactInternalMemoizedMaskedChildContext=au),au}function Zf(iu){return iu=iu.childContextTypes,iu!=null}function $f(){E$1(Wf),E$1(H$1)}function ag(iu,eu,tu){if(H$1.current!==Vf)throw Error(p$1(168));G$1(H$1,eu),G$1(Wf,tu)}function bg(iu,eu,tu){var su=iu.stateNode;if(eu=eu.childContextTypes,typeof su.getChildContext!="function")return tu;su=su.getChildContext();for(var au in su)if(!(au in eu))throw Error(p$1(108,Ra$1(iu)||"Unknown",au));return A$1({},tu,su)}function cg(iu){return iu=(iu=iu.stateNode)&&iu.__reactInternalMemoizedMergedChildContext||Vf,Xf=H$1.current,G$1(H$1,iu),G$1(Wf,Wf.current),!0}function dg(iu,eu,tu){var su=iu.stateNode;if(!su)throw Error(p$1(169));tu?(iu=bg(iu,eu,Xf),su.__reactInternalMemoizedMergedChildContext=iu,E$1(Wf),E$1(H$1),G$1(H$1,iu)):E$1(Wf),G$1(Wf,tu)}var eg=null,fg=!1,gg=!1;function hg(iu){eg===null?eg=[iu]:eg.push(iu)}function ig(iu){fg=!0,hg(iu)}function jg(){if(!gg&&eg!==null){gg=!0;var iu=0,eu=C$1;try{var tu=eg;for(C$1=1;iu<tu.length;iu++){var su=tu[iu];do su=su(!0);while(su!==null)}eg=null,fg=!1}catch(au){throw eg!==null&&(eg=eg.slice(iu+1)),ac$1(fc$1,jg),au}finally{C$1=eu,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(iu,eu){kg[lg++]=ng,kg[lg++]=mg,mg=iu,ng=eu}function ug(iu,eu,tu){og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,qg=iu;var su=rg;iu=sg;var au=32-oc$1(su)-1;su&=~(1<<au),tu+=1;var uu=32-oc$1(eu)+au;if(30<uu){var du=au-au%5;uu=(su&(1<<du)-1).toString(32),su>>=du,au-=du,rg=1<<32-oc$1(eu)+au|tu<<au|su,sg=uu+iu}else rg=1<<uu|tu<<au|su,sg=iu}function vg(iu){iu.return!==null&&(tg(iu,1),ug(iu,1,0))}function wg(iu){for(;iu===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;iu===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I$1=!1,zg=null;function Ag(iu,eu){var tu=Bg(5,null,null,0);tu.elementType="DELETED",tu.stateNode=eu,tu.return=iu,eu=iu.deletions,eu===null?(iu.deletions=[tu],iu.flags|=16):eu.push(tu)}function Cg(iu,eu){switch(iu.tag){case 5:var tu=iu.type;return eu=eu.nodeType!==1||tu.toLowerCase()!==eu.nodeName.toLowerCase()?null:eu,eu!==null?(iu.stateNode=eu,xg=iu,yg=Lf(eu.firstChild),!0):!1;case 6:return eu=iu.pendingProps===""||eu.nodeType!==3?null:eu,eu!==null?(iu.stateNode=eu,xg=iu,yg=null,!0):!1;case 13:return eu=eu.nodeType!==8?null:eu,eu!==null?(tu=qg!==null?{id:rg,overflow:sg}:null,iu.memoizedState={dehydrated:eu,treeContext:tu,retryLane:1073741824},tu=Bg(18,null,null,0),tu.stateNode=eu,tu.return=iu,iu.child=tu,xg=iu,yg=null,!0):!1;default:return!1}}function Dg(iu){return(iu.mode&1)!==0&&(iu.flags&128)===0}function Eg(iu){if(I$1){var eu=yg;if(eu){var tu=eu;if(!Cg(iu,eu)){if(Dg(iu))throw Error(p$1(418));eu=Lf(tu.nextSibling);var su=xg;eu&&Cg(iu,eu)?Ag(su,tu):(iu.flags=iu.flags&-4097|2,I$1=!1,xg=iu)}}else{if(Dg(iu))throw Error(p$1(418));iu.flags=iu.flags&-4097|2,I$1=!1,xg=iu}}}function Fg(iu){for(iu=iu.return;iu!==null&&iu.tag!==5&&iu.tag!==3&&iu.tag!==13;)iu=iu.return;xg=iu}function Gg(iu){if(iu!==xg)return!1;if(!I$1)return Fg(iu),I$1=!0,!1;var eu;if((eu=iu.tag!==3)&&!(eu=iu.tag!==5)&&(eu=iu.type,eu=eu!=="head"&&eu!=="body"&&!Ef(iu.type,iu.memoizedProps)),eu&&(eu=yg)){if(Dg(iu))throw Hg(),Error(p$1(418));for(;eu;)Ag(iu,eu),eu=Lf(eu.nextSibling)}if(Fg(iu),iu.tag===13){if(iu=iu.memoizedState,iu=iu!==null?iu.dehydrated:null,!iu)throw Error(p$1(317));e:{for(iu=iu.nextSibling,eu=0;iu;){if(iu.nodeType===8){var tu=iu.data;if(tu==="/$"){if(eu===0){yg=Lf(iu.nextSibling);break e}eu--}else tu!=="$"&&tu!=="$!"&&tu!=="$?"||eu++}iu=iu.nextSibling}yg=null}}else yg=xg?Lf(iu.stateNode.nextSibling):null;return!0}function Hg(){for(var iu=yg;iu;)iu=Lf(iu.nextSibling)}function Ig(){yg=xg=null,I$1=!1}function Jg(iu){zg===null?zg=[iu]:zg.push(iu)}var Kg=ua$1.ReactCurrentBatchConfig;function Lg(iu,eu,tu){if(iu=tu.ref,iu!==null&&typeof iu!="function"&&typeof iu!="object"){if(tu._owner){if(tu=tu._owner,tu){if(tu.tag!==1)throw Error(p$1(309));var su=tu.stateNode}if(!su)throw Error(p$1(147,iu));var au=su,uu=""+iu;return eu!==null&&eu.ref!==null&&typeof eu.ref=="function"&&eu.ref._stringRef===uu?eu.ref:(eu=function(du){var fu=au.refs;du===null?delete fu[uu]:fu[uu]=du},eu._stringRef=uu,eu)}if(typeof iu!="string")throw Error(p$1(284));if(!tu._owner)throw Error(p$1(290,iu))}return iu}function Mg(iu,eu){throw iu=Object.prototype.toString.call(eu),Error(p$1(31,iu==="[object Object]"?"object with keys {"+Object.keys(eu).join(", ")+"}":iu))}function Ng(iu){var eu=iu._init;return eu(iu._payload)}function Og(iu){function eu(_u,Lu){if(iu){var Du=_u.deletions;Du===null?(_u.deletions=[Lu],_u.flags|=16):Du.push(Lu)}}function tu(_u,Lu){if(!iu)return null;for(;Lu!==null;)eu(_u,Lu),Lu=Lu.sibling;return null}function su(_u,Lu){for(_u=new Map;Lu!==null;)Lu.key!==null?_u.set(Lu.key,Lu):_u.set(Lu.index,Lu),Lu=Lu.sibling;return _u}function au(_u,Lu){return _u=Pg(_u,Lu),_u.index=0,_u.sibling=null,_u}function uu(_u,Lu,Du){return _u.index=Du,iu?(Du=_u.alternate,Du!==null?(Du=Du.index,Du<Lu?(_u.flags|=2,Lu):Du):(_u.flags|=2,Lu)):(_u.flags|=1048576,Lu)}function du(_u){return iu&&_u.alternate===null&&(_u.flags|=2),_u}function fu(_u,Lu,Du,Ou){return Lu===null||Lu.tag!==6?(Lu=Qg(Du,_u.mode,Ou),Lu.return=_u,Lu):(Lu=au(Lu,Du),Lu.return=_u,Lu)}function gu(_u,Lu,Du,Ou){var Wu=Du.type;return Wu===ya$1?xu(_u,Lu,Du.props.children,Ou,Du.key):Lu!==null&&(Lu.elementType===Wu||typeof Wu=="object"&&Wu!==null&&Wu.$$typeof===Ha$1&&Ng(Wu)===Lu.type)?(Ou=au(Lu,Du.props),Ou.ref=Lg(_u,Lu,Du),Ou.return=_u,Ou):(Ou=Rg(Du.type,Du.key,Du.props,null,_u.mode,Ou),Ou.ref=Lg(_u,Lu,Du),Ou.return=_u,Ou)}function yu(_u,Lu,Du,Ou){return Lu===null||Lu.tag!==4||Lu.stateNode.containerInfo!==Du.containerInfo||Lu.stateNode.implementation!==Du.implementation?(Lu=Sg(Du,_u.mode,Ou),Lu.return=_u,Lu):(Lu=au(Lu,Du.children||[]),Lu.return=_u,Lu)}function xu(_u,Lu,Du,Ou,Wu){return Lu===null||Lu.tag!==7?(Lu=Tg(Du,_u.mode,Ou,Wu),Lu.return=_u,Lu):(Lu=au(Lu,Du),Lu.return=_u,Lu)}function vu(_u,Lu,Du){if(typeof Lu=="string"&&Lu!==""||typeof Lu=="number")return Lu=Qg(""+Lu,_u.mode,Du),Lu.return=_u,Lu;if(typeof Lu=="object"&&Lu!==null){switch(Lu.$$typeof){case va$1:return Du=Rg(Lu.type,Lu.key,Lu.props,null,_u.mode,Du),Du.ref=Lg(_u,null,Lu),Du.return=_u,Du;case wa$1:return Lu=Sg(Lu,_u.mode,Du),Lu.return=_u,Lu;case Ha$1:var Ou=Lu._init;return vu(_u,Ou(Lu._payload),Du)}if(eb(Lu)||Ka$1(Lu))return Lu=Tg(Lu,_u.mode,Du,null),Lu.return=_u,Lu;Mg(_u,Lu)}return null}function Su(_u,Lu,Du,Ou){var Wu=Lu!==null?Lu.key:null;if(typeof Du=="string"&&Du!==""||typeof Du=="number")return Wu!==null?null:fu(_u,Lu,""+Du,Ou);if(typeof Du=="object"&&Du!==null){switch(Du.$$typeof){case va$1:return Du.key===Wu?gu(_u,Lu,Du,Ou):null;case wa$1:return Du.key===Wu?yu(_u,Lu,Du,Ou):null;case Ha$1:return Wu=Du._init,Su(_u,Lu,Wu(Du._payload),Ou)}if(eb(Du)||Ka$1(Du))return Wu!==null?null:xu(_u,Lu,Du,Ou,null);Mg(_u,Du)}return null}function Iu(_u,Lu,Du,Ou,Wu){if(typeof Ou=="string"&&Ou!==""||typeof Ou=="number")return _u=_u.get(Du)||null,fu(Lu,_u,""+Ou,Wu);if(typeof Ou=="object"&&Ou!==null){switch(Ou.$$typeof){case va$1:return _u=_u.get(Ou.key===null?Du:Ou.key)||null,gu(Lu,_u,Ou,Wu);case wa$1:return _u=_u.get(Ou.key===null?Du:Ou.key)||null,yu(Lu,_u,Ou,Wu);case Ha$1:var Zu=Ou._init;return Iu(_u,Lu,Du,Zu(Ou._payload),Wu)}if(eb(Ou)||Ka$1(Ou))return _u=_u.get(Du)||null,xu(Lu,_u,Ou,Wu,null);Mg(Lu,Ou)}return null}function Mu(_u,Lu,Du,Ou){for(var Wu=null,Zu=null,Hu=Lu,Yu=Lu=0,Ku=null;Hu!==null&&Yu<Du.length;Yu++){Hu.index>Yu?(Ku=Hu,Hu=null):Ku=Hu.sibling;var ju=Su(_u,Hu,Du[Yu],Ou);if(ju===null){Hu===null&&(Hu=Ku);break}iu&&Hu&&ju.alternate===null&&eu(_u,Hu),Lu=uu(ju,Lu,Yu),Zu===null?Wu=ju:Zu.sibling=ju,Zu=ju,Hu=Ku}if(Yu===Du.length)return tu(_u,Hu),I$1&&tg(_u,Yu),Wu;if(Hu===null){for(;Yu<Du.length;Yu++)Hu=vu(_u,Du[Yu],Ou),Hu!==null&&(Lu=uu(Hu,Lu,Yu),Zu===null?Wu=Hu:Zu.sibling=Hu,Zu=Hu);return I$1&&tg(_u,Yu),Wu}for(Hu=su(_u,Hu);Yu<Du.length;Yu++)Ku=Iu(Hu,_u,Yu,Du[Yu],Ou),Ku!==null&&(iu&&Ku.alternate!==null&&Hu.delete(Ku.key===null?Yu:Ku.key),Lu=uu(Ku,Lu,Yu),Zu===null?Wu=Ku:Zu.sibling=Ku,Zu=Ku);return iu&&Hu.forEach(function(tp){return eu(_u,tp)}),I$1&&tg(_u,Yu),Wu}function ku(_u,Lu,Du,Ou){var Wu=Ka$1(Du);if(typeof Wu!="function")throw Error(p$1(150));if(Du=Wu.call(Du),Du==null)throw Error(p$1(151));for(var Zu=Wu=null,Hu=Lu,Yu=Lu=0,Ku=null,ju=Du.next();Hu!==null&&!ju.done;Yu++,ju=Du.next()){Hu.index>Yu?(Ku=Hu,Hu=null):Ku=Hu.sibling;var tp=Su(_u,Hu,ju.value,Ou);if(tp===null){Hu===null&&(Hu=Ku);break}iu&&Hu&&tp.alternate===null&&eu(_u,Hu),Lu=uu(tp,Lu,Yu),Zu===null?Wu=tp:Zu.sibling=tp,Zu=tp,Hu=Ku}if(ju.done)return tu(_u,Hu),I$1&&tg(_u,Yu),Wu;if(Hu===null){for(;!ju.done;Yu++,ju=Du.next())ju=vu(_u,ju.value,Ou),ju!==null&&(Lu=uu(ju,Lu,Yu),Zu===null?Wu=ju:Zu.sibling=ju,Zu=ju);return I$1&&tg(_u,Yu),Wu}for(Hu=su(_u,Hu);!ju.done;Yu++,ju=Du.next())ju=Iu(Hu,_u,Yu,ju.value,Ou),ju!==null&&(iu&&ju.alternate!==null&&Hu.delete(ju.key===null?Yu:ju.key),Lu=uu(ju,Lu,Yu),Zu===null?Wu=ju:Zu.sibling=ju,Zu=ju);return iu&&Hu.forEach(function(gp){return eu(_u,gp)}),I$1&&tg(_u,Yu),Wu}function Bu(_u,Lu,Du,Ou){if(typeof Du=="object"&&Du!==null&&Du.type===ya$1&&Du.key===null&&(Du=Du.props.children),typeof Du=="object"&&Du!==null){switch(Du.$$typeof){case va$1:e:{for(var Wu=Du.key,Zu=Lu;Zu!==null;){if(Zu.key===Wu){if(Wu=Du.type,Wu===ya$1){if(Zu.tag===7){tu(_u,Zu.sibling),Lu=au(Zu,Du.props.children),Lu.return=_u,_u=Lu;break e}}else if(Zu.elementType===Wu||typeof Wu=="object"&&Wu!==null&&Wu.$$typeof===Ha$1&&Ng(Wu)===Zu.type){tu(_u,Zu.sibling),Lu=au(Zu,Du.props),Lu.ref=Lg(_u,Zu,Du),Lu.return=_u,_u=Lu;break e}tu(_u,Zu);break}else eu(_u,Zu);Zu=Zu.sibling}Du.type===ya$1?(Lu=Tg(Du.props.children,_u.mode,Ou,Du.key),Lu.return=_u,_u=Lu):(Ou=Rg(Du.type,Du.key,Du.props,null,_u.mode,Ou),Ou.ref=Lg(_u,Lu,Du),Ou.return=_u,_u=Ou)}return du(_u);case wa$1:e:{for(Zu=Du.key;Lu!==null;){if(Lu.key===Zu)if(Lu.tag===4&&Lu.stateNode.containerInfo===Du.containerInfo&&Lu.stateNode.implementation===Du.implementation){tu(_u,Lu.sibling),Lu=au(Lu,Du.children||[]),Lu.return=_u,_u=Lu;break e}else{tu(_u,Lu);break}else eu(_u,Lu);Lu=Lu.sibling}Lu=Sg(Du,_u.mode,Ou),Lu.return=_u,_u=Lu}return du(_u);case Ha$1:return Zu=Du._init,Bu(_u,Lu,Zu(Du._payload),Ou)}if(eb(Du))return Mu(_u,Lu,Du,Ou);if(Ka$1(Du))return ku(_u,Lu,Du,Ou);Mg(_u,Du)}return typeof Du=="string"&&Du!==""||typeof Du=="number"?(Du=""+Du,Lu!==null&&Lu.tag===6?(tu(_u,Lu.sibling),Lu=au(Lu,Du),Lu.return=_u,_u=Lu):(tu(_u,Lu),Lu=Qg(Du,_u.mode,Ou),Lu.return=_u,_u=Lu),du(_u)):tu(_u,Lu)}return Bu}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(iu){var eu=Wg.current;E$1(Wg),iu._currentValue=eu}function bh(iu,eu,tu){for(;iu!==null;){var su=iu.alternate;if((iu.childLanes&eu)!==eu?(iu.childLanes|=eu,su!==null&&(su.childLanes|=eu)):su!==null&&(su.childLanes&eu)!==eu&&(su.childLanes|=eu),iu===tu)break;iu=iu.return}}function ch(iu,eu){Xg=iu,Zg=Yg=null,iu=iu.dependencies,iu!==null&&iu.firstContext!==null&&(iu.lanes&eu&&(dh=!0),iu.firstContext=null)}function eh(iu){var eu=iu._currentValue;if(Zg!==iu)if(iu={context:iu,memoizedValue:eu,next:null},Yg===null){if(Xg===null)throw Error(p$1(308));Yg=iu,Xg.dependencies={lanes:0,firstContext:iu}}else Yg=Yg.next=iu;return eu}var fh=null;function gh(iu){fh===null?fh=[iu]:fh.push(iu)}function hh(iu,eu,tu,su){var au=eu.interleaved;return au===null?(tu.next=tu,gh(eu)):(tu.next=au.next,au.next=tu),eu.interleaved=tu,ih(iu,su)}function ih(iu,eu){iu.lanes|=eu;var tu=iu.alternate;for(tu!==null&&(tu.lanes|=eu),tu=iu,iu=iu.return;iu!==null;)iu.childLanes|=eu,tu=iu.alternate,tu!==null&&(tu.childLanes|=eu),tu=iu,iu=iu.return;return tu.tag===3?tu.stateNode:null}var jh=!1;function kh(iu){iu.updateQueue={baseState:iu.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(iu,eu){iu=iu.updateQueue,eu.updateQueue===iu&&(eu.updateQueue={baseState:iu.baseState,firstBaseUpdate:iu.firstBaseUpdate,lastBaseUpdate:iu.lastBaseUpdate,shared:iu.shared,effects:iu.effects})}function mh(iu,eu){return{eventTime:iu,lane:eu,tag:0,payload:null,callback:null,next:null}}function nh(iu,eu,tu){var su=iu.updateQueue;if(su===null)return null;if(su=su.shared,K$1&2){var au=su.pending;return au===null?eu.next=eu:(eu.next=au.next,au.next=eu),su.pending=eu,ih(iu,tu)}return au=su.interleaved,au===null?(eu.next=eu,gh(su)):(eu.next=au.next,au.next=eu),su.interleaved=eu,ih(iu,tu)}function oh(iu,eu,tu){if(eu=eu.updateQueue,eu!==null&&(eu=eu.shared,(tu&4194240)!==0)){var su=eu.lanes;su&=iu.pendingLanes,tu|=su,eu.lanes=tu,Cc$1(iu,tu)}}function ph(iu,eu){var tu=iu.updateQueue,su=iu.alternate;if(su!==null&&(su=su.updateQueue,tu===su)){var au=null,uu=null;if(tu=tu.firstBaseUpdate,tu!==null){do{var du={eventTime:tu.eventTime,lane:tu.lane,tag:tu.tag,payload:tu.payload,callback:tu.callback,next:null};uu===null?au=uu=du:uu=uu.next=du,tu=tu.next}while(tu!==null);uu===null?au=uu=eu:uu=uu.next=eu}else au=uu=eu;tu={baseState:su.baseState,firstBaseUpdate:au,lastBaseUpdate:uu,shared:su.shared,effects:su.effects},iu.updateQueue=tu;return}iu=tu.lastBaseUpdate,iu===null?tu.firstBaseUpdate=eu:iu.next=eu,tu.lastBaseUpdate=eu}function qh(iu,eu,tu,su){var au=iu.updateQueue;jh=!1;var uu=au.firstBaseUpdate,du=au.lastBaseUpdate,fu=au.shared.pending;if(fu!==null){au.shared.pending=null;var gu=fu,yu=gu.next;gu.next=null,du===null?uu=yu:du.next=yu,du=gu;var xu=iu.alternate;xu!==null&&(xu=xu.updateQueue,fu=xu.lastBaseUpdate,fu!==du&&(fu===null?xu.firstBaseUpdate=yu:fu.next=yu,xu.lastBaseUpdate=gu))}if(uu!==null){var vu=au.baseState;du=0,xu=yu=gu=null,fu=uu;do{var Su=fu.lane,Iu=fu.eventTime;if((su&Su)===Su){xu!==null&&(xu=xu.next={eventTime:Iu,lane:0,tag:fu.tag,payload:fu.payload,callback:fu.callback,next:null});e:{var Mu=iu,ku=fu;switch(Su=eu,Iu=tu,ku.tag){case 1:if(Mu=ku.payload,typeof Mu=="function"){vu=Mu.call(Iu,vu,Su);break e}vu=Mu;break e;case 3:Mu.flags=Mu.flags&-65537|128;case 0:if(Mu=ku.payload,Su=typeof Mu=="function"?Mu.call(Iu,vu,Su):Mu,Su==null)break e;vu=A$1({},vu,Su);break e;case 2:jh=!0}}fu.callback!==null&&fu.lane!==0&&(iu.flags|=64,Su=au.effects,Su===null?au.effects=[fu]:Su.push(fu))}else Iu={eventTime:Iu,lane:Su,tag:fu.tag,payload:fu.payload,callback:fu.callback,next:null},xu===null?(yu=xu=Iu,gu=vu):xu=xu.next=Iu,du|=Su;if(fu=fu.next,fu===null){if(fu=au.shared.pending,fu===null)break;Su=fu,fu=Su.next,Su.next=null,au.lastBaseUpdate=Su,au.shared.pending=null}}while(!0);if(xu===null&&(gu=vu),au.baseState=gu,au.firstBaseUpdate=yu,au.lastBaseUpdate=xu,eu=au.shared.interleaved,eu!==null){au=eu;do du|=au.lane,au=au.next;while(au!==eu)}else uu===null&&(au.shared.lanes=0);rh|=du,iu.lanes=du,iu.memoizedState=vu}}function sh(iu,eu,tu){if(iu=eu.effects,eu.effects=null,iu!==null)for(eu=0;eu<iu.length;eu++){var su=iu[eu],au=su.callback;if(au!==null){if(su.callback=null,su=tu,typeof au!="function")throw Error(p$1(191,au));au.call(su)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(iu){if(iu===th)throw Error(p$1(174));return iu}function yh(iu,eu){switch(G$1(wh,eu),G$1(vh,iu),G$1(uh,th),iu=eu.nodeType,iu){case 9:case 11:eu=(eu=eu.documentElement)?eu.namespaceURI:lb(null,"");break;default:iu=iu===8?eu.parentNode:eu,eu=iu.namespaceURI||null,iu=iu.tagName,eu=lb(eu,iu)}E$1(uh),G$1(uh,eu)}function zh(){E$1(uh),E$1(vh),E$1(wh)}function Ah(iu){xh(wh.current);var eu=xh(uh.current),tu=lb(eu,iu.type);eu!==tu&&(G$1(vh,iu),G$1(uh,tu))}function Bh(iu){vh.current===iu&&(E$1(uh),E$1(vh))}var L$1=Uf(0);function Ch(iu){for(var eu=iu;eu!==null;){if(eu.tag===13){var tu=eu.memoizedState;if(tu!==null&&(tu=tu.dehydrated,tu===null||tu.data==="$?"||tu.data==="$!"))return eu}else if(eu.tag===19&&eu.memoizedProps.revealOrder!==void 0){if(eu.flags&128)return eu}else if(eu.child!==null){eu.child.return=eu,eu=eu.child;continue}if(eu===iu)break;for(;eu.sibling===null;){if(eu.return===null||eu.return===iu)return null;eu=eu.return}eu.sibling.return=eu.return,eu=eu.sibling}return null}var Dh=[];function Eh(){for(var iu=0;iu<Dh.length;iu++)Dh[iu]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua$1.ReactCurrentDispatcher,Gh=ua$1.ReactCurrentBatchConfig,Hh=0,M$1=null,N$1=null,O$1=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P$1(){throw Error(p$1(321))}function Mh(iu,eu){if(eu===null)return!1;for(var tu=0;tu<eu.length&&tu<iu.length;tu++)if(!He$1(iu[tu],eu[tu]))return!1;return!0}function Nh(iu,eu,tu,su,au,uu){if(Hh=uu,M$1=eu,eu.memoizedState=null,eu.updateQueue=null,eu.lanes=0,Fh.current=iu===null||iu.memoizedState===null?Oh:Ph,iu=tu(su,au),Jh){uu=0;do{if(Jh=!1,Kh=0,25<=uu)throw Error(p$1(301));uu+=1,O$1=N$1=null,eu.updateQueue=null,Fh.current=Qh,iu=tu(su,au)}while(Jh)}if(Fh.current=Rh,eu=N$1!==null&&N$1.next!==null,Hh=0,O$1=N$1=M$1=null,Ih=!1,eu)throw Error(p$1(300));return iu}function Sh(){var iu=Kh!==0;return Kh=0,iu}function Th(){var iu={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O$1===null?M$1.memoizedState=O$1=iu:O$1=O$1.next=iu,O$1}function Uh(){if(N$1===null){var iu=M$1.alternate;iu=iu!==null?iu.memoizedState:null}else iu=N$1.next;var eu=O$1===null?M$1.memoizedState:O$1.next;if(eu!==null)O$1=eu,N$1=iu;else{if(iu===null)throw Error(p$1(310));N$1=iu,iu={memoizedState:N$1.memoizedState,baseState:N$1.baseState,baseQueue:N$1.baseQueue,queue:N$1.queue,next:null},O$1===null?M$1.memoizedState=O$1=iu:O$1=O$1.next=iu}return O$1}function Vh(iu,eu){return typeof eu=="function"?eu(iu):eu}function Wh(iu){var eu=Uh(),tu=eu.queue;if(tu===null)throw Error(p$1(311));tu.lastRenderedReducer=iu;var su=N$1,au=su.baseQueue,uu=tu.pending;if(uu!==null){if(au!==null){var du=au.next;au.next=uu.next,uu.next=du}su.baseQueue=au=uu,tu.pending=null}if(au!==null){uu=au.next,su=su.baseState;var fu=du=null,gu=null,yu=uu;do{var xu=yu.lane;if((Hh&xu)===xu)gu!==null&&(gu=gu.next={lane:0,action:yu.action,hasEagerState:yu.hasEagerState,eagerState:yu.eagerState,next:null}),su=yu.hasEagerState?yu.eagerState:iu(su,yu.action);else{var vu={lane:xu,action:yu.action,hasEagerState:yu.hasEagerState,eagerState:yu.eagerState,next:null};gu===null?(fu=gu=vu,du=su):gu=gu.next=vu,M$1.lanes|=xu,rh|=xu}yu=yu.next}while(yu!==null&&yu!==uu);gu===null?du=su:gu.next=fu,He$1(su,eu.memoizedState)||(dh=!0),eu.memoizedState=su,eu.baseState=du,eu.baseQueue=gu,tu.lastRenderedState=su}if(iu=tu.interleaved,iu!==null){au=iu;do uu=au.lane,M$1.lanes|=uu,rh|=uu,au=au.next;while(au!==iu)}else au===null&&(tu.lanes=0);return[eu.memoizedState,tu.dispatch]}function Xh(iu){var eu=Uh(),tu=eu.queue;if(tu===null)throw Error(p$1(311));tu.lastRenderedReducer=iu;var su=tu.dispatch,au=tu.pending,uu=eu.memoizedState;if(au!==null){tu.pending=null;var du=au=au.next;do uu=iu(uu,du.action),du=du.next;while(du!==au);He$1(uu,eu.memoizedState)||(dh=!0),eu.memoizedState=uu,eu.baseQueue===null&&(eu.baseState=uu),tu.lastRenderedState=uu}return[uu,su]}function Yh(){}function Zh(iu,eu){var tu=M$1,su=Uh(),au=eu(),uu=!He$1(su.memoizedState,au);if(uu&&(su.memoizedState=au,dh=!0),su=su.queue,$h(ai$1.bind(null,tu,su,iu),[iu]),su.getSnapshot!==eu||uu||O$1!==null&&O$1.memoizedState.tag&1){if(tu.flags|=2048,bi$1(9,ci$1.bind(null,tu,su,au,eu),void 0,null),Q$1===null)throw Error(p$1(349));Hh&30||di$1(tu,eu,au)}return au}function di$1(iu,eu,tu){iu.flags|=16384,iu={getSnapshot:eu,value:tu},eu=M$1.updateQueue,eu===null?(eu={lastEffect:null,stores:null},M$1.updateQueue=eu,eu.stores=[iu]):(tu=eu.stores,tu===null?eu.stores=[iu]:tu.push(iu))}function ci$1(iu,eu,tu,su){eu.value=tu,eu.getSnapshot=su,ei$1(eu)&&fi$1(iu)}function ai$1(iu,eu,tu){return tu(function(){ei$1(eu)&&fi$1(iu)})}function ei$1(iu){var eu=iu.getSnapshot;iu=iu.value;try{var tu=eu();return!He$1(iu,tu)}catch{return!0}}function fi$1(iu){var eu=ih(iu,1);eu!==null&&gi$1(eu,iu,1,-1)}function hi$1(iu){var eu=Th();return typeof iu=="function"&&(iu=iu()),eu.memoizedState=eu.baseState=iu,iu={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:iu},eu.queue=iu,iu=iu.dispatch=ii$1.bind(null,M$1,iu),[eu.memoizedState,iu]}function bi$1(iu,eu,tu,su){return iu={tag:iu,create:eu,destroy:tu,deps:su,next:null},eu=M$1.updateQueue,eu===null?(eu={lastEffect:null,stores:null},M$1.updateQueue=eu,eu.lastEffect=iu.next=iu):(tu=eu.lastEffect,tu===null?eu.lastEffect=iu.next=iu:(su=tu.next,tu.next=iu,iu.next=su,eu.lastEffect=iu)),iu}function ji$1(){return Uh().memoizedState}function ki$1(iu,eu,tu,su){var au=Th();M$1.flags|=iu,au.memoizedState=bi$1(1|eu,tu,void 0,su===void 0?null:su)}function li$1(iu,eu,tu,su){var au=Uh();su=su===void 0?null:su;var uu=void 0;if(N$1!==null){var du=N$1.memoizedState;if(uu=du.destroy,su!==null&&Mh(su,du.deps)){au.memoizedState=bi$1(eu,tu,uu,su);return}}M$1.flags|=iu,au.memoizedState=bi$1(1|eu,tu,uu,su)}function mi$1(iu,eu){return ki$1(8390656,8,iu,eu)}function $h(iu,eu){return li$1(2048,8,iu,eu)}function ni$1(iu,eu){return li$1(4,2,iu,eu)}function oi$1(iu,eu){return li$1(4,4,iu,eu)}function pi$1(iu,eu){if(typeof eu=="function")return iu=iu(),eu(iu),function(){eu(null)};if(eu!=null)return iu=iu(),eu.current=iu,function(){eu.current=null}}function qi$1(iu,eu,tu){return tu=tu!=null?tu.concat([iu]):null,li$1(4,4,pi$1.bind(null,eu,iu),tu)}function ri$1(){}function si$1(iu,eu){var tu=Uh();eu=eu===void 0?null:eu;var su=tu.memoizedState;return su!==null&&eu!==null&&Mh(eu,su[1])?su[0]:(tu.memoizedState=[iu,eu],iu)}function ti$1(iu,eu){var tu=Uh();eu=eu===void 0?null:eu;var su=tu.memoizedState;return su!==null&&eu!==null&&Mh(eu,su[1])?su[0]:(iu=iu(),tu.memoizedState=[iu,eu],iu)}function ui$1(iu,eu,tu){return Hh&21?(He$1(tu,eu)||(tu=yc$1(),M$1.lanes|=tu,rh|=tu,iu.baseState=!0),eu):(iu.baseState&&(iu.baseState=!1,dh=!0),iu.memoizedState=tu)}function vi$1(iu,eu){var tu=C$1;C$1=tu!==0&&4>tu?tu:4,iu(!0);var su=Gh.transition;Gh.transition={};try{iu(!1),eu()}finally{C$1=tu,Gh.transition=su}}function wi$1(){return Uh().memoizedState}function xi$1(iu,eu,tu){var su=yi$1(iu);if(tu={lane:su,action:tu,hasEagerState:!1,eagerState:null,next:null},zi$1(iu))Ai$1(eu,tu);else if(tu=hh(iu,eu,tu,su),tu!==null){var au=R$1();gi$1(tu,iu,su,au),Bi$1(tu,eu,su)}}function ii$1(iu,eu,tu){var su=yi$1(iu),au={lane:su,action:tu,hasEagerState:!1,eagerState:null,next:null};if(zi$1(iu))Ai$1(eu,au);else{var uu=iu.alternate;if(iu.lanes===0&&(uu===null||uu.lanes===0)&&(uu=eu.lastRenderedReducer,uu!==null))try{var du=eu.lastRenderedState,fu=uu(du,tu);if(au.hasEagerState=!0,au.eagerState=fu,He$1(fu,du)){var gu=eu.interleaved;gu===null?(au.next=au,gh(eu)):(au.next=gu.next,gu.next=au),eu.interleaved=au;return}}catch{}finally{}tu=hh(iu,eu,au,su),tu!==null&&(au=R$1(),gi$1(tu,iu,su,au),Bi$1(tu,eu,su))}}function zi$1(iu){var eu=iu.alternate;return iu===M$1||eu!==null&&eu===M$1}function Ai$1(iu,eu){Jh=Ih=!0;var tu=iu.pending;tu===null?eu.next=eu:(eu.next=tu.next,tu.next=eu),iu.pending=eu}function Bi$1(iu,eu,tu){if(tu&4194240){var su=eu.lanes;su&=iu.pendingLanes,tu|=su,eu.lanes=tu,Cc$1(iu,tu)}}var Rh={readContext:eh,useCallback:P$1,useContext:P$1,useEffect:P$1,useImperativeHandle:P$1,useInsertionEffect:P$1,useLayoutEffect:P$1,useMemo:P$1,useReducer:P$1,useRef:P$1,useState:P$1,useDebugValue:P$1,useDeferredValue:P$1,useTransition:P$1,useMutableSource:P$1,useSyncExternalStore:P$1,useId:P$1,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(iu,eu){return Th().memoizedState=[iu,eu===void 0?null:eu],iu},useContext:eh,useEffect:mi$1,useImperativeHandle:function(iu,eu,tu){return tu=tu!=null?tu.concat([iu]):null,ki$1(4194308,4,pi$1.bind(null,eu,iu),tu)},useLayoutEffect:function(iu,eu){return ki$1(4194308,4,iu,eu)},useInsertionEffect:function(iu,eu){return ki$1(4,2,iu,eu)},useMemo:function(iu,eu){var tu=Th();return eu=eu===void 0?null:eu,iu=iu(),tu.memoizedState=[iu,eu],iu},useReducer:function(iu,eu,tu){var su=Th();return eu=tu!==void 0?tu(eu):eu,su.memoizedState=su.baseState=eu,iu={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:iu,lastRenderedState:eu},su.queue=iu,iu=iu.dispatch=xi$1.bind(null,M$1,iu),[su.memoizedState,iu]},useRef:function(iu){var eu=Th();return iu={current:iu},eu.memoizedState=iu},useState:hi$1,useDebugValue:ri$1,useDeferredValue:function(iu){return Th().memoizedState=iu},useTransition:function(){var iu=hi$1(!1),eu=iu[0];return iu=vi$1.bind(null,iu[1]),Th().memoizedState=iu,[eu,iu]},useMutableSource:function(){},useSyncExternalStore:function(iu,eu,tu){var su=M$1,au=Th();if(I$1){if(tu===void 0)throw Error(p$1(407));tu=tu()}else{if(tu=eu(),Q$1===null)throw Error(p$1(349));Hh&30||di$1(su,eu,tu)}au.memoizedState=tu;var uu={value:tu,getSnapshot:eu};return au.queue=uu,mi$1(ai$1.bind(null,su,uu,iu),[iu]),su.flags|=2048,bi$1(9,ci$1.bind(null,su,uu,tu,eu),void 0,null),tu},useId:function(){var iu=Th(),eu=Q$1.identifierPrefix;if(I$1){var tu=sg,su=rg;tu=(su&~(1<<32-oc$1(su)-1)).toString(32)+tu,eu=":"+eu+"R"+tu,tu=Kh++,0<tu&&(eu+="H"+tu.toString(32)),eu+=":"}else tu=Lh++,eu=":"+eu+"r"+tu.toString(32)+":";return iu.memoizedState=eu},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Wh,useRef:ji$1,useState:function(){return Wh(Vh)},useDebugValue:ri$1,useDeferredValue:function(iu){var eu=Uh();return ui$1(eu,N$1.memoizedState,iu)},useTransition:function(){var iu=Wh(Vh)[0],eu=Uh().memoizedState;return[iu,eu]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi$1,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Xh,useRef:ji$1,useState:function(){return Xh(Vh)},useDebugValue:ri$1,useDeferredValue:function(iu){var eu=Uh();return N$1===null?eu.memoizedState=iu:ui$1(eu,N$1.memoizedState,iu)},useTransition:function(){var iu=Xh(Vh)[0],eu=Uh().memoizedState;return[iu,eu]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi$1,unstable_isNewReconciler:!1};function Ci$1(iu,eu){if(iu&&iu.defaultProps){eu=A$1({},eu),iu=iu.defaultProps;for(var tu in iu)eu[tu]===void 0&&(eu[tu]=iu[tu]);return eu}return eu}function Di$1(iu,eu,tu,su){eu=iu.memoizedState,tu=tu(su,eu),tu=tu==null?eu:A$1({},eu,tu),iu.memoizedState=tu,iu.lanes===0&&(iu.updateQueue.baseState=tu)}var Ei$1={isMounted:function(iu){return(iu=iu._reactInternals)?Vb(iu)===iu:!1},enqueueSetState:function(iu,eu,tu){iu=iu._reactInternals;var su=R$1(),au=yi$1(iu),uu=mh(su,au);uu.payload=eu,tu!=null&&(uu.callback=tu),eu=nh(iu,uu,au),eu!==null&&(gi$1(eu,iu,au,su),oh(eu,iu,au))},enqueueReplaceState:function(iu,eu,tu){iu=iu._reactInternals;var su=R$1(),au=yi$1(iu),uu=mh(su,au);uu.tag=1,uu.payload=eu,tu!=null&&(uu.callback=tu),eu=nh(iu,uu,au),eu!==null&&(gi$1(eu,iu,au,su),oh(eu,iu,au))},enqueueForceUpdate:function(iu,eu){iu=iu._reactInternals;var tu=R$1(),su=yi$1(iu),au=mh(tu,su);au.tag=2,eu!=null&&(au.callback=eu),eu=nh(iu,au,su),eu!==null&&(gi$1(eu,iu,su,tu),oh(eu,iu,su))}};function Fi$1(iu,eu,tu,su,au,uu,du){return iu=iu.stateNode,typeof iu.shouldComponentUpdate=="function"?iu.shouldComponentUpdate(su,uu,du):eu.prototype&&eu.prototype.isPureReactComponent?!Ie$1(tu,su)||!Ie$1(au,uu):!0}function Gi$1(iu,eu,tu){var su=!1,au=Vf,uu=eu.contextType;return typeof uu=="object"&&uu!==null?uu=eh(uu):(au=Zf(eu)?Xf:H$1.current,su=eu.contextTypes,uu=(su=su!=null)?Yf(iu,au):Vf),eu=new eu(tu,uu),iu.memoizedState=eu.state!==null&&eu.state!==void 0?eu.state:null,eu.updater=Ei$1,iu.stateNode=eu,eu._reactInternals=iu,su&&(iu=iu.stateNode,iu.__reactInternalMemoizedUnmaskedChildContext=au,iu.__reactInternalMemoizedMaskedChildContext=uu),eu}function Hi$1(iu,eu,tu,su){iu=eu.state,typeof eu.componentWillReceiveProps=="function"&&eu.componentWillReceiveProps(tu,su),typeof eu.UNSAFE_componentWillReceiveProps=="function"&&eu.UNSAFE_componentWillReceiveProps(tu,su),eu.state!==iu&&Ei$1.enqueueReplaceState(eu,eu.state,null)}function Ii$1(iu,eu,tu,su){var au=iu.stateNode;au.props=tu,au.state=iu.memoizedState,au.refs={},kh(iu);var uu=eu.contextType;typeof uu=="object"&&uu!==null?au.context=eh(uu):(uu=Zf(eu)?Xf:H$1.current,au.context=Yf(iu,uu)),au.state=iu.memoizedState,uu=eu.getDerivedStateFromProps,typeof uu=="function"&&(Di$1(iu,eu,uu,tu),au.state=iu.memoizedState),typeof eu.getDerivedStateFromProps=="function"||typeof au.getSnapshotBeforeUpdate=="function"||typeof au.UNSAFE_componentWillMount!="function"&&typeof au.componentWillMount!="function"||(eu=au.state,typeof au.componentWillMount=="function"&&au.componentWillMount(),typeof au.UNSAFE_componentWillMount=="function"&&au.UNSAFE_componentWillMount(),eu!==au.state&&Ei$1.enqueueReplaceState(au,au.state,null),qh(iu,tu,au,su),au.state=iu.memoizedState),typeof au.componentDidMount=="function"&&(iu.flags|=4194308)}function Ji$1(iu,eu){try{var tu="",su=eu;do tu+=Pa$1(su),su=su.return;while(su);var au=tu}catch(uu){au=`
Error generating stack: `+uu.message+`
`+uu.stack}return{value:iu,source:eu,stack:au,digest:null}}function Ki$1(iu,eu,tu){return{value:iu,source:null,stack:tu??null,digest:eu??null}}function Li$1(iu,eu){try{console.error(eu.value)}catch(tu){setTimeout(function(){throw tu})}}var Mi$1=typeof WeakMap=="function"?WeakMap:Map;function Ni$1(iu,eu,tu){tu=mh(-1,tu),tu.tag=3,tu.payload={element:null};var su=eu.value;return tu.callback=function(){Oi$1||(Oi$1=!0,Pi$1=su),Li$1(iu,eu)},tu}function Qi$1(iu,eu,tu){tu=mh(-1,tu),tu.tag=3;var su=iu.type.getDerivedStateFromError;if(typeof su=="function"){var au=eu.value;tu.payload=function(){return su(au)},tu.callback=function(){Li$1(iu,eu)}}var uu=iu.stateNode;return uu!==null&&typeof uu.componentDidCatch=="function"&&(tu.callback=function(){Li$1(iu,eu),typeof su!="function"&&(Ri$1===null?Ri$1=new Set([this]):Ri$1.add(this));var du=eu.stack;this.componentDidCatch(eu.value,{componentStack:du!==null?du:""})}),tu}function Si$1(iu,eu,tu){var su=iu.pingCache;if(su===null){su=iu.pingCache=new Mi$1;var au=new Set;su.set(eu,au)}else au=su.get(eu),au===void 0&&(au=new Set,su.set(eu,au));au.has(tu)||(au.add(tu),iu=Ti$1.bind(null,iu,eu,tu),eu.then(iu,iu))}function Ui$1(iu){do{var eu;if((eu=iu.tag===13)&&(eu=iu.memoizedState,eu=eu!==null?eu.dehydrated!==null:!0),eu)return iu;iu=iu.return}while(iu!==null);return null}function Vi$1(iu,eu,tu,su,au){return iu.mode&1?(iu.flags|=65536,iu.lanes=au,iu):(iu===eu?iu.flags|=65536:(iu.flags|=128,tu.flags|=131072,tu.flags&=-52805,tu.tag===1&&(tu.alternate===null?tu.tag=17:(eu=mh(-1,1),eu.tag=2,nh(tu,eu,1))),tu.lanes|=1),iu)}var Wi$1=ua$1.ReactCurrentOwner,dh=!1;function Xi$1(iu,eu,tu,su){eu.child=iu===null?Vg(eu,null,tu,su):Ug(eu,iu.child,tu,su)}function Yi$1(iu,eu,tu,su,au){tu=tu.render;var uu=eu.ref;return ch(eu,au),su=Nh(iu,eu,tu,su,uu,au),tu=Sh(),iu!==null&&!dh?(eu.updateQueue=iu.updateQueue,eu.flags&=-2053,iu.lanes&=~au,Zi$1(iu,eu,au)):(I$1&&tu&&vg(eu),eu.flags|=1,Xi$1(iu,eu,su,au),eu.child)}function $i$1(iu,eu,tu,su,au){if(iu===null){var uu=tu.type;return typeof uu=="function"&&!aj(uu)&&uu.defaultProps===void 0&&tu.compare===null&&tu.defaultProps===void 0?(eu.tag=15,eu.type=uu,bj(iu,eu,uu,su,au)):(iu=Rg(tu.type,null,su,eu,eu.mode,au),iu.ref=eu.ref,iu.return=eu,eu.child=iu)}if(uu=iu.child,!(iu.lanes&au)){var du=uu.memoizedProps;if(tu=tu.compare,tu=tu!==null?tu:Ie$1,tu(du,su)&&iu.ref===eu.ref)return Zi$1(iu,eu,au)}return eu.flags|=1,iu=Pg(uu,su),iu.ref=eu.ref,iu.return=eu,eu.child=iu}function bj(iu,eu,tu,su,au){if(iu!==null){var uu=iu.memoizedProps;if(Ie$1(uu,su)&&iu.ref===eu.ref)if(dh=!1,eu.pendingProps=su=uu,(iu.lanes&au)!==0)iu.flags&131072&&(dh=!0);else return eu.lanes=iu.lanes,Zi$1(iu,eu,au)}return cj(iu,eu,tu,su,au)}function dj(iu,eu,tu){var su=eu.pendingProps,au=su.children,uu=iu!==null?iu.memoizedState:null;if(su.mode==="hidden")if(!(eu.mode&1))eu.memoizedState={baseLanes:0,cachePool:null,transitions:null},G$1(ej,fj),fj|=tu;else{if(!(tu&1073741824))return iu=uu!==null?uu.baseLanes|tu:tu,eu.lanes=eu.childLanes=1073741824,eu.memoizedState={baseLanes:iu,cachePool:null,transitions:null},eu.updateQueue=null,G$1(ej,fj),fj|=iu,null;eu.memoizedState={baseLanes:0,cachePool:null,transitions:null},su=uu!==null?uu.baseLanes:tu,G$1(ej,fj),fj|=su}else uu!==null?(su=uu.baseLanes|tu,eu.memoizedState=null):su=tu,G$1(ej,fj),fj|=su;return Xi$1(iu,eu,au,tu),eu.child}function gj(iu,eu){var tu=eu.ref;(iu===null&&tu!==null||iu!==null&&iu.ref!==tu)&&(eu.flags|=512,eu.flags|=2097152)}function cj(iu,eu,tu,su,au){var uu=Zf(tu)?Xf:H$1.current;return uu=Yf(eu,uu),ch(eu,au),tu=Nh(iu,eu,tu,su,uu,au),su=Sh(),iu!==null&&!dh?(eu.updateQueue=iu.updateQueue,eu.flags&=-2053,iu.lanes&=~au,Zi$1(iu,eu,au)):(I$1&&su&&vg(eu),eu.flags|=1,Xi$1(iu,eu,tu,au),eu.child)}function hj(iu,eu,tu,su,au){if(Zf(tu)){var uu=!0;cg(eu)}else uu=!1;if(ch(eu,au),eu.stateNode===null)ij(iu,eu),Gi$1(eu,tu,su),Ii$1(eu,tu,su,au),su=!0;else if(iu===null){var du=eu.stateNode,fu=eu.memoizedProps;du.props=fu;var gu=du.context,yu=tu.contextType;typeof yu=="object"&&yu!==null?yu=eh(yu):(yu=Zf(tu)?Xf:H$1.current,yu=Yf(eu,yu));var xu=tu.getDerivedStateFromProps,vu=typeof xu=="function"||typeof du.getSnapshotBeforeUpdate=="function";vu||typeof du.UNSAFE_componentWillReceiveProps!="function"&&typeof du.componentWillReceiveProps!="function"||(fu!==su||gu!==yu)&&Hi$1(eu,du,su,yu),jh=!1;var Su=eu.memoizedState;du.state=Su,qh(eu,su,du,au),gu=eu.memoizedState,fu!==su||Su!==gu||Wf.current||jh?(typeof xu=="function"&&(Di$1(eu,tu,xu,su),gu=eu.memoizedState),(fu=jh||Fi$1(eu,tu,fu,su,Su,gu,yu))?(vu||typeof du.UNSAFE_componentWillMount!="function"&&typeof du.componentWillMount!="function"||(typeof du.componentWillMount=="function"&&du.componentWillMount(),typeof du.UNSAFE_componentWillMount=="function"&&du.UNSAFE_componentWillMount()),typeof du.componentDidMount=="function"&&(eu.flags|=4194308)):(typeof du.componentDidMount=="function"&&(eu.flags|=4194308),eu.memoizedProps=su,eu.memoizedState=gu),du.props=su,du.state=gu,du.context=yu,su=fu):(typeof du.componentDidMount=="function"&&(eu.flags|=4194308),su=!1)}else{du=eu.stateNode,lh(iu,eu),fu=eu.memoizedProps,yu=eu.type===eu.elementType?fu:Ci$1(eu.type,fu),du.props=yu,vu=eu.pendingProps,Su=du.context,gu=tu.contextType,typeof gu=="object"&&gu!==null?gu=eh(gu):(gu=Zf(tu)?Xf:H$1.current,gu=Yf(eu,gu));var Iu=tu.getDerivedStateFromProps;(xu=typeof Iu=="function"||typeof du.getSnapshotBeforeUpdate=="function")||typeof du.UNSAFE_componentWillReceiveProps!="function"&&typeof du.componentWillReceiveProps!="function"||(fu!==vu||Su!==gu)&&Hi$1(eu,du,su,gu),jh=!1,Su=eu.memoizedState,du.state=Su,qh(eu,su,du,au);var Mu=eu.memoizedState;fu!==vu||Su!==Mu||Wf.current||jh?(typeof Iu=="function"&&(Di$1(eu,tu,Iu,su),Mu=eu.memoizedState),(yu=jh||Fi$1(eu,tu,yu,su,Su,Mu,gu)||!1)?(xu||typeof du.UNSAFE_componentWillUpdate!="function"&&typeof du.componentWillUpdate!="function"||(typeof du.componentWillUpdate=="function"&&du.componentWillUpdate(su,Mu,gu),typeof du.UNSAFE_componentWillUpdate=="function"&&du.UNSAFE_componentWillUpdate(su,Mu,gu)),typeof du.componentDidUpdate=="function"&&(eu.flags|=4),typeof du.getSnapshotBeforeUpdate=="function"&&(eu.flags|=1024)):(typeof du.componentDidUpdate!="function"||fu===iu.memoizedProps&&Su===iu.memoizedState||(eu.flags|=4),typeof du.getSnapshotBeforeUpdate!="function"||fu===iu.memoizedProps&&Su===iu.memoizedState||(eu.flags|=1024),eu.memoizedProps=su,eu.memoizedState=Mu),du.props=su,du.state=Mu,du.context=gu,su=yu):(typeof du.componentDidUpdate!="function"||fu===iu.memoizedProps&&Su===iu.memoizedState||(eu.flags|=4),typeof du.getSnapshotBeforeUpdate!="function"||fu===iu.memoizedProps&&Su===iu.memoizedState||(eu.flags|=1024),su=!1)}return jj(iu,eu,tu,su,uu,au)}function jj(iu,eu,tu,su,au,uu){gj(iu,eu);var du=(eu.flags&128)!==0;if(!su&&!du)return au&&dg(eu,tu,!1),Zi$1(iu,eu,uu);su=eu.stateNode,Wi$1.current=eu;var fu=du&&typeof tu.getDerivedStateFromError!="function"?null:su.render();return eu.flags|=1,iu!==null&&du?(eu.child=Ug(eu,iu.child,null,uu),eu.child=Ug(eu,null,fu,uu)):Xi$1(iu,eu,fu,uu),eu.memoizedState=su.state,au&&dg(eu,tu,!0),eu.child}function kj(iu){var eu=iu.stateNode;eu.pendingContext?ag(iu,eu.pendingContext,eu.pendingContext!==eu.context):eu.context&&ag(iu,eu.context,!1),yh(iu,eu.containerInfo)}function lj(iu,eu,tu,su,au){return Ig(),Jg(au),eu.flags|=256,Xi$1(iu,eu,tu,su),eu.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(iu){return{baseLanes:iu,cachePool:null,transitions:null}}function oj(iu,eu,tu){var su=eu.pendingProps,au=L$1.current,uu=!1,du=(eu.flags&128)!==0,fu;if((fu=du)||(fu=iu!==null&&iu.memoizedState===null?!1:(au&2)!==0),fu?(uu=!0,eu.flags&=-129):(iu===null||iu.memoizedState!==null)&&(au|=1),G$1(L$1,au&1),iu===null)return Eg(eu),iu=eu.memoizedState,iu!==null&&(iu=iu.dehydrated,iu!==null)?(eu.mode&1?iu.data==="$!"?eu.lanes=8:eu.lanes=1073741824:eu.lanes=1,null):(du=su.children,iu=su.fallback,uu?(su=eu.mode,uu=eu.child,du={mode:"hidden",children:du},!(su&1)&&uu!==null?(uu.childLanes=0,uu.pendingProps=du):uu=pj(du,su,0,null),iu=Tg(iu,su,tu,null),uu.return=eu,iu.return=eu,uu.sibling=iu,eu.child=uu,eu.child.memoizedState=nj(tu),eu.memoizedState=mj,iu):qj(eu,du));if(au=iu.memoizedState,au!==null&&(fu=au.dehydrated,fu!==null))return rj(iu,eu,du,su,fu,au,tu);if(uu){uu=su.fallback,du=eu.mode,au=iu.child,fu=au.sibling;var gu={mode:"hidden",children:su.children};return!(du&1)&&eu.child!==au?(su=eu.child,su.childLanes=0,su.pendingProps=gu,eu.deletions=null):(su=Pg(au,gu),su.subtreeFlags=au.subtreeFlags&14680064),fu!==null?uu=Pg(fu,uu):(uu=Tg(uu,du,tu,null),uu.flags|=2),uu.return=eu,su.return=eu,su.sibling=uu,eu.child=su,su=uu,uu=eu.child,du=iu.child.memoizedState,du=du===null?nj(tu):{baseLanes:du.baseLanes|tu,cachePool:null,transitions:du.transitions},uu.memoizedState=du,uu.childLanes=iu.childLanes&~tu,eu.memoizedState=mj,su}return uu=iu.child,iu=uu.sibling,su=Pg(uu,{mode:"visible",children:su.children}),!(eu.mode&1)&&(su.lanes=tu),su.return=eu,su.sibling=null,iu!==null&&(tu=eu.deletions,tu===null?(eu.deletions=[iu],eu.flags|=16):tu.push(iu)),eu.child=su,eu.memoizedState=null,su}function qj(iu,eu){return eu=pj({mode:"visible",children:eu},iu.mode,0,null),eu.return=iu,iu.child=eu}function sj(iu,eu,tu,su){return su!==null&&Jg(su),Ug(eu,iu.child,null,tu),iu=qj(eu,eu.pendingProps.children),iu.flags|=2,eu.memoizedState=null,iu}function rj(iu,eu,tu,su,au,uu,du){if(tu)return eu.flags&256?(eu.flags&=-257,su=Ki$1(Error(p$1(422))),sj(iu,eu,du,su)):eu.memoizedState!==null?(eu.child=iu.child,eu.flags|=128,null):(uu=su.fallback,au=eu.mode,su=pj({mode:"visible",children:su.children},au,0,null),uu=Tg(uu,au,du,null),uu.flags|=2,su.return=eu,uu.return=eu,su.sibling=uu,eu.child=su,eu.mode&1&&Ug(eu,iu.child,null,du),eu.child.memoizedState=nj(du),eu.memoizedState=mj,uu);if(!(eu.mode&1))return sj(iu,eu,du,null);if(au.data==="$!"){if(su=au.nextSibling&&au.nextSibling.dataset,su)var fu=su.dgst;return su=fu,uu=Error(p$1(419)),su=Ki$1(uu,su,void 0),sj(iu,eu,du,su)}if(fu=(du&iu.childLanes)!==0,dh||fu){if(su=Q$1,su!==null){switch(du&-du){case 4:au=2;break;case 16:au=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:au=32;break;case 536870912:au=268435456;break;default:au=0}au=au&(su.suspendedLanes|du)?0:au,au!==0&&au!==uu.retryLane&&(uu.retryLane=au,ih(iu,au),gi$1(su,iu,au,-1))}return tj(),su=Ki$1(Error(p$1(421))),sj(iu,eu,du,su)}return au.data==="$?"?(eu.flags|=128,eu.child=iu.child,eu=uj.bind(null,iu),au._reactRetry=eu,null):(iu=uu.treeContext,yg=Lf(au.nextSibling),xg=eu,I$1=!0,zg=null,iu!==null&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=iu.id,sg=iu.overflow,qg=eu),eu=qj(eu,su.children),eu.flags|=4096,eu)}function vj(iu,eu,tu){iu.lanes|=eu;var su=iu.alternate;su!==null&&(su.lanes|=eu),bh(iu.return,eu,tu)}function wj(iu,eu,tu,su,au){var uu=iu.memoizedState;uu===null?iu.memoizedState={isBackwards:eu,rendering:null,renderingStartTime:0,last:su,tail:tu,tailMode:au}:(uu.isBackwards=eu,uu.rendering=null,uu.renderingStartTime=0,uu.last=su,uu.tail=tu,uu.tailMode=au)}function xj(iu,eu,tu){var su=eu.pendingProps,au=su.revealOrder,uu=su.tail;if(Xi$1(iu,eu,su.children,tu),su=L$1.current,su&2)su=su&1|2,eu.flags|=128;else{if(iu!==null&&iu.flags&128)e:for(iu=eu.child;iu!==null;){if(iu.tag===13)iu.memoizedState!==null&&vj(iu,tu,eu);else if(iu.tag===19)vj(iu,tu,eu);else if(iu.child!==null){iu.child.return=iu,iu=iu.child;continue}if(iu===eu)break e;for(;iu.sibling===null;){if(iu.return===null||iu.return===eu)break e;iu=iu.return}iu.sibling.return=iu.return,iu=iu.sibling}su&=1}if(G$1(L$1,su),!(eu.mode&1))eu.memoizedState=null;else switch(au){case"forwards":for(tu=eu.child,au=null;tu!==null;)iu=tu.alternate,iu!==null&&Ch(iu)===null&&(au=tu),tu=tu.sibling;tu=au,tu===null?(au=eu.child,eu.child=null):(au=tu.sibling,tu.sibling=null),wj(eu,!1,au,tu,uu);break;case"backwards":for(tu=null,au=eu.child,eu.child=null;au!==null;){if(iu=au.alternate,iu!==null&&Ch(iu)===null){eu.child=au;break}iu=au.sibling,au.sibling=tu,tu=au,au=iu}wj(eu,!0,tu,null,uu);break;case"together":wj(eu,!1,null,null,void 0);break;default:eu.memoizedState=null}return eu.child}function ij(iu,eu){!(eu.mode&1)&&iu!==null&&(iu.alternate=null,eu.alternate=null,eu.flags|=2)}function Zi$1(iu,eu,tu){if(iu!==null&&(eu.dependencies=iu.dependencies),rh|=eu.lanes,!(tu&eu.childLanes))return null;if(iu!==null&&eu.child!==iu.child)throw Error(p$1(153));if(eu.child!==null){for(iu=eu.child,tu=Pg(iu,iu.pendingProps),eu.child=tu,tu.return=eu;iu.sibling!==null;)iu=iu.sibling,tu=tu.sibling=Pg(iu,iu.pendingProps),tu.return=eu;tu.sibling=null}return eu.child}function yj(iu,eu,tu){switch(eu.tag){case 3:kj(eu),Ig();break;case 5:Ah(eu);break;case 1:Zf(eu.type)&&cg(eu);break;case 4:yh(eu,eu.stateNode.containerInfo);break;case 10:var su=eu.type._context,au=eu.memoizedProps.value;G$1(Wg,su._currentValue),su._currentValue=au;break;case 13:if(su=eu.memoizedState,su!==null)return su.dehydrated!==null?(G$1(L$1,L$1.current&1),eu.flags|=128,null):tu&eu.child.childLanes?oj(iu,eu,tu):(G$1(L$1,L$1.current&1),iu=Zi$1(iu,eu,tu),iu!==null?iu.sibling:null);G$1(L$1,L$1.current&1);break;case 19:if(su=(tu&eu.childLanes)!==0,iu.flags&128){if(su)return xj(iu,eu,tu);eu.flags|=128}if(au=eu.memoizedState,au!==null&&(au.rendering=null,au.tail=null,au.lastEffect=null),G$1(L$1,L$1.current),su)break;return null;case 22:case 23:return eu.lanes=0,dj(iu,eu,tu)}return Zi$1(iu,eu,tu)}var zj,Aj,Bj,Cj;zj=function(iu,eu){for(var tu=eu.child;tu!==null;){if(tu.tag===5||tu.tag===6)iu.appendChild(tu.stateNode);else if(tu.tag!==4&&tu.child!==null){tu.child.return=tu,tu=tu.child;continue}if(tu===eu)break;for(;tu.sibling===null;){if(tu.return===null||tu.return===eu)return;tu=tu.return}tu.sibling.return=tu.return,tu=tu.sibling}};Aj=function(){};Bj=function(iu,eu,tu,su){var au=iu.memoizedProps;if(au!==su){iu=eu.stateNode,xh(uh.current);var uu=null;switch(tu){case"input":au=Ya$1(iu,au),su=Ya$1(iu,su),uu=[];break;case"select":au=A$1({},au,{value:void 0}),su=A$1({},su,{value:void 0}),uu=[];break;case"textarea":au=gb(iu,au),su=gb(iu,su),uu=[];break;default:typeof au.onClick!="function"&&typeof su.onClick=="function"&&(iu.onclick=Bf)}ub(tu,su);var du;tu=null;for(yu in au)if(!su.hasOwnProperty(yu)&&au.hasOwnProperty(yu)&&au[yu]!=null)if(yu==="style"){var fu=au[yu];for(du in fu)fu.hasOwnProperty(du)&&(tu||(tu={}),tu[du]="")}else yu!=="dangerouslySetInnerHTML"&&yu!=="children"&&yu!=="suppressContentEditableWarning"&&yu!=="suppressHydrationWarning"&&yu!=="autoFocus"&&(ea$1.hasOwnProperty(yu)?uu||(uu=[]):(uu=uu||[]).push(yu,null));for(yu in su){var gu=su[yu];if(fu=au!=null?au[yu]:void 0,su.hasOwnProperty(yu)&&gu!==fu&&(gu!=null||fu!=null))if(yu==="style")if(fu){for(du in fu)!fu.hasOwnProperty(du)||gu&&gu.hasOwnProperty(du)||(tu||(tu={}),tu[du]="");for(du in gu)gu.hasOwnProperty(du)&&fu[du]!==gu[du]&&(tu||(tu={}),tu[du]=gu[du])}else tu||(uu||(uu=[]),uu.push(yu,tu)),tu=gu;else yu==="dangerouslySetInnerHTML"?(gu=gu?gu.__html:void 0,fu=fu?fu.__html:void 0,gu!=null&&fu!==gu&&(uu=uu||[]).push(yu,gu)):yu==="children"?typeof gu!="string"&&typeof gu!="number"||(uu=uu||[]).push(yu,""+gu):yu!=="suppressContentEditableWarning"&&yu!=="suppressHydrationWarning"&&(ea$1.hasOwnProperty(yu)?(gu!=null&&yu==="onScroll"&&D$1("scroll",iu),uu||fu===gu||(uu=[])):(uu=uu||[]).push(yu,gu))}tu&&(uu=uu||[]).push("style",tu);var yu=uu;(eu.updateQueue=yu)&&(eu.flags|=4)}};Cj=function(iu,eu,tu,su){tu!==su&&(eu.flags|=4)};function Dj(iu,eu){if(!I$1)switch(iu.tailMode){case"hidden":eu=iu.tail;for(var tu=null;eu!==null;)eu.alternate!==null&&(tu=eu),eu=eu.sibling;tu===null?iu.tail=null:tu.sibling=null;break;case"collapsed":tu=iu.tail;for(var su=null;tu!==null;)tu.alternate!==null&&(su=tu),tu=tu.sibling;su===null?eu||iu.tail===null?iu.tail=null:iu.tail.sibling=null:su.sibling=null}}function S$1(iu){var eu=iu.alternate!==null&&iu.alternate.child===iu.child,tu=0,su=0;if(eu)for(var au=iu.child;au!==null;)tu|=au.lanes|au.childLanes,su|=au.subtreeFlags&14680064,su|=au.flags&14680064,au.return=iu,au=au.sibling;else for(au=iu.child;au!==null;)tu|=au.lanes|au.childLanes,su|=au.subtreeFlags,su|=au.flags,au.return=iu,au=au.sibling;return iu.subtreeFlags|=su,iu.childLanes=tu,eu}function Ej(iu,eu,tu){var su=eu.pendingProps;switch(wg(eu),eu.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S$1(eu),null;case 1:return Zf(eu.type)&&$f(),S$1(eu),null;case 3:return su=eu.stateNode,zh(),E$1(Wf),E$1(H$1),Eh(),su.pendingContext&&(su.context=su.pendingContext,su.pendingContext=null),(iu===null||iu.child===null)&&(Gg(eu)?eu.flags|=4:iu===null||iu.memoizedState.isDehydrated&&!(eu.flags&256)||(eu.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(iu,eu),S$1(eu),null;case 5:Bh(eu);var au=xh(wh.current);if(tu=eu.type,iu!==null&&eu.stateNode!=null)Bj(iu,eu,tu,su,au),iu.ref!==eu.ref&&(eu.flags|=512,eu.flags|=2097152);else{if(!su){if(eu.stateNode===null)throw Error(p$1(166));return S$1(eu),null}if(iu=xh(uh.current),Gg(eu)){su=eu.stateNode,tu=eu.type;var uu=eu.memoizedProps;switch(su[Of]=eu,su[Pf]=uu,iu=(eu.mode&1)!==0,tu){case"dialog":D$1("cancel",su),D$1("close",su);break;case"iframe":case"object":case"embed":D$1("load",su);break;case"video":case"audio":for(au=0;au<lf.length;au++)D$1(lf[au],su);break;case"source":D$1("error",su);break;case"img":case"image":case"link":D$1("error",su),D$1("load",su);break;case"details":D$1("toggle",su);break;case"input":Za$1(su,uu),D$1("invalid",su);break;case"select":su._wrapperState={wasMultiple:!!uu.multiple},D$1("invalid",su);break;case"textarea":hb(su,uu),D$1("invalid",su)}ub(tu,uu),au=null;for(var du in uu)if(uu.hasOwnProperty(du)){var fu=uu[du];du==="children"?typeof fu=="string"?su.textContent!==fu&&(uu.suppressHydrationWarning!==!0&&Af(su.textContent,fu,iu),au=["children",fu]):typeof fu=="number"&&su.textContent!==""+fu&&(uu.suppressHydrationWarning!==!0&&Af(su.textContent,fu,iu),au=["children",""+fu]):ea$1.hasOwnProperty(du)&&fu!=null&&du==="onScroll"&&D$1("scroll",su)}switch(tu){case"input":Va$1(su),db(su,uu,!0);break;case"textarea":Va$1(su),jb(su);break;case"select":case"option":break;default:typeof uu.onClick=="function"&&(su.onclick=Bf)}su=au,eu.updateQueue=su,su!==null&&(eu.flags|=4)}else{du=au.nodeType===9?au:au.ownerDocument,iu==="http://www.w3.org/1999/xhtml"&&(iu=kb(tu)),iu==="http://www.w3.org/1999/xhtml"?tu==="script"?(iu=du.createElement("div"),iu.innerHTML="<script><\/script>",iu=iu.removeChild(iu.firstChild)):typeof su.is=="string"?iu=du.createElement(tu,{is:su.is}):(iu=du.createElement(tu),tu==="select"&&(du=iu,su.multiple?du.multiple=!0:su.size&&(du.size=su.size))):iu=du.createElementNS(iu,tu),iu[Of]=eu,iu[Pf]=su,zj(iu,eu,!1,!1),eu.stateNode=iu;e:{switch(du=vb(tu,su),tu){case"dialog":D$1("cancel",iu),D$1("close",iu),au=su;break;case"iframe":case"object":case"embed":D$1("load",iu),au=su;break;case"video":case"audio":for(au=0;au<lf.length;au++)D$1(lf[au],iu);au=su;break;case"source":D$1("error",iu),au=su;break;case"img":case"image":case"link":D$1("error",iu),D$1("load",iu),au=su;break;case"details":D$1("toggle",iu),au=su;break;case"input":Za$1(iu,su),au=Ya$1(iu,su),D$1("invalid",iu);break;case"option":au=su;break;case"select":iu._wrapperState={wasMultiple:!!su.multiple},au=A$1({},su,{value:void 0}),D$1("invalid",iu);break;case"textarea":hb(iu,su),au=gb(iu,su),D$1("invalid",iu);break;default:au=su}ub(tu,au),fu=au;for(uu in fu)if(fu.hasOwnProperty(uu)){var gu=fu[uu];uu==="style"?sb(iu,gu):uu==="dangerouslySetInnerHTML"?(gu=gu?gu.__html:void 0,gu!=null&&nb(iu,gu)):uu==="children"?typeof gu=="string"?(tu!=="textarea"||gu!=="")&&ob(iu,gu):typeof gu=="number"&&ob(iu,""+gu):uu!=="suppressContentEditableWarning"&&uu!=="suppressHydrationWarning"&&uu!=="autoFocus"&&(ea$1.hasOwnProperty(uu)?gu!=null&&uu==="onScroll"&&D$1("scroll",iu):gu!=null&&ta$1(iu,uu,gu,du))}switch(tu){case"input":Va$1(iu),db(iu,su,!1);break;case"textarea":Va$1(iu),jb(iu);break;case"option":su.value!=null&&iu.setAttribute("value",""+Sa$1(su.value));break;case"select":iu.multiple=!!su.multiple,uu=su.value,uu!=null?fb(iu,!!su.multiple,uu,!1):su.defaultValue!=null&&fb(iu,!!su.multiple,su.defaultValue,!0);break;default:typeof au.onClick=="function"&&(iu.onclick=Bf)}switch(tu){case"button":case"input":case"select":case"textarea":su=!!su.autoFocus;break e;case"img":su=!0;break e;default:su=!1}}su&&(eu.flags|=4)}eu.ref!==null&&(eu.flags|=512,eu.flags|=2097152)}return S$1(eu),null;case 6:if(iu&&eu.stateNode!=null)Cj(iu,eu,iu.memoizedProps,su);else{if(typeof su!="string"&&eu.stateNode===null)throw Error(p$1(166));if(tu=xh(wh.current),xh(uh.current),Gg(eu)){if(su=eu.stateNode,tu=eu.memoizedProps,su[Of]=eu,(uu=su.nodeValue!==tu)&&(iu=xg,iu!==null))switch(iu.tag){case 3:Af(su.nodeValue,tu,(iu.mode&1)!==0);break;case 5:iu.memoizedProps.suppressHydrationWarning!==!0&&Af(su.nodeValue,tu,(iu.mode&1)!==0)}uu&&(eu.flags|=4)}else su=(tu.nodeType===9?tu:tu.ownerDocument).createTextNode(su),su[Of]=eu,eu.stateNode=su}return S$1(eu),null;case 13:if(E$1(L$1),su=eu.memoizedState,iu===null||iu.memoizedState!==null&&iu.memoizedState.dehydrated!==null){if(I$1&&yg!==null&&eu.mode&1&&!(eu.flags&128))Hg(),Ig(),eu.flags|=98560,uu=!1;else if(uu=Gg(eu),su!==null&&su.dehydrated!==null){if(iu===null){if(!uu)throw Error(p$1(318));if(uu=eu.memoizedState,uu=uu!==null?uu.dehydrated:null,!uu)throw Error(p$1(317));uu[Of]=eu}else Ig(),!(eu.flags&128)&&(eu.memoizedState=null),eu.flags|=4;S$1(eu),uu=!1}else zg!==null&&(Fj(zg),zg=null),uu=!0;if(!uu)return eu.flags&65536?eu:null}return eu.flags&128?(eu.lanes=tu,eu):(su=su!==null,su!==(iu!==null&&iu.memoizedState!==null)&&su&&(eu.child.flags|=8192,eu.mode&1&&(iu===null||L$1.current&1?T$1===0&&(T$1=3):tj())),eu.updateQueue!==null&&(eu.flags|=4),S$1(eu),null);case 4:return zh(),Aj(iu,eu),iu===null&&sf(eu.stateNode.containerInfo),S$1(eu),null;case 10:return ah(eu.type._context),S$1(eu),null;case 17:return Zf(eu.type)&&$f(),S$1(eu),null;case 19:if(E$1(L$1),uu=eu.memoizedState,uu===null)return S$1(eu),null;if(su=(eu.flags&128)!==0,du=uu.rendering,du===null)if(su)Dj(uu,!1);else{if(T$1!==0||iu!==null&&iu.flags&128)for(iu=eu.child;iu!==null;){if(du=Ch(iu),du!==null){for(eu.flags|=128,Dj(uu,!1),su=du.updateQueue,su!==null&&(eu.updateQueue=su,eu.flags|=4),eu.subtreeFlags=0,su=tu,tu=eu.child;tu!==null;)uu=tu,iu=su,uu.flags&=14680066,du=uu.alternate,du===null?(uu.childLanes=0,uu.lanes=iu,uu.child=null,uu.subtreeFlags=0,uu.memoizedProps=null,uu.memoizedState=null,uu.updateQueue=null,uu.dependencies=null,uu.stateNode=null):(uu.childLanes=du.childLanes,uu.lanes=du.lanes,uu.child=du.child,uu.subtreeFlags=0,uu.deletions=null,uu.memoizedProps=du.memoizedProps,uu.memoizedState=du.memoizedState,uu.updateQueue=du.updateQueue,uu.type=du.type,iu=du.dependencies,uu.dependencies=iu===null?null:{lanes:iu.lanes,firstContext:iu.firstContext}),tu=tu.sibling;return G$1(L$1,L$1.current&1|2),eu.child}iu=iu.sibling}uu.tail!==null&&B$1()>Gj&&(eu.flags|=128,su=!0,Dj(uu,!1),eu.lanes=4194304)}else{if(!su)if(iu=Ch(du),iu!==null){if(eu.flags|=128,su=!0,tu=iu.updateQueue,tu!==null&&(eu.updateQueue=tu,eu.flags|=4),Dj(uu,!0),uu.tail===null&&uu.tailMode==="hidden"&&!du.alternate&&!I$1)return S$1(eu),null}else 2*B$1()-uu.renderingStartTime>Gj&&tu!==1073741824&&(eu.flags|=128,su=!0,Dj(uu,!1),eu.lanes=4194304);uu.isBackwards?(du.sibling=eu.child,eu.child=du):(tu=uu.last,tu!==null?tu.sibling=du:eu.child=du,uu.last=du)}return uu.tail!==null?(eu=uu.tail,uu.rendering=eu,uu.tail=eu.sibling,uu.renderingStartTime=B$1(),eu.sibling=null,tu=L$1.current,G$1(L$1,su?tu&1|2:tu&1),eu):(S$1(eu),null);case 22:case 23:return Hj(),su=eu.memoizedState!==null,iu!==null&&iu.memoizedState!==null!==su&&(eu.flags|=8192),su&&eu.mode&1?fj&1073741824&&(S$1(eu),eu.subtreeFlags&6&&(eu.flags|=8192)):S$1(eu),null;case 24:return null;case 25:return null}throw Error(p$1(156,eu.tag))}function Ij(iu,eu){switch(wg(eu),eu.tag){case 1:return Zf(eu.type)&&$f(),iu=eu.flags,iu&65536?(eu.flags=iu&-65537|128,eu):null;case 3:return zh(),E$1(Wf),E$1(H$1),Eh(),iu=eu.flags,iu&65536&&!(iu&128)?(eu.flags=iu&-65537|128,eu):null;case 5:return Bh(eu),null;case 13:if(E$1(L$1),iu=eu.memoizedState,iu!==null&&iu.dehydrated!==null){if(eu.alternate===null)throw Error(p$1(340));Ig()}return iu=eu.flags,iu&65536?(eu.flags=iu&-65537|128,eu):null;case 19:return E$1(L$1),null;case 4:return zh(),null;case 10:return ah(eu.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U$1=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V$1=null;function Lj(iu,eu){var tu=iu.ref;if(tu!==null)if(typeof tu=="function")try{tu(null)}catch(su){W$1(iu,eu,su)}else tu.current=null}function Mj(iu,eu,tu){try{tu()}catch(su){W$1(iu,eu,su)}}var Nj=!1;function Oj(iu,eu){if(Cf=dd,iu=Me$1(),Ne$1(iu)){if("selectionStart"in iu)var tu={start:iu.selectionStart,end:iu.selectionEnd};else e:{tu=(tu=iu.ownerDocument)&&tu.defaultView||window;var su=tu.getSelection&&tu.getSelection();if(su&&su.rangeCount!==0){tu=su.anchorNode;var au=su.anchorOffset,uu=su.focusNode;su=su.focusOffset;try{tu.nodeType,uu.nodeType}catch{tu=null;break e}var du=0,fu=-1,gu=-1,yu=0,xu=0,vu=iu,Su=null;t:for(;;){for(var Iu;vu!==tu||au!==0&&vu.nodeType!==3||(fu=du+au),vu!==uu||su!==0&&vu.nodeType!==3||(gu=du+su),vu.nodeType===3&&(du+=vu.nodeValue.length),(Iu=vu.firstChild)!==null;)Su=vu,vu=Iu;for(;;){if(vu===iu)break t;if(Su===tu&&++yu===au&&(fu=du),Su===uu&&++xu===su&&(gu=du),(Iu=vu.nextSibling)!==null)break;vu=Su,Su=vu.parentNode}vu=Iu}tu=fu===-1||gu===-1?null:{start:fu,end:gu}}else tu=null}tu=tu||{start:0,end:0}}else tu=null;for(Df={focusedElem:iu,selectionRange:tu},dd=!1,V$1=eu;V$1!==null;)if(eu=V$1,iu=eu.child,(eu.subtreeFlags&1028)!==0&&iu!==null)iu.return=eu,V$1=iu;else for(;V$1!==null;){eu=V$1;try{var Mu=eu.alternate;if(eu.flags&1024)switch(eu.tag){case 0:case 11:case 15:break;case 1:if(Mu!==null){var ku=Mu.memoizedProps,Bu=Mu.memoizedState,_u=eu.stateNode,Lu=_u.getSnapshotBeforeUpdate(eu.elementType===eu.type?ku:Ci$1(eu.type,ku),Bu);_u.__reactInternalSnapshotBeforeUpdate=Lu}break;case 3:var Du=eu.stateNode.containerInfo;Du.nodeType===1?Du.textContent="":Du.nodeType===9&&Du.documentElement&&Du.removeChild(Du.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$1(163))}}catch(Ou){W$1(eu,eu.return,Ou)}if(iu=eu.sibling,iu!==null){iu.return=eu.return,V$1=iu;break}V$1=eu.return}return Mu=Nj,Nj=!1,Mu}function Pj(iu,eu,tu){var su=eu.updateQueue;if(su=su!==null?su.lastEffect:null,su!==null){var au=su=su.next;do{if((au.tag&iu)===iu){var uu=au.destroy;au.destroy=void 0,uu!==void 0&&Mj(eu,tu,uu)}au=au.next}while(au!==su)}}function Qj(iu,eu){if(eu=eu.updateQueue,eu=eu!==null?eu.lastEffect:null,eu!==null){var tu=eu=eu.next;do{if((tu.tag&iu)===iu){var su=tu.create;tu.destroy=su()}tu=tu.next}while(tu!==eu)}}function Rj(iu){var eu=iu.ref;if(eu!==null){var tu=iu.stateNode;switch(iu.tag){case 5:iu=tu;break;default:iu=tu}typeof eu=="function"?eu(iu):eu.current=iu}}function Sj(iu){var eu=iu.alternate;eu!==null&&(iu.alternate=null,Sj(eu)),iu.child=null,iu.deletions=null,iu.sibling=null,iu.tag===5&&(eu=iu.stateNode,eu!==null&&(delete eu[Of],delete eu[Pf],delete eu[of],delete eu[Qf],delete eu[Rf])),iu.stateNode=null,iu.return=null,iu.dependencies=null,iu.memoizedProps=null,iu.memoizedState=null,iu.pendingProps=null,iu.stateNode=null,iu.updateQueue=null}function Tj(iu){return iu.tag===5||iu.tag===3||iu.tag===4}function Uj(iu){e:for(;;){for(;iu.sibling===null;){if(iu.return===null||Tj(iu.return))return null;iu=iu.return}for(iu.sibling.return=iu.return,iu=iu.sibling;iu.tag!==5&&iu.tag!==6&&iu.tag!==18;){if(iu.flags&2||iu.child===null||iu.tag===4)continue e;iu.child.return=iu,iu=iu.child}if(!(iu.flags&2))return iu.stateNode}}function Vj(iu,eu,tu){var su=iu.tag;if(su===5||su===6)iu=iu.stateNode,eu?tu.nodeType===8?tu.parentNode.insertBefore(iu,eu):tu.insertBefore(iu,eu):(tu.nodeType===8?(eu=tu.parentNode,eu.insertBefore(iu,tu)):(eu=tu,eu.appendChild(iu)),tu=tu._reactRootContainer,tu!=null||eu.onclick!==null||(eu.onclick=Bf));else if(su!==4&&(iu=iu.child,iu!==null))for(Vj(iu,eu,tu),iu=iu.sibling;iu!==null;)Vj(iu,eu,tu),iu=iu.sibling}function Wj(iu,eu,tu){var su=iu.tag;if(su===5||su===6)iu=iu.stateNode,eu?tu.insertBefore(iu,eu):tu.appendChild(iu);else if(su!==4&&(iu=iu.child,iu!==null))for(Wj(iu,eu,tu),iu=iu.sibling;iu!==null;)Wj(iu,eu,tu),iu=iu.sibling}var X$1=null,Xj=!1;function Yj(iu,eu,tu){for(tu=tu.child;tu!==null;)Zj(iu,eu,tu),tu=tu.sibling}function Zj(iu,eu,tu){if(lc$1&&typeof lc$1.onCommitFiberUnmount=="function")try{lc$1.onCommitFiberUnmount(kc$1,tu)}catch{}switch(tu.tag){case 5:U$1||Lj(tu,eu);case 6:var su=X$1,au=Xj;X$1=null,Yj(iu,eu,tu),X$1=su,Xj=au,X$1!==null&&(Xj?(iu=X$1,tu=tu.stateNode,iu.nodeType===8?iu.parentNode.removeChild(tu):iu.removeChild(tu)):X$1.removeChild(tu.stateNode));break;case 18:X$1!==null&&(Xj?(iu=X$1,tu=tu.stateNode,iu.nodeType===8?Kf(iu.parentNode,tu):iu.nodeType===1&&Kf(iu,tu),bd(iu)):Kf(X$1,tu.stateNode));break;case 4:su=X$1,au=Xj,X$1=tu.stateNode.containerInfo,Xj=!0,Yj(iu,eu,tu),X$1=su,Xj=au;break;case 0:case 11:case 14:case 15:if(!U$1&&(su=tu.updateQueue,su!==null&&(su=su.lastEffect,su!==null))){au=su=su.next;do{var uu=au,du=uu.destroy;uu=uu.tag,du!==void 0&&(uu&2||uu&4)&&Mj(tu,eu,du),au=au.next}while(au!==su)}Yj(iu,eu,tu);break;case 1:if(!U$1&&(Lj(tu,eu),su=tu.stateNode,typeof su.componentWillUnmount=="function"))try{su.props=tu.memoizedProps,su.state=tu.memoizedState,su.componentWillUnmount()}catch(fu){W$1(tu,eu,fu)}Yj(iu,eu,tu);break;case 21:Yj(iu,eu,tu);break;case 22:tu.mode&1?(U$1=(su=U$1)||tu.memoizedState!==null,Yj(iu,eu,tu),U$1=su):Yj(iu,eu,tu);break;default:Yj(iu,eu,tu)}}function ak(iu){var eu=iu.updateQueue;if(eu!==null){iu.updateQueue=null;var tu=iu.stateNode;tu===null&&(tu=iu.stateNode=new Kj),eu.forEach(function(su){var au=bk.bind(null,iu,su);tu.has(su)||(tu.add(su),su.then(au,au))})}}function ck(iu,eu){var tu=eu.deletions;if(tu!==null)for(var su=0;su<tu.length;su++){var au=tu[su];try{var uu=iu,du=eu,fu=du;e:for(;fu!==null;){switch(fu.tag){case 5:X$1=fu.stateNode,Xj=!1;break e;case 3:X$1=fu.stateNode.containerInfo,Xj=!0;break e;case 4:X$1=fu.stateNode.containerInfo,Xj=!0;break e}fu=fu.return}if(X$1===null)throw Error(p$1(160));Zj(uu,du,au),X$1=null,Xj=!1;var gu=au.alternate;gu!==null&&(gu.return=null),au.return=null}catch(yu){W$1(au,eu,yu)}}if(eu.subtreeFlags&12854)for(eu=eu.child;eu!==null;)dk(eu,iu),eu=eu.sibling}function dk(iu,eu){var tu=iu.alternate,su=iu.flags;switch(iu.tag){case 0:case 11:case 14:case 15:if(ck(eu,iu),ek(iu),su&4){try{Pj(3,iu,iu.return),Qj(3,iu)}catch(ku){W$1(iu,iu.return,ku)}try{Pj(5,iu,iu.return)}catch(ku){W$1(iu,iu.return,ku)}}break;case 1:ck(eu,iu),ek(iu),su&512&&tu!==null&&Lj(tu,tu.return);break;case 5:if(ck(eu,iu),ek(iu),su&512&&tu!==null&&Lj(tu,tu.return),iu.flags&32){var au=iu.stateNode;try{ob(au,"")}catch(ku){W$1(iu,iu.return,ku)}}if(su&4&&(au=iu.stateNode,au!=null)){var uu=iu.memoizedProps,du=tu!==null?tu.memoizedProps:uu,fu=iu.type,gu=iu.updateQueue;if(iu.updateQueue=null,gu!==null)try{fu==="input"&&uu.type==="radio"&&uu.name!=null&&ab(au,uu),vb(fu,du);var yu=vb(fu,uu);for(du=0;du<gu.length;du+=2){var xu=gu[du],vu=gu[du+1];xu==="style"?sb(au,vu):xu==="dangerouslySetInnerHTML"?nb(au,vu):xu==="children"?ob(au,vu):ta$1(au,xu,vu,yu)}switch(fu){case"input":bb(au,uu);break;case"textarea":ib(au,uu);break;case"select":var Su=au._wrapperState.wasMultiple;au._wrapperState.wasMultiple=!!uu.multiple;var Iu=uu.value;Iu!=null?fb(au,!!uu.multiple,Iu,!1):Su!==!!uu.multiple&&(uu.defaultValue!=null?fb(au,!!uu.multiple,uu.defaultValue,!0):fb(au,!!uu.multiple,uu.multiple?[]:"",!1))}au[Pf]=uu}catch(ku){W$1(iu,iu.return,ku)}}break;case 6:if(ck(eu,iu),ek(iu),su&4){if(iu.stateNode===null)throw Error(p$1(162));au=iu.stateNode,uu=iu.memoizedProps;try{au.nodeValue=uu}catch(ku){W$1(iu,iu.return,ku)}}break;case 3:if(ck(eu,iu),ek(iu),su&4&&tu!==null&&tu.memoizedState.isDehydrated)try{bd(eu.containerInfo)}catch(ku){W$1(iu,iu.return,ku)}break;case 4:ck(eu,iu),ek(iu);break;case 13:ck(eu,iu),ek(iu),au=iu.child,au.flags&8192&&(uu=au.memoizedState!==null,au.stateNode.isHidden=uu,!uu||au.alternate!==null&&au.alternate.memoizedState!==null||(fk=B$1())),su&4&&ak(iu);break;case 22:if(xu=tu!==null&&tu.memoizedState!==null,iu.mode&1?(U$1=(yu=U$1)||xu,ck(eu,iu),U$1=yu):ck(eu,iu),ek(iu),su&8192){if(yu=iu.memoizedState!==null,(iu.stateNode.isHidden=yu)&&!xu&&iu.mode&1)for(V$1=iu,xu=iu.child;xu!==null;){for(vu=V$1=xu;V$1!==null;){switch(Su=V$1,Iu=Su.child,Su.tag){case 0:case 11:case 14:case 15:Pj(4,Su,Su.return);break;case 1:Lj(Su,Su.return);var Mu=Su.stateNode;if(typeof Mu.componentWillUnmount=="function"){su=Su,tu=Su.return;try{eu=su,Mu.props=eu.memoizedProps,Mu.state=eu.memoizedState,Mu.componentWillUnmount()}catch(ku){W$1(su,tu,ku)}}break;case 5:Lj(Su,Su.return);break;case 22:if(Su.memoizedState!==null){gk(vu);continue}}Iu!==null?(Iu.return=Su,V$1=Iu):gk(vu)}xu=xu.sibling}e:for(xu=null,vu=iu;;){if(vu.tag===5){if(xu===null){xu=vu;try{au=vu.stateNode,yu?(uu=au.style,typeof uu.setProperty=="function"?uu.setProperty("display","none","important"):uu.display="none"):(fu=vu.stateNode,gu=vu.memoizedProps.style,du=gu!=null&&gu.hasOwnProperty("display")?gu.display:null,fu.style.display=rb("display",du))}catch(ku){W$1(iu,iu.return,ku)}}}else if(vu.tag===6){if(xu===null)try{vu.stateNode.nodeValue=yu?"":vu.memoizedProps}catch(ku){W$1(iu,iu.return,ku)}}else if((vu.tag!==22&&vu.tag!==23||vu.memoizedState===null||vu===iu)&&vu.child!==null){vu.child.return=vu,vu=vu.child;continue}if(vu===iu)break e;for(;vu.sibling===null;){if(vu.return===null||vu.return===iu)break e;xu===vu&&(xu=null),vu=vu.return}xu===vu&&(xu=null),vu.sibling.return=vu.return,vu=vu.sibling}}break;case 19:ck(eu,iu),ek(iu),su&4&&ak(iu);break;case 21:break;default:ck(eu,iu),ek(iu)}}function ek(iu){var eu=iu.flags;if(eu&2){try{e:{for(var tu=iu.return;tu!==null;){if(Tj(tu)){var su=tu;break e}tu=tu.return}throw Error(p$1(160))}switch(su.tag){case 5:var au=su.stateNode;su.flags&32&&(ob(au,""),su.flags&=-33);var uu=Uj(iu);Wj(iu,uu,au);break;case 3:case 4:var du=su.stateNode.containerInfo,fu=Uj(iu);Vj(iu,fu,du);break;default:throw Error(p$1(161))}}catch(gu){W$1(iu,iu.return,gu)}iu.flags&=-3}eu&4096&&(iu.flags&=-4097)}function hk(iu,eu,tu){V$1=iu,ik(iu)}function ik(iu,eu,tu){for(var su=(iu.mode&1)!==0;V$1!==null;){var au=V$1,uu=au.child;if(au.tag===22&&su){var du=au.memoizedState!==null||Jj;if(!du){var fu=au.alternate,gu=fu!==null&&fu.memoizedState!==null||U$1;fu=Jj;var yu=U$1;if(Jj=du,(U$1=gu)&&!yu)for(V$1=au;V$1!==null;)du=V$1,gu=du.child,du.tag===22&&du.memoizedState!==null?jk(au):gu!==null?(gu.return=du,V$1=gu):jk(au);for(;uu!==null;)V$1=uu,ik(uu),uu=uu.sibling;V$1=au,Jj=fu,U$1=yu}kk(iu)}else au.subtreeFlags&8772&&uu!==null?(uu.return=au,V$1=uu):kk(iu)}}function kk(iu){for(;V$1!==null;){var eu=V$1;if(eu.flags&8772){var tu=eu.alternate;try{if(eu.flags&8772)switch(eu.tag){case 0:case 11:case 15:U$1||Qj(5,eu);break;case 1:var su=eu.stateNode;if(eu.flags&4&&!U$1)if(tu===null)su.componentDidMount();else{var au=eu.elementType===eu.type?tu.memoizedProps:Ci$1(eu.type,tu.memoizedProps);su.componentDidUpdate(au,tu.memoizedState,su.__reactInternalSnapshotBeforeUpdate)}var uu=eu.updateQueue;uu!==null&&sh(eu,uu,su);break;case 3:var du=eu.updateQueue;if(du!==null){if(tu=null,eu.child!==null)switch(eu.child.tag){case 5:tu=eu.child.stateNode;break;case 1:tu=eu.child.stateNode}sh(eu,du,tu)}break;case 5:var fu=eu.stateNode;if(tu===null&&eu.flags&4){tu=fu;var gu=eu.memoizedProps;switch(eu.type){case"button":case"input":case"select":case"textarea":gu.autoFocus&&tu.focus();break;case"img":gu.src&&(tu.src=gu.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(eu.memoizedState===null){var yu=eu.alternate;if(yu!==null){var xu=yu.memoizedState;if(xu!==null){var vu=xu.dehydrated;vu!==null&&bd(vu)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p$1(163))}U$1||eu.flags&512&&Rj(eu)}catch(Su){W$1(eu,eu.return,Su)}}if(eu===iu){V$1=null;break}if(tu=eu.sibling,tu!==null){tu.return=eu.return,V$1=tu;break}V$1=eu.return}}function gk(iu){for(;V$1!==null;){var eu=V$1;if(eu===iu){V$1=null;break}var tu=eu.sibling;if(tu!==null){tu.return=eu.return,V$1=tu;break}V$1=eu.return}}function jk(iu){for(;V$1!==null;){var eu=V$1;try{switch(eu.tag){case 0:case 11:case 15:var tu=eu.return;try{Qj(4,eu)}catch(gu){W$1(eu,tu,gu)}break;case 1:var su=eu.stateNode;if(typeof su.componentDidMount=="function"){var au=eu.return;try{su.componentDidMount()}catch(gu){W$1(eu,au,gu)}}var uu=eu.return;try{Rj(eu)}catch(gu){W$1(eu,uu,gu)}break;case 5:var du=eu.return;try{Rj(eu)}catch(gu){W$1(eu,du,gu)}}}catch(gu){W$1(eu,eu.return,gu)}if(eu===iu){V$1=null;break}var fu=eu.sibling;if(fu!==null){fu.return=eu.return,V$1=fu;break}V$1=eu.return}}var lk=Math.ceil,mk=ua$1.ReactCurrentDispatcher,nk=ua$1.ReactCurrentOwner,ok=ua$1.ReactCurrentBatchConfig,K$1=0,Q$1=null,Y$1=null,Z$1=0,fj=0,ej=Uf(0),T$1=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi$1=!1,Pi$1=null,Ri$1=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R$1(){return K$1&6?B$1():Ak!==-1?Ak:Ak=B$1()}function yi$1(iu){return iu.mode&1?K$1&2&&Z$1!==0?Z$1&-Z$1:Kg.transition!==null?(Bk===0&&(Bk=yc$1()),Bk):(iu=C$1,iu!==0||(iu=window.event,iu=iu===void 0?16:jd(iu.type)),iu):1}function gi$1(iu,eu,tu,su){if(50<yk)throw yk=0,zk=null,Error(p$1(185));Ac$1(iu,tu,su),(!(K$1&2)||iu!==Q$1)&&(iu===Q$1&&(!(K$1&2)&&(qk|=tu),T$1===4&&Ck(iu,Z$1)),Dk(iu,su),tu===1&&K$1===0&&!(eu.mode&1)&&(Gj=B$1()+500,fg&&jg()))}function Dk(iu,eu){var tu=iu.callbackNode;wc$1(iu,eu);var su=uc$1(iu,iu===Q$1?Z$1:0);if(su===0)tu!==null&&bc$1(tu),iu.callbackNode=null,iu.callbackPriority=0;else if(eu=su&-su,iu.callbackPriority!==eu){if(tu!=null&&bc$1(tu),eu===1)iu.tag===0?ig(Ek.bind(null,iu)):hg(Ek.bind(null,iu)),Jf(function(){!(K$1&6)&&jg()}),tu=null;else{switch(Dc$1(su)){case 1:tu=fc$1;break;case 4:tu=gc$1;break;case 16:tu=hc$1;break;case 536870912:tu=jc$1;break;default:tu=hc$1}tu=Fk(tu,Gk.bind(null,iu))}iu.callbackPriority=eu,iu.callbackNode=tu}}function Gk(iu,eu){if(Ak=-1,Bk=0,K$1&6)throw Error(p$1(327));var tu=iu.callbackNode;if(Hk()&&iu.callbackNode!==tu)return null;var su=uc$1(iu,iu===Q$1?Z$1:0);if(su===0)return null;if(su&30||su&iu.expiredLanes||eu)eu=Ik(iu,su);else{eu=su;var au=K$1;K$1|=2;var uu=Jk();(Q$1!==iu||Z$1!==eu)&&(uk=null,Gj=B$1()+500,Kk(iu,eu));do try{Lk();break}catch(fu){Mk(iu,fu)}while(!0);$g(),mk.current=uu,K$1=au,Y$1!==null?eu=0:(Q$1=null,Z$1=0,eu=T$1)}if(eu!==0){if(eu===2&&(au=xc$1(iu),au!==0&&(su=au,eu=Nk(iu,au))),eu===1)throw tu=pk,Kk(iu,0),Ck(iu,su),Dk(iu,B$1()),tu;if(eu===6)Ck(iu,su);else{if(au=iu.current.alternate,!(su&30)&&!Ok(au)&&(eu=Ik(iu,su),eu===2&&(uu=xc$1(iu),uu!==0&&(su=uu,eu=Nk(iu,uu))),eu===1))throw tu=pk,Kk(iu,0),Ck(iu,su),Dk(iu,B$1()),tu;switch(iu.finishedWork=au,iu.finishedLanes=su,eu){case 0:case 1:throw Error(p$1(345));case 2:Pk(iu,tk,uk);break;case 3:if(Ck(iu,su),(su&130023424)===su&&(eu=fk+500-B$1(),10<eu)){if(uc$1(iu,0)!==0)break;if(au=iu.suspendedLanes,(au&su)!==su){R$1(),iu.pingedLanes|=iu.suspendedLanes&au;break}iu.timeoutHandle=Ff(Pk.bind(null,iu,tk,uk),eu);break}Pk(iu,tk,uk);break;case 4:if(Ck(iu,su),(su&4194240)===su)break;for(eu=iu.eventTimes,au=-1;0<su;){var du=31-oc$1(su);uu=1<<du,du=eu[du],du>au&&(au=du),su&=~uu}if(su=au,su=B$1()-su,su=(120>su?120:480>su?480:1080>su?1080:1920>su?1920:3e3>su?3e3:4320>su?4320:1960*lk(su/1960))-su,10<su){iu.timeoutHandle=Ff(Pk.bind(null,iu,tk,uk),su);break}Pk(iu,tk,uk);break;case 5:Pk(iu,tk,uk);break;default:throw Error(p$1(329))}}}return Dk(iu,B$1()),iu.callbackNode===tu?Gk.bind(null,iu):null}function Nk(iu,eu){var tu=sk;return iu.current.memoizedState.isDehydrated&&(Kk(iu,eu).flags|=256),iu=Ik(iu,eu),iu!==2&&(eu=tk,tk=tu,eu!==null&&Fj(eu)),iu}function Fj(iu){tk===null?tk=iu:tk.push.apply(tk,iu)}function Ok(iu){for(var eu=iu;;){if(eu.flags&16384){var tu=eu.updateQueue;if(tu!==null&&(tu=tu.stores,tu!==null))for(var su=0;su<tu.length;su++){var au=tu[su],uu=au.getSnapshot;au=au.value;try{if(!He$1(uu(),au))return!1}catch{return!1}}}if(tu=eu.child,eu.subtreeFlags&16384&&tu!==null)tu.return=eu,eu=tu;else{if(eu===iu)break;for(;eu.sibling===null;){if(eu.return===null||eu.return===iu)return!0;eu=eu.return}eu.sibling.return=eu.return,eu=eu.sibling}}return!0}function Ck(iu,eu){for(eu&=~rk,eu&=~qk,iu.suspendedLanes|=eu,iu.pingedLanes&=~eu,iu=iu.expirationTimes;0<eu;){var tu=31-oc$1(eu),su=1<<tu;iu[tu]=-1,eu&=~su}}function Ek(iu){if(K$1&6)throw Error(p$1(327));Hk();var eu=uc$1(iu,0);if(!(eu&1))return Dk(iu,B$1()),null;var tu=Ik(iu,eu);if(iu.tag!==0&&tu===2){var su=xc$1(iu);su!==0&&(eu=su,tu=Nk(iu,su))}if(tu===1)throw tu=pk,Kk(iu,0),Ck(iu,eu),Dk(iu,B$1()),tu;if(tu===6)throw Error(p$1(345));return iu.finishedWork=iu.current.alternate,iu.finishedLanes=eu,Pk(iu,tk,uk),Dk(iu,B$1()),null}function Qk(iu,eu){var tu=K$1;K$1|=1;try{return iu(eu)}finally{K$1=tu,K$1===0&&(Gj=B$1()+500,fg&&jg())}}function Rk(iu){wk!==null&&wk.tag===0&&!(K$1&6)&&Hk();var eu=K$1;K$1|=1;var tu=ok.transition,su=C$1;try{if(ok.transition=null,C$1=1,iu)return iu()}finally{C$1=su,ok.transition=tu,K$1=eu,!(K$1&6)&&jg()}}function Hj(){fj=ej.current,E$1(ej)}function Kk(iu,eu){iu.finishedWork=null,iu.finishedLanes=0;var tu=iu.timeoutHandle;if(tu!==-1&&(iu.timeoutHandle=-1,Gf(tu)),Y$1!==null)for(tu=Y$1.return;tu!==null;){var su=tu;switch(wg(su),su.tag){case 1:su=su.type.childContextTypes,su!=null&&$f();break;case 3:zh(),E$1(Wf),E$1(H$1),Eh();break;case 5:Bh(su);break;case 4:zh();break;case 13:E$1(L$1);break;case 19:E$1(L$1);break;case 10:ah(su.type._context);break;case 22:case 23:Hj()}tu=tu.return}if(Q$1=iu,Y$1=iu=Pg(iu.current,null),Z$1=fj=eu,T$1=0,pk=null,rk=qk=rh=0,tk=sk=null,fh!==null){for(eu=0;eu<fh.length;eu++)if(tu=fh[eu],su=tu.interleaved,su!==null){tu.interleaved=null;var au=su.next,uu=tu.pending;if(uu!==null){var du=uu.next;uu.next=au,su.next=du}tu.pending=su}fh=null}return iu}function Mk(iu,eu){do{var tu=Y$1;try{if($g(),Fh.current=Rh,Ih){for(var su=M$1.memoizedState;su!==null;){var au=su.queue;au!==null&&(au.pending=null),su=su.next}Ih=!1}if(Hh=0,O$1=N$1=M$1=null,Jh=!1,Kh=0,nk.current=null,tu===null||tu.return===null){T$1=1,pk=eu,Y$1=null;break}e:{var uu=iu,du=tu.return,fu=tu,gu=eu;if(eu=Z$1,fu.flags|=32768,gu!==null&&typeof gu=="object"&&typeof gu.then=="function"){var yu=gu,xu=fu,vu=xu.tag;if(!(xu.mode&1)&&(vu===0||vu===11||vu===15)){var Su=xu.alternate;Su?(xu.updateQueue=Su.updateQueue,xu.memoizedState=Su.memoizedState,xu.lanes=Su.lanes):(xu.updateQueue=null,xu.memoizedState=null)}var Iu=Ui$1(du);if(Iu!==null){Iu.flags&=-257,Vi$1(Iu,du,fu,uu,eu),Iu.mode&1&&Si$1(uu,yu,eu),eu=Iu,gu=yu;var Mu=eu.updateQueue;if(Mu===null){var ku=new Set;ku.add(gu),eu.updateQueue=ku}else Mu.add(gu);break e}else{if(!(eu&1)){Si$1(uu,yu,eu),tj();break e}gu=Error(p$1(426))}}else if(I$1&&fu.mode&1){var Bu=Ui$1(du);if(Bu!==null){!(Bu.flags&65536)&&(Bu.flags|=256),Vi$1(Bu,du,fu,uu,eu),Jg(Ji$1(gu,fu));break e}}uu=gu=Ji$1(gu,fu),T$1!==4&&(T$1=2),sk===null?sk=[uu]:sk.push(uu),uu=du;do{switch(uu.tag){case 3:uu.flags|=65536,eu&=-eu,uu.lanes|=eu;var _u=Ni$1(uu,gu,eu);ph(uu,_u);break e;case 1:fu=gu;var Lu=uu.type,Du=uu.stateNode;if(!(uu.flags&128)&&(typeof Lu.getDerivedStateFromError=="function"||Du!==null&&typeof Du.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(Du)))){uu.flags|=65536,eu&=-eu,uu.lanes|=eu;var Ou=Qi$1(uu,fu,eu);ph(uu,Ou);break e}}uu=uu.return}while(uu!==null)}Sk(tu)}catch(Wu){eu=Wu,Y$1===tu&&tu!==null&&(Y$1=tu=tu.return);continue}break}while(!0)}function Jk(){var iu=mk.current;return mk.current=Rh,iu===null?Rh:iu}function tj(){(T$1===0||T$1===3||T$1===2)&&(T$1=4),Q$1===null||!(rh&268435455)&&!(qk&268435455)||Ck(Q$1,Z$1)}function Ik(iu,eu){var tu=K$1;K$1|=2;var su=Jk();(Q$1!==iu||Z$1!==eu)&&(uk=null,Kk(iu,eu));do try{Tk();break}catch(au){Mk(iu,au)}while(!0);if($g(),K$1=tu,mk.current=su,Y$1!==null)throw Error(p$1(261));return Q$1=null,Z$1=0,T$1}function Tk(){for(;Y$1!==null;)Uk(Y$1)}function Lk(){for(;Y$1!==null&&!cc$1();)Uk(Y$1)}function Uk(iu){var eu=Vk(iu.alternate,iu,fj);iu.memoizedProps=iu.pendingProps,eu===null?Sk(iu):Y$1=eu,nk.current=null}function Sk(iu){var eu=iu;do{var tu=eu.alternate;if(iu=eu.return,eu.flags&32768){if(tu=Ij(tu,eu),tu!==null){tu.flags&=32767,Y$1=tu;return}if(iu!==null)iu.flags|=32768,iu.subtreeFlags=0,iu.deletions=null;else{T$1=6,Y$1=null;return}}else if(tu=Ej(tu,eu,fj),tu!==null){Y$1=tu;return}if(eu=eu.sibling,eu!==null){Y$1=eu;return}Y$1=eu=iu}while(eu!==null);T$1===0&&(T$1=5)}function Pk(iu,eu,tu){var su=C$1,au=ok.transition;try{ok.transition=null,C$1=1,Wk(iu,eu,tu,su)}finally{ok.transition=au,C$1=su}return null}function Wk(iu,eu,tu,su){do Hk();while(wk!==null);if(K$1&6)throw Error(p$1(327));tu=iu.finishedWork;var au=iu.finishedLanes;if(tu===null)return null;if(iu.finishedWork=null,iu.finishedLanes=0,tu===iu.current)throw Error(p$1(177));iu.callbackNode=null,iu.callbackPriority=0;var uu=tu.lanes|tu.childLanes;if(Bc$1(iu,uu),iu===Q$1&&(Y$1=Q$1=null,Z$1=0),!(tu.subtreeFlags&2064)&&!(tu.flags&2064)||vk||(vk=!0,Fk(hc$1,function(){return Hk(),null})),uu=(tu.flags&15990)!==0,tu.subtreeFlags&15990||uu){uu=ok.transition,ok.transition=null;var du=C$1;C$1=1;var fu=K$1;K$1|=4,nk.current=null,Oj(iu,tu),dk(tu,iu),Oe$1(Df),dd=!!Cf,Df=Cf=null,iu.current=tu,hk(tu),dc$1(),K$1=fu,C$1=du,ok.transition=uu}else iu.current=tu;if(vk&&(vk=!1,wk=iu,xk=au),uu=iu.pendingLanes,uu===0&&(Ri$1=null),mc$1(tu.stateNode),Dk(iu,B$1()),eu!==null)for(su=iu.onRecoverableError,tu=0;tu<eu.length;tu++)au=eu[tu],su(au.value,{componentStack:au.stack,digest:au.digest});if(Oi$1)throw Oi$1=!1,iu=Pi$1,Pi$1=null,iu;return xk&1&&iu.tag!==0&&Hk(),uu=iu.pendingLanes,uu&1?iu===zk?yk++:(yk=0,zk=iu):yk=0,jg(),null}function Hk(){if(wk!==null){var iu=Dc$1(xk),eu=ok.transition,tu=C$1;try{if(ok.transition=null,C$1=16>iu?16:iu,wk===null)var su=!1;else{if(iu=wk,wk=null,xk=0,K$1&6)throw Error(p$1(331));var au=K$1;for(K$1|=4,V$1=iu.current;V$1!==null;){var uu=V$1,du=uu.child;if(V$1.flags&16){var fu=uu.deletions;if(fu!==null){for(var gu=0;gu<fu.length;gu++){var yu=fu[gu];for(V$1=yu;V$1!==null;){var xu=V$1;switch(xu.tag){case 0:case 11:case 15:Pj(8,xu,uu)}var vu=xu.child;if(vu!==null)vu.return=xu,V$1=vu;else for(;V$1!==null;){xu=V$1;var Su=xu.sibling,Iu=xu.return;if(Sj(xu),xu===yu){V$1=null;break}if(Su!==null){Su.return=Iu,V$1=Su;break}V$1=Iu}}}var Mu=uu.alternate;if(Mu!==null){var ku=Mu.child;if(ku!==null){Mu.child=null;do{var Bu=ku.sibling;ku.sibling=null,ku=Bu}while(ku!==null)}}V$1=uu}}if(uu.subtreeFlags&2064&&du!==null)du.return=uu,V$1=du;else e:for(;V$1!==null;){if(uu=V$1,uu.flags&2048)switch(uu.tag){case 0:case 11:case 15:Pj(9,uu,uu.return)}var _u=uu.sibling;if(_u!==null){_u.return=uu.return,V$1=_u;break e}V$1=uu.return}}var Lu=iu.current;for(V$1=Lu;V$1!==null;){du=V$1;var Du=du.child;if(du.subtreeFlags&2064&&Du!==null)Du.return=du,V$1=Du;else e:for(du=Lu;V$1!==null;){if(fu=V$1,fu.flags&2048)try{switch(fu.tag){case 0:case 11:case 15:Qj(9,fu)}}catch(Wu){W$1(fu,fu.return,Wu)}if(fu===du){V$1=null;break e}var Ou=fu.sibling;if(Ou!==null){Ou.return=fu.return,V$1=Ou;break e}V$1=fu.return}}if(K$1=au,jg(),lc$1&&typeof lc$1.onPostCommitFiberRoot=="function")try{lc$1.onPostCommitFiberRoot(kc$1,iu)}catch{}su=!0}return su}finally{C$1=tu,ok.transition=eu}}return!1}function Xk(iu,eu,tu){eu=Ji$1(tu,eu),eu=Ni$1(iu,eu,1),iu=nh(iu,eu,1),eu=R$1(),iu!==null&&(Ac$1(iu,1,eu),Dk(iu,eu))}function W$1(iu,eu,tu){if(iu.tag===3)Xk(iu,iu,tu);else for(;eu!==null;){if(eu.tag===3){Xk(eu,iu,tu);break}else if(eu.tag===1){var su=eu.stateNode;if(typeof eu.type.getDerivedStateFromError=="function"||typeof su.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(su))){iu=Ji$1(tu,iu),iu=Qi$1(eu,iu,1),eu=nh(eu,iu,1),iu=R$1(),eu!==null&&(Ac$1(eu,1,iu),Dk(eu,iu));break}}eu=eu.return}}function Ti$1(iu,eu,tu){var su=iu.pingCache;su!==null&&su.delete(eu),eu=R$1(),iu.pingedLanes|=iu.suspendedLanes&tu,Q$1===iu&&(Z$1&tu)===tu&&(T$1===4||T$1===3&&(Z$1&130023424)===Z$1&&500>B$1()-fk?Kk(iu,0):rk|=tu),Dk(iu,eu)}function Yk(iu,eu){eu===0&&(iu.mode&1?(eu=sc$1,sc$1<<=1,!(sc$1&130023424)&&(sc$1=4194304)):eu=1);var tu=R$1();iu=ih(iu,eu),iu!==null&&(Ac$1(iu,eu,tu),Dk(iu,tu))}function uj(iu){var eu=iu.memoizedState,tu=0;eu!==null&&(tu=eu.retryLane),Yk(iu,tu)}function bk(iu,eu){var tu=0;switch(iu.tag){case 13:var su=iu.stateNode,au=iu.memoizedState;au!==null&&(tu=au.retryLane);break;case 19:su=iu.stateNode;break;default:throw Error(p$1(314))}su!==null&&su.delete(eu),Yk(iu,tu)}var Vk;Vk=function(iu,eu,tu){if(iu!==null)if(iu.memoizedProps!==eu.pendingProps||Wf.current)dh=!0;else{if(!(iu.lanes&tu)&&!(eu.flags&128))return dh=!1,yj(iu,eu,tu);dh=!!(iu.flags&131072)}else dh=!1,I$1&&eu.flags&1048576&&ug(eu,ng,eu.index);switch(eu.lanes=0,eu.tag){case 2:var su=eu.type;ij(iu,eu),iu=eu.pendingProps;var au=Yf(eu,H$1.current);ch(eu,tu),au=Nh(null,eu,su,iu,au,tu);var uu=Sh();return eu.flags|=1,typeof au=="object"&&au!==null&&typeof au.render=="function"&&au.$$typeof===void 0?(eu.tag=1,eu.memoizedState=null,eu.updateQueue=null,Zf(su)?(uu=!0,cg(eu)):uu=!1,eu.memoizedState=au.state!==null&&au.state!==void 0?au.state:null,kh(eu),au.updater=Ei$1,eu.stateNode=au,au._reactInternals=eu,Ii$1(eu,su,iu,tu),eu=jj(null,eu,su,!0,uu,tu)):(eu.tag=0,I$1&&uu&&vg(eu),Xi$1(null,eu,au,tu),eu=eu.child),eu;case 16:su=eu.elementType;e:{switch(ij(iu,eu),iu=eu.pendingProps,au=su._init,su=au(su._payload),eu.type=su,au=eu.tag=Zk(su),iu=Ci$1(su,iu),au){case 0:eu=cj(null,eu,su,iu,tu);break e;case 1:eu=hj(null,eu,su,iu,tu);break e;case 11:eu=Yi$1(null,eu,su,iu,tu);break e;case 14:eu=$i$1(null,eu,su,Ci$1(su.type,iu),tu);break e}throw Error(p$1(306,su,""))}return eu;case 0:return su=eu.type,au=eu.pendingProps,au=eu.elementType===su?au:Ci$1(su,au),cj(iu,eu,su,au,tu);case 1:return su=eu.type,au=eu.pendingProps,au=eu.elementType===su?au:Ci$1(su,au),hj(iu,eu,su,au,tu);case 3:e:{if(kj(eu),iu===null)throw Error(p$1(387));su=eu.pendingProps,uu=eu.memoizedState,au=uu.element,lh(iu,eu),qh(eu,su,null,tu);var du=eu.memoizedState;if(su=du.element,uu.isDehydrated)if(uu={element:su,isDehydrated:!1,cache:du.cache,pendingSuspenseBoundaries:du.pendingSuspenseBoundaries,transitions:du.transitions},eu.updateQueue.baseState=uu,eu.memoizedState=uu,eu.flags&256){au=Ji$1(Error(p$1(423)),eu),eu=lj(iu,eu,su,tu,au);break e}else if(su!==au){au=Ji$1(Error(p$1(424)),eu),eu=lj(iu,eu,su,tu,au);break e}else for(yg=Lf(eu.stateNode.containerInfo.firstChild),xg=eu,I$1=!0,zg=null,tu=Vg(eu,null,su,tu),eu.child=tu;tu;)tu.flags=tu.flags&-3|4096,tu=tu.sibling;else{if(Ig(),su===au){eu=Zi$1(iu,eu,tu);break e}Xi$1(iu,eu,su,tu)}eu=eu.child}return eu;case 5:return Ah(eu),iu===null&&Eg(eu),su=eu.type,au=eu.pendingProps,uu=iu!==null?iu.memoizedProps:null,du=au.children,Ef(su,au)?du=null:uu!==null&&Ef(su,uu)&&(eu.flags|=32),gj(iu,eu),Xi$1(iu,eu,du,tu),eu.child;case 6:return iu===null&&Eg(eu),null;case 13:return oj(iu,eu,tu);case 4:return yh(eu,eu.stateNode.containerInfo),su=eu.pendingProps,iu===null?eu.child=Ug(eu,null,su,tu):Xi$1(iu,eu,su,tu),eu.child;case 11:return su=eu.type,au=eu.pendingProps,au=eu.elementType===su?au:Ci$1(su,au),Yi$1(iu,eu,su,au,tu);case 7:return Xi$1(iu,eu,eu.pendingProps,tu),eu.child;case 8:return Xi$1(iu,eu,eu.pendingProps.children,tu),eu.child;case 12:return Xi$1(iu,eu,eu.pendingProps.children,tu),eu.child;case 10:e:{if(su=eu.type._context,au=eu.pendingProps,uu=eu.memoizedProps,du=au.value,G$1(Wg,su._currentValue),su._currentValue=du,uu!==null)if(He$1(uu.value,du)){if(uu.children===au.children&&!Wf.current){eu=Zi$1(iu,eu,tu);break e}}else for(uu=eu.child,uu!==null&&(uu.return=eu);uu!==null;){var fu=uu.dependencies;if(fu!==null){du=uu.child;for(var gu=fu.firstContext;gu!==null;){if(gu.context===su){if(uu.tag===1){gu=mh(-1,tu&-tu),gu.tag=2;var yu=uu.updateQueue;if(yu!==null){yu=yu.shared;var xu=yu.pending;xu===null?gu.next=gu:(gu.next=xu.next,xu.next=gu),yu.pending=gu}}uu.lanes|=tu,gu=uu.alternate,gu!==null&&(gu.lanes|=tu),bh(uu.return,tu,eu),fu.lanes|=tu;break}gu=gu.next}}else if(uu.tag===10)du=uu.type===eu.type?null:uu.child;else if(uu.tag===18){if(du=uu.return,du===null)throw Error(p$1(341));du.lanes|=tu,fu=du.alternate,fu!==null&&(fu.lanes|=tu),bh(du,tu,eu),du=uu.sibling}else du=uu.child;if(du!==null)du.return=uu;else for(du=uu;du!==null;){if(du===eu){du=null;break}if(uu=du.sibling,uu!==null){uu.return=du.return,du=uu;break}du=du.return}uu=du}Xi$1(iu,eu,au.children,tu),eu=eu.child}return eu;case 9:return au=eu.type,su=eu.pendingProps.children,ch(eu,tu),au=eh(au),su=su(au),eu.flags|=1,Xi$1(iu,eu,su,tu),eu.child;case 14:return su=eu.type,au=Ci$1(su,eu.pendingProps),au=Ci$1(su.type,au),$i$1(iu,eu,su,au,tu);case 15:return bj(iu,eu,eu.type,eu.pendingProps,tu);case 17:return su=eu.type,au=eu.pendingProps,au=eu.elementType===su?au:Ci$1(su,au),ij(iu,eu),eu.tag=1,Zf(su)?(iu=!0,cg(eu)):iu=!1,ch(eu,tu),Gi$1(eu,su,au),Ii$1(eu,su,au,tu),jj(null,eu,su,!0,iu,tu);case 19:return xj(iu,eu,tu);case 22:return dj(iu,eu,tu)}throw Error(p$1(156,eu.tag))};function Fk(iu,eu){return ac$1(iu,eu)}function $k(iu,eu,tu,su){this.tag=iu,this.key=tu,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=eu,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=su,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(iu,eu,tu,su){return new $k(iu,eu,tu,su)}function aj(iu){return iu=iu.prototype,!(!iu||!iu.isReactComponent)}function Zk(iu){if(typeof iu=="function")return aj(iu)?1:0;if(iu!=null){if(iu=iu.$$typeof,iu===Da$1)return 11;if(iu===Ga$1)return 14}return 2}function Pg(iu,eu){var tu=iu.alternate;return tu===null?(tu=Bg(iu.tag,eu,iu.key,iu.mode),tu.elementType=iu.elementType,tu.type=iu.type,tu.stateNode=iu.stateNode,tu.alternate=iu,iu.alternate=tu):(tu.pendingProps=eu,tu.type=iu.type,tu.flags=0,tu.subtreeFlags=0,tu.deletions=null),tu.flags=iu.flags&14680064,tu.childLanes=iu.childLanes,tu.lanes=iu.lanes,tu.child=iu.child,tu.memoizedProps=iu.memoizedProps,tu.memoizedState=iu.memoizedState,tu.updateQueue=iu.updateQueue,eu=iu.dependencies,tu.dependencies=eu===null?null:{lanes:eu.lanes,firstContext:eu.firstContext},tu.sibling=iu.sibling,tu.index=iu.index,tu.ref=iu.ref,tu}function Rg(iu,eu,tu,su,au,uu){var du=2;if(su=iu,typeof iu=="function")aj(iu)&&(du=1);else if(typeof iu=="string")du=5;else e:switch(iu){case ya$1:return Tg(tu.children,au,uu,eu);case za$1:du=8,au|=8;break;case Aa$1:return iu=Bg(12,tu,eu,au|2),iu.elementType=Aa$1,iu.lanes=uu,iu;case Ea$1:return iu=Bg(13,tu,eu,au),iu.elementType=Ea$1,iu.lanes=uu,iu;case Fa$1:return iu=Bg(19,tu,eu,au),iu.elementType=Fa$1,iu.lanes=uu,iu;case Ia$1:return pj(tu,au,uu,eu);default:if(typeof iu=="object"&&iu!==null)switch(iu.$$typeof){case Ba$1:du=10;break e;case Ca$1:du=9;break e;case Da$1:du=11;break e;case Ga$1:du=14;break e;case Ha$1:du=16,su=null;break e}throw Error(p$1(130,iu==null?iu:typeof iu,""))}return eu=Bg(du,tu,eu,au),eu.elementType=iu,eu.type=su,eu.lanes=uu,eu}function Tg(iu,eu,tu,su){return iu=Bg(7,iu,su,eu),iu.lanes=tu,iu}function pj(iu,eu,tu,su){return iu=Bg(22,iu,su,eu),iu.elementType=Ia$1,iu.lanes=tu,iu.stateNode={isHidden:!1},iu}function Qg(iu,eu,tu){return iu=Bg(6,iu,null,eu),iu.lanes=tu,iu}function Sg(iu,eu,tu){return eu=Bg(4,iu.children!==null?iu.children:[],iu.key,eu),eu.lanes=tu,eu.stateNode={containerInfo:iu.containerInfo,pendingChildren:null,implementation:iu.implementation},eu}function al$1(iu,eu,tu,su,au){this.tag=eu,this.containerInfo=iu,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc(0),this.expirationTimes=zc(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc(0),this.identifierPrefix=su,this.onRecoverableError=au,this.mutableSourceEagerHydrationData=null}function bl$1(iu,eu,tu,su,au,uu,du,fu,gu){return iu=new al$1(iu,eu,tu,fu,gu),eu===1?(eu=1,uu===!0&&(eu|=8)):eu=0,uu=Bg(3,null,null,eu),iu.current=uu,uu.stateNode=iu,uu.memoizedState={element:su,isDehydrated:tu,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh(uu),iu}function cl$1(iu,eu,tu){var su=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa$1,key:su==null?null:""+su,children:iu,containerInfo:eu,implementation:tu}}function dl$1(iu){if(!iu)return Vf;iu=iu._reactInternals;e:{if(Vb(iu)!==iu||iu.tag!==1)throw Error(p$1(170));var eu=iu;do{switch(eu.tag){case 3:eu=eu.stateNode.context;break e;case 1:if(Zf(eu.type)){eu=eu.stateNode.__reactInternalMemoizedMergedChildContext;break e}}eu=eu.return}while(eu!==null);throw Error(p$1(171))}if(iu.tag===1){var tu=iu.type;if(Zf(tu))return bg(iu,tu,eu)}return eu}function el$1(iu,eu,tu,su,au,uu,du,fu,gu){return iu=bl$1(tu,su,!0,iu,au,uu,du,fu,gu),iu.context=dl$1(null),tu=iu.current,su=R$1(),au=yi$1(tu),uu=mh(su,au),uu.callback=eu??null,nh(tu,uu,au),iu.current.lanes=au,Ac$1(iu,au,su),Dk(iu,su),iu}function fl$1(iu,eu,tu,su){var au=eu.current,uu=R$1(),du=yi$1(au);return tu=dl$1(tu),eu.context===null?eu.context=tu:eu.pendingContext=tu,eu=mh(uu,du),eu.payload={element:iu},su=su===void 0?null:su,su!==null&&(eu.callback=su),iu=nh(au,eu,du),iu!==null&&(gi$1(iu,au,du,uu),oh(iu,au,du)),du}function gl$1(iu){if(iu=iu.current,!iu.child)return null;switch(iu.child.tag){case 5:return iu.child.stateNode;default:return iu.child.stateNode}}function hl$1(iu,eu){if(iu=iu.memoizedState,iu!==null&&iu.dehydrated!==null){var tu=iu.retryLane;iu.retryLane=tu!==0&&tu<eu?tu:eu}}function il$1(iu,eu){hl$1(iu,eu),(iu=iu.alternate)&&hl$1(iu,eu)}function jl$1(){return null}var kl$1=typeof reportError=="function"?reportError:function(iu){console.error(iu)};function ll$1(iu){this._internalRoot=iu}ml$1.prototype.render=ll$1.prototype.render=function(iu){var eu=this._internalRoot;if(eu===null)throw Error(p$1(409));fl$1(iu,eu,null,null)};ml$1.prototype.unmount=ll$1.prototype.unmount=function(){var iu=this._internalRoot;if(iu!==null){this._internalRoot=null;var eu=iu.containerInfo;Rk(function(){fl$1(null,iu,null,null)}),eu[uf]=null}};function ml$1(iu){this._internalRoot=iu}ml$1.prototype.unstable_scheduleHydration=function(iu){if(iu){var eu=Hc$1();iu={blockedOn:null,target:iu,priority:eu};for(var tu=0;tu<Qc$1.length&&eu!==0&&eu<Qc$1[tu].priority;tu++);Qc$1.splice(tu,0,iu),tu===0&&Vc(iu)}};function nl$1(iu){return!(!iu||iu.nodeType!==1&&iu.nodeType!==9&&iu.nodeType!==11)}function ol$1(iu){return!(!iu||iu.nodeType!==1&&iu.nodeType!==9&&iu.nodeType!==11&&(iu.nodeType!==8||iu.nodeValue!==" react-mount-point-unstable "))}function pl$1(){}function ql$1(iu,eu,tu,su,au){if(au){if(typeof su=="function"){var uu=su;su=function(){var yu=gl$1(du);uu.call(yu)}}var du=el$1(eu,su,iu,0,null,!1,!1,"",pl$1);return iu._reactRootContainer=du,iu[uf]=du.current,sf(iu.nodeType===8?iu.parentNode:iu),Rk(),du}for(;au=iu.lastChild;)iu.removeChild(au);if(typeof su=="function"){var fu=su;su=function(){var yu=gl$1(gu);fu.call(yu)}}var gu=bl$1(iu,0,!1,null,null,!1,!1,"",pl$1);return iu._reactRootContainer=gu,iu[uf]=gu.current,sf(iu.nodeType===8?iu.parentNode:iu),Rk(function(){fl$1(eu,gu,tu,su)}),gu}function rl$1(iu,eu,tu,su,au){var uu=tu._reactRootContainer;if(uu){var du=uu;if(typeof au=="function"){var fu=au;au=function(){var gu=gl$1(du);fu.call(gu)}}fl$1(eu,du,iu,au)}else du=ql$1(tu,eu,iu,au,su);return gl$1(du)}Ec$1=function(iu){switch(iu.tag){case 3:var eu=iu.stateNode;if(eu.current.memoizedState.isDehydrated){var tu=tc$1(eu.pendingLanes);tu!==0&&(Cc$1(eu,tu|1),Dk(eu,B$1()),!(K$1&6)&&(Gj=B$1()+500,jg()))}break;case 13:Rk(function(){var su=ih(iu,1);if(su!==null){var au=R$1();gi$1(su,iu,1,au)}}),il$1(iu,1)}};Fc$1=function(iu){if(iu.tag===13){var eu=ih(iu,134217728);if(eu!==null){var tu=R$1();gi$1(eu,iu,134217728,tu)}il$1(iu,134217728)}};Gc$1=function(iu){if(iu.tag===13){var eu=yi$1(iu),tu=ih(iu,eu);if(tu!==null){var su=R$1();gi$1(tu,iu,eu,su)}il$1(iu,eu)}};Hc$1=function(){return C$1};Ic$1=function(iu,eu){var tu=C$1;try{return C$1=iu,eu()}finally{C$1=tu}};yb=function(iu,eu,tu){switch(eu){case"input":if(bb(iu,tu),eu=tu.name,tu.type==="radio"&&eu!=null){for(tu=iu;tu.parentNode;)tu=tu.parentNode;for(tu=tu.querySelectorAll("input[name="+JSON.stringify(""+eu)+'][type="radio"]'),eu=0;eu<tu.length;eu++){var su=tu[eu];if(su!==iu&&su.form===iu.form){var au=Db(su);if(!au)throw Error(p$1(90));Wa$1(su),bb(su,au)}}}break;case"textarea":ib(iu,tu);break;case"select":eu=tu.value,eu!=null&&fb(iu,!!tu.multiple,eu,!1)}};Gb=Qk;Hb=Rk;var sl$1={usingClientEntryPoint:!1,Events:[Cb,ue$1,Db,Eb,Fb,Qk]},tl$1={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul$1={bundleType:tl$1.bundleType,version:tl$1.version,rendererPackageName:tl$1.rendererPackageName,rendererConfig:tl$1.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua$1.ReactCurrentDispatcher,findHostInstanceByFiber:function(iu){return iu=Zb(iu),iu===null?null:iu.stateNode},findFiberByHostInstance:tl$1.findFiberByHostInstance||jl$1,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl$1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl$1.isDisabled&&vl$1.supportsFiber)try{kc$1=vl$1.inject(ul$1),lc$1=vl$1}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl$1;reactDom_production_min.createPortal=function(iu,eu){var tu=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl$1(eu))throw Error(p$1(200));return cl$1(iu,eu,null,tu)};reactDom_production_min.createRoot=function(iu,eu){if(!nl$1(iu))throw Error(p$1(299));var tu=!1,su="",au=kl$1;return eu!=null&&(eu.unstable_strictMode===!0&&(tu=!0),eu.identifierPrefix!==void 0&&(su=eu.identifierPrefix),eu.onRecoverableError!==void 0&&(au=eu.onRecoverableError)),eu=bl$1(iu,1,!1,null,null,tu,!1,su,au),iu[uf]=eu.current,sf(iu.nodeType===8?iu.parentNode:iu),new ll$1(eu)};reactDom_production_min.findDOMNode=function(iu){if(iu==null)return null;if(iu.nodeType===1)return iu;var eu=iu._reactInternals;if(eu===void 0)throw typeof iu.render=="function"?Error(p$1(188)):(iu=Object.keys(iu).join(","),Error(p$1(268,iu)));return iu=Zb(eu),iu=iu===null?null:iu.stateNode,iu};reactDom_production_min.flushSync=function(iu){return Rk(iu)};reactDom_production_min.hydrate=function(iu,eu,tu){if(!ol$1(eu))throw Error(p$1(200));return rl$1(null,iu,eu,!0,tu)};reactDom_production_min.hydrateRoot=function(iu,eu,tu){if(!nl$1(iu))throw Error(p$1(405));var su=tu!=null&&tu.hydratedSources||null,au=!1,uu="",du=kl$1;if(tu!=null&&(tu.unstable_strictMode===!0&&(au=!0),tu.identifierPrefix!==void 0&&(uu=tu.identifierPrefix),tu.onRecoverableError!==void 0&&(du=tu.onRecoverableError)),eu=el$1(eu,null,iu,1,tu??null,au,!1,uu,du),iu[uf]=eu.current,sf(iu),su)for(iu=0;iu<su.length;iu++)tu=su[iu],au=tu._getVersion,au=au(tu._source),eu.mutableSourceEagerHydrationData==null?eu.mutableSourceEagerHydrationData=[tu,au]:eu.mutableSourceEagerHydrationData.push(tu,au);return new ml$1(eu)};reactDom_production_min.render=function(iu,eu,tu){if(!ol$1(eu))throw Error(p$1(200));return rl$1(null,iu,eu,!1,tu)};reactDom_production_min.unmountComponentAtNode=function(iu){if(!ol$1(iu))throw Error(p$1(40));return iu._reactRootContainer?(Rk(function(){rl$1(null,null,iu,!1,function(){iu._reactRootContainer=null,iu[uf]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(iu,eu,tu,su){if(!ol$1(tu))throw Error(p$1(200));if(iu==null||iu._reactInternals===void 0)throw Error(p$1(38));return rl$1(iu,eu,tu,!1,su)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(iu){console.error(iu)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports,createRoot,m$1=reactDomExports;createRoot=m$1.createRoot,m$1.hydrateRoot;function getDefaultExportFromCjs(iu){return iu&&iu.__esModule&&Object.prototype.hasOwnProperty.call(iu,"default")?iu.default:iu}var browser$1={exports:{}},process=browser$1.exports={},cachedSetTimeout,cachedClearTimeout;function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?cachedSetTimeout=setTimeout:cachedSetTimeout=defaultSetTimout}catch{cachedSetTimeout=defaultSetTimout}try{typeof clearTimeout=="function"?cachedClearTimeout=clearTimeout:cachedClearTimeout=defaultClearTimeout}catch{cachedClearTimeout=defaultClearTimeout}})();function runTimeout(iu){if(cachedSetTimeout===setTimeout)return setTimeout(iu,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(iu,0);try{return cachedSetTimeout(iu,0)}catch{try{return cachedSetTimeout.call(null,iu,0)}catch{return cachedSetTimeout.call(this,iu,0)}}}function runClearTimeout(iu){if(cachedClearTimeout===clearTimeout)return clearTimeout(iu);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(iu);try{return cachedClearTimeout(iu)}catch{try{return cachedClearTimeout.call(null,iu)}catch{return cachedClearTimeout.call(this,iu)}}}var queue=[],draining=!1,currentQueue,queueIndex=-1;function cleanUpNextTick(){!draining||!currentQueue||(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var iu=runTimeout(cleanUpNextTick);draining=!0;for(var eu=queue.length;eu;){for(currentQueue=queue,queue=[];++queueIndex<eu;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,eu=queue.length}currentQueue=null,draining=!1,runClearTimeout(iu)}}process.nextTick=function(iu){var eu=new Array(arguments.length-1);if(arguments.length>1)for(var tu=1;tu<arguments.length;tu++)eu[tu-1]=arguments[tu];queue.push(new Item(iu,eu)),queue.length===1&&!draining&&runTimeout(drainQueue)};function Item(iu,eu){this.fun=iu,this.array=eu}Item.prototype.run=function(){this.fun.apply(null,this.array)};process.title="browser";process.browser=!0;process.env={};process.argv=[];process.version="";process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(iu){return[]};process.binding=function(iu){throw new Error("process.binding is not supported")};process.cwd=function(){return"/"};process.chdir=function(iu){throw new Error("process.chdir is not supported")};process.umask=function(){return 0};var browserExports=browser$1.exports;const process$1=getDefaultExportFromCjs(browserExports);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="173",MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,CullFaceFrontBack=3,BasicShadowMap=0,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AgXToneMapping=6,NeutralToneMapping=7,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipMapNearestFilter=1004,NearestMipmapLinearFilter=1005,NearestMipMapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipMapNearestFilter=1007,LinearMipmapLinearFilter=1008,LinearMipMapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,UnsignedInt5999Type=35902,AlphaFormat=1021,RGBFormat=1022,RGBAFormat=1023,LuminanceFormat=1024,LuminanceAlphaFormat=1025,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBIntegerFormat=1032,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,LoopOnce=2200,LoopRepeat=2201,LoopPingPong=2202,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,AdditiveAnimationBlendMode=2501,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,BasicDepthPacking=3200,RGBADepthPacking=3201,RGBDepthPacking=3202,RGDepthPacking=3203,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",LinearTransfer="linear",SRGBTransfer="srgb",ZeroStencilOp=0,KeepStencilOp=7680,ReplaceStencilOp=7681,IncrementStencilOp=7682,DecrementStencilOp=7683,IncrementWrapStencilOp=34055,DecrementWrapStencilOp=34056,InvertStencilOp=5386,NeverStencilFunc=512,LessStencilFunc=513,EqualStencilFunc=514,LessEqualStencilFunc=515,GreaterStencilFunc=516,NotEqualStencilFunc=517,GreaterEqualStencilFunc=518,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,DynamicDrawUsage=35048,StreamDrawUsage=35040,StaticReadUsage=35045,DynamicReadUsage=35049,StreamReadUsage=35041,StaticCopyUsage=35046,DynamicCopyUsage=35050,StreamCopyUsage=35042,GLSL1="100",GLSL3="300 es",WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001,TimestampQuery={COMPUTE:"compute",RENDER:"render"};class EventDispatcher{addEventListener(eu,tu){this._listeners===void 0&&(this._listeners={});const su=this._listeners;su[eu]===void 0&&(su[eu]=[]),su[eu].indexOf(tu)===-1&&su[eu].push(tu)}hasEventListener(eu,tu){const su=this._listeners;return su===void 0?!1:su[eu]!==void 0&&su[eu].indexOf(tu)!==-1}removeEventListener(eu,tu){const su=this._listeners;if(su===void 0)return;const au=su[eu];if(au!==void 0){const uu=au.indexOf(tu);uu!==-1&&au.splice(uu,1)}}dispatchEvent(eu){const tu=this._listeners;if(tu===void 0)return;const su=tu[eu.type];if(su!==void 0){eu.target=this;const au=su.slice(0);for(let uu=0,du=au.length;uu<du;uu++)au[uu].call(this,eu);eu.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const iu=Math.random()*4294967295|0,eu=Math.random()*4294967295|0,tu=Math.random()*4294967295|0,su=Math.random()*4294967295|0;return(_lut[iu&255]+_lut[iu>>8&255]+_lut[iu>>16&255]+_lut[iu>>24&255]+"-"+_lut[eu&255]+_lut[eu>>8&255]+"-"+_lut[eu>>16&15|64]+_lut[eu>>24&255]+"-"+_lut[tu&63|128]+_lut[tu>>8&255]+"-"+_lut[tu>>16&255]+_lut[tu>>24&255]+_lut[su&255]+_lut[su>>8&255]+_lut[su>>16&255]+_lut[su>>24&255]).toLowerCase()}function clamp(iu,eu,tu){return Math.max(eu,Math.min(tu,iu))}function euclideanModulo(iu,eu){return(iu%eu+eu)%eu}function mapLinear(iu,eu,tu,su,au){return su+(iu-eu)*(au-su)/(tu-eu)}function inverseLerp(iu,eu,tu){return iu!==eu?(tu-iu)/(eu-iu):0}function lerp(iu,eu,tu){return(1-tu)*iu+tu*eu}function damp(iu,eu,tu,su){return lerp(iu,eu,1-Math.exp(-tu*su))}function pingpong(iu,eu=1){return eu-Math.abs(euclideanModulo(iu,eu*2)-eu)}function smoothstep(iu,eu,tu){return iu<=eu?0:iu>=tu?1:(iu=(iu-eu)/(tu-eu),iu*iu*(3-2*iu))}function smootherstep(iu,eu,tu){return iu<=eu?0:iu>=tu?1:(iu=(iu-eu)/(tu-eu),iu*iu*iu*(iu*(iu*6-15)+10))}function randInt(iu,eu){return iu+Math.floor(Math.random()*(eu-iu+1))}function randFloat(iu,eu){return iu+Math.random()*(eu-iu)}function randFloatSpread(iu){return iu*(.5-Math.random())}function seededRandom(iu){iu!==void 0&&(_seed=iu);let eu=_seed+=1831565813;return eu=Math.imul(eu^eu>>>15,eu|1),eu^=eu+Math.imul(eu^eu>>>7,eu|61),((eu^eu>>>14)>>>0)/4294967296}function degToRad(iu){return iu*DEG2RAD}function radToDeg(iu){return iu*RAD2DEG}function isPowerOfTwo(iu){return(iu&iu-1)===0&&iu!==0}function ceilPowerOfTwo(iu){return Math.pow(2,Math.ceil(Math.log(iu)/Math.LN2))}function floorPowerOfTwo(iu){return Math.pow(2,Math.floor(Math.log(iu)/Math.LN2))}function setQuaternionFromProperEuler(iu,eu,tu,su,au){const uu=Math.cos,du=Math.sin,fu=uu(tu/2),gu=du(tu/2),yu=uu((eu+su)/2),xu=du((eu+su)/2),vu=uu((eu-su)/2),Su=du((eu-su)/2),Iu=uu((su-eu)/2),Mu=du((su-eu)/2);switch(au){case"XYX":iu.set(fu*xu,gu*vu,gu*Su,fu*yu);break;case"YZY":iu.set(gu*Su,fu*xu,gu*vu,fu*yu);break;case"ZXZ":iu.set(gu*vu,gu*Su,fu*xu,fu*yu);break;case"XZX":iu.set(fu*xu,gu*Mu,gu*Iu,fu*yu);break;case"YXY":iu.set(gu*Iu,fu*xu,gu*Mu,fu*yu);break;case"ZYZ":iu.set(gu*Mu,gu*Iu,fu*xu,fu*yu);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+au)}}function denormalize(iu,eu){switch(eu.constructor){case Float32Array:return iu;case Uint32Array:return iu/4294967295;case Uint16Array:return iu/65535;case Uint8Array:return iu/255;case Int32Array:return Math.max(iu/2147483647,-1);case Int16Array:return Math.max(iu/32767,-1);case Int8Array:return Math.max(iu/127,-1);default:throw new Error("Invalid component type.")}}function normalize(iu,eu){switch(eu.constructor){case Float32Array:return iu;case Uint32Array:return Math.round(iu*4294967295);case Uint16Array:return Math.round(iu*65535);case Uint8Array:return Math.round(iu*255);case Int32Array:return Math.round(iu*2147483647);case Int16Array:return Math.round(iu*32767);case Int8Array:return Math.round(iu*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp,euclideanModulo,mapLinear,inverseLerp,lerp,damp,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg,isPowerOfTwo,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize,denormalize};class Vector2{constructor(eu=0,tu=0){Vector2.prototype.isVector2=!0,this.x=eu,this.y=tu}get width(){return this.x}set width(eu){this.x=eu}get height(){return this.y}set height(eu){this.y=eu}set(eu,tu){return this.x=eu,this.y=tu,this}setScalar(eu){return this.x=eu,this.y=eu,this}setX(eu){return this.x=eu,this}setY(eu){return this.y=eu,this}setComponent(eu,tu){switch(eu){case 0:this.x=tu;break;case 1:this.y=tu;break;default:throw new Error("index is out of range: "+eu)}return this}getComponent(eu){switch(eu){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+eu)}}clone(){return new this.constructor(this.x,this.y)}copy(eu){return this.x=eu.x,this.y=eu.y,this}add(eu){return this.x+=eu.x,this.y+=eu.y,this}addScalar(eu){return this.x+=eu,this.y+=eu,this}addVectors(eu,tu){return this.x=eu.x+tu.x,this.y=eu.y+tu.y,this}addScaledVector(eu,tu){return this.x+=eu.x*tu,this.y+=eu.y*tu,this}sub(eu){return this.x-=eu.x,this.y-=eu.y,this}subScalar(eu){return this.x-=eu,this.y-=eu,this}subVectors(eu,tu){return this.x=eu.x-tu.x,this.y=eu.y-tu.y,this}multiply(eu){return this.x*=eu.x,this.y*=eu.y,this}multiplyScalar(eu){return this.x*=eu,this.y*=eu,this}divide(eu){return this.x/=eu.x,this.y/=eu.y,this}divideScalar(eu){return this.multiplyScalar(1/eu)}applyMatrix3(eu){const tu=this.x,su=this.y,au=eu.elements;return this.x=au[0]*tu+au[3]*su+au[6],this.y=au[1]*tu+au[4]*su+au[7],this}min(eu){return this.x=Math.min(this.x,eu.x),this.y=Math.min(this.y,eu.y),this}max(eu){return this.x=Math.max(this.x,eu.x),this.y=Math.max(this.y,eu.y),this}clamp(eu,tu){return this.x=clamp(this.x,eu.x,tu.x),this.y=clamp(this.y,eu.y,tu.y),this}clampScalar(eu,tu){return this.x=clamp(this.x,eu,tu),this.y=clamp(this.y,eu,tu),this}clampLength(eu,tu){const su=this.length();return this.divideScalar(su||1).multiplyScalar(clamp(su,eu,tu))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(eu){return this.x*eu.x+this.y*eu.y}cross(eu){return this.x*eu.y-this.y*eu.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(eu){const tu=Math.sqrt(this.lengthSq()*eu.lengthSq());if(tu===0)return Math.PI/2;const su=this.dot(eu)/tu;return Math.acos(clamp(su,-1,1))}distanceTo(eu){return Math.sqrt(this.distanceToSquared(eu))}distanceToSquared(eu){const tu=this.x-eu.x,su=this.y-eu.y;return tu*tu+su*su}manhattanDistanceTo(eu){return Math.abs(this.x-eu.x)+Math.abs(this.y-eu.y)}setLength(eu){return this.normalize().multiplyScalar(eu)}lerp(eu,tu){return this.x+=(eu.x-this.x)*tu,this.y+=(eu.y-this.y)*tu,this}lerpVectors(eu,tu,su){return this.x=eu.x+(tu.x-eu.x)*su,this.y=eu.y+(tu.y-eu.y)*su,this}equals(eu){return eu.x===this.x&&eu.y===this.y}fromArray(eu,tu=0){return this.x=eu[tu],this.y=eu[tu+1],this}toArray(eu=[],tu=0){return eu[tu]=this.x,eu[tu+1]=this.y,eu}fromBufferAttribute(eu,tu){return this.x=eu.getX(tu),this.y=eu.getY(tu),this}rotateAround(eu,tu){const su=Math.cos(tu),au=Math.sin(tu),uu=this.x-eu.x,du=this.y-eu.y;return this.x=uu*su-du*au+eu.x,this.y=uu*au+du*su+eu.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(eu,tu,su,au,uu,du,fu,gu,yu){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],eu!==void 0&&this.set(eu,tu,su,au,uu,du,fu,gu,yu)}set(eu,tu,su,au,uu,du,fu,gu,yu){const xu=this.elements;return xu[0]=eu,xu[1]=au,xu[2]=fu,xu[3]=tu,xu[4]=uu,xu[5]=gu,xu[6]=su,xu[7]=du,xu[8]=yu,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(eu){const tu=this.elements,su=eu.elements;return tu[0]=su[0],tu[1]=su[1],tu[2]=su[2],tu[3]=su[3],tu[4]=su[4],tu[5]=su[5],tu[6]=su[6],tu[7]=su[7],tu[8]=su[8],this}extractBasis(eu,tu,su){return eu.setFromMatrix3Column(this,0),tu.setFromMatrix3Column(this,1),su.setFromMatrix3Column(this,2),this}setFromMatrix4(eu){const tu=eu.elements;return this.set(tu[0],tu[4],tu[8],tu[1],tu[5],tu[9],tu[2],tu[6],tu[10]),this}multiply(eu){return this.multiplyMatrices(this,eu)}premultiply(eu){return this.multiplyMatrices(eu,this)}multiplyMatrices(eu,tu){const su=eu.elements,au=tu.elements,uu=this.elements,du=su[0],fu=su[3],gu=su[6],yu=su[1],xu=su[4],vu=su[7],Su=su[2],Iu=su[5],Mu=su[8],ku=au[0],Bu=au[3],_u=au[6],Lu=au[1],Du=au[4],Ou=au[7],Wu=au[2],Zu=au[5],Hu=au[8];return uu[0]=du*ku+fu*Lu+gu*Wu,uu[3]=du*Bu+fu*Du+gu*Zu,uu[6]=du*_u+fu*Ou+gu*Hu,uu[1]=yu*ku+xu*Lu+vu*Wu,uu[4]=yu*Bu+xu*Du+vu*Zu,uu[7]=yu*_u+xu*Ou+vu*Hu,uu[2]=Su*ku+Iu*Lu+Mu*Wu,uu[5]=Su*Bu+Iu*Du+Mu*Zu,uu[8]=Su*_u+Iu*Ou+Mu*Hu,this}multiplyScalar(eu){const tu=this.elements;return tu[0]*=eu,tu[3]*=eu,tu[6]*=eu,tu[1]*=eu,tu[4]*=eu,tu[7]*=eu,tu[2]*=eu,tu[5]*=eu,tu[8]*=eu,this}determinant(){const eu=this.elements,tu=eu[0],su=eu[1],au=eu[2],uu=eu[3],du=eu[4],fu=eu[5],gu=eu[6],yu=eu[7],xu=eu[8];return tu*du*xu-tu*fu*yu-su*uu*xu+su*fu*gu+au*uu*yu-au*du*gu}invert(){const eu=this.elements,tu=eu[0],su=eu[1],au=eu[2],uu=eu[3],du=eu[4],fu=eu[5],gu=eu[6],yu=eu[7],xu=eu[8],vu=xu*du-fu*yu,Su=fu*gu-xu*uu,Iu=yu*uu-du*gu,Mu=tu*vu+su*Su+au*Iu;if(Mu===0)return this.set(0,0,0,0,0,0,0,0,0);const ku=1/Mu;return eu[0]=vu*ku,eu[1]=(au*yu-xu*su)*ku,eu[2]=(fu*su-au*du)*ku,eu[3]=Su*ku,eu[4]=(xu*tu-au*gu)*ku,eu[5]=(au*uu-fu*tu)*ku,eu[6]=Iu*ku,eu[7]=(su*gu-yu*tu)*ku,eu[8]=(du*tu-su*uu)*ku,this}transpose(){let eu;const tu=this.elements;return eu=tu[1],tu[1]=tu[3],tu[3]=eu,eu=tu[2],tu[2]=tu[6],tu[6]=eu,eu=tu[5],tu[5]=tu[7],tu[7]=eu,this}getNormalMatrix(eu){return this.setFromMatrix4(eu).invert().transpose()}transposeIntoArray(eu){const tu=this.elements;return eu[0]=tu[0],eu[1]=tu[3],eu[2]=tu[6],eu[3]=tu[1],eu[4]=tu[4],eu[5]=tu[7],eu[6]=tu[2],eu[7]=tu[5],eu[8]=tu[8],this}setUvTransform(eu,tu,su,au,uu,du,fu){const gu=Math.cos(uu),yu=Math.sin(uu);return this.set(su*gu,su*yu,-su*(gu*du+yu*fu)+du+eu,-au*yu,au*gu,-au*(-yu*du+gu*fu)+fu+tu,0,0,1),this}scale(eu,tu){return this.premultiply(_m3.makeScale(eu,tu)),this}rotate(eu){return this.premultiply(_m3.makeRotation(-eu)),this}translate(eu,tu){return this.premultiply(_m3.makeTranslation(eu,tu)),this}makeTranslation(eu,tu){return eu.isVector2?this.set(1,0,eu.x,0,1,eu.y,0,0,1):this.set(1,0,eu,0,1,tu,0,0,1),this}makeRotation(eu){const tu=Math.cos(eu),su=Math.sin(eu);return this.set(tu,-su,0,su,tu,0,0,0,1),this}makeScale(eu,tu){return this.set(eu,0,0,0,tu,0,0,0,1),this}equals(eu){const tu=this.elements,su=eu.elements;for(let au=0;au<9;au++)if(tu[au]!==su[au])return!1;return!0}fromArray(eu,tu=0){for(let su=0;su<9;su++)this.elements[su]=eu[su+tu];return this}toArray(eu=[],tu=0){const su=this.elements;return eu[tu]=su[0],eu[tu+1]=su[1],eu[tu+2]=su[2],eu[tu+3]=su[3],eu[tu+4]=su[4],eu[tu+5]=su[5],eu[tu+6]=su[6],eu[tu+7]=su[7],eu[tu+8]=su[8],eu}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3;function arrayNeedsUint32(iu){for(let eu=iu.length-1;eu>=0;--eu)if(iu[eu]>=65535)return!0;return!1}const TYPED_ARRAYS={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function getTypedArray(iu,eu){return new TYPED_ARRAYS[iu](eu)}function createElementNS(iu){return document.createElementNS("http://www.w3.org/1999/xhtml",iu)}function createCanvasElement(){const iu=createElementNS("canvas");return iu.style.display="block",iu}const _cache={};function warnOnce(iu){iu in _cache||(_cache[iu]=!0,console.warn(iu))}function probeAsync(iu,eu,tu){return new Promise(function(su,au){function uu(){switch(iu.clientWaitSync(eu,iu.SYNC_FLUSH_COMMANDS_BIT,0)){case iu.WAIT_FAILED:au();break;case iu.TIMEOUT_EXPIRED:setTimeout(uu,tu);break;default:su()}}setTimeout(uu,tu)})}function toNormalizedProjectionMatrix(iu){const eu=iu.elements;eu[2]=.5*eu[2]+.5*eu[3],eu[6]=.5*eu[6]+.5*eu[7],eu[10]=.5*eu[10]+.5*eu[11],eu[14]=.5*eu[14]+.5*eu[15]}function toReversedProjectionMatrix(iu){const eu=iu.elements;eu[11]===-1?(eu[10]=-eu[10]-1,eu[14]=-eu[14]):(eu[10]=-eu[10],eu[14]=-eu[14]+1)}const LINEAR_REC709_TO_XYZ=new Matrix3().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),XYZ_TO_LINEAR_REC709=new Matrix3().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function createColorManagement(){const iu={enabled:!0,workingColorSpace:LinearSRGBColorSpace,spaces:{},convert:function(au,uu,du){return this.enabled===!1||uu===du||!uu||!du||(this.spaces[uu].transfer===SRGBTransfer&&(au.r=SRGBToLinear(au.r),au.g=SRGBToLinear(au.g),au.b=SRGBToLinear(au.b)),this.spaces[uu].primaries!==this.spaces[du].primaries&&(au.applyMatrix3(this.spaces[uu].toXYZ),au.applyMatrix3(this.spaces[du].fromXYZ)),this.spaces[du].transfer===SRGBTransfer&&(au.r=LinearToSRGB(au.r),au.g=LinearToSRGB(au.g),au.b=LinearToSRGB(au.b))),au},fromWorkingColorSpace:function(au,uu){return this.convert(au,this.workingColorSpace,uu)},toWorkingColorSpace:function(au,uu){return this.convert(au,uu,this.workingColorSpace)},getPrimaries:function(au){return this.spaces[au].primaries},getTransfer:function(au){return au===NoColorSpace?LinearTransfer:this.spaces[au].transfer},getLuminanceCoefficients:function(au,uu=this.workingColorSpace){return au.fromArray(this.spaces[uu].luminanceCoefficients)},define:function(au){Object.assign(this.spaces,au)},_getMatrix:function(au,uu,du){return au.copy(this.spaces[uu].toXYZ).multiply(this.spaces[du].fromXYZ)},_getDrawingBufferColorSpace:function(au){return this.spaces[au].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(au=this.workingColorSpace){return this.spaces[au].workingColorSpaceConfig.unpackColorSpace}},eu=[.64,.33,.3,.6,.15,.06],tu=[.2126,.7152,.0722],su=[.3127,.329];return iu.define({[LinearSRGBColorSpace]:{primaries:eu,whitePoint:su,transfer:LinearTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:tu,workingColorSpaceConfig:{unpackColorSpace:SRGBColorSpace},outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}},[SRGBColorSpace]:{primaries:eu,whitePoint:su,transfer:SRGBTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:tu,outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}}}),iu}const ColorManagement=createColorManagement();function SRGBToLinear(iu){return iu<.04045?iu*.0773993808:Math.pow(iu*.9478672986+.0521327014,2.4)}function LinearToSRGB(iu){return iu<.0031308?iu*12.92:1.055*Math.pow(iu,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(eu){if(/^data:/i.test(eu.src)||typeof HTMLCanvasElement>"u")return eu.src;let tu;if(eu instanceof HTMLCanvasElement)tu=eu;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=eu.width,_canvas.height=eu.height;const su=_canvas.getContext("2d");eu instanceof ImageData?su.putImageData(eu,0,0):su.drawImage(eu,0,0,eu.width,eu.height),tu=_canvas}return tu.toDataURL("image/png")}static sRGBToLinear(eu){if(typeof HTMLImageElement<"u"&&eu instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&eu instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&eu instanceof ImageBitmap){const tu=createElementNS("canvas");tu.width=eu.width,tu.height=eu.height;const su=tu.getContext("2d");su.drawImage(eu,0,0,eu.width,eu.height);const au=su.getImageData(0,0,eu.width,eu.height),uu=au.data;for(let du=0;du<uu.length;du++)uu[du]=SRGBToLinear(uu[du]/255)*255;return su.putImageData(au,0,0),tu}else if(eu.data){const tu=eu.data.slice(0);for(let su=0;su<tu.length;su++)tu instanceof Uint8Array||tu instanceof Uint8ClampedArray?tu[su]=Math.floor(SRGBToLinear(tu[su]/255)*255):tu[su]=SRGBToLinear(tu[su]);return{data:tu,width:eu.width,height:eu.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),eu}}let _sourceId=0;class Source{constructor(eu=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=eu,this.dataReady=!0,this.version=0}set needsUpdate(eu){eu===!0&&this.version++}toJSON(eu){const tu=eu===void 0||typeof eu=="string";if(!tu&&eu.images[this.uuid]!==void 0)return eu.images[this.uuid];const su={uuid:this.uuid,url:""},au=this.data;if(au!==null){let uu;if(Array.isArray(au)){uu=[];for(let du=0,fu=au.length;du<fu;du++)au[du].isDataTexture?uu.push(serializeImage(au[du].image)):uu.push(serializeImage(au[du]))}else uu=serializeImage(au);su.url=uu}return tu||(eu.images[this.uuid]=su),su}}function serializeImage(iu){return typeof HTMLImageElement<"u"&&iu instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&iu instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&iu instanceof ImageBitmap?ImageUtils.getDataURL(iu):iu.data?{data:Array.from(iu.data),width:iu.width,height:iu.height,type:iu.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _textureId=0;class Texture extends EventDispatcher{constructor(eu=Texture.DEFAULT_IMAGE,tu=Texture.DEFAULT_MAPPING,su=ClampToEdgeWrapping,au=ClampToEdgeWrapping,uu=LinearFilter,du=LinearMipmapLinearFilter,fu=RGBAFormat,gu=UnsignedByteType,yu=Texture.DEFAULT_ANISOTROPY,xu=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(eu),this.mipmaps=[],this.mapping=tu,this.channel=0,this.wrapS=su,this.wrapT=au,this.magFilter=uu,this.minFilter=du,this.anisotropy=yu,this.format=fu,this.internalFormat=null,this.type=gu,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=xu,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(eu=null){this.source.data=eu}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(eu){return this.name=eu.name,this.source=eu.source,this.mipmaps=eu.mipmaps.slice(0),this.mapping=eu.mapping,this.channel=eu.channel,this.wrapS=eu.wrapS,this.wrapT=eu.wrapT,this.magFilter=eu.magFilter,this.minFilter=eu.minFilter,this.anisotropy=eu.anisotropy,this.format=eu.format,this.internalFormat=eu.internalFormat,this.type=eu.type,this.offset.copy(eu.offset),this.repeat.copy(eu.repeat),this.center.copy(eu.center),this.rotation=eu.rotation,this.matrixAutoUpdate=eu.matrixAutoUpdate,this.matrix.copy(eu.matrix),this.generateMipmaps=eu.generateMipmaps,this.premultiplyAlpha=eu.premultiplyAlpha,this.flipY=eu.flipY,this.unpackAlignment=eu.unpackAlignment,this.colorSpace=eu.colorSpace,this.renderTarget=eu.renderTarget,this.isRenderTargetTexture=eu.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(eu.userData)),this.needsUpdate=!0,this}toJSON(eu){const tu=eu===void 0||typeof eu=="string";if(!tu&&eu.textures[this.uuid]!==void 0)return eu.textures[this.uuid];const su={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(eu).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(su.userData=this.userData),tu||(eu.textures[this.uuid]=su),su}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(eu){if(this.mapping!==UVMapping)return eu;if(eu.applyMatrix3(this.matrix),eu.x<0||eu.x>1)switch(this.wrapS){case RepeatWrapping:eu.x=eu.x-Math.floor(eu.x);break;case ClampToEdgeWrapping:eu.x=eu.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(eu.x)%2)===1?eu.x=Math.ceil(eu.x)-eu.x:eu.x=eu.x-Math.floor(eu.x);break}if(eu.y<0||eu.y>1)switch(this.wrapT){case RepeatWrapping:eu.y=eu.y-Math.floor(eu.y);break;case ClampToEdgeWrapping:eu.y=eu.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(eu.y)%2)===1?eu.y=Math.ceil(eu.y)-eu.y:eu.y=eu.y-Math.floor(eu.y);break}return this.flipY&&(eu.y=1-eu.y),eu}set needsUpdate(eu){eu===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(eu){eu===!0&&this.pmremVersion++}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(eu=0,tu=0,su=0,au=1){Vector4.prototype.isVector4=!0,this.x=eu,this.y=tu,this.z=su,this.w=au}get width(){return this.z}set width(eu){this.z=eu}get height(){return this.w}set height(eu){this.w=eu}set(eu,tu,su,au){return this.x=eu,this.y=tu,this.z=su,this.w=au,this}setScalar(eu){return this.x=eu,this.y=eu,this.z=eu,this.w=eu,this}setX(eu){return this.x=eu,this}setY(eu){return this.y=eu,this}setZ(eu){return this.z=eu,this}setW(eu){return this.w=eu,this}setComponent(eu,tu){switch(eu){case 0:this.x=tu;break;case 1:this.y=tu;break;case 2:this.z=tu;break;case 3:this.w=tu;break;default:throw new Error("index is out of range: "+eu)}return this}getComponent(eu){switch(eu){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+eu)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(eu){return this.x=eu.x,this.y=eu.y,this.z=eu.z,this.w=eu.w!==void 0?eu.w:1,this}add(eu){return this.x+=eu.x,this.y+=eu.y,this.z+=eu.z,this.w+=eu.w,this}addScalar(eu){return this.x+=eu,this.y+=eu,this.z+=eu,this.w+=eu,this}addVectors(eu,tu){return this.x=eu.x+tu.x,this.y=eu.y+tu.y,this.z=eu.z+tu.z,this.w=eu.w+tu.w,this}addScaledVector(eu,tu){return this.x+=eu.x*tu,this.y+=eu.y*tu,this.z+=eu.z*tu,this.w+=eu.w*tu,this}sub(eu){return this.x-=eu.x,this.y-=eu.y,this.z-=eu.z,this.w-=eu.w,this}subScalar(eu){return this.x-=eu,this.y-=eu,this.z-=eu,this.w-=eu,this}subVectors(eu,tu){return this.x=eu.x-tu.x,this.y=eu.y-tu.y,this.z=eu.z-tu.z,this.w=eu.w-tu.w,this}multiply(eu){return this.x*=eu.x,this.y*=eu.y,this.z*=eu.z,this.w*=eu.w,this}multiplyScalar(eu){return this.x*=eu,this.y*=eu,this.z*=eu,this.w*=eu,this}applyMatrix4(eu){const tu=this.x,su=this.y,au=this.z,uu=this.w,du=eu.elements;return this.x=du[0]*tu+du[4]*su+du[8]*au+du[12]*uu,this.y=du[1]*tu+du[5]*su+du[9]*au+du[13]*uu,this.z=du[2]*tu+du[6]*su+du[10]*au+du[14]*uu,this.w=du[3]*tu+du[7]*su+du[11]*au+du[15]*uu,this}divide(eu){return this.x/=eu.x,this.y/=eu.y,this.z/=eu.z,this.w/=eu.w,this}divideScalar(eu){return this.multiplyScalar(1/eu)}setAxisAngleFromQuaternion(eu){this.w=2*Math.acos(eu.w);const tu=Math.sqrt(1-eu.w*eu.w);return tu<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=eu.x/tu,this.y=eu.y/tu,this.z=eu.z/tu),this}setAxisAngleFromRotationMatrix(eu){let tu,su,au,uu;const gu=eu.elements,yu=gu[0],xu=gu[4],vu=gu[8],Su=gu[1],Iu=gu[5],Mu=gu[9],ku=gu[2],Bu=gu[6],_u=gu[10];if(Math.abs(xu-Su)<.01&&Math.abs(vu-ku)<.01&&Math.abs(Mu-Bu)<.01){if(Math.abs(xu+Su)<.1&&Math.abs(vu+ku)<.1&&Math.abs(Mu+Bu)<.1&&Math.abs(yu+Iu+_u-3)<.1)return this.set(1,0,0,0),this;tu=Math.PI;const Du=(yu+1)/2,Ou=(Iu+1)/2,Wu=(_u+1)/2,Zu=(xu+Su)/4,Hu=(vu+ku)/4,Yu=(Mu+Bu)/4;return Du>Ou&&Du>Wu?Du<.01?(su=0,au=.707106781,uu=.707106781):(su=Math.sqrt(Du),au=Zu/su,uu=Hu/su):Ou>Wu?Ou<.01?(su=.707106781,au=0,uu=.707106781):(au=Math.sqrt(Ou),su=Zu/au,uu=Yu/au):Wu<.01?(su=.707106781,au=.707106781,uu=0):(uu=Math.sqrt(Wu),su=Hu/uu,au=Yu/uu),this.set(su,au,uu,tu),this}let Lu=Math.sqrt((Bu-Mu)*(Bu-Mu)+(vu-ku)*(vu-ku)+(Su-xu)*(Su-xu));return Math.abs(Lu)<.001&&(Lu=1),this.x=(Bu-Mu)/Lu,this.y=(vu-ku)/Lu,this.z=(Su-xu)/Lu,this.w=Math.acos((yu+Iu+_u-1)/2),this}setFromMatrixPosition(eu){const tu=eu.elements;return this.x=tu[12],this.y=tu[13],this.z=tu[14],this.w=tu[15],this}min(eu){return this.x=Math.min(this.x,eu.x),this.y=Math.min(this.y,eu.y),this.z=Math.min(this.z,eu.z),this.w=Math.min(this.w,eu.w),this}max(eu){return this.x=Math.max(this.x,eu.x),this.y=Math.max(this.y,eu.y),this.z=Math.max(this.z,eu.z),this.w=Math.max(this.w,eu.w),this}clamp(eu,tu){return this.x=clamp(this.x,eu.x,tu.x),this.y=clamp(this.y,eu.y,tu.y),this.z=clamp(this.z,eu.z,tu.z),this.w=clamp(this.w,eu.w,tu.w),this}clampScalar(eu,tu){return this.x=clamp(this.x,eu,tu),this.y=clamp(this.y,eu,tu),this.z=clamp(this.z,eu,tu),this.w=clamp(this.w,eu,tu),this}clampLength(eu,tu){const su=this.length();return this.divideScalar(su||1).multiplyScalar(clamp(su,eu,tu))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(eu){return this.x*eu.x+this.y*eu.y+this.z*eu.z+this.w*eu.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(eu){return this.normalize().multiplyScalar(eu)}lerp(eu,tu){return this.x+=(eu.x-this.x)*tu,this.y+=(eu.y-this.y)*tu,this.z+=(eu.z-this.z)*tu,this.w+=(eu.w-this.w)*tu,this}lerpVectors(eu,tu,su){return this.x=eu.x+(tu.x-eu.x)*su,this.y=eu.y+(tu.y-eu.y)*su,this.z=eu.z+(tu.z-eu.z)*su,this.w=eu.w+(tu.w-eu.w)*su,this}equals(eu){return eu.x===this.x&&eu.y===this.y&&eu.z===this.z&&eu.w===this.w}fromArray(eu,tu=0){return this.x=eu[tu],this.y=eu[tu+1],this.z=eu[tu+2],this.w=eu[tu+3],this}toArray(eu=[],tu=0){return eu[tu]=this.x,eu[tu+1]=this.y,eu[tu+2]=this.z,eu[tu+3]=this.w,eu}fromBufferAttribute(eu,tu){return this.x=eu.getX(tu),this.y=eu.getY(tu),this.z=eu.getZ(tu),this.w=eu.getW(tu),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(eu=1,tu=1,su={}){super(),this.isRenderTarget=!0,this.width=eu,this.height=tu,this.depth=1,this.scissor=new Vector4(0,0,eu,tu),this.scissorTest=!1,this.viewport=new Vector4(0,0,eu,tu);const au={width:eu,height:tu,depth:1};su=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},su);const uu=new Texture(au,su.mapping,su.wrapS,su.wrapT,su.magFilter,su.minFilter,su.format,su.type,su.anisotropy,su.colorSpace);uu.flipY=!1,uu.generateMipmaps=su.generateMipmaps,uu.internalFormat=su.internalFormat,this.textures=[];const du=su.count;for(let fu=0;fu<du;fu++)this.textures[fu]=uu.clone(),this.textures[fu].isRenderTargetTexture=!0,this.textures[fu].renderTarget=this;this.depthBuffer=su.depthBuffer,this.stencilBuffer=su.stencilBuffer,this.resolveDepthBuffer=su.resolveDepthBuffer,this.resolveStencilBuffer=su.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=su.depthTexture,this.samples=su.samples}get texture(){return this.textures[0]}set texture(eu){this.textures[0]=eu}set depthTexture(eu){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),eu!==null&&(eu.renderTarget=this),this._depthTexture=eu}get depthTexture(){return this._depthTexture}setSize(eu,tu,su=1){if(this.width!==eu||this.height!==tu||this.depth!==su){this.width=eu,this.height=tu,this.depth=su;for(let au=0,uu=this.textures.length;au<uu;au++)this.textures[au].image.width=eu,this.textures[au].image.height=tu,this.textures[au].image.depth=su;this.dispose()}this.viewport.set(0,0,eu,tu),this.scissor.set(0,0,eu,tu)}clone(){return new this.constructor().copy(this)}copy(eu){this.width=eu.width,this.height=eu.height,this.depth=eu.depth,this.scissor.copy(eu.scissor),this.scissorTest=eu.scissorTest,this.viewport.copy(eu.viewport),this.textures.length=0;for(let su=0,au=eu.textures.length;su<au;su++)this.textures[su]=eu.textures[su].clone(),this.textures[su].isRenderTargetTexture=!0,this.textures[su].renderTarget=this;const tu=Object.assign({},eu.texture.image);return this.texture.source=new Source(tu),this.depthBuffer=eu.depthBuffer,this.stencilBuffer=eu.stencilBuffer,this.resolveDepthBuffer=eu.resolveDepthBuffer,this.resolveStencilBuffer=eu.resolveStencilBuffer,eu.depthTexture!==null&&(this.depthTexture=eu.depthTexture.clone()),this.samples=eu.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(eu=1,tu=1,su={}){super(eu,tu,su),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture{constructor(eu=null,tu=1,su=1,au=1){super(null),this.isDataArrayTexture=!0,this.image={data:eu,width:tu,height:su,depth:au},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(eu){this.layerUpdates.add(eu)}clearLayerUpdates(){this.layerUpdates.clear()}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(eu=1,tu=1,su=1,au={}){super(eu,tu,au),this.isWebGLArrayRenderTarget=!0,this.depth=su,this.texture=new DataArrayTexture(null,eu,tu,su),this.texture.isRenderTargetTexture=!0}}class Data3DTexture extends Texture{constructor(eu=null,tu=1,su=1,au=1){super(null),this.isData3DTexture=!0,this.image={data:eu,width:tu,height:su,depth:au},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(eu=1,tu=1,su=1,au={}){super(eu,tu,au),this.isWebGL3DRenderTarget=!0,this.depth=su,this.texture=new Data3DTexture(null,eu,tu,su),this.texture.isRenderTargetTexture=!0}}class Quaternion{constructor(eu=0,tu=0,su=0,au=1){this.isQuaternion=!0,this._x=eu,this._y=tu,this._z=su,this._w=au}static slerpFlat(eu,tu,su,au,uu,du,fu){let gu=su[au+0],yu=su[au+1],xu=su[au+2],vu=su[au+3];const Su=uu[du+0],Iu=uu[du+1],Mu=uu[du+2],ku=uu[du+3];if(fu===0){eu[tu+0]=gu,eu[tu+1]=yu,eu[tu+2]=xu,eu[tu+3]=vu;return}if(fu===1){eu[tu+0]=Su,eu[tu+1]=Iu,eu[tu+2]=Mu,eu[tu+3]=ku;return}if(vu!==ku||gu!==Su||yu!==Iu||xu!==Mu){let Bu=1-fu;const _u=gu*Su+yu*Iu+xu*Mu+vu*ku,Lu=_u>=0?1:-1,Du=1-_u*_u;if(Du>Number.EPSILON){const Wu=Math.sqrt(Du),Zu=Math.atan2(Wu,_u*Lu);Bu=Math.sin(Bu*Zu)/Wu,fu=Math.sin(fu*Zu)/Wu}const Ou=fu*Lu;if(gu=gu*Bu+Su*Ou,yu=yu*Bu+Iu*Ou,xu=xu*Bu+Mu*Ou,vu=vu*Bu+ku*Ou,Bu===1-fu){const Wu=1/Math.sqrt(gu*gu+yu*yu+xu*xu+vu*vu);gu*=Wu,yu*=Wu,xu*=Wu,vu*=Wu}}eu[tu]=gu,eu[tu+1]=yu,eu[tu+2]=xu,eu[tu+3]=vu}static multiplyQuaternionsFlat(eu,tu,su,au,uu,du){const fu=su[au],gu=su[au+1],yu=su[au+2],xu=su[au+3],vu=uu[du],Su=uu[du+1],Iu=uu[du+2],Mu=uu[du+3];return eu[tu]=fu*Mu+xu*vu+gu*Iu-yu*Su,eu[tu+1]=gu*Mu+xu*Su+yu*vu-fu*Iu,eu[tu+2]=yu*Mu+xu*Iu+fu*Su-gu*vu,eu[tu+3]=xu*Mu-fu*vu-gu*Su-yu*Iu,eu}get x(){return this._x}set x(eu){this._x=eu,this._onChangeCallback()}get y(){return this._y}set y(eu){this._y=eu,this._onChangeCallback()}get z(){return this._z}set z(eu){this._z=eu,this._onChangeCallback()}get w(){return this._w}set w(eu){this._w=eu,this._onChangeCallback()}set(eu,tu,su,au){return this._x=eu,this._y=tu,this._z=su,this._w=au,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(eu){return this._x=eu.x,this._y=eu.y,this._z=eu.z,this._w=eu.w,this._onChangeCallback(),this}setFromEuler(eu,tu=!0){const su=eu._x,au=eu._y,uu=eu._z,du=eu._order,fu=Math.cos,gu=Math.sin,yu=fu(su/2),xu=fu(au/2),vu=fu(uu/2),Su=gu(su/2),Iu=gu(au/2),Mu=gu(uu/2);switch(du){case"XYZ":this._x=Su*xu*vu+yu*Iu*Mu,this._y=yu*Iu*vu-Su*xu*Mu,this._z=yu*xu*Mu+Su*Iu*vu,this._w=yu*xu*vu-Su*Iu*Mu;break;case"YXZ":this._x=Su*xu*vu+yu*Iu*Mu,this._y=yu*Iu*vu-Su*xu*Mu,this._z=yu*xu*Mu-Su*Iu*vu,this._w=yu*xu*vu+Su*Iu*Mu;break;case"ZXY":this._x=Su*xu*vu-yu*Iu*Mu,this._y=yu*Iu*vu+Su*xu*Mu,this._z=yu*xu*Mu+Su*Iu*vu,this._w=yu*xu*vu-Su*Iu*Mu;break;case"ZYX":this._x=Su*xu*vu-yu*Iu*Mu,this._y=yu*Iu*vu+Su*xu*Mu,this._z=yu*xu*Mu-Su*Iu*vu,this._w=yu*xu*vu+Su*Iu*Mu;break;case"YZX":this._x=Su*xu*vu+yu*Iu*Mu,this._y=yu*Iu*vu+Su*xu*Mu,this._z=yu*xu*Mu-Su*Iu*vu,this._w=yu*xu*vu-Su*Iu*Mu;break;case"XZY":this._x=Su*xu*vu-yu*Iu*Mu,this._y=yu*Iu*vu-Su*xu*Mu,this._z=yu*xu*Mu+Su*Iu*vu,this._w=yu*xu*vu+Su*Iu*Mu;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+du)}return tu===!0&&this._onChangeCallback(),this}setFromAxisAngle(eu,tu){const su=tu/2,au=Math.sin(su);return this._x=eu.x*au,this._y=eu.y*au,this._z=eu.z*au,this._w=Math.cos(su),this._onChangeCallback(),this}setFromRotationMatrix(eu){const tu=eu.elements,su=tu[0],au=tu[4],uu=tu[8],du=tu[1],fu=tu[5],gu=tu[9],yu=tu[2],xu=tu[6],vu=tu[10],Su=su+fu+vu;if(Su>0){const Iu=.5/Math.sqrt(Su+1);this._w=.25/Iu,this._x=(xu-gu)*Iu,this._y=(uu-yu)*Iu,this._z=(du-au)*Iu}else if(su>fu&&su>vu){const Iu=2*Math.sqrt(1+su-fu-vu);this._w=(xu-gu)/Iu,this._x=.25*Iu,this._y=(au+du)/Iu,this._z=(uu+yu)/Iu}else if(fu>vu){const Iu=2*Math.sqrt(1+fu-su-vu);this._w=(uu-yu)/Iu,this._x=(au+du)/Iu,this._y=.25*Iu,this._z=(gu+xu)/Iu}else{const Iu=2*Math.sqrt(1+vu-su-fu);this._w=(du-au)/Iu,this._x=(uu+yu)/Iu,this._y=(gu+xu)/Iu,this._z=.25*Iu}return this._onChangeCallback(),this}setFromUnitVectors(eu,tu){let su=eu.dot(tu)+1;return su<Number.EPSILON?(su=0,Math.abs(eu.x)>Math.abs(eu.z)?(this._x=-eu.y,this._y=eu.x,this._z=0,this._w=su):(this._x=0,this._y=-eu.z,this._z=eu.y,this._w=su)):(this._x=eu.y*tu.z-eu.z*tu.y,this._y=eu.z*tu.x-eu.x*tu.z,this._z=eu.x*tu.y-eu.y*tu.x,this._w=su),this.normalize()}angleTo(eu){return 2*Math.acos(Math.abs(clamp(this.dot(eu),-1,1)))}rotateTowards(eu,tu){const su=this.angleTo(eu);if(su===0)return this;const au=Math.min(1,tu/su);return this.slerp(eu,au),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(eu){return this._x*eu._x+this._y*eu._y+this._z*eu._z+this._w*eu._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let eu=this.length();return eu===0?(this._x=0,this._y=0,this._z=0,this._w=1):(eu=1/eu,this._x=this._x*eu,this._y=this._y*eu,this._z=this._z*eu,this._w=this._w*eu),this._onChangeCallback(),this}multiply(eu){return this.multiplyQuaternions(this,eu)}premultiply(eu){return this.multiplyQuaternions(eu,this)}multiplyQuaternions(eu,tu){const su=eu._x,au=eu._y,uu=eu._z,du=eu._w,fu=tu._x,gu=tu._y,yu=tu._z,xu=tu._w;return this._x=su*xu+du*fu+au*yu-uu*gu,this._y=au*xu+du*gu+uu*fu-su*yu,this._z=uu*xu+du*yu+su*gu-au*fu,this._w=du*xu-su*fu-au*gu-uu*yu,this._onChangeCallback(),this}slerp(eu,tu){if(tu===0)return this;if(tu===1)return this.copy(eu);const su=this._x,au=this._y,uu=this._z,du=this._w;let fu=du*eu._w+su*eu._x+au*eu._y+uu*eu._z;if(fu<0?(this._w=-eu._w,this._x=-eu._x,this._y=-eu._y,this._z=-eu._z,fu=-fu):this.copy(eu),fu>=1)return this._w=du,this._x=su,this._y=au,this._z=uu,this;const gu=1-fu*fu;if(gu<=Number.EPSILON){const Iu=1-tu;return this._w=Iu*du+tu*this._w,this._x=Iu*su+tu*this._x,this._y=Iu*au+tu*this._y,this._z=Iu*uu+tu*this._z,this.normalize(),this}const yu=Math.sqrt(gu),xu=Math.atan2(yu,fu),vu=Math.sin((1-tu)*xu)/yu,Su=Math.sin(tu*xu)/yu;return this._w=du*vu+this._w*Su,this._x=su*vu+this._x*Su,this._y=au*vu+this._y*Su,this._z=uu*vu+this._z*Su,this._onChangeCallback(),this}slerpQuaternions(eu,tu,su){return this.copy(eu).slerp(tu,su)}random(){const eu=2*Math.PI*Math.random(),tu=2*Math.PI*Math.random(),su=Math.random(),au=Math.sqrt(1-su),uu=Math.sqrt(su);return this.set(au*Math.sin(eu),au*Math.cos(eu),uu*Math.sin(tu),uu*Math.cos(tu))}equals(eu){return eu._x===this._x&&eu._y===this._y&&eu._z===this._z&&eu._w===this._w}fromArray(eu,tu=0){return this._x=eu[tu],this._y=eu[tu+1],this._z=eu[tu+2],this._w=eu[tu+3],this._onChangeCallback(),this}toArray(eu=[],tu=0){return eu[tu]=this._x,eu[tu+1]=this._y,eu[tu+2]=this._z,eu[tu+3]=this._w,eu}fromBufferAttribute(eu,tu){return this._x=eu.getX(tu),this._y=eu.getY(tu),this._z=eu.getZ(tu),this._w=eu.getW(tu),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(eu){return this._onChangeCallback=eu,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(eu=0,tu=0,su=0){Vector3.prototype.isVector3=!0,this.x=eu,this.y=tu,this.z=su}set(eu,tu,su){return su===void 0&&(su=this.z),this.x=eu,this.y=tu,this.z=su,this}setScalar(eu){return this.x=eu,this.y=eu,this.z=eu,this}setX(eu){return this.x=eu,this}setY(eu){return this.y=eu,this}setZ(eu){return this.z=eu,this}setComponent(eu,tu){switch(eu){case 0:this.x=tu;break;case 1:this.y=tu;break;case 2:this.z=tu;break;default:throw new Error("index is out of range: "+eu)}return this}getComponent(eu){switch(eu){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+eu)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(eu){return this.x=eu.x,this.y=eu.y,this.z=eu.z,this}add(eu){return this.x+=eu.x,this.y+=eu.y,this.z+=eu.z,this}addScalar(eu){return this.x+=eu,this.y+=eu,this.z+=eu,this}addVectors(eu,tu){return this.x=eu.x+tu.x,this.y=eu.y+tu.y,this.z=eu.z+tu.z,this}addScaledVector(eu,tu){return this.x+=eu.x*tu,this.y+=eu.y*tu,this.z+=eu.z*tu,this}sub(eu){return this.x-=eu.x,this.y-=eu.y,this.z-=eu.z,this}subScalar(eu){return this.x-=eu,this.y-=eu,this.z-=eu,this}subVectors(eu,tu){return this.x=eu.x-tu.x,this.y=eu.y-tu.y,this.z=eu.z-tu.z,this}multiply(eu){return this.x*=eu.x,this.y*=eu.y,this.z*=eu.z,this}multiplyScalar(eu){return this.x*=eu,this.y*=eu,this.z*=eu,this}multiplyVectors(eu,tu){return this.x=eu.x*tu.x,this.y=eu.y*tu.y,this.z=eu.z*tu.z,this}applyEuler(eu){return this.applyQuaternion(_quaternion$4.setFromEuler(eu))}applyAxisAngle(eu,tu){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(eu,tu))}applyMatrix3(eu){const tu=this.x,su=this.y,au=this.z,uu=eu.elements;return this.x=uu[0]*tu+uu[3]*su+uu[6]*au,this.y=uu[1]*tu+uu[4]*su+uu[7]*au,this.z=uu[2]*tu+uu[5]*su+uu[8]*au,this}applyNormalMatrix(eu){return this.applyMatrix3(eu).normalize()}applyMatrix4(eu){const tu=this.x,su=this.y,au=this.z,uu=eu.elements,du=1/(uu[3]*tu+uu[7]*su+uu[11]*au+uu[15]);return this.x=(uu[0]*tu+uu[4]*su+uu[8]*au+uu[12])*du,this.y=(uu[1]*tu+uu[5]*su+uu[9]*au+uu[13])*du,this.z=(uu[2]*tu+uu[6]*su+uu[10]*au+uu[14])*du,this}applyQuaternion(eu){const tu=this.x,su=this.y,au=this.z,uu=eu.x,du=eu.y,fu=eu.z,gu=eu.w,yu=2*(du*au-fu*su),xu=2*(fu*tu-uu*au),vu=2*(uu*su-du*tu);return this.x=tu+gu*yu+du*vu-fu*xu,this.y=su+gu*xu+fu*yu-uu*vu,this.z=au+gu*vu+uu*xu-du*yu,this}project(eu){return this.applyMatrix4(eu.matrixWorldInverse).applyMatrix4(eu.projectionMatrix)}unproject(eu){return this.applyMatrix4(eu.projectionMatrixInverse).applyMatrix4(eu.matrixWorld)}transformDirection(eu){const tu=this.x,su=this.y,au=this.z,uu=eu.elements;return this.x=uu[0]*tu+uu[4]*su+uu[8]*au,this.y=uu[1]*tu+uu[5]*su+uu[9]*au,this.z=uu[2]*tu+uu[6]*su+uu[10]*au,this.normalize()}divide(eu){return this.x/=eu.x,this.y/=eu.y,this.z/=eu.z,this}divideScalar(eu){return this.multiplyScalar(1/eu)}min(eu){return this.x=Math.min(this.x,eu.x),this.y=Math.min(this.y,eu.y),this.z=Math.min(this.z,eu.z),this}max(eu){return this.x=Math.max(this.x,eu.x),this.y=Math.max(this.y,eu.y),this.z=Math.max(this.z,eu.z),this}clamp(eu,tu){return this.x=clamp(this.x,eu.x,tu.x),this.y=clamp(this.y,eu.y,tu.y),this.z=clamp(this.z,eu.z,tu.z),this}clampScalar(eu,tu){return this.x=clamp(this.x,eu,tu),this.y=clamp(this.y,eu,tu),this.z=clamp(this.z,eu,tu),this}clampLength(eu,tu){const su=this.length();return this.divideScalar(su||1).multiplyScalar(clamp(su,eu,tu))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(eu){return this.x*eu.x+this.y*eu.y+this.z*eu.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(eu){return this.normalize().multiplyScalar(eu)}lerp(eu,tu){return this.x+=(eu.x-this.x)*tu,this.y+=(eu.y-this.y)*tu,this.z+=(eu.z-this.z)*tu,this}lerpVectors(eu,tu,su){return this.x=eu.x+(tu.x-eu.x)*su,this.y=eu.y+(tu.y-eu.y)*su,this.z=eu.z+(tu.z-eu.z)*su,this}cross(eu){return this.crossVectors(this,eu)}crossVectors(eu,tu){const su=eu.x,au=eu.y,uu=eu.z,du=tu.x,fu=tu.y,gu=tu.z;return this.x=au*gu-uu*fu,this.y=uu*du-su*gu,this.z=su*fu-au*du,this}projectOnVector(eu){const tu=eu.lengthSq();if(tu===0)return this.set(0,0,0);const su=eu.dot(this)/tu;return this.copy(eu).multiplyScalar(su)}projectOnPlane(eu){return _vector$c.copy(this).projectOnVector(eu),this.sub(_vector$c)}reflect(eu){return this.sub(_vector$c.copy(eu).multiplyScalar(2*this.dot(eu)))}angleTo(eu){const tu=Math.sqrt(this.lengthSq()*eu.lengthSq());if(tu===0)return Math.PI/2;const su=this.dot(eu)/tu;return Math.acos(clamp(su,-1,1))}distanceTo(eu){return Math.sqrt(this.distanceToSquared(eu))}distanceToSquared(eu){const tu=this.x-eu.x,su=this.y-eu.y,au=this.z-eu.z;return tu*tu+su*su+au*au}manhattanDistanceTo(eu){return Math.abs(this.x-eu.x)+Math.abs(this.y-eu.y)+Math.abs(this.z-eu.z)}setFromSpherical(eu){return this.setFromSphericalCoords(eu.radius,eu.phi,eu.theta)}setFromSphericalCoords(eu,tu,su){const au=Math.sin(tu)*eu;return this.x=au*Math.sin(su),this.y=Math.cos(tu)*eu,this.z=au*Math.cos(su),this}setFromCylindrical(eu){return this.setFromCylindricalCoords(eu.radius,eu.theta,eu.y)}setFromCylindricalCoords(eu,tu,su){return this.x=eu*Math.sin(tu),this.y=su,this.z=eu*Math.cos(tu),this}setFromMatrixPosition(eu){const tu=eu.elements;return this.x=tu[12],this.y=tu[13],this.z=tu[14],this}setFromMatrixScale(eu){const tu=this.setFromMatrixColumn(eu,0).length(),su=this.setFromMatrixColumn(eu,1).length(),au=this.setFromMatrixColumn(eu,2).length();return this.x=tu,this.y=su,this.z=au,this}setFromMatrixColumn(eu,tu){return this.fromArray(eu.elements,tu*4)}setFromMatrix3Column(eu,tu){return this.fromArray(eu.elements,tu*3)}setFromEuler(eu){return this.x=eu._x,this.y=eu._y,this.z=eu._z,this}setFromColor(eu){return this.x=eu.r,this.y=eu.g,this.z=eu.b,this}equals(eu){return eu.x===this.x&&eu.y===this.y&&eu.z===this.z}fromArray(eu,tu=0){return this.x=eu[tu],this.y=eu[tu+1],this.z=eu[tu+2],this}toArray(eu=[],tu=0){return eu[tu]=this.x,eu[tu+1]=this.y,eu[tu+2]=this.z,eu}fromBufferAttribute(eu,tu){return this.x=eu.getX(tu),this.y=eu.getY(tu),this.z=eu.getZ(tu),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const eu=Math.random()*Math.PI*2,tu=Math.random()*2-1,su=Math.sqrt(1-tu*tu);return this.x=su*Math.cos(eu),this.y=tu,this.z=su*Math.sin(eu),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(eu=new Vector3(1/0,1/0,1/0),tu=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=eu,this.max=tu}set(eu,tu){return this.min.copy(eu),this.max.copy(tu),this}setFromArray(eu){this.makeEmpty();for(let tu=0,su=eu.length;tu<su;tu+=3)this.expandByPoint(_vector$b.fromArray(eu,tu));return this}setFromBufferAttribute(eu){this.makeEmpty();for(let tu=0,su=eu.count;tu<su;tu++)this.expandByPoint(_vector$b.fromBufferAttribute(eu,tu));return this}setFromPoints(eu){this.makeEmpty();for(let tu=0,su=eu.length;tu<su;tu++)this.expandByPoint(eu[tu]);return this}setFromCenterAndSize(eu,tu){const su=_vector$b.copy(tu).multiplyScalar(.5);return this.min.copy(eu).sub(su),this.max.copy(eu).add(su),this}setFromObject(eu,tu=!1){return this.makeEmpty(),this.expandByObject(eu,tu)}clone(){return new this.constructor().copy(this)}copy(eu){return this.min.copy(eu.min),this.max.copy(eu.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(eu){return this.isEmpty()?eu.set(0,0,0):eu.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(eu){return this.isEmpty()?eu.set(0,0,0):eu.subVectors(this.max,this.min)}expandByPoint(eu){return this.min.min(eu),this.max.max(eu),this}expandByVector(eu){return this.min.sub(eu),this.max.add(eu),this}expandByScalar(eu){return this.min.addScalar(-eu),this.max.addScalar(eu),this}expandByObject(eu,tu=!1){eu.updateWorldMatrix(!1,!1);const su=eu.geometry;if(su!==void 0){const uu=su.getAttribute("position");if(tu===!0&&uu!==void 0&&eu.isInstancedMesh!==!0)for(let du=0,fu=uu.count;du<fu;du++)eu.isMesh===!0?eu.getVertexPosition(du,_vector$b):_vector$b.fromBufferAttribute(uu,du),_vector$b.applyMatrix4(eu.matrixWorld),this.expandByPoint(_vector$b);else eu.boundingBox!==void 0?(eu.boundingBox===null&&eu.computeBoundingBox(),_box$4.copy(eu.boundingBox)):(su.boundingBox===null&&su.computeBoundingBox(),_box$4.copy(su.boundingBox)),_box$4.applyMatrix4(eu.matrixWorld),this.union(_box$4)}const au=eu.children;for(let uu=0,du=au.length;uu<du;uu++)this.expandByObject(au[uu],tu);return this}containsPoint(eu){return eu.x>=this.min.x&&eu.x<=this.max.x&&eu.y>=this.min.y&&eu.y<=this.max.y&&eu.z>=this.min.z&&eu.z<=this.max.z}containsBox(eu){return this.min.x<=eu.min.x&&eu.max.x<=this.max.x&&this.min.y<=eu.min.y&&eu.max.y<=this.max.y&&this.min.z<=eu.min.z&&eu.max.z<=this.max.z}getParameter(eu,tu){return tu.set((eu.x-this.min.x)/(this.max.x-this.min.x),(eu.y-this.min.y)/(this.max.y-this.min.y),(eu.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(eu){return eu.max.x>=this.min.x&&eu.min.x<=this.max.x&&eu.max.y>=this.min.y&&eu.min.y<=this.max.y&&eu.max.z>=this.min.z&&eu.min.z<=this.max.z}intersectsSphere(eu){return this.clampPoint(eu.center,_vector$b),_vector$b.distanceToSquared(eu.center)<=eu.radius*eu.radius}intersectsPlane(eu){let tu,su;return eu.normal.x>0?(tu=eu.normal.x*this.min.x,su=eu.normal.x*this.max.x):(tu=eu.normal.x*this.max.x,su=eu.normal.x*this.min.x),eu.normal.y>0?(tu+=eu.normal.y*this.min.y,su+=eu.normal.y*this.max.y):(tu+=eu.normal.y*this.max.y,su+=eu.normal.y*this.min.y),eu.normal.z>0?(tu+=eu.normal.z*this.min.z,su+=eu.normal.z*this.max.z):(tu+=eu.normal.z*this.max.z,su+=eu.normal.z*this.min.z),tu<=-eu.constant&&su>=-eu.constant}intersectsTriangle(eu){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(eu.a,_center),_v1$7.subVectors(eu.b,_center),_v2$4.subVectors(eu.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let tu=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(tu,_v0$2,_v1$7,_v2$4,_extents)||(tu=[1,0,0,0,1,0,0,0,1],!satForAxes(tu,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),tu=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(tu,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(eu,tu){return tu.copy(eu).clamp(this.min,this.max)}distanceToPoint(eu){return this.clampPoint(eu,_vector$b).distanceTo(eu)}getBoundingSphere(eu){return this.isEmpty()?eu.makeEmpty():(this.getCenter(eu.center),eu.radius=this.getSize(_vector$b).length()*.5),eu}intersect(eu){return this.min.max(eu.min),this.max.min(eu.max),this.isEmpty()&&this.makeEmpty(),this}union(eu){return this.min.min(eu.min),this.max.max(eu.max),this}applyMatrix4(eu){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(eu),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(eu),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(eu),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(eu),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(eu),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(eu),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(eu),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(eu),this.setFromPoints(_points),this)}translate(eu){return this.min.add(eu),this.max.add(eu),this}equals(eu){return eu.min.equals(this.min)&&eu.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$4=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(iu,eu,tu,su,au){for(let uu=0,du=iu.length-3;uu<=du;uu+=3){_testAxis.fromArray(iu,uu);const fu=au.x*Math.abs(_testAxis.x)+au.y*Math.abs(_testAxis.y)+au.z*Math.abs(_testAxis.z),gu=eu.dot(_testAxis),yu=tu.dot(_testAxis),xu=su.dot(_testAxis);if(Math.max(-Math.max(gu,yu,xu),Math.min(gu,yu,xu))>fu)return!1}return!0}const _box$3=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(eu=new Vector3,tu=-1){this.isSphere=!0,this.center=eu,this.radius=tu}set(eu,tu){return this.center.copy(eu),this.radius=tu,this}setFromPoints(eu,tu){const su=this.center;tu!==void 0?su.copy(tu):_box$3.setFromPoints(eu).getCenter(su);let au=0;for(let uu=0,du=eu.length;uu<du;uu++)au=Math.max(au,su.distanceToSquared(eu[uu]));return this.radius=Math.sqrt(au),this}copy(eu){return this.center.copy(eu.center),this.radius=eu.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(eu){return eu.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(eu){return eu.distanceTo(this.center)-this.radius}intersectsSphere(eu){const tu=this.radius+eu.radius;return eu.center.distanceToSquared(this.center)<=tu*tu}intersectsBox(eu){return eu.intersectsSphere(this)}intersectsPlane(eu){return Math.abs(eu.distanceToPoint(this.center))<=this.radius}clampPoint(eu,tu){const su=this.center.distanceToSquared(eu);return tu.copy(eu),su>this.radius*this.radius&&(tu.sub(this.center).normalize(),tu.multiplyScalar(this.radius).add(this.center)),tu}getBoundingBox(eu){return this.isEmpty()?(eu.makeEmpty(),eu):(eu.set(this.center,this.center),eu.expandByScalar(this.radius),eu)}applyMatrix4(eu){return this.center.applyMatrix4(eu),this.radius=this.radius*eu.getMaxScaleOnAxis(),this}translate(eu){return this.center.add(eu),this}expandByPoint(eu){if(this.isEmpty())return this.center.copy(eu),this.radius=0,this;_v1$6.subVectors(eu,this.center);const tu=_v1$6.lengthSq();if(tu>this.radius*this.radius){const su=Math.sqrt(tu),au=(su-this.radius)*.5;this.center.addScaledVector(_v1$6,au/su),this.radius+=au}return this}union(eu){return eu.isEmpty()?this:this.isEmpty()?(this.copy(eu),this):(this.center.equals(eu.center)===!0?this.radius=Math.max(this.radius,eu.radius):(_v2$3.subVectors(eu.center,this.center).setLength(eu.radius),this.expandByPoint(_v1$6.copy(eu.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(eu.center).sub(_v2$3))),this)}equals(eu){return eu.center.equals(this.center)&&eu.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(eu=new Vector3,tu=new Vector3(0,0,-1)){this.origin=eu,this.direction=tu}set(eu,tu){return this.origin.copy(eu),this.direction.copy(tu),this}copy(eu){return this.origin.copy(eu.origin),this.direction.copy(eu.direction),this}at(eu,tu){return tu.copy(this.origin).addScaledVector(this.direction,eu)}lookAt(eu){return this.direction.copy(eu).sub(this.origin).normalize(),this}recast(eu){return this.origin.copy(this.at(eu,_vector$a)),this}closestPointToPoint(eu,tu){tu.subVectors(eu,this.origin);const su=tu.dot(this.direction);return su<0?tu.copy(this.origin):tu.copy(this.origin).addScaledVector(this.direction,su)}distanceToPoint(eu){return Math.sqrt(this.distanceSqToPoint(eu))}distanceSqToPoint(eu){const tu=_vector$a.subVectors(eu,this.origin).dot(this.direction);return tu<0?this.origin.distanceToSquared(eu):(_vector$a.copy(this.origin).addScaledVector(this.direction,tu),_vector$a.distanceToSquared(eu))}distanceSqToSegment(eu,tu,su,au){_segCenter.copy(eu).add(tu).multiplyScalar(.5),_segDir.copy(tu).sub(eu).normalize(),_diff.copy(this.origin).sub(_segCenter);const uu=eu.distanceTo(tu)*.5,du=-this.direction.dot(_segDir),fu=_diff.dot(this.direction),gu=-_diff.dot(_segDir),yu=_diff.lengthSq(),xu=Math.abs(1-du*du);let vu,Su,Iu,Mu;if(xu>0)if(vu=du*gu-fu,Su=du*fu-gu,Mu=uu*xu,vu>=0)if(Su>=-Mu)if(Su<=Mu){const ku=1/xu;vu*=ku,Su*=ku,Iu=vu*(vu+du*Su+2*fu)+Su*(du*vu+Su+2*gu)+yu}else Su=uu,vu=Math.max(0,-(du*Su+fu)),Iu=-vu*vu+Su*(Su+2*gu)+yu;else Su=-uu,vu=Math.max(0,-(du*Su+fu)),Iu=-vu*vu+Su*(Su+2*gu)+yu;else Su<=-Mu?(vu=Math.max(0,-(-du*uu+fu)),Su=vu>0?-uu:Math.min(Math.max(-uu,-gu),uu),Iu=-vu*vu+Su*(Su+2*gu)+yu):Su<=Mu?(vu=0,Su=Math.min(Math.max(-uu,-gu),uu),Iu=Su*(Su+2*gu)+yu):(vu=Math.max(0,-(du*uu+fu)),Su=vu>0?uu:Math.min(Math.max(-uu,-gu),uu),Iu=-vu*vu+Su*(Su+2*gu)+yu);else Su=du>0?-uu:uu,vu=Math.max(0,-(du*Su+fu)),Iu=-vu*vu+Su*(Su+2*gu)+yu;return su&&su.copy(this.origin).addScaledVector(this.direction,vu),au&&au.copy(_segCenter).addScaledVector(_segDir,Su),Iu}intersectSphere(eu,tu){_vector$a.subVectors(eu.center,this.origin);const su=_vector$a.dot(this.direction),au=_vector$a.dot(_vector$a)-su*su,uu=eu.radius*eu.radius;if(au>uu)return null;const du=Math.sqrt(uu-au),fu=su-du,gu=su+du;return gu<0?null:fu<0?this.at(gu,tu):this.at(fu,tu)}intersectsSphere(eu){return this.distanceSqToPoint(eu.center)<=eu.radius*eu.radius}distanceToPlane(eu){const tu=eu.normal.dot(this.direction);if(tu===0)return eu.distanceToPoint(this.origin)===0?0:null;const su=-(this.origin.dot(eu.normal)+eu.constant)/tu;return su>=0?su:null}intersectPlane(eu,tu){const su=this.distanceToPlane(eu);return su===null?null:this.at(su,tu)}intersectsPlane(eu){const tu=eu.distanceToPoint(this.origin);return tu===0||eu.normal.dot(this.direction)*tu<0}intersectBox(eu,tu){let su,au,uu,du,fu,gu;const yu=1/this.direction.x,xu=1/this.direction.y,vu=1/this.direction.z,Su=this.origin;return yu>=0?(su=(eu.min.x-Su.x)*yu,au=(eu.max.x-Su.x)*yu):(su=(eu.max.x-Su.x)*yu,au=(eu.min.x-Su.x)*yu),xu>=0?(uu=(eu.min.y-Su.y)*xu,du=(eu.max.y-Su.y)*xu):(uu=(eu.max.y-Su.y)*xu,du=(eu.min.y-Su.y)*xu),su>du||uu>au||((uu>su||isNaN(su))&&(su=uu),(du<au||isNaN(au))&&(au=du),vu>=0?(fu=(eu.min.z-Su.z)*vu,gu=(eu.max.z-Su.z)*vu):(fu=(eu.max.z-Su.z)*vu,gu=(eu.min.z-Su.z)*vu),su>gu||fu>au)||((fu>su||su!==su)&&(su=fu),(gu<au||au!==au)&&(au=gu),au<0)?null:this.at(su>=0?su:au,tu)}intersectsBox(eu){return this.intersectBox(eu,_vector$a)!==null}intersectTriangle(eu,tu,su,au,uu){_edge1.subVectors(tu,eu),_edge2.subVectors(su,eu),_normal$1.crossVectors(_edge1,_edge2);let du=this.direction.dot(_normal$1),fu;if(du>0){if(au)return null;fu=1}else if(du<0)fu=-1,du=-du;else return null;_diff.subVectors(this.origin,eu);const gu=fu*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(gu<0)return null;const yu=fu*this.direction.dot(_edge1.cross(_diff));if(yu<0||gu+yu>du)return null;const xu=-fu*_diff.dot(_normal$1);return xu<0?null:this.at(xu/du,uu)}applyMatrix4(eu){return this.origin.applyMatrix4(eu),this.direction.transformDirection(eu),this}equals(eu){return eu.origin.equals(this.origin)&&eu.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(eu,tu,su,au,uu,du,fu,gu,yu,xu,vu,Su,Iu,Mu,ku,Bu){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],eu!==void 0&&this.set(eu,tu,su,au,uu,du,fu,gu,yu,xu,vu,Su,Iu,Mu,ku,Bu)}set(eu,tu,su,au,uu,du,fu,gu,yu,xu,vu,Su,Iu,Mu,ku,Bu){const _u=this.elements;return _u[0]=eu,_u[4]=tu,_u[8]=su,_u[12]=au,_u[1]=uu,_u[5]=du,_u[9]=fu,_u[13]=gu,_u[2]=yu,_u[6]=xu,_u[10]=vu,_u[14]=Su,_u[3]=Iu,_u[7]=Mu,_u[11]=ku,_u[15]=Bu,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(eu){const tu=this.elements,su=eu.elements;return tu[0]=su[0],tu[1]=su[1],tu[2]=su[2],tu[3]=su[3],tu[4]=su[4],tu[5]=su[5],tu[6]=su[6],tu[7]=su[7],tu[8]=su[8],tu[9]=su[9],tu[10]=su[10],tu[11]=su[11],tu[12]=su[12],tu[13]=su[13],tu[14]=su[14],tu[15]=su[15],this}copyPosition(eu){const tu=this.elements,su=eu.elements;return tu[12]=su[12],tu[13]=su[13],tu[14]=su[14],this}setFromMatrix3(eu){const tu=eu.elements;return this.set(tu[0],tu[3],tu[6],0,tu[1],tu[4],tu[7],0,tu[2],tu[5],tu[8],0,0,0,0,1),this}extractBasis(eu,tu,su){return eu.setFromMatrixColumn(this,0),tu.setFromMatrixColumn(this,1),su.setFromMatrixColumn(this,2),this}makeBasis(eu,tu,su){return this.set(eu.x,tu.x,su.x,0,eu.y,tu.y,su.y,0,eu.z,tu.z,su.z,0,0,0,0,1),this}extractRotation(eu){const tu=this.elements,su=eu.elements,au=1/_v1$5.setFromMatrixColumn(eu,0).length(),uu=1/_v1$5.setFromMatrixColumn(eu,1).length(),du=1/_v1$5.setFromMatrixColumn(eu,2).length();return tu[0]=su[0]*au,tu[1]=su[1]*au,tu[2]=su[2]*au,tu[3]=0,tu[4]=su[4]*uu,tu[5]=su[5]*uu,tu[6]=su[6]*uu,tu[7]=0,tu[8]=su[8]*du,tu[9]=su[9]*du,tu[10]=su[10]*du,tu[11]=0,tu[12]=0,tu[13]=0,tu[14]=0,tu[15]=1,this}makeRotationFromEuler(eu){const tu=this.elements,su=eu.x,au=eu.y,uu=eu.z,du=Math.cos(su),fu=Math.sin(su),gu=Math.cos(au),yu=Math.sin(au),xu=Math.cos(uu),vu=Math.sin(uu);if(eu.order==="XYZ"){const Su=du*xu,Iu=du*vu,Mu=fu*xu,ku=fu*vu;tu[0]=gu*xu,tu[4]=-gu*vu,tu[8]=yu,tu[1]=Iu+Mu*yu,tu[5]=Su-ku*yu,tu[9]=-fu*gu,tu[2]=ku-Su*yu,tu[6]=Mu+Iu*yu,tu[10]=du*gu}else if(eu.order==="YXZ"){const Su=gu*xu,Iu=gu*vu,Mu=yu*xu,ku=yu*vu;tu[0]=Su+ku*fu,tu[4]=Mu*fu-Iu,tu[8]=du*yu,tu[1]=du*vu,tu[5]=du*xu,tu[9]=-fu,tu[2]=Iu*fu-Mu,tu[6]=ku+Su*fu,tu[10]=du*gu}else if(eu.order==="ZXY"){const Su=gu*xu,Iu=gu*vu,Mu=yu*xu,ku=yu*vu;tu[0]=Su-ku*fu,tu[4]=-du*vu,tu[8]=Mu+Iu*fu,tu[1]=Iu+Mu*fu,tu[5]=du*xu,tu[9]=ku-Su*fu,tu[2]=-du*yu,tu[6]=fu,tu[10]=du*gu}else if(eu.order==="ZYX"){const Su=du*xu,Iu=du*vu,Mu=fu*xu,ku=fu*vu;tu[0]=gu*xu,tu[4]=Mu*yu-Iu,tu[8]=Su*yu+ku,tu[1]=gu*vu,tu[5]=ku*yu+Su,tu[9]=Iu*yu-Mu,tu[2]=-yu,tu[6]=fu*gu,tu[10]=du*gu}else if(eu.order==="YZX"){const Su=du*gu,Iu=du*yu,Mu=fu*gu,ku=fu*yu;tu[0]=gu*xu,tu[4]=ku-Su*vu,tu[8]=Mu*vu+Iu,tu[1]=vu,tu[5]=du*xu,tu[9]=-fu*xu,tu[2]=-yu*xu,tu[6]=Iu*vu+Mu,tu[10]=Su-ku*vu}else if(eu.order==="XZY"){const Su=du*gu,Iu=du*yu,Mu=fu*gu,ku=fu*yu;tu[0]=gu*xu,tu[4]=-vu,tu[8]=yu*xu,tu[1]=Su*vu+ku,tu[5]=du*xu,tu[9]=Iu*vu-Mu,tu[2]=Mu*vu-Iu,tu[6]=fu*xu,tu[10]=ku*vu+Su}return tu[3]=0,tu[7]=0,tu[11]=0,tu[12]=0,tu[13]=0,tu[14]=0,tu[15]=1,this}makeRotationFromQuaternion(eu){return this.compose(_zero,eu,_one)}lookAt(eu,tu,su){const au=this.elements;return _z.subVectors(eu,tu),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(su,_z),_x.lengthSq()===0&&(Math.abs(su.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(su,_z)),_x.normalize(),_y.crossVectors(_z,_x),au[0]=_x.x,au[4]=_y.x,au[8]=_z.x,au[1]=_x.y,au[5]=_y.y,au[9]=_z.y,au[2]=_x.z,au[6]=_y.z,au[10]=_z.z,this}multiply(eu){return this.multiplyMatrices(this,eu)}premultiply(eu){return this.multiplyMatrices(eu,this)}multiplyMatrices(eu,tu){const su=eu.elements,au=tu.elements,uu=this.elements,du=su[0],fu=su[4],gu=su[8],yu=su[12],xu=su[1],vu=su[5],Su=su[9],Iu=su[13],Mu=su[2],ku=su[6],Bu=su[10],_u=su[14],Lu=su[3],Du=su[7],Ou=su[11],Wu=su[15],Zu=au[0],Hu=au[4],Yu=au[8],Ku=au[12],ju=au[1],tp=au[5],gp=au[9],yp=au[13],Cp=au[2],Hp=au[6],wp=au[10],Dp=au[14],dp=au[3],Rp=au[7],xp=au[11],cm=au[15];return uu[0]=du*Zu+fu*ju+gu*Cp+yu*dp,uu[4]=du*Hu+fu*tp+gu*Hp+yu*Rp,uu[8]=du*Yu+fu*gp+gu*wp+yu*xp,uu[12]=du*Ku+fu*yp+gu*Dp+yu*cm,uu[1]=xu*Zu+vu*ju+Su*Cp+Iu*dp,uu[5]=xu*Hu+vu*tp+Su*Hp+Iu*Rp,uu[9]=xu*Yu+vu*gp+Su*wp+Iu*xp,uu[13]=xu*Ku+vu*yp+Su*Dp+Iu*cm,uu[2]=Mu*Zu+ku*ju+Bu*Cp+_u*dp,uu[6]=Mu*Hu+ku*tp+Bu*Hp+_u*Rp,uu[10]=Mu*Yu+ku*gp+Bu*wp+_u*xp,uu[14]=Mu*Ku+ku*yp+Bu*Dp+_u*cm,uu[3]=Lu*Zu+Du*ju+Ou*Cp+Wu*dp,uu[7]=Lu*Hu+Du*tp+Ou*Hp+Wu*Rp,uu[11]=Lu*Yu+Du*gp+Ou*wp+Wu*xp,uu[15]=Lu*Ku+Du*yp+Ou*Dp+Wu*cm,this}multiplyScalar(eu){const tu=this.elements;return tu[0]*=eu,tu[4]*=eu,tu[8]*=eu,tu[12]*=eu,tu[1]*=eu,tu[5]*=eu,tu[9]*=eu,tu[13]*=eu,tu[2]*=eu,tu[6]*=eu,tu[10]*=eu,tu[14]*=eu,tu[3]*=eu,tu[7]*=eu,tu[11]*=eu,tu[15]*=eu,this}determinant(){const eu=this.elements,tu=eu[0],su=eu[4],au=eu[8],uu=eu[12],du=eu[1],fu=eu[5],gu=eu[9],yu=eu[13],xu=eu[2],vu=eu[6],Su=eu[10],Iu=eu[14],Mu=eu[3],ku=eu[7],Bu=eu[11],_u=eu[15];return Mu*(+uu*gu*vu-au*yu*vu-uu*fu*Su+su*yu*Su+au*fu*Iu-su*gu*Iu)+ku*(+tu*gu*Iu-tu*yu*Su+uu*du*Su-au*du*Iu+au*yu*xu-uu*gu*xu)+Bu*(+tu*yu*vu-tu*fu*Iu-uu*du*vu+su*du*Iu+uu*fu*xu-su*yu*xu)+_u*(-au*fu*xu-tu*gu*vu+tu*fu*Su+au*du*vu-su*du*Su+su*gu*xu)}transpose(){const eu=this.elements;let tu;return tu=eu[1],eu[1]=eu[4],eu[4]=tu,tu=eu[2],eu[2]=eu[8],eu[8]=tu,tu=eu[6],eu[6]=eu[9],eu[9]=tu,tu=eu[3],eu[3]=eu[12],eu[12]=tu,tu=eu[7],eu[7]=eu[13],eu[13]=tu,tu=eu[11],eu[11]=eu[14],eu[14]=tu,this}setPosition(eu,tu,su){const au=this.elements;return eu.isVector3?(au[12]=eu.x,au[13]=eu.y,au[14]=eu.z):(au[12]=eu,au[13]=tu,au[14]=su),this}invert(){const eu=this.elements,tu=eu[0],su=eu[1],au=eu[2],uu=eu[3],du=eu[4],fu=eu[5],gu=eu[6],yu=eu[7],xu=eu[8],vu=eu[9],Su=eu[10],Iu=eu[11],Mu=eu[12],ku=eu[13],Bu=eu[14],_u=eu[15],Lu=vu*Bu*yu-ku*Su*yu+ku*gu*Iu-fu*Bu*Iu-vu*gu*_u+fu*Su*_u,Du=Mu*Su*yu-xu*Bu*yu-Mu*gu*Iu+du*Bu*Iu+xu*gu*_u-du*Su*_u,Ou=xu*ku*yu-Mu*vu*yu+Mu*fu*Iu-du*ku*Iu-xu*fu*_u+du*vu*_u,Wu=Mu*vu*gu-xu*ku*gu-Mu*fu*Su+du*ku*Su+xu*fu*Bu-du*vu*Bu,Zu=tu*Lu+su*Du+au*Ou+uu*Wu;if(Zu===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const Hu=1/Zu;return eu[0]=Lu*Hu,eu[1]=(ku*Su*uu-vu*Bu*uu-ku*au*Iu+su*Bu*Iu+vu*au*_u-su*Su*_u)*Hu,eu[2]=(fu*Bu*uu-ku*gu*uu+ku*au*yu-su*Bu*yu-fu*au*_u+su*gu*_u)*Hu,eu[3]=(vu*gu*uu-fu*Su*uu-vu*au*yu+su*Su*yu+fu*au*Iu-su*gu*Iu)*Hu,eu[4]=Du*Hu,eu[5]=(xu*Bu*uu-Mu*Su*uu+Mu*au*Iu-tu*Bu*Iu-xu*au*_u+tu*Su*_u)*Hu,eu[6]=(Mu*gu*uu-du*Bu*uu-Mu*au*yu+tu*Bu*yu+du*au*_u-tu*gu*_u)*Hu,eu[7]=(du*Su*uu-xu*gu*uu+xu*au*yu-tu*Su*yu-du*au*Iu+tu*gu*Iu)*Hu,eu[8]=Ou*Hu,eu[9]=(Mu*vu*uu-xu*ku*uu-Mu*su*Iu+tu*ku*Iu+xu*su*_u-tu*vu*_u)*Hu,eu[10]=(du*ku*uu-Mu*fu*uu+Mu*su*yu-tu*ku*yu-du*su*_u+tu*fu*_u)*Hu,eu[11]=(xu*fu*uu-du*vu*uu-xu*su*yu+tu*vu*yu+du*su*Iu-tu*fu*Iu)*Hu,eu[12]=Wu*Hu,eu[13]=(xu*ku*au-Mu*vu*au+Mu*su*Su-tu*ku*Su-xu*su*Bu+tu*vu*Bu)*Hu,eu[14]=(Mu*fu*au-du*ku*au-Mu*su*gu+tu*ku*gu+du*su*Bu-tu*fu*Bu)*Hu,eu[15]=(du*vu*au-xu*fu*au+xu*su*gu-tu*vu*gu-du*su*Su+tu*fu*Su)*Hu,this}scale(eu){const tu=this.elements,su=eu.x,au=eu.y,uu=eu.z;return tu[0]*=su,tu[4]*=au,tu[8]*=uu,tu[1]*=su,tu[5]*=au,tu[9]*=uu,tu[2]*=su,tu[6]*=au,tu[10]*=uu,tu[3]*=su,tu[7]*=au,tu[11]*=uu,this}getMaxScaleOnAxis(){const eu=this.elements,tu=eu[0]*eu[0]+eu[1]*eu[1]+eu[2]*eu[2],su=eu[4]*eu[4]+eu[5]*eu[5]+eu[6]*eu[6],au=eu[8]*eu[8]+eu[9]*eu[9]+eu[10]*eu[10];return Math.sqrt(Math.max(tu,su,au))}makeTranslation(eu,tu,su){return eu.isVector3?this.set(1,0,0,eu.x,0,1,0,eu.y,0,0,1,eu.z,0,0,0,1):this.set(1,0,0,eu,0,1,0,tu,0,0,1,su,0,0,0,1),this}makeRotationX(eu){const tu=Math.cos(eu),su=Math.sin(eu);return this.set(1,0,0,0,0,tu,-su,0,0,su,tu,0,0,0,0,1),this}makeRotationY(eu){const tu=Math.cos(eu),su=Math.sin(eu);return this.set(tu,0,su,0,0,1,0,0,-su,0,tu,0,0,0,0,1),this}makeRotationZ(eu){const tu=Math.cos(eu),su=Math.sin(eu);return this.set(tu,-su,0,0,su,tu,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(eu,tu){const su=Math.cos(tu),au=Math.sin(tu),uu=1-su,du=eu.x,fu=eu.y,gu=eu.z,yu=uu*du,xu=uu*fu;return this.set(yu*du+su,yu*fu-au*gu,yu*gu+au*fu,0,yu*fu+au*gu,xu*fu+su,xu*gu-au*du,0,yu*gu-au*fu,xu*gu+au*du,uu*gu*gu+su,0,0,0,0,1),this}makeScale(eu,tu,su){return this.set(eu,0,0,0,0,tu,0,0,0,0,su,0,0,0,0,1),this}makeShear(eu,tu,su,au,uu,du){return this.set(1,su,uu,0,eu,1,du,0,tu,au,1,0,0,0,0,1),this}compose(eu,tu,su){const au=this.elements,uu=tu._x,du=tu._y,fu=tu._z,gu=tu._w,yu=uu+uu,xu=du+du,vu=fu+fu,Su=uu*yu,Iu=uu*xu,Mu=uu*vu,ku=du*xu,Bu=du*vu,_u=fu*vu,Lu=gu*yu,Du=gu*xu,Ou=gu*vu,Wu=su.x,Zu=su.y,Hu=su.z;return au[0]=(1-(ku+_u))*Wu,au[1]=(Iu+Ou)*Wu,au[2]=(Mu-Du)*Wu,au[3]=0,au[4]=(Iu-Ou)*Zu,au[5]=(1-(Su+_u))*Zu,au[6]=(Bu+Lu)*Zu,au[7]=0,au[8]=(Mu+Du)*Hu,au[9]=(Bu-Lu)*Hu,au[10]=(1-(Su+ku))*Hu,au[11]=0,au[12]=eu.x,au[13]=eu.y,au[14]=eu.z,au[15]=1,this}decompose(eu,tu,su){const au=this.elements;let uu=_v1$5.set(au[0],au[1],au[2]).length();const du=_v1$5.set(au[4],au[5],au[6]).length(),fu=_v1$5.set(au[8],au[9],au[10]).length();this.determinant()<0&&(uu=-uu),eu.x=au[12],eu.y=au[13],eu.z=au[14],_m1$2.copy(this);const yu=1/uu,xu=1/du,vu=1/fu;return _m1$2.elements[0]*=yu,_m1$2.elements[1]*=yu,_m1$2.elements[2]*=yu,_m1$2.elements[4]*=xu,_m1$2.elements[5]*=xu,_m1$2.elements[6]*=xu,_m1$2.elements[8]*=vu,_m1$2.elements[9]*=vu,_m1$2.elements[10]*=vu,tu.setFromRotationMatrix(_m1$2),su.x=uu,su.y=du,su.z=fu,this}makePerspective(eu,tu,su,au,uu,du,fu=WebGLCoordinateSystem){const gu=this.elements,yu=2*uu/(tu-eu),xu=2*uu/(su-au),vu=(tu+eu)/(tu-eu),Su=(su+au)/(su-au);let Iu,Mu;if(fu===WebGLCoordinateSystem)Iu=-(du+uu)/(du-uu),Mu=-2*du*uu/(du-uu);else if(fu===WebGPUCoordinateSystem)Iu=-du/(du-uu),Mu=-du*uu/(du-uu);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+fu);return gu[0]=yu,gu[4]=0,gu[8]=vu,gu[12]=0,gu[1]=0,gu[5]=xu,gu[9]=Su,gu[13]=0,gu[2]=0,gu[6]=0,gu[10]=Iu,gu[14]=Mu,gu[3]=0,gu[7]=0,gu[11]=-1,gu[15]=0,this}makeOrthographic(eu,tu,su,au,uu,du,fu=WebGLCoordinateSystem){const gu=this.elements,yu=1/(tu-eu),xu=1/(su-au),vu=1/(du-uu),Su=(tu+eu)*yu,Iu=(su+au)*xu;let Mu,ku;if(fu===WebGLCoordinateSystem)Mu=(du+uu)*vu,ku=-2*vu;else if(fu===WebGPUCoordinateSystem)Mu=uu*vu,ku=-1*vu;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+fu);return gu[0]=2*yu,gu[4]=0,gu[8]=0,gu[12]=-Su,gu[1]=0,gu[5]=2*xu,gu[9]=0,gu[13]=-Iu,gu[2]=0,gu[6]=0,gu[10]=ku,gu[14]=-Mu,gu[3]=0,gu[7]=0,gu[11]=0,gu[15]=1,this}equals(eu){const tu=this.elements,su=eu.elements;for(let au=0;au<16;au++)if(tu[au]!==su[au])return!1;return!0}fromArray(eu,tu=0){for(let su=0;su<16;su++)this.elements[su]=eu[su+tu];return this}toArray(eu=[],tu=0){const su=this.elements;return eu[tu]=su[0],eu[tu+1]=su[1],eu[tu+2]=su[2],eu[tu+3]=su[3],eu[tu+4]=su[4],eu[tu+5]=su[5],eu[tu+6]=su[6],eu[tu+7]=su[7],eu[tu+8]=su[8],eu[tu+9]=su[9],eu[tu+10]=su[10],eu[tu+11]=su[11],eu[tu+12]=su[12],eu[tu+13]=su[13],eu[tu+14]=su[14],eu[tu+15]=su[15],eu}}const _v1$5=new Vector3,_m1$2=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$2=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(eu=0,tu=0,su=0,au=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=eu,this._y=tu,this._z=su,this._order=au}get x(){return this._x}set x(eu){this._x=eu,this._onChangeCallback()}get y(){return this._y}set y(eu){this._y=eu,this._onChangeCallback()}get z(){return this._z}set z(eu){this._z=eu,this._onChangeCallback()}get order(){return this._order}set order(eu){this._order=eu,this._onChangeCallback()}set(eu,tu,su,au=this._order){return this._x=eu,this._y=tu,this._z=su,this._order=au,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(eu){return this._x=eu._x,this._y=eu._y,this._z=eu._z,this._order=eu._order,this._onChangeCallback(),this}setFromRotationMatrix(eu,tu=this._order,su=!0){const au=eu.elements,uu=au[0],du=au[4],fu=au[8],gu=au[1],yu=au[5],xu=au[9],vu=au[2],Su=au[6],Iu=au[10];switch(tu){case"XYZ":this._y=Math.asin(clamp(fu,-1,1)),Math.abs(fu)<.9999999?(this._x=Math.atan2(-xu,Iu),this._z=Math.atan2(-du,uu)):(this._x=Math.atan2(Su,yu),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp(xu,-1,1)),Math.abs(xu)<.9999999?(this._y=Math.atan2(fu,Iu),this._z=Math.atan2(gu,yu)):(this._y=Math.atan2(-vu,uu),this._z=0);break;case"ZXY":this._x=Math.asin(clamp(Su,-1,1)),Math.abs(Su)<.9999999?(this._y=Math.atan2(-vu,Iu),this._z=Math.atan2(-du,yu)):(this._y=0,this._z=Math.atan2(gu,uu));break;case"ZYX":this._y=Math.asin(-clamp(vu,-1,1)),Math.abs(vu)<.9999999?(this._x=Math.atan2(Su,Iu),this._z=Math.atan2(gu,uu)):(this._x=0,this._z=Math.atan2(-du,yu));break;case"YZX":this._z=Math.asin(clamp(gu,-1,1)),Math.abs(gu)<.9999999?(this._x=Math.atan2(-xu,yu),this._y=Math.atan2(-vu,uu)):(this._x=0,this._y=Math.atan2(fu,Iu));break;case"XZY":this._z=Math.asin(-clamp(du,-1,1)),Math.abs(du)<.9999999?(this._x=Math.atan2(Su,yu),this._y=Math.atan2(fu,uu)):(this._x=Math.atan2(-xu,Iu),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+tu)}return this._order=tu,su===!0&&this._onChangeCallback(),this}setFromQuaternion(eu,tu,su){return _matrix$2.makeRotationFromQuaternion(eu),this.setFromRotationMatrix(_matrix$2,tu,su)}setFromVector3(eu,tu=this._order){return this.set(eu.x,eu.y,eu.z,tu)}reorder(eu){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,eu)}equals(eu){return eu._x===this._x&&eu._y===this._y&&eu._z===this._z&&eu._order===this._order}fromArray(eu){return this._x=eu[0],this._y=eu[1],this._z=eu[2],eu[3]!==void 0&&(this._order=eu[3]),this._onChangeCallback(),this}toArray(eu=[],tu=0){return eu[tu]=this._x,eu[tu+1]=this._y,eu[tu+2]=this._z,eu[tu+3]=this._order,eu}_onChange(eu){return this._onChangeCallback=eu,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(eu){this.mask=(1<<eu|0)>>>0}enable(eu){this.mask|=1<<eu|0}enableAll(){this.mask=-1}toggle(eu){this.mask^=1<<eu|0}disable(eu){this.mask&=~(1<<eu|0)}disableAll(){this.mask=0}test(eu){return(this.mask&eu.mask)!==0}isEnabled(eu){return(this.mask&(1<<eu|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$1$1=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const eu=new Vector3,tu=new Euler,su=new Quaternion,au=new Vector3(1,1,1);function uu(){su.setFromEuler(tu,!1)}function du(){tu.setFromQuaternion(su,void 0,!1)}tu._onChange(uu),su._onChange(du),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:eu},rotation:{configurable:!0,enumerable:!0,value:tu},quaternion:{configurable:!0,enumerable:!0,value:su},scale:{configurable:!0,enumerable:!0,value:au},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(eu){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(eu),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(eu){return this.quaternion.premultiply(eu),this}setRotationFromAxisAngle(eu,tu){this.quaternion.setFromAxisAngle(eu,tu)}setRotationFromEuler(eu){this.quaternion.setFromEuler(eu,!0)}setRotationFromMatrix(eu){this.quaternion.setFromRotationMatrix(eu)}setRotationFromQuaternion(eu){this.quaternion.copy(eu)}rotateOnAxis(eu,tu){return _q1.setFromAxisAngle(eu,tu),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(eu,tu){return _q1.setFromAxisAngle(eu,tu),this.quaternion.premultiply(_q1),this}rotateX(eu){return this.rotateOnAxis(_xAxis,eu)}rotateY(eu){return this.rotateOnAxis(_yAxis,eu)}rotateZ(eu){return this.rotateOnAxis(_zAxis,eu)}translateOnAxis(eu,tu){return _v1$4.copy(eu).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(tu)),this}translateX(eu){return this.translateOnAxis(_xAxis,eu)}translateY(eu){return this.translateOnAxis(_yAxis,eu)}translateZ(eu){return this.translateOnAxis(_zAxis,eu)}localToWorld(eu){return this.updateWorldMatrix(!0,!1),eu.applyMatrix4(this.matrixWorld)}worldToLocal(eu){return this.updateWorldMatrix(!0,!1),eu.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert())}lookAt(eu,tu,su){eu.isVector3?_target.copy(eu):_target.set(eu,tu,su);const au=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$1$1.lookAt(_position$3,_target,this.up):_m1$1$1.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$1$1),au&&(_m1$1$1.extractRotation(au.matrixWorld),_q1.setFromRotationMatrix(_m1$1$1),this.quaternion.premultiply(_q1.invert()))}add(eu){if(arguments.length>1){for(let tu=0;tu<arguments.length;tu++)this.add(arguments[tu]);return this}return eu===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",eu),this):(eu&&eu.isObject3D?(eu.removeFromParent(),eu.parent=this,this.children.push(eu),eu.dispatchEvent(_addedEvent),_childaddedEvent.child=eu,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",eu),this)}remove(eu){if(arguments.length>1){for(let su=0;su<arguments.length;su++)this.remove(arguments[su]);return this}const tu=this.children.indexOf(eu);return tu!==-1&&(eu.parent=null,this.children.splice(tu,1),eu.dispatchEvent(_removedEvent),_childremovedEvent.child=eu,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const eu=this.parent;return eu!==null&&eu.remove(this),this}clear(){return this.remove(...this.children)}attach(eu){return this.updateWorldMatrix(!0,!1),_m1$1$1.copy(this.matrixWorld).invert(),eu.parent!==null&&(eu.parent.updateWorldMatrix(!0,!1),_m1$1$1.multiply(eu.parent.matrixWorld)),eu.applyMatrix4(_m1$1$1),eu.removeFromParent(),eu.parent=this,this.children.push(eu),eu.updateWorldMatrix(!1,!0),eu.dispatchEvent(_addedEvent),_childaddedEvent.child=eu,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null,this}getObjectById(eu){return this.getObjectByProperty("id",eu)}getObjectByName(eu){return this.getObjectByProperty("name",eu)}getObjectByProperty(eu,tu){if(this[eu]===tu)return this;for(let su=0,au=this.children.length;su<au;su++){const du=this.children[su].getObjectByProperty(eu,tu);if(du!==void 0)return du}}getObjectsByProperty(eu,tu,su=[]){this[eu]===tu&&su.push(this);const au=this.children;for(let uu=0,du=au.length;uu<du;uu++)au[uu].getObjectsByProperty(eu,tu,su);return su}getWorldPosition(eu){return this.updateWorldMatrix(!0,!1),eu.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(eu){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,eu,_scale$2),eu}getWorldScale(eu){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,eu),eu}getWorldDirection(eu){this.updateWorldMatrix(!0,!1);const tu=this.matrixWorld.elements;return eu.set(tu[8],tu[9],tu[10]).normalize()}raycast(){}traverse(eu){eu(this);const tu=this.children;for(let su=0,au=tu.length;su<au;su++)tu[su].traverse(eu)}traverseVisible(eu){if(this.visible===!1)return;eu(this);const tu=this.children;for(let su=0,au=tu.length;su<au;su++)tu[su].traverseVisible(eu)}traverseAncestors(eu){const tu=this.parent;tu!==null&&(eu(tu),tu.traverseAncestors(eu))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(eu){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||eu)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,eu=!0);const tu=this.children;for(let su=0,au=tu.length;su<au;su++)tu[su].updateMatrixWorld(eu)}updateWorldMatrix(eu,tu){const su=this.parent;if(eu===!0&&su!==null&&su.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),tu===!0){const au=this.children;for(let uu=0,du=au.length;uu<du;uu++)au[uu].updateWorldMatrix(!1,!0)}}toJSON(eu){const tu=eu===void 0||typeof eu=="string",su={};tu&&(eu={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},su.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const au={};au.uuid=this.uuid,au.type=this.type,this.name!==""&&(au.name=this.name),this.castShadow===!0&&(au.castShadow=!0),this.receiveShadow===!0&&(au.receiveShadow=!0),this.visible===!1&&(au.visible=!1),this.frustumCulled===!1&&(au.frustumCulled=!1),this.renderOrder!==0&&(au.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(au.userData=this.userData),au.layers=this.layers.mask,au.matrix=this.matrix.toArray(),au.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(au.matrixAutoUpdate=!1),this.isInstancedMesh&&(au.type="InstancedMesh",au.count=this.count,au.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(au.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(au.type="BatchedMesh",au.perObjectFrustumCulled=this.perObjectFrustumCulled,au.sortObjects=this.sortObjects,au.drawRanges=this._drawRanges,au.reservedRanges=this._reservedRanges,au.visibility=this._visibility,au.active=this._active,au.bounds=this._bounds.map(fu=>({boxInitialized:fu.boxInitialized,boxMin:fu.box.min.toArray(),boxMax:fu.box.max.toArray(),sphereInitialized:fu.sphereInitialized,sphereRadius:fu.sphere.radius,sphereCenter:fu.sphere.center.toArray()})),au.maxInstanceCount=this._maxInstanceCount,au.maxVertexCount=this._maxVertexCount,au.maxIndexCount=this._maxIndexCount,au.geometryInitialized=this._geometryInitialized,au.geometryCount=this._geometryCount,au.matricesTexture=this._matricesTexture.toJSON(eu),this._colorsTexture!==null&&(au.colorsTexture=this._colorsTexture.toJSON(eu)),this.boundingSphere!==null&&(au.boundingSphere={center:au.boundingSphere.center.toArray(),radius:au.boundingSphere.radius}),this.boundingBox!==null&&(au.boundingBox={min:au.boundingBox.min.toArray(),max:au.boundingBox.max.toArray()}));function uu(fu,gu){return fu[gu.uuid]===void 0&&(fu[gu.uuid]=gu.toJSON(eu)),gu.uuid}if(this.isScene)this.background&&(this.background.isColor?au.background=this.background.toJSON():this.background.isTexture&&(au.background=this.background.toJSON(eu).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(au.environment=this.environment.toJSON(eu).uuid);else if(this.isMesh||this.isLine||this.isPoints){au.geometry=uu(eu.geometries,this.geometry);const fu=this.geometry.parameters;if(fu!==void 0&&fu.shapes!==void 0){const gu=fu.shapes;if(Array.isArray(gu))for(let yu=0,xu=gu.length;yu<xu;yu++){const vu=gu[yu];uu(eu.shapes,vu)}else uu(eu.shapes,gu)}}if(this.isSkinnedMesh&&(au.bindMode=this.bindMode,au.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(uu(eu.skeletons,this.skeleton),au.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const fu=[];for(let gu=0,yu=this.material.length;gu<yu;gu++)fu.push(uu(eu.materials,this.material[gu]));au.material=fu}else au.material=uu(eu.materials,this.material);if(this.children.length>0){au.children=[];for(let fu=0;fu<this.children.length;fu++)au.children.push(this.children[fu].toJSON(eu).object)}if(this.animations.length>0){au.animations=[];for(let fu=0;fu<this.animations.length;fu++){const gu=this.animations[fu];au.animations.push(uu(eu.animations,gu))}}if(tu){const fu=du(eu.geometries),gu=du(eu.materials),yu=du(eu.textures),xu=du(eu.images),vu=du(eu.shapes),Su=du(eu.skeletons),Iu=du(eu.animations),Mu=du(eu.nodes);fu.length>0&&(su.geometries=fu),gu.length>0&&(su.materials=gu),yu.length>0&&(su.textures=yu),xu.length>0&&(su.images=xu),vu.length>0&&(su.shapes=vu),Su.length>0&&(su.skeletons=Su),Iu.length>0&&(su.animations=Iu),Mu.length>0&&(su.nodes=Mu)}return su.object=au,su;function du(fu){const gu=[];for(const yu in fu){const xu=fu[yu];delete xu.metadata,gu.push(xu)}return gu}}clone(eu){return new this.constructor().copy(this,eu)}copy(eu,tu=!0){if(this.name=eu.name,this.up.copy(eu.up),this.position.copy(eu.position),this.rotation.order=eu.rotation.order,this.quaternion.copy(eu.quaternion),this.scale.copy(eu.scale),this.matrix.copy(eu.matrix),this.matrixWorld.copy(eu.matrixWorld),this.matrixAutoUpdate=eu.matrixAutoUpdate,this.matrixWorldAutoUpdate=eu.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=eu.matrixWorldNeedsUpdate,this.layers.mask=eu.layers.mask,this.visible=eu.visible,this.castShadow=eu.castShadow,this.receiveShadow=eu.receiveShadow,this.frustumCulled=eu.frustumCulled,this.renderOrder=eu.renderOrder,this.animations=eu.animations.slice(),this.userData=JSON.parse(JSON.stringify(eu.userData)),tu===!0)for(let su=0;su<eu.children.length;su++){const au=eu.children[su];this.add(au.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$2=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3,_v40=new Vector4,_v41=new Vector4,_v42=new Vector4;class Triangle{constructor(eu=new Vector3,tu=new Vector3,su=new Vector3){this.a=eu,this.b=tu,this.c=su}static getNormal(eu,tu,su,au){au.subVectors(su,tu),_v0$1.subVectors(eu,tu),au.cross(_v0$1);const uu=au.lengthSq();return uu>0?au.multiplyScalar(1/Math.sqrt(uu)):au.set(0,0,0)}static getBarycoord(eu,tu,su,au,uu){_v0$1.subVectors(au,tu),_v1$3.subVectors(su,tu),_v2$2.subVectors(eu,tu);const du=_v0$1.dot(_v0$1),fu=_v0$1.dot(_v1$3),gu=_v0$1.dot(_v2$2),yu=_v1$3.dot(_v1$3),xu=_v1$3.dot(_v2$2),vu=du*yu-fu*fu;if(vu===0)return uu.set(0,0,0),null;const Su=1/vu,Iu=(yu*gu-fu*xu)*Su,Mu=(du*xu-fu*gu)*Su;return uu.set(1-Iu-Mu,Mu,Iu)}static containsPoint(eu,tu,su,au){return this.getBarycoord(eu,tu,su,au,_v3$2)===null?!1:_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1}static getInterpolation(eu,tu,su,au,uu,du,fu,gu){return this.getBarycoord(eu,tu,su,au,_v3$2)===null?(gu.x=0,gu.y=0,"z"in gu&&(gu.z=0),"w"in gu&&(gu.w=0),null):(gu.setScalar(0),gu.addScaledVector(uu,_v3$2.x),gu.addScaledVector(du,_v3$2.y),gu.addScaledVector(fu,_v3$2.z),gu)}static getInterpolatedAttribute(eu,tu,su,au,uu,du){return _v40.setScalar(0),_v41.setScalar(0),_v42.setScalar(0),_v40.fromBufferAttribute(eu,tu),_v41.fromBufferAttribute(eu,su),_v42.fromBufferAttribute(eu,au),du.setScalar(0),du.addScaledVector(_v40,uu.x),du.addScaledVector(_v41,uu.y),du.addScaledVector(_v42,uu.z),du}static isFrontFacing(eu,tu,su,au){return _v0$1.subVectors(su,tu),_v1$3.subVectors(eu,tu),_v0$1.cross(_v1$3).dot(au)<0}set(eu,tu,su){return this.a.copy(eu),this.b.copy(tu),this.c.copy(su),this}setFromPointsAndIndices(eu,tu,su,au){return this.a.copy(eu[tu]),this.b.copy(eu[su]),this.c.copy(eu[au]),this}setFromAttributeAndIndices(eu,tu,su,au){return this.a.fromBufferAttribute(eu,tu),this.b.fromBufferAttribute(eu,su),this.c.fromBufferAttribute(eu,au),this}clone(){return new this.constructor().copy(this)}copy(eu){return this.a.copy(eu.a),this.b.copy(eu.b),this.c.copy(eu.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(eu){return eu.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(eu){return Triangle.getNormal(this.a,this.b,this.c,eu)}getPlane(eu){return eu.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(eu,tu){return Triangle.getBarycoord(eu,this.a,this.b,this.c,tu)}getInterpolation(eu,tu,su,au,uu){return Triangle.getInterpolation(eu,this.a,this.b,this.c,tu,su,au,uu)}containsPoint(eu){return Triangle.containsPoint(eu,this.a,this.b,this.c)}isFrontFacing(eu){return Triangle.isFrontFacing(this.a,this.b,this.c,eu)}intersectsBox(eu){return eu.intersectsTriangle(this)}closestPointToPoint(eu,tu){const su=this.a,au=this.b,uu=this.c;let du,fu;_vab.subVectors(au,su),_vac.subVectors(uu,su),_vap.subVectors(eu,su);const gu=_vab.dot(_vap),yu=_vac.dot(_vap);if(gu<=0&&yu<=0)return tu.copy(su);_vbp.subVectors(eu,au);const xu=_vab.dot(_vbp),vu=_vac.dot(_vbp);if(xu>=0&&vu<=xu)return tu.copy(au);const Su=gu*vu-xu*yu;if(Su<=0&&gu>=0&&xu<=0)return du=gu/(gu-xu),tu.copy(su).addScaledVector(_vab,du);_vcp.subVectors(eu,uu);const Iu=_vab.dot(_vcp),Mu=_vac.dot(_vcp);if(Mu>=0&&Iu<=Mu)return tu.copy(uu);const ku=Iu*yu-gu*Mu;if(ku<=0&&yu>=0&&Mu<=0)return fu=yu/(yu-Mu),tu.copy(su).addScaledVector(_vac,fu);const Bu=xu*Mu-Iu*vu;if(Bu<=0&&vu-xu>=0&&Iu-Mu>=0)return _vbc.subVectors(uu,au),fu=(vu-xu)/(vu-xu+(Iu-Mu)),tu.copy(au).addScaledVector(_vbc,fu);const _u=1/(Bu+ku+Su);return du=ku*_u,fu=Su*_u,tu.copy(su).addScaledVector(_vab,du).addScaledVector(_vac,fu)}equals(eu){return eu.a.equals(this.a)&&eu.b.equals(this.b)&&eu.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(iu,eu,tu){return tu<0&&(tu+=1),tu>1&&(tu-=1),tu<1/6?iu+(eu-iu)*6*tu:tu<1/2?eu:tu<2/3?iu+(eu-iu)*6*(2/3-tu):iu}class Color{constructor(eu,tu,su){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(eu,tu,su)}set(eu,tu,su){if(tu===void 0&&su===void 0){const au=eu;au&&au.isColor?this.copy(au):typeof au=="number"?this.setHex(au):typeof au=="string"&&this.setStyle(au)}else this.setRGB(eu,tu,su);return this}setScalar(eu){return this.r=eu,this.g=eu,this.b=eu,this}setHex(eu,tu=SRGBColorSpace){return eu=Math.floor(eu),this.r=(eu>>16&255)/255,this.g=(eu>>8&255)/255,this.b=(eu&255)/255,ColorManagement.toWorkingColorSpace(this,tu),this}setRGB(eu,tu,su,au=ColorManagement.workingColorSpace){return this.r=eu,this.g=tu,this.b=su,ColorManagement.toWorkingColorSpace(this,au),this}setHSL(eu,tu,su,au=ColorManagement.workingColorSpace){if(eu=euclideanModulo(eu,1),tu=clamp(tu,0,1),su=clamp(su,0,1),tu===0)this.r=this.g=this.b=su;else{const uu=su<=.5?su*(1+tu):su+tu-su*tu,du=2*su-uu;this.r=hue2rgb(du,uu,eu+1/3),this.g=hue2rgb(du,uu,eu),this.b=hue2rgb(du,uu,eu-1/3)}return ColorManagement.toWorkingColorSpace(this,au),this}setStyle(eu,tu=SRGBColorSpace){function su(uu){uu!==void 0&&parseFloat(uu)<1&&console.warn("THREE.Color: Alpha component of "+eu+" will be ignored.")}let au;if(au=/^(\w+)\(([^\)]*)\)/.exec(eu)){let uu;const du=au[1],fu=au[2];switch(du){case"rgb":case"rgba":if(uu=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(fu))return su(uu[4]),this.setRGB(Math.min(255,parseInt(uu[1],10))/255,Math.min(255,parseInt(uu[2],10))/255,Math.min(255,parseInt(uu[3],10))/255,tu);if(uu=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(fu))return su(uu[4]),this.setRGB(Math.min(100,parseInt(uu[1],10))/100,Math.min(100,parseInt(uu[2],10))/100,Math.min(100,parseInt(uu[3],10))/100,tu);break;case"hsl":case"hsla":if(uu=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(fu))return su(uu[4]),this.setHSL(parseFloat(uu[1])/360,parseFloat(uu[2])/100,parseFloat(uu[3])/100,tu);break;default:console.warn("THREE.Color: Unknown color model "+eu)}}else if(au=/^\#([A-Fa-f\d]+)$/.exec(eu)){const uu=au[1],du=uu.length;if(du===3)return this.setRGB(parseInt(uu.charAt(0),16)/15,parseInt(uu.charAt(1),16)/15,parseInt(uu.charAt(2),16)/15,tu);if(du===6)return this.setHex(parseInt(uu,16),tu);console.warn("THREE.Color: Invalid hex color "+eu)}else if(eu&&eu.length>0)return this.setColorName(eu,tu);return this}setColorName(eu,tu=SRGBColorSpace){const su=_colorKeywords[eu.toLowerCase()];return su!==void 0?this.setHex(su,tu):console.warn("THREE.Color: Unknown color "+eu),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(eu){return this.r=eu.r,this.g=eu.g,this.b=eu.b,this}copySRGBToLinear(eu){return this.r=SRGBToLinear(eu.r),this.g=SRGBToLinear(eu.g),this.b=SRGBToLinear(eu.b),this}copyLinearToSRGB(eu){return this.r=LinearToSRGB(eu.r),this.g=LinearToSRGB(eu.g),this.b=LinearToSRGB(eu.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(eu=SRGBColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),eu),Math.round(clamp(_color.r*255,0,255))*65536+Math.round(clamp(_color.g*255,0,255))*256+Math.round(clamp(_color.b*255,0,255))}getHexString(eu=SRGBColorSpace){return("000000"+this.getHex(eu).toString(16)).slice(-6)}getHSL(eu,tu=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),tu);const su=_color.r,au=_color.g,uu=_color.b,du=Math.max(su,au,uu),fu=Math.min(su,au,uu);let gu,yu;const xu=(fu+du)/2;if(fu===du)gu=0,yu=0;else{const vu=du-fu;switch(yu=xu<=.5?vu/(du+fu):vu/(2-du-fu),du){case su:gu=(au-uu)/vu+(au<uu?6:0);break;case au:gu=(uu-su)/vu+2;break;case uu:gu=(su-au)/vu+4;break}gu/=6}return eu.h=gu,eu.s=yu,eu.l=xu,eu}getRGB(eu,tu=ColorManagement.workingColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),tu),eu.r=_color.r,eu.g=_color.g,eu.b=_color.b,eu}getStyle(eu=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),eu);const tu=_color.r,su=_color.g,au=_color.b;return eu!==SRGBColorSpace?`color(${eu} ${tu.toFixed(3)} ${su.toFixed(3)} ${au.toFixed(3)})`:`rgb(${Math.round(tu*255)},${Math.round(su*255)},${Math.round(au*255)})`}offsetHSL(eu,tu,su){return this.getHSL(_hslA),this.setHSL(_hslA.h+eu,_hslA.s+tu,_hslA.l+su)}add(eu){return this.r+=eu.r,this.g+=eu.g,this.b+=eu.b,this}addColors(eu,tu){return this.r=eu.r+tu.r,this.g=eu.g+tu.g,this.b=eu.b+tu.b,this}addScalar(eu){return this.r+=eu,this.g+=eu,this.b+=eu,this}sub(eu){return this.r=Math.max(0,this.r-eu.r),this.g=Math.max(0,this.g-eu.g),this.b=Math.max(0,this.b-eu.b),this}multiply(eu){return this.r*=eu.r,this.g*=eu.g,this.b*=eu.b,this}multiplyScalar(eu){return this.r*=eu,this.g*=eu,this.b*=eu,this}lerp(eu,tu){return this.r+=(eu.r-this.r)*tu,this.g+=(eu.g-this.g)*tu,this.b+=(eu.b-this.b)*tu,this}lerpColors(eu,tu,su){return this.r=eu.r+(tu.r-eu.r)*su,this.g=eu.g+(tu.g-eu.g)*su,this.b=eu.b+(tu.b-eu.b)*su,this}lerpHSL(eu,tu){this.getHSL(_hslA),eu.getHSL(_hslB);const su=lerp(_hslA.h,_hslB.h,tu),au=lerp(_hslA.s,_hslB.s,tu),uu=lerp(_hslA.l,_hslB.l,tu);return this.setHSL(su,au,uu),this}setFromVector3(eu){return this.r=eu.x,this.g=eu.y,this.b=eu.z,this}applyMatrix3(eu){const tu=this.r,su=this.g,au=this.b,uu=eu.elements;return this.r=uu[0]*tu+uu[3]*su+uu[6]*au,this.g=uu[1]*tu+uu[4]*su+uu[7]*au,this.b=uu[2]*tu+uu[5]*su+uu[8]*au,this}equals(eu){return eu.r===this.r&&eu.g===this.g&&eu.b===this.b}fromArray(eu,tu=0){return this.r=eu[tu],this.g=eu[tu+1],this.b=eu[tu+2],this}toArray(eu=[],tu=0){return eu[tu]=this.r,eu[tu+1]=this.g,eu[tu+2]=this.b,eu}fromBufferAttribute(eu,tu){return this.r=eu.getX(tu),this.g=eu.getY(tu),this.b=eu.getZ(tu),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const _color=new Color;Color.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(eu){this._alphaTest>0!=eu>0&&this.version++,this._alphaTest=eu}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(eu){if(eu!==void 0)for(const tu in eu){const su=eu[tu];if(su===void 0){console.warn(`THREE.Material: parameter '${tu}' has value of undefined.`);continue}const au=this[tu];if(au===void 0){console.warn(`THREE.Material: '${tu}' is not a property of THREE.${this.type}.`);continue}au&&au.isColor?au.set(su):au&&au.isVector3&&su&&su.isVector3?au.copy(su):this[tu]=su}}toJSON(eu){const tu=eu===void 0||typeof eu=="string";tu&&(eu={textures:{},images:{}});const su={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};su.uuid=this.uuid,su.type=this.type,this.name!==""&&(su.name=this.name),this.color&&this.color.isColor&&(su.color=this.color.getHex()),this.roughness!==void 0&&(su.roughness=this.roughness),this.metalness!==void 0&&(su.metalness=this.metalness),this.sheen!==void 0&&(su.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(su.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(su.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(su.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(su.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(su.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(su.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(su.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(su.shininess=this.shininess),this.clearcoat!==void 0&&(su.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(su.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(su.clearcoatMap=this.clearcoatMap.toJSON(eu).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(su.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(eu).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(su.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(eu).uuid,su.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(su.dispersion=this.dispersion),this.iridescence!==void 0&&(su.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(su.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(su.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(su.iridescenceMap=this.iridescenceMap.toJSON(eu).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(su.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(eu).uuid),this.anisotropy!==void 0&&(su.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(su.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(su.anisotropyMap=this.anisotropyMap.toJSON(eu).uuid),this.map&&this.map.isTexture&&(su.map=this.map.toJSON(eu).uuid),this.matcap&&this.matcap.isTexture&&(su.matcap=this.matcap.toJSON(eu).uuid),this.alphaMap&&this.alphaMap.isTexture&&(su.alphaMap=this.alphaMap.toJSON(eu).uuid),this.lightMap&&this.lightMap.isTexture&&(su.lightMap=this.lightMap.toJSON(eu).uuid,su.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(su.aoMap=this.aoMap.toJSON(eu).uuid,su.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(su.bumpMap=this.bumpMap.toJSON(eu).uuid,su.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(su.normalMap=this.normalMap.toJSON(eu).uuid,su.normalMapType=this.normalMapType,su.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(su.displacementMap=this.displacementMap.toJSON(eu).uuid,su.displacementScale=this.displacementScale,su.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(su.roughnessMap=this.roughnessMap.toJSON(eu).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(su.metalnessMap=this.metalnessMap.toJSON(eu).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(su.emissiveMap=this.emissiveMap.toJSON(eu).uuid),this.specularMap&&this.specularMap.isTexture&&(su.specularMap=this.specularMap.toJSON(eu).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(su.specularIntensityMap=this.specularIntensityMap.toJSON(eu).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(su.specularColorMap=this.specularColorMap.toJSON(eu).uuid),this.envMap&&this.envMap.isTexture&&(su.envMap=this.envMap.toJSON(eu).uuid,this.combine!==void 0&&(su.combine=this.combine)),this.envMapRotation!==void 0&&(su.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(su.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(su.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(su.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(su.gradientMap=this.gradientMap.toJSON(eu).uuid),this.transmission!==void 0&&(su.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(su.transmissionMap=this.transmissionMap.toJSON(eu).uuid),this.thickness!==void 0&&(su.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(su.thicknessMap=this.thicknessMap.toJSON(eu).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(su.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(su.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(su.size=this.size),this.shadowSide!==null&&(su.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(su.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(su.blending=this.blending),this.side!==FrontSide&&(su.side=this.side),this.vertexColors===!0&&(su.vertexColors=!0),this.opacity<1&&(su.opacity=this.opacity),this.transparent===!0&&(su.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(su.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(su.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(su.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(su.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(su.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(su.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(su.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(su.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(su.depthFunc=this.depthFunc),this.depthTest===!1&&(su.depthTest=this.depthTest),this.depthWrite===!1&&(su.depthWrite=this.depthWrite),this.colorWrite===!1&&(su.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(su.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(su.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(su.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(su.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(su.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(su.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(su.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(su.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(su.rotation=this.rotation),this.polygonOffset===!0&&(su.polygonOffset=!0),this.polygonOffsetFactor!==0&&(su.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(su.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(su.linewidth=this.linewidth),this.dashSize!==void 0&&(su.dashSize=this.dashSize),this.gapSize!==void 0&&(su.gapSize=this.gapSize),this.scale!==void 0&&(su.scale=this.scale),this.dithering===!0&&(su.dithering=!0),this.alphaTest>0&&(su.alphaTest=this.alphaTest),this.alphaHash===!0&&(su.alphaHash=!0),this.alphaToCoverage===!0&&(su.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(su.premultipliedAlpha=!0),this.forceSinglePass===!0&&(su.forceSinglePass=!0),this.wireframe===!0&&(su.wireframe=!0),this.wireframeLinewidth>1&&(su.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(su.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(su.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(su.flatShading=!0),this.visible===!1&&(su.visible=!1),this.toneMapped===!1&&(su.toneMapped=!1),this.fog===!1&&(su.fog=!1),Object.keys(this.userData).length>0&&(su.userData=this.userData);function au(uu){const du=[];for(const fu in uu){const gu=uu[fu];delete gu.metadata,du.push(gu)}return du}if(tu){const uu=au(eu.textures),du=au(eu.images);uu.length>0&&(su.textures=uu),du.length>0&&(su.images=du)}return su}clone(){return new this.constructor().copy(this)}copy(eu){this.name=eu.name,this.blending=eu.blending,this.side=eu.side,this.vertexColors=eu.vertexColors,this.opacity=eu.opacity,this.transparent=eu.transparent,this.blendSrc=eu.blendSrc,this.blendDst=eu.blendDst,this.blendEquation=eu.blendEquation,this.blendSrcAlpha=eu.blendSrcAlpha,this.blendDstAlpha=eu.blendDstAlpha,this.blendEquationAlpha=eu.blendEquationAlpha,this.blendColor.copy(eu.blendColor),this.blendAlpha=eu.blendAlpha,this.depthFunc=eu.depthFunc,this.depthTest=eu.depthTest,this.depthWrite=eu.depthWrite,this.stencilWriteMask=eu.stencilWriteMask,this.stencilFunc=eu.stencilFunc,this.stencilRef=eu.stencilRef,this.stencilFuncMask=eu.stencilFuncMask,this.stencilFail=eu.stencilFail,this.stencilZFail=eu.stencilZFail,this.stencilZPass=eu.stencilZPass,this.stencilWrite=eu.stencilWrite;const tu=eu.clippingPlanes;let su=null;if(tu!==null){const au=tu.length;su=new Array(au);for(let uu=0;uu!==au;++uu)su[uu]=tu[uu].clone()}return this.clippingPlanes=su,this.clipIntersection=eu.clipIntersection,this.clipShadows=eu.clipShadows,this.shadowSide=eu.shadowSide,this.colorWrite=eu.colorWrite,this.precision=eu.precision,this.polygonOffset=eu.polygonOffset,this.polygonOffsetFactor=eu.polygonOffsetFactor,this.polygonOffsetUnits=eu.polygonOffsetUnits,this.dithering=eu.dithering,this.alphaTest=eu.alphaTest,this.alphaHash=eu.alphaHash,this.alphaToCoverage=eu.alphaToCoverage,this.premultipliedAlpha=eu.premultipliedAlpha,this.forceSinglePass=eu.forceSinglePass,this.visible=eu.visible,this.toneMapped=eu.toneMapped,this.userData=JSON.parse(JSON.stringify(eu.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(eu){eu===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class MeshBasicMaterial extends Material{constructor(eu){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.map=eu.map,this.lightMap=eu.lightMap,this.lightMapIntensity=eu.lightMapIntensity,this.aoMap=eu.aoMap,this.aoMapIntensity=eu.aoMapIntensity,this.specularMap=eu.specularMap,this.alphaMap=eu.alphaMap,this.envMap=eu.envMap,this.envMapRotation.copy(eu.envMapRotation),this.combine=eu.combine,this.reflectivity=eu.reflectivity,this.refractionRatio=eu.refractionRatio,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.wireframeLinecap=eu.wireframeLinecap,this.wireframeLinejoin=eu.wireframeLinejoin,this.fog=eu.fog,this}}const _tables=_generateTables();function _generateTables(){const iu=new ArrayBuffer(4),eu=new Float32Array(iu),tu=new Uint32Array(iu),su=new Uint32Array(512),au=new Uint32Array(512);for(let gu=0;gu<256;++gu){const yu=gu-127;yu<-27?(su[gu]=0,su[gu|256]=32768,au[gu]=24,au[gu|256]=24):yu<-14?(su[gu]=1024>>-yu-14,su[gu|256]=1024>>-yu-14|32768,au[gu]=-yu-1,au[gu|256]=-yu-1):yu<=15?(su[gu]=yu+15<<10,su[gu|256]=yu+15<<10|32768,au[gu]=13,au[gu|256]=13):yu<128?(su[gu]=31744,su[gu|256]=64512,au[gu]=24,au[gu|256]=24):(su[gu]=31744,su[gu|256]=64512,au[gu]=13,au[gu|256]=13)}const uu=new Uint32Array(2048),du=new Uint32Array(64),fu=new Uint32Array(64);for(let gu=1;gu<1024;++gu){let yu=gu<<13,xu=0;for(;!(yu&8388608);)yu<<=1,xu-=8388608;yu&=-8388609,xu+=947912704,uu[gu]=yu|xu}for(let gu=1024;gu<2048;++gu)uu[gu]=939524096+(gu-1024<<13);for(let gu=1;gu<31;++gu)du[gu]=gu<<23;du[31]=1199570944,du[32]=2147483648;for(let gu=33;gu<63;++gu)du[gu]=2147483648+(gu-32<<23);du[63]=3347054592;for(let gu=1;gu<64;++gu)gu!==32&&(fu[gu]=1024);return{floatView:eu,uint32View:tu,baseTable:su,shiftTable:au,mantissaTable:uu,exponentTable:du,offsetTable:fu}}function toHalfFloat(iu){Math.abs(iu)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),iu=clamp(iu,-65504,65504),_tables.floatView[0]=iu;const eu=_tables.uint32View[0],tu=eu>>23&511;return _tables.baseTable[tu]+((eu&8388607)>>_tables.shiftTable[tu])}function fromHalfFloat(iu){const eu=iu>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[eu]+(iu&1023)]+_tables.exponentTable[eu],_tables.floatView[0]}const DataUtils={toHalfFloat,fromHalfFloat},_vector$9=new Vector3,_vector2$1=new Vector2;let _id$2=0;class BufferAttribute{constructor(eu,tu,su=!1){if(Array.isArray(eu))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.name="",this.array=eu,this.itemSize=tu,this.count=eu!==void 0?eu.length/tu:0,this.normalized=su,this.usage=StaticDrawUsage,this.updateRanges=[],this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(eu){eu===!0&&this.version++}setUsage(eu){return this.usage=eu,this}addUpdateRange(eu,tu){this.updateRanges.push({start:eu,count:tu})}clearUpdateRanges(){this.updateRanges.length=0}copy(eu){return this.name=eu.name,this.array=new eu.array.constructor(eu.array),this.itemSize=eu.itemSize,this.count=eu.count,this.normalized=eu.normalized,this.usage=eu.usage,this.gpuType=eu.gpuType,this}copyAt(eu,tu,su){eu*=this.itemSize,su*=tu.itemSize;for(let au=0,uu=this.itemSize;au<uu;au++)this.array[eu+au]=tu.array[su+au];return this}copyArray(eu){return this.array.set(eu),this}applyMatrix3(eu){if(this.itemSize===2)for(let tu=0,su=this.count;tu<su;tu++)_vector2$1.fromBufferAttribute(this,tu),_vector2$1.applyMatrix3(eu),this.setXY(tu,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let tu=0,su=this.count;tu<su;tu++)_vector$9.fromBufferAttribute(this,tu),_vector$9.applyMatrix3(eu),this.setXYZ(tu,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(eu){for(let tu=0,su=this.count;tu<su;tu++)_vector$9.fromBufferAttribute(this,tu),_vector$9.applyMatrix4(eu),this.setXYZ(tu,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(eu){for(let tu=0,su=this.count;tu<su;tu++)_vector$9.fromBufferAttribute(this,tu),_vector$9.applyNormalMatrix(eu),this.setXYZ(tu,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(eu){for(let tu=0,su=this.count;tu<su;tu++)_vector$9.fromBufferAttribute(this,tu),_vector$9.transformDirection(eu),this.setXYZ(tu,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(eu,tu=0){return this.array.set(eu,tu),this}getComponent(eu,tu){let su=this.array[eu*this.itemSize+tu];return this.normalized&&(su=denormalize(su,this.array)),su}setComponent(eu,tu,su){return this.normalized&&(su=normalize(su,this.array)),this.array[eu*this.itemSize+tu]=su,this}getX(eu){let tu=this.array[eu*this.itemSize];return this.normalized&&(tu=denormalize(tu,this.array)),tu}setX(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize]=tu,this}getY(eu){let tu=this.array[eu*this.itemSize+1];return this.normalized&&(tu=denormalize(tu,this.array)),tu}setY(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize+1]=tu,this}getZ(eu){let tu=this.array[eu*this.itemSize+2];return this.normalized&&(tu=denormalize(tu,this.array)),tu}setZ(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize+2]=tu,this}getW(eu){let tu=this.array[eu*this.itemSize+3];return this.normalized&&(tu=denormalize(tu,this.array)),tu}setW(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize+3]=tu,this}setXY(eu,tu,su){return eu*=this.itemSize,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array)),this.array[eu+0]=tu,this.array[eu+1]=su,this}setXYZ(eu,tu,su,au){return eu*=this.itemSize,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array),au=normalize(au,this.array)),this.array[eu+0]=tu,this.array[eu+1]=su,this.array[eu+2]=au,this}setXYZW(eu,tu,su,au,uu){return eu*=this.itemSize,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array),au=normalize(au,this.array),uu=normalize(uu,this.array)),this.array[eu+0]=tu,this.array[eu+1]=su,this.array[eu+2]=au,this.array[eu+3]=uu,this}onUpload(eu){return this.onUploadCallback=eu,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const eu={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(eu.name=this.name),this.usage!==StaticDrawUsage&&(eu.usage=this.usage),eu}}class Int8BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Int8Array(eu),tu,su)}}class Uint8BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Uint8Array(eu),tu,su)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Uint8ClampedArray(eu),tu,su)}}class Int16BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Int16Array(eu),tu,su)}}class Uint16BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Uint16Array(eu),tu,su)}}class Int32BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Int32Array(eu),tu,su)}}class Uint32BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Uint32Array(eu),tu,su)}}class Float16BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Uint16Array(eu),tu,su),this.isFloat16BufferAttribute=!0}getX(eu){let tu=fromHalfFloat(this.array[eu*this.itemSize]);return this.normalized&&(tu=denormalize(tu,this.array)),tu}setX(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize]=toHalfFloat(tu),this}getY(eu){let tu=fromHalfFloat(this.array[eu*this.itemSize+1]);return this.normalized&&(tu=denormalize(tu,this.array)),tu}setY(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize+1]=toHalfFloat(tu),this}getZ(eu){let tu=fromHalfFloat(this.array[eu*this.itemSize+2]);return this.normalized&&(tu=denormalize(tu,this.array)),tu}setZ(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize+2]=toHalfFloat(tu),this}getW(eu){let tu=fromHalfFloat(this.array[eu*this.itemSize+3]);return this.normalized&&(tu=denormalize(tu,this.array)),tu}setW(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.array[eu*this.itemSize+3]=toHalfFloat(tu),this}setXY(eu,tu,su){return eu*=this.itemSize,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array)),this.array[eu+0]=toHalfFloat(tu),this.array[eu+1]=toHalfFloat(su),this}setXYZ(eu,tu,su,au){return eu*=this.itemSize,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array),au=normalize(au,this.array)),this.array[eu+0]=toHalfFloat(tu),this.array[eu+1]=toHalfFloat(su),this.array[eu+2]=toHalfFloat(au),this}setXYZW(eu,tu,su,au,uu){return eu*=this.itemSize,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array),au=normalize(au,this.array),uu=normalize(uu,this.array)),this.array[eu+0]=toHalfFloat(tu),this.array[eu+1]=toHalfFloat(su),this.array[eu+2]=toHalfFloat(au),this.array[eu+3]=toHalfFloat(uu),this}}class Float32BufferAttribute extends BufferAttribute{constructor(eu,tu,su){super(new Float32Array(eu),tu,su)}}let _id$1=0;const _m1$3=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$2=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$1++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(eu){return Array.isArray(eu)?this.index=new(arrayNeedsUint32(eu)?Uint32BufferAttribute:Uint16BufferAttribute)(eu,1):this.index=eu,this}setIndirect(eu){return this.indirect=eu,this}getIndirect(){return this.indirect}getAttribute(eu){return this.attributes[eu]}setAttribute(eu,tu){return this.attributes[eu]=tu,this}deleteAttribute(eu){return delete this.attributes[eu],this}hasAttribute(eu){return this.attributes[eu]!==void 0}addGroup(eu,tu,su=0){this.groups.push({start:eu,count:tu,materialIndex:su})}clearGroups(){this.groups=[]}setDrawRange(eu,tu){this.drawRange.start=eu,this.drawRange.count=tu}applyMatrix4(eu){const tu=this.attributes.position;tu!==void 0&&(tu.applyMatrix4(eu),tu.needsUpdate=!0);const su=this.attributes.normal;if(su!==void 0){const uu=new Matrix3().getNormalMatrix(eu);su.applyNormalMatrix(uu),su.needsUpdate=!0}const au=this.attributes.tangent;return au!==void 0&&(au.transformDirection(eu),au.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(eu){return _m1$3.makeRotationFromQuaternion(eu),this.applyMatrix4(_m1$3),this}rotateX(eu){return _m1$3.makeRotationX(eu),this.applyMatrix4(_m1$3),this}rotateY(eu){return _m1$3.makeRotationY(eu),this.applyMatrix4(_m1$3),this}rotateZ(eu){return _m1$3.makeRotationZ(eu),this.applyMatrix4(_m1$3),this}translate(eu,tu,su){return _m1$3.makeTranslation(eu,tu,su),this.applyMatrix4(_m1$3),this}scale(eu,tu,su){return _m1$3.makeScale(eu,tu,su),this.applyMatrix4(_m1$3),this}lookAt(eu){return _obj.lookAt(eu),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(eu){const tu=this.getAttribute("position");if(tu===void 0){const su=[];for(let au=0,uu=eu.length;au<uu;au++){const du=eu[au];su.push(du.x,du.y,du.z||0)}this.setAttribute("position",new Float32BufferAttribute(su,3))}else{const su=Math.min(eu.length,tu.count);for(let au=0;au<su;au++){const uu=eu[au];tu.setXYZ(au,uu.x,uu.y,uu.z||0)}eu.length>tu.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),tu.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const eu=this.attributes.position,tu=this.morphAttributes.position;if(eu&&eu.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(eu!==void 0){if(this.boundingBox.setFromBufferAttribute(eu),tu)for(let su=0,au=tu.length;su<au;su++){const uu=tu[su];_box$2.setFromBufferAttribute(uu),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const eu=this.attributes.position,tu=this.morphAttributes.position;if(eu&&eu.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Vector3,1/0);return}if(eu){const su=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(eu),tu)for(let uu=0,du=tu.length;uu<du;uu++){const fu=tu[uu];_boxMorphTargets.setFromBufferAttribute(fu),this.morphTargetsRelative?(_vector$8.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$8),_vector$8.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$8)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(su);let au=0;for(let uu=0,du=eu.count;uu<du;uu++)_vector$8.fromBufferAttribute(eu,uu),au=Math.max(au,su.distanceToSquared(_vector$8));if(tu)for(let uu=0,du=tu.length;uu<du;uu++){const fu=tu[uu],gu=this.morphTargetsRelative;for(let yu=0,xu=fu.count;yu<xu;yu++)_vector$8.fromBufferAttribute(fu,yu),gu&&(_offset.fromBufferAttribute(eu,yu),_vector$8.add(_offset)),au=Math.max(au,su.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(au),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const eu=this.index,tu=this.attributes;if(eu===null||tu.position===void 0||tu.normal===void 0||tu.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const su=tu.position,au=tu.normal,uu=tu.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*su.count),4));const du=this.getAttribute("tangent"),fu=[],gu=[];for(let Yu=0;Yu<su.count;Yu++)fu[Yu]=new Vector3,gu[Yu]=new Vector3;const yu=new Vector3,xu=new Vector3,vu=new Vector3,Su=new Vector2,Iu=new Vector2,Mu=new Vector2,ku=new Vector3,Bu=new Vector3;function _u(Yu,Ku,ju){yu.fromBufferAttribute(su,Yu),xu.fromBufferAttribute(su,Ku),vu.fromBufferAttribute(su,ju),Su.fromBufferAttribute(uu,Yu),Iu.fromBufferAttribute(uu,Ku),Mu.fromBufferAttribute(uu,ju),xu.sub(yu),vu.sub(yu),Iu.sub(Su),Mu.sub(Su);const tp=1/(Iu.x*Mu.y-Mu.x*Iu.y);isFinite(tp)&&(ku.copy(xu).multiplyScalar(Mu.y).addScaledVector(vu,-Iu.y).multiplyScalar(tp),Bu.copy(vu).multiplyScalar(Iu.x).addScaledVector(xu,-Mu.x).multiplyScalar(tp),fu[Yu].add(ku),fu[Ku].add(ku),fu[ju].add(ku),gu[Yu].add(Bu),gu[Ku].add(Bu),gu[ju].add(Bu))}let Lu=this.groups;Lu.length===0&&(Lu=[{start:0,count:eu.count}]);for(let Yu=0,Ku=Lu.length;Yu<Ku;++Yu){const ju=Lu[Yu],tp=ju.start,gp=ju.count;for(let yp=tp,Cp=tp+gp;yp<Cp;yp+=3)_u(eu.getX(yp+0),eu.getX(yp+1),eu.getX(yp+2))}const Du=new Vector3,Ou=new Vector3,Wu=new Vector3,Zu=new Vector3;function Hu(Yu){Wu.fromBufferAttribute(au,Yu),Zu.copy(Wu);const Ku=fu[Yu];Du.copy(Ku),Du.sub(Wu.multiplyScalar(Wu.dot(Ku))).normalize(),Ou.crossVectors(Zu,Ku);const tp=Ou.dot(gu[Yu])<0?-1:1;du.setXYZW(Yu,Du.x,Du.y,Du.z,tp)}for(let Yu=0,Ku=Lu.length;Yu<Ku;++Yu){const ju=Lu[Yu],tp=ju.start,gp=ju.count;for(let yp=tp,Cp=tp+gp;yp<Cp;yp+=3)Hu(eu.getX(yp+0)),Hu(eu.getX(yp+1)),Hu(eu.getX(yp+2))}}computeVertexNormals(){const eu=this.index,tu=this.getAttribute("position");if(tu!==void 0){let su=this.getAttribute("normal");if(su===void 0)su=new BufferAttribute(new Float32Array(tu.count*3),3),this.setAttribute("normal",su);else for(let Su=0,Iu=su.count;Su<Iu;Su++)su.setXYZ(Su,0,0,0);const au=new Vector3,uu=new Vector3,du=new Vector3,fu=new Vector3,gu=new Vector3,yu=new Vector3,xu=new Vector3,vu=new Vector3;if(eu)for(let Su=0,Iu=eu.count;Su<Iu;Su+=3){const Mu=eu.getX(Su+0),ku=eu.getX(Su+1),Bu=eu.getX(Su+2);au.fromBufferAttribute(tu,Mu),uu.fromBufferAttribute(tu,ku),du.fromBufferAttribute(tu,Bu),xu.subVectors(du,uu),vu.subVectors(au,uu),xu.cross(vu),fu.fromBufferAttribute(su,Mu),gu.fromBufferAttribute(su,ku),yu.fromBufferAttribute(su,Bu),fu.add(xu),gu.add(xu),yu.add(xu),su.setXYZ(Mu,fu.x,fu.y,fu.z),su.setXYZ(ku,gu.x,gu.y,gu.z),su.setXYZ(Bu,yu.x,yu.y,yu.z)}else for(let Su=0,Iu=tu.count;Su<Iu;Su+=3)au.fromBufferAttribute(tu,Su+0),uu.fromBufferAttribute(tu,Su+1),du.fromBufferAttribute(tu,Su+2),xu.subVectors(du,uu),vu.subVectors(au,uu),xu.cross(vu),su.setXYZ(Su+0,xu.x,xu.y,xu.z),su.setXYZ(Su+1,xu.x,xu.y,xu.z),su.setXYZ(Su+2,xu.x,xu.y,xu.z);this.normalizeNormals(),su.needsUpdate=!0}}normalizeNormals(){const eu=this.attributes.normal;for(let tu=0,su=eu.count;tu<su;tu++)_vector$8.fromBufferAttribute(eu,tu),_vector$8.normalize(),eu.setXYZ(tu,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function eu(fu,gu){const yu=fu.array,xu=fu.itemSize,vu=fu.normalized,Su=new yu.constructor(gu.length*xu);let Iu=0,Mu=0;for(let ku=0,Bu=gu.length;ku<Bu;ku++){fu.isInterleavedBufferAttribute?Iu=gu[ku]*fu.data.stride+fu.offset:Iu=gu[ku]*xu;for(let _u=0;_u<xu;_u++)Su[Mu++]=yu[Iu++]}return new BufferAttribute(Su,xu,vu)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const tu=new BufferGeometry,su=this.index.array,au=this.attributes;for(const fu in au){const gu=au[fu],yu=eu(gu,su);tu.setAttribute(fu,yu)}const uu=this.morphAttributes;for(const fu in uu){const gu=[],yu=uu[fu];for(let xu=0,vu=yu.length;xu<vu;xu++){const Su=yu[xu],Iu=eu(Su,su);gu.push(Iu)}tu.morphAttributes[fu]=gu}tu.morphTargetsRelative=this.morphTargetsRelative;const du=this.groups;for(let fu=0,gu=du.length;fu<gu;fu++){const yu=du[fu];tu.addGroup(yu.start,yu.count,yu.materialIndex)}return tu}toJSON(){const eu={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(eu.uuid=this.uuid,eu.type=this.type,this.name!==""&&(eu.name=this.name),Object.keys(this.userData).length>0&&(eu.userData=this.userData),this.parameters!==void 0){const gu=this.parameters;for(const yu in gu)gu[yu]!==void 0&&(eu[yu]=gu[yu]);return eu}eu.data={attributes:{}};const tu=this.index;tu!==null&&(eu.data.index={type:tu.array.constructor.name,array:Array.prototype.slice.call(tu.array)});const su=this.attributes;for(const gu in su){const yu=su[gu];eu.data.attributes[gu]=yu.toJSON(eu.data)}const au={};let uu=!1;for(const gu in this.morphAttributes){const yu=this.morphAttributes[gu],xu=[];for(let vu=0,Su=yu.length;vu<Su;vu++){const Iu=yu[vu];xu.push(Iu.toJSON(eu.data))}xu.length>0&&(au[gu]=xu,uu=!0)}uu&&(eu.data.morphAttributes=au,eu.data.morphTargetsRelative=this.morphTargetsRelative);const du=this.groups;du.length>0&&(eu.data.groups=JSON.parse(JSON.stringify(du)));const fu=this.boundingSphere;return fu!==null&&(eu.data.boundingSphere={center:fu.center.toArray(),radius:fu.radius}),eu}clone(){return new this.constructor().copy(this)}copy(eu){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const tu={};this.name=eu.name;const su=eu.index;su!==null&&this.setIndex(su.clone(tu));const au=eu.attributes;for(const yu in au){const xu=au[yu];this.setAttribute(yu,xu.clone(tu))}const uu=eu.morphAttributes;for(const yu in uu){const xu=[],vu=uu[yu];for(let Su=0,Iu=vu.length;Su<Iu;Su++)xu.push(vu[Su].clone(tu));this.morphAttributes[yu]=xu}this.morphTargetsRelative=eu.morphTargetsRelative;const du=eu.groups;for(let yu=0,xu=du.length;yu<xu;yu++){const vu=du[yu];this.addGroup(vu.start,vu.count,vu.materialIndex)}const fu=eu.boundingBox;fu!==null&&(this.boundingBox=fu.clone());const gu=eu.boundingSphere;return gu!==null&&(this.boundingSphere=gu.clone()),this.drawRange.start=eu.drawRange.start,this.drawRange.count=eu.drawRange.count,this.userData=eu.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$6=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(eu=new BufferGeometry,tu=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=eu,this.material=tu,this.updateMorphTargets()}copy(eu,tu){return super.copy(eu,tu),eu.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=eu.morphTargetInfluences.slice()),eu.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},eu.morphTargetDictionary)),this.material=Array.isArray(eu.material)?eu.material.slice():eu.material,this.geometry=eu.geometry,this}updateMorphTargets(){const tu=this.geometry.morphAttributes,su=Object.keys(tu);if(su.length>0){const au=tu[su[0]];if(au!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let uu=0,du=au.length;uu<du;uu++){const fu=au[uu].name||String(uu);this.morphTargetInfluences.push(0),this.morphTargetDictionary[fu]=uu}}}}getVertexPosition(eu,tu){const su=this.geometry,au=su.attributes.position,uu=su.morphAttributes.position,du=su.morphTargetsRelative;tu.fromBufferAttribute(au,eu);const fu=this.morphTargetInfluences;if(uu&&fu){_morphA.set(0,0,0);for(let gu=0,yu=uu.length;gu<yu;gu++){const xu=fu[gu],vu=uu[gu];xu!==0&&(_tempA.fromBufferAttribute(vu,eu),du?_morphA.addScaledVector(_tempA,xu):_morphA.addScaledVector(_tempA.sub(tu),xu))}tu.add(_morphA)}return tu}raycast(eu,tu){const su=this.geometry,au=this.material,uu=this.matrixWorld;au!==void 0&&(su.boundingSphere===null&&su.computeBoundingSphere(),_sphere$6.copy(su.boundingSphere),_sphere$6.applyMatrix4(uu),_ray$3.copy(eu.ray).recast(eu.near),!(_sphere$6.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(eu.far-eu.near)**2))&&(_inverseMatrix$3.copy(uu).invert(),_ray$3.copy(eu.ray).applyMatrix4(_inverseMatrix$3),!(su.boundingBox!==null&&_ray$3.intersectsBox(su.boundingBox)===!1)&&this._computeIntersections(eu,tu,_ray$3)))}_computeIntersections(eu,tu,su){let au;const uu=this.geometry,du=this.material,fu=uu.index,gu=uu.attributes.position,yu=uu.attributes.uv,xu=uu.attributes.uv1,vu=uu.attributes.normal,Su=uu.groups,Iu=uu.drawRange;if(fu!==null)if(Array.isArray(du))for(let Mu=0,ku=Su.length;Mu<ku;Mu++){const Bu=Su[Mu],_u=du[Bu.materialIndex],Lu=Math.max(Bu.start,Iu.start),Du=Math.min(fu.count,Math.min(Bu.start+Bu.count,Iu.start+Iu.count));for(let Ou=Lu,Wu=Du;Ou<Wu;Ou+=3){const Zu=fu.getX(Ou),Hu=fu.getX(Ou+1),Yu=fu.getX(Ou+2);au=checkGeometryIntersection(this,_u,eu,su,yu,xu,vu,Zu,Hu,Yu),au&&(au.faceIndex=Math.floor(Ou/3),au.face.materialIndex=Bu.materialIndex,tu.push(au))}}else{const Mu=Math.max(0,Iu.start),ku=Math.min(fu.count,Iu.start+Iu.count);for(let Bu=Mu,_u=ku;Bu<_u;Bu+=3){const Lu=fu.getX(Bu),Du=fu.getX(Bu+1),Ou=fu.getX(Bu+2);au=checkGeometryIntersection(this,du,eu,su,yu,xu,vu,Lu,Du,Ou),au&&(au.faceIndex=Math.floor(Bu/3),tu.push(au))}}else if(gu!==void 0)if(Array.isArray(du))for(let Mu=0,ku=Su.length;Mu<ku;Mu++){const Bu=Su[Mu],_u=du[Bu.materialIndex],Lu=Math.max(Bu.start,Iu.start),Du=Math.min(gu.count,Math.min(Bu.start+Bu.count,Iu.start+Iu.count));for(let Ou=Lu,Wu=Du;Ou<Wu;Ou+=3){const Zu=Ou,Hu=Ou+1,Yu=Ou+2;au=checkGeometryIntersection(this,_u,eu,su,yu,xu,vu,Zu,Hu,Yu),au&&(au.faceIndex=Math.floor(Ou/3),au.face.materialIndex=Bu.materialIndex,tu.push(au))}}else{const Mu=Math.max(0,Iu.start),ku=Math.min(gu.count,Iu.start+Iu.count);for(let Bu=Mu,_u=ku;Bu<_u;Bu+=3){const Lu=Bu,Du=Bu+1,Ou=Bu+2;au=checkGeometryIntersection(this,du,eu,su,yu,xu,vu,Lu,Du,Ou),au&&(au.faceIndex=Math.floor(Bu/3),tu.push(au))}}}}function checkIntersection$1(iu,eu,tu,su,au,uu,du,fu){let gu;if(eu.side===BackSide?gu=su.intersectTriangle(du,uu,au,!0,fu):gu=su.intersectTriangle(au,uu,du,eu.side===FrontSide,fu),gu===null)return null;_intersectionPointWorld.copy(fu),_intersectionPointWorld.applyMatrix4(iu.matrixWorld);const yu=tu.ray.origin.distanceTo(_intersectionPointWorld);return yu<tu.near||yu>tu.far?null:{distance:yu,point:_intersectionPointWorld.clone(),object:iu}}function checkGeometryIntersection(iu,eu,tu,su,au,uu,du,fu,gu,yu){iu.getVertexPosition(fu,_vA$1),iu.getVertexPosition(gu,_vB$1),iu.getVertexPosition(yu,_vC$1);const xu=checkIntersection$1(iu,eu,tu,su,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(xu){const vu=new Vector3;Triangle.getBarycoord(_intersectionPoint,_vA$1,_vB$1,_vC$1,vu),au&&(xu.uv=Triangle.getInterpolatedAttribute(au,fu,gu,yu,vu,new Vector2)),uu&&(xu.uv1=Triangle.getInterpolatedAttribute(uu,fu,gu,yu,vu,new Vector2)),du&&(xu.normal=Triangle.getInterpolatedAttribute(du,fu,gu,yu,vu,new Vector3),xu.normal.dot(su.direction)>0&&xu.normal.multiplyScalar(-1));const Su={a:fu,b:gu,c:yu,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,Su.normal),xu.face=Su,xu.barycoord=vu}return xu}class BoxGeometry extends BufferGeometry{constructor(eu=1,tu=1,su=1,au=1,uu=1,du=1){super(),this.type="BoxGeometry",this.parameters={width:eu,height:tu,depth:su,widthSegments:au,heightSegments:uu,depthSegments:du};const fu=this;au=Math.floor(au),uu=Math.floor(uu),du=Math.floor(du);const gu=[],yu=[],xu=[],vu=[];let Su=0,Iu=0;Mu("z","y","x",-1,-1,su,tu,eu,du,uu,0),Mu("z","y","x",1,-1,su,tu,-eu,du,uu,1),Mu("x","z","y",1,1,eu,su,tu,au,du,2),Mu("x","z","y",1,-1,eu,su,-tu,au,du,3),Mu("x","y","z",1,-1,eu,tu,su,au,uu,4),Mu("x","y","z",-1,-1,eu,tu,-su,au,uu,5),this.setIndex(gu),this.setAttribute("position",new Float32BufferAttribute(yu,3)),this.setAttribute("normal",new Float32BufferAttribute(xu,3)),this.setAttribute("uv",new Float32BufferAttribute(vu,2));function Mu(ku,Bu,_u,Lu,Du,Ou,Wu,Zu,Hu,Yu,Ku){const ju=Ou/Hu,tp=Wu/Yu,gp=Ou/2,yp=Wu/2,Cp=Zu/2,Hp=Hu+1,wp=Yu+1;let Dp=0,dp=0;const Rp=new Vector3;for(let xp=0;xp<wp;xp++){const cm=xp*tp-yp;for(let lm=0;lm<Hp;lm++){const vp=lm*ju-gp;Rp[ku]=vp*Lu,Rp[Bu]=cm*Du,Rp[_u]=Cp,yu.push(Rp.x,Rp.y,Rp.z),Rp[ku]=0,Rp[Bu]=0,Rp[_u]=Zu>0?1:-1,xu.push(Rp.x,Rp.y,Rp.z),vu.push(lm/Hu),vu.push(1-xp/Yu),Dp+=1}}for(let xp=0;xp<Yu;xp++)for(let cm=0;cm<Hu;cm++){const lm=Su+cm+Hp*xp,vp=Su+cm+Hp*(xp+1),bp=Su+(cm+1)+Hp*(xp+1),kp=Su+(cm+1)+Hp*xp;gu.push(lm,vp,kp),gu.push(vp,bp,kp),dp+=6}fu.addGroup(Iu,dp,Ku),Iu+=dp,Su+=Dp}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new BoxGeometry(eu.width,eu.height,eu.depth,eu.widthSegments,eu.heightSegments,eu.depthSegments)}}function cloneUniforms(iu){const eu={};for(const tu in iu){eu[tu]={};for(const su in iu[tu]){const au=iu[tu][su];au&&(au.isColor||au.isMatrix3||au.isMatrix4||au.isVector2||au.isVector3||au.isVector4||au.isTexture||au.isQuaternion)?au.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),eu[tu][su]=null):eu[tu][su]=au.clone():Array.isArray(au)?eu[tu][su]=au.slice():eu[tu][su]=au}}return eu}function mergeUniforms(iu){const eu={};for(let tu=0;tu<iu.length;tu++){const su=cloneUniforms(iu[tu]);for(const au in su)eu[au]=su[au]}return eu}function cloneUniformsGroups(iu){const eu=[];for(let tu=0;tu<iu.length;tu++)eu.push(iu[tu].clone());return eu}function getUnlitUniformColorSpace(iu){const eu=iu.getRenderTarget();return eu===null?iu.outputColorSpace:eu.isXRRenderTarget===!0?eu.texture.colorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material{constructor(eu){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,eu!==void 0&&this.setValues(eu)}copy(eu){return super.copy(eu),this.fragmentShader=eu.fragmentShader,this.vertexShader=eu.vertexShader,this.uniforms=cloneUniforms(eu.uniforms),this.uniformsGroups=cloneUniformsGroups(eu.uniformsGroups),this.defines=Object.assign({},eu.defines),this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.fog=eu.fog,this.lights=eu.lights,this.clipping=eu.clipping,this.extensions=Object.assign({},eu.extensions),this.glslVersion=eu.glslVersion,this}toJSON(eu){const tu=super.toJSON(eu);tu.glslVersion=this.glslVersion,tu.uniforms={};for(const au in this.uniforms){const du=this.uniforms[au].value;du&&du.isTexture?tu.uniforms[au]={type:"t",value:du.toJSON(eu).uuid}:du&&du.isColor?tu.uniforms[au]={type:"c",value:du.getHex()}:du&&du.isVector2?tu.uniforms[au]={type:"v2",value:du.toArray()}:du&&du.isVector3?tu.uniforms[au]={type:"v3",value:du.toArray()}:du&&du.isVector4?tu.uniforms[au]={type:"v4",value:du.toArray()}:du&&du.isMatrix3?tu.uniforms[au]={type:"m3",value:du.toArray()}:du&&du.isMatrix4?tu.uniforms[au]={type:"m4",value:du.toArray()}:tu.uniforms[au]={value:du}}Object.keys(this.defines).length>0&&(tu.defines=this.defines),tu.vertexShader=this.vertexShader,tu.fragmentShader=this.fragmentShader,tu.lights=this.lights,tu.clipping=this.clipping;const su={};for(const au in this.extensions)this.extensions[au]===!0&&(su[au]=!0);return Object.keys(su).length>0&&(tu.extensions=su),tu}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem}copy(eu,tu){return super.copy(eu,tu),this.matrixWorldInverse.copy(eu.matrixWorldInverse),this.projectionMatrix.copy(eu.projectionMatrix),this.projectionMatrixInverse.copy(eu.projectionMatrixInverse),this.coordinateSystem=eu.coordinateSystem,this}getWorldDirection(eu){return super.getWorldDirection(eu).negate()}updateMatrixWorld(eu){super.updateMatrixWorld(eu),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(eu,tu){super.updateWorldMatrix(eu,tu),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const _v3$1=new Vector3,_minTarget=new Vector2,_maxTarget=new Vector2;class PerspectiveCamera extends Camera{constructor(eu=50,tu=1,su=.1,au=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=eu,this.zoom=1,this.near=su,this.far=au,this.focus=10,this.aspect=tu,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(eu,tu){return super.copy(eu,tu),this.fov=eu.fov,this.zoom=eu.zoom,this.near=eu.near,this.far=eu.far,this.focus=eu.focus,this.aspect=eu.aspect,this.view=eu.view===null?null:Object.assign({},eu.view),this.filmGauge=eu.filmGauge,this.filmOffset=eu.filmOffset,this}setFocalLength(eu){const tu=.5*this.getFilmHeight()/eu;this.fov=RAD2DEG*2*Math.atan(tu),this.updateProjectionMatrix()}getFocalLength(){const eu=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/eu}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(eu,tu,su){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),tu.set(_v3$1.x,_v3$1.y).multiplyScalar(-eu/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),su.set(_v3$1.x,_v3$1.y).multiplyScalar(-eu/_v3$1.z)}getViewSize(eu,tu){return this.getViewBounds(eu,_minTarget,_maxTarget),tu.subVectors(_maxTarget,_minTarget)}setViewOffset(eu,tu,su,au,uu,du){this.aspect=eu/tu,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=eu,this.view.fullHeight=tu,this.view.offsetX=su,this.view.offsetY=au,this.view.width=uu,this.view.height=du,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const eu=this.near;let tu=eu*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,su=2*tu,au=this.aspect*su,uu=-.5*au;const du=this.view;if(this.view!==null&&this.view.enabled){const gu=du.fullWidth,yu=du.fullHeight;uu+=du.offsetX*au/gu,tu-=du.offsetY*su/yu,au*=du.width/gu,su*=du.height/yu}const fu=this.filmOffset;fu!==0&&(uu+=eu*fu/this.getFilmWidth()),this.projectionMatrix.makePerspective(uu,uu+au,tu,tu-su,eu,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(eu){const tu=super.toJSON(eu);return tu.object.fov=this.fov,tu.object.zoom=this.zoom,tu.object.near=this.near,tu.object.far=this.far,tu.object.focus=this.focus,tu.object.aspect=this.aspect,this.view!==null&&(tu.object.view=Object.assign({},this.view)),tu.object.filmGauge=this.filmGauge,tu.object.filmOffset=this.filmOffset,tu}}const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(eu,tu,su){super(),this.type="CubeCamera",this.renderTarget=su,this.coordinateSystem=null,this.activeMipmapLevel=0;const au=new PerspectiveCamera(fov,aspect,eu,tu);au.layers=this.layers,this.add(au);const uu=new PerspectiveCamera(fov,aspect,eu,tu);uu.layers=this.layers,this.add(uu);const du=new PerspectiveCamera(fov,aspect,eu,tu);du.layers=this.layers,this.add(du);const fu=new PerspectiveCamera(fov,aspect,eu,tu);fu.layers=this.layers,this.add(fu);const gu=new PerspectiveCamera(fov,aspect,eu,tu);gu.layers=this.layers,this.add(gu);const yu=new PerspectiveCamera(fov,aspect,eu,tu);yu.layers=this.layers,this.add(yu)}updateCoordinateSystem(){const eu=this.coordinateSystem,tu=this.children.concat(),[su,au,uu,du,fu,gu]=tu;for(const yu of tu)this.remove(yu);if(eu===WebGLCoordinateSystem)su.up.set(0,1,0),su.lookAt(1,0,0),au.up.set(0,1,0),au.lookAt(-1,0,0),uu.up.set(0,0,-1),uu.lookAt(0,1,0),du.up.set(0,0,1),du.lookAt(0,-1,0),fu.up.set(0,1,0),fu.lookAt(0,0,1),gu.up.set(0,1,0),gu.lookAt(0,0,-1);else if(eu===WebGPUCoordinateSystem)su.up.set(0,-1,0),su.lookAt(-1,0,0),au.up.set(0,-1,0),au.lookAt(1,0,0),uu.up.set(0,0,1),uu.lookAt(0,1,0),du.up.set(0,0,-1),du.lookAt(0,-1,0),fu.up.set(0,-1,0),fu.lookAt(0,0,1),gu.up.set(0,-1,0),gu.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+eu);for(const yu of tu)this.add(yu),yu.updateMatrixWorld()}update(eu,tu){this.parent===null&&this.updateMatrixWorld();const{renderTarget:su,activeMipmapLevel:au}=this;this.coordinateSystem!==eu.coordinateSystem&&(this.coordinateSystem=eu.coordinateSystem,this.updateCoordinateSystem());const[uu,du,fu,gu,yu,xu]=this.children,vu=eu.getRenderTarget(),Su=eu.getActiveCubeFace(),Iu=eu.getActiveMipmapLevel(),Mu=eu.xr.enabled;eu.xr.enabled=!1;const ku=su.texture.generateMipmaps;su.texture.generateMipmaps=!1,eu.setRenderTarget(su,0,au),eu.render(tu,uu),eu.setRenderTarget(su,1,au),eu.render(tu,du),eu.setRenderTarget(su,2,au),eu.render(tu,fu),eu.setRenderTarget(su,3,au),eu.render(tu,gu),eu.setRenderTarget(su,4,au),eu.render(tu,yu),su.texture.generateMipmaps=ku,eu.setRenderTarget(su,5,au),eu.render(tu,xu),eu.setRenderTarget(vu,Su,Iu),eu.xr.enabled=Mu,su.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(eu,tu,su,au,uu,du,fu,gu,yu,xu){eu=eu!==void 0?eu:[],tu=tu!==void 0?tu:CubeReflectionMapping,super(eu,tu,su,au,uu,du,fu,gu,yu,xu),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(eu){this.image=eu}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(eu=1,tu={}){super(eu,eu,tu),this.isWebGLCubeRenderTarget=!0;const su={width:eu,height:eu,depth:1},au=[su,su,su,su,su,su];this.texture=new CubeTexture(au,tu.mapping,tu.wrapS,tu.wrapT,tu.magFilter,tu.minFilter,tu.format,tu.type,tu.anisotropy,tu.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=tu.generateMipmaps!==void 0?tu.generateMipmaps:!1,this.texture.minFilter=tu.minFilter!==void 0?tu.minFilter:LinearFilter}fromEquirectangularTexture(eu,tu){this.texture.type=tu.type,this.texture.colorSpace=tu.colorSpace,this.texture.generateMipmaps=tu.generateMipmaps,this.texture.minFilter=tu.minFilter,this.texture.magFilter=tu.magFilter;const su={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},au=new BoxGeometry(5,5,5),uu=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(su.uniforms),vertexShader:su.vertexShader,fragmentShader:su.fragmentShader,side:BackSide,blending:NoBlending});uu.uniforms.tEquirect.value=tu;const du=new Mesh(au,uu),fu=tu.minFilter;return tu.minFilter===LinearMipmapLinearFilter&&(tu.minFilter=LinearFilter),new CubeCamera(1,10,this).update(eu,du),tu.minFilter=fu,du.geometry.dispose(),du.material.dispose(),this}clear(eu,tu,su,au){const uu=eu.getRenderTarget();for(let du=0;du<6;du++)eu.setRenderTarget(this,du),eu.clear(tu,su,au);eu.setRenderTarget(uu)}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(eu){return this._targetRay!==null&&this._targetRay.dispatchEvent(eu),this._grip!==null&&this._grip.dispatchEvent(eu),this._hand!==null&&this._hand.dispatchEvent(eu),this}connect(eu){if(eu&&eu.hand){const tu=this._hand;if(tu)for(const su of eu.hand.values())this._getHandJoint(tu,su)}return this.dispatchEvent({type:"connected",data:eu}),this}disconnect(eu){return this.dispatchEvent({type:"disconnected",data:eu}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(eu,tu,su){let au=null,uu=null,du=null;const fu=this._targetRay,gu=this._grip,yu=this._hand;if(eu&&tu.session.visibilityState!=="visible-blurred"){if(yu&&eu.hand){du=!0;for(const ku of eu.hand.values()){const Bu=tu.getJointPose(ku,su),_u=this._getHandJoint(yu,ku);Bu!==null&&(_u.matrix.fromArray(Bu.transform.matrix),_u.matrix.decompose(_u.position,_u.rotation,_u.scale),_u.matrixWorldNeedsUpdate=!0,_u.jointRadius=Bu.radius),_u.visible=Bu!==null}const xu=yu.joints["index-finger-tip"],vu=yu.joints["thumb-tip"],Su=xu.position.distanceTo(vu.position),Iu=.02,Mu=.005;yu.inputState.pinching&&Su>Iu+Mu?(yu.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:eu.handedness,target:this})):!yu.inputState.pinching&&Su<=Iu-Mu&&(yu.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:eu.handedness,target:this}))}else gu!==null&&eu.gripSpace&&(uu=tu.getPose(eu.gripSpace,su),uu!==null&&(gu.matrix.fromArray(uu.transform.matrix),gu.matrix.decompose(gu.position,gu.rotation,gu.scale),gu.matrixWorldNeedsUpdate=!0,uu.linearVelocity?(gu.hasLinearVelocity=!0,gu.linearVelocity.copy(uu.linearVelocity)):gu.hasLinearVelocity=!1,uu.angularVelocity?(gu.hasAngularVelocity=!0,gu.angularVelocity.copy(uu.angularVelocity)):gu.hasAngularVelocity=!1));fu!==null&&(au=tu.getPose(eu.targetRaySpace,su),au===null&&uu!==null&&(au=uu),au!==null&&(fu.matrix.fromArray(au.transform.matrix),fu.matrix.decompose(fu.position,fu.rotation,fu.scale),fu.matrixWorldNeedsUpdate=!0,au.linearVelocity?(fu.hasLinearVelocity=!0,fu.linearVelocity.copy(au.linearVelocity)):fu.hasLinearVelocity=!1,au.angularVelocity?(fu.hasAngularVelocity=!0,fu.angularVelocity.copy(au.angularVelocity)):fu.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return fu!==null&&(fu.visible=au!==null),gu!==null&&(gu.visible=uu!==null),yu!==null&&(yu.visible=du!==null),this}_getHandJoint(eu,tu){if(eu.joints[tu.jointName]===void 0){const su=new Group;su.matrixAutoUpdate=!1,su.visible=!1,eu.joints[tu.jointName]=su,eu.add(su)}return eu.joints[tu.jointName]}}class FogExp2{constructor(eu,tu=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color(eu),this.density=tu}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Fog{constructor(eu,tu=1,su=1e3){this.isFog=!0,this.name="",this.color=new Color(eu),this.near=tu,this.far=su}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentIntensity=1,this.environmentRotation=new Euler,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(eu,tu){return super.copy(eu,tu),eu.background!==null&&(this.background=eu.background.clone()),eu.environment!==null&&(this.environment=eu.environment.clone()),eu.fog!==null&&(this.fog=eu.fog.clone()),this.backgroundBlurriness=eu.backgroundBlurriness,this.backgroundIntensity=eu.backgroundIntensity,this.backgroundRotation.copy(eu.backgroundRotation),this.environmentIntensity=eu.environmentIntensity,this.environmentRotation.copy(eu.environmentRotation),eu.overrideMaterial!==null&&(this.overrideMaterial=eu.overrideMaterial.clone()),this.matrixAutoUpdate=eu.matrixAutoUpdate,this}toJSON(eu){const tu=super.toJSON(eu);return this.fog!==null&&(tu.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(tu.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(tu.object.backgroundIntensity=this.backgroundIntensity),tu.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(tu.object.environmentIntensity=this.environmentIntensity),tu.object.environmentRotation=this.environmentRotation.toArray(),tu}}class InterleavedBuffer{constructor(eu,tu){this.isInterleavedBuffer=!0,this.array=eu,this.stride=tu,this.count=eu!==void 0?eu.length/tu:0,this.usage=StaticDrawUsage,this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(eu){eu===!0&&this.version++}setUsage(eu){return this.usage=eu,this}addUpdateRange(eu,tu){this.updateRanges.push({start:eu,count:tu})}clearUpdateRanges(){this.updateRanges.length=0}copy(eu){return this.array=new eu.array.constructor(eu.array),this.count=eu.count,this.stride=eu.stride,this.usage=eu.usage,this}copyAt(eu,tu,su){eu*=this.stride,su*=tu.stride;for(let au=0,uu=this.stride;au<uu;au++)this.array[eu+au]=tu.array[su+au];return this}set(eu,tu=0){return this.array.set(eu,tu),this}clone(eu){eu.arrayBuffers===void 0&&(eu.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),eu.arrayBuffers[this.array.buffer._uuid]===void 0&&(eu.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const tu=new this.array.constructor(eu.arrayBuffers[this.array.buffer._uuid]),su=new this.constructor(tu,this.stride);return su.setUsage(this.usage),su}onUpload(eu){return this.onUploadCallback=eu,this}toJSON(eu){return eu.arrayBuffers===void 0&&(eu.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),eu.arrayBuffers[this.array.buffer._uuid]===void 0&&(eu.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$7=new Vector3;class InterleavedBufferAttribute{constructor(eu,tu,su,au=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=eu,this.itemSize=tu,this.offset=su,this.normalized=au}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(eu){this.data.needsUpdate=eu}applyMatrix4(eu){for(let tu=0,su=this.data.count;tu<su;tu++)_vector$7.fromBufferAttribute(this,tu),_vector$7.applyMatrix4(eu),this.setXYZ(tu,_vector$7.x,_vector$7.y,_vector$7.z);return this}applyNormalMatrix(eu){for(let tu=0,su=this.count;tu<su;tu++)_vector$7.fromBufferAttribute(this,tu),_vector$7.applyNormalMatrix(eu),this.setXYZ(tu,_vector$7.x,_vector$7.y,_vector$7.z);return this}transformDirection(eu){for(let tu=0,su=this.count;tu<su;tu++)_vector$7.fromBufferAttribute(this,tu),_vector$7.transformDirection(eu),this.setXYZ(tu,_vector$7.x,_vector$7.y,_vector$7.z);return this}getComponent(eu,tu){let su=this.array[eu*this.data.stride+this.offset+tu];return this.normalized&&(su=denormalize(su,this.array)),su}setComponent(eu,tu,su){return this.normalized&&(su=normalize(su,this.array)),this.data.array[eu*this.data.stride+this.offset+tu]=su,this}setX(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.data.array[eu*this.data.stride+this.offset]=tu,this}setY(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.data.array[eu*this.data.stride+this.offset+1]=tu,this}setZ(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.data.array[eu*this.data.stride+this.offset+2]=tu,this}setW(eu,tu){return this.normalized&&(tu=normalize(tu,this.array)),this.data.array[eu*this.data.stride+this.offset+3]=tu,this}getX(eu){let tu=this.data.array[eu*this.data.stride+this.offset];return this.normalized&&(tu=denormalize(tu,this.array)),tu}getY(eu){let tu=this.data.array[eu*this.data.stride+this.offset+1];return this.normalized&&(tu=denormalize(tu,this.array)),tu}getZ(eu){let tu=this.data.array[eu*this.data.stride+this.offset+2];return this.normalized&&(tu=denormalize(tu,this.array)),tu}getW(eu){let tu=this.data.array[eu*this.data.stride+this.offset+3];return this.normalized&&(tu=denormalize(tu,this.array)),tu}setXY(eu,tu,su){return eu=eu*this.data.stride+this.offset,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array)),this.data.array[eu+0]=tu,this.data.array[eu+1]=su,this}setXYZ(eu,tu,su,au){return eu=eu*this.data.stride+this.offset,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array),au=normalize(au,this.array)),this.data.array[eu+0]=tu,this.data.array[eu+1]=su,this.data.array[eu+2]=au,this}setXYZW(eu,tu,su,au,uu){return eu=eu*this.data.stride+this.offset,this.normalized&&(tu=normalize(tu,this.array),su=normalize(su,this.array),au=normalize(au,this.array),uu=normalize(uu,this.array)),this.data.array[eu+0]=tu,this.data.array[eu+1]=su,this.data.array[eu+2]=au,this.data.array[eu+3]=uu,this}clone(eu){if(eu===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const tu=[];for(let su=0;su<this.count;su++){const au=su*this.data.stride+this.offset;for(let uu=0;uu<this.itemSize;uu++)tu.push(this.data.array[au+uu])}return new BufferAttribute(new this.array.constructor(tu),this.itemSize,this.normalized)}else return eu.interleavedBuffers===void 0&&(eu.interleavedBuffers={}),eu.interleavedBuffers[this.data.uuid]===void 0&&(eu.interleavedBuffers[this.data.uuid]=this.data.clone(eu)),new InterleavedBufferAttribute(eu.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(eu){if(eu===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const tu=[];for(let su=0;su<this.count;su++){const au=su*this.data.stride+this.offset;for(let uu=0;uu<this.itemSize;uu++)tu.push(this.data.array[au+uu])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:tu,normalized:this.normalized}}else return eu.interleavedBuffers===void 0&&(eu.interleavedBuffers={}),eu.interleavedBuffers[this.data.uuid]===void 0&&(eu.interleavedBuffers[this.data.uuid]=this.data.toJSON(eu)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(eu){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.map=eu.map,this.alphaMap=eu.alphaMap,this.rotation=eu.rotation,this.sizeAttenuation=eu.sizeAttenuation,this.fog=eu.fog,this}}let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(eu=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",_geometry===void 0){_geometry=new BufferGeometry;const tu=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),su=new InterleavedBuffer(tu,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(su,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(su,2,3,!1))}this.geometry=_geometry,this.material=eu,this.center=new Vector2(.5,.5)}raycast(eu,tu){eu.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(eu.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(eu.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),eu.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&_worldScale.multiplyScalar(-_mvPosition.z);const su=this.material.rotation;let au,uu;su!==0&&(uu=Math.cos(su),au=Math.sin(su));const du=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,du,_worldScale,au,uu),transformVertex(_vB.set(.5,-.5,0),_mvPosition,du,_worldScale,au,uu),transformVertex(_vC.set(.5,.5,0),_mvPosition,du,_worldScale,au,uu),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let fu=eu.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(fu===null&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,du,_worldScale,au,uu),_uvB.set(0,1),fu=eu.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),fu===null))return;const gu=eu.ray.origin.distanceTo(_intersectPoint);gu<eu.near||gu>eu.far||tu.push({distance:gu,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(eu,tu){return super.copy(eu,tu),eu.center!==void 0&&this.center.copy(eu.center),this.material=eu.material,this}}function transformVertex(iu,eu,tu,su,au,uu){_alignedPosition.subVectors(iu,tu).addScalar(.5).multiply(su),au!==void 0?(_rotatedPosition.x=uu*_alignedPosition.x-au*_alignedPosition.y,_rotatedPosition.y=au*_alignedPosition.x+uu*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),iu.copy(eu),iu.x+=_rotatedPosition.x,iu.y+=_rotatedPosition.y,iu.applyMatrix4(_viewWorldMatrix)}const _v1$2=new Vector3,_v2$1=new Vector3;class LOD extends Object3D{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(eu){super.copy(eu,!1);const tu=eu.levels;for(let su=0,au=tu.length;su<au;su++){const uu=tu[su];this.addLevel(uu.object.clone(),uu.distance,uu.hysteresis)}return this.autoUpdate=eu.autoUpdate,this}addLevel(eu,tu=0,su=0){tu=Math.abs(tu);const au=this.levels;let uu;for(uu=0;uu<au.length&&!(tu<au[uu].distance);uu++);return au.splice(uu,0,{distance:tu,hysteresis:su,object:eu}),this.add(eu),this}removeLevel(eu){const tu=this.levels;for(let su=0;su<tu.length;su++)if(tu[su].distance===eu){const au=tu.splice(su,1);return this.remove(au[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(eu){const tu=this.levels;if(tu.length>0){let su,au;for(su=1,au=tu.length;su<au;su++){let uu=tu[su].distance;if(tu[su].object.visible&&(uu-=uu*tu[su].hysteresis),eu<uu)break}return tu[su-1].object}return null}raycast(eu,tu){if(this.levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const au=eu.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(au).raycast(eu,tu)}}update(eu){const tu=this.levels;if(tu.length>1){_v1$2.setFromMatrixPosition(eu.matrixWorld),_v2$1.setFromMatrixPosition(this.matrixWorld);const su=_v1$2.distanceTo(_v2$1)/eu.zoom;tu[0].object.visible=!0;let au,uu;for(au=1,uu=tu.length;au<uu;au++){let du=tu[au].distance;if(tu[au].object.visible&&(du-=du*tu[au].hysteresis),su>=du)tu[au-1].object.visible=!1,tu[au].object.visible=!0;else break}for(this._currentLevel=au-1;au<uu;au++)tu[au].object.visible=!1}}toJSON(eu){const tu=super.toJSON(eu);this.autoUpdate===!1&&(tu.object.autoUpdate=!1),tu.object.levels=[];const su=this.levels;for(let au=0,uu=su.length;au<uu;au++){const du=su[au];tu.object.levels.push({object:du.object.uuid,distance:du.distance,hysteresis:du.hysteresis})}return tu}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$5=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(eu,tu){super(eu,tu),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const eu=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const tu=eu.getAttribute("position");for(let su=0;su<tu.count;su++)this.getVertexPosition(su,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const eu=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const tu=eu.getAttribute("position");for(let su=0;su<tu.count;su++)this.getVertexPosition(su,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(eu,tu){return super.copy(eu,tu),this.bindMode=eu.bindMode,this.bindMatrix.copy(eu.bindMatrix),this.bindMatrixInverse.copy(eu.bindMatrixInverse),this.skeleton=eu.skeleton,eu.boundingBox!==null&&(this.boundingBox=eu.boundingBox.clone()),eu.boundingSphere!==null&&(this.boundingSphere=eu.boundingSphere.clone()),this}raycast(eu,tu){const su=this.material,au=this.matrixWorld;su!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$5.copy(this.boundingSphere),_sphere$5.applyMatrix4(au),eu.ray.intersectsSphere(_sphere$5)!==!1&&(_inverseMatrix$2.copy(au).invert(),_ray$2.copy(eu.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(eu,tu,_ray$2)))}getVertexPosition(eu,tu){return super.getVertexPosition(eu,tu),this.applyBoneTransform(eu,tu),tu}bind(eu,tu){this.skeleton=eu,tu===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),tu=this.matrixWorld),this.bindMatrix.copy(tu),this.bindMatrixInverse.copy(tu).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const eu=new Vector4,tu=this.geometry.attributes.skinWeight;for(let su=0,au=tu.count;su<au;su++){eu.fromBufferAttribute(tu,su);const uu=1/eu.manhattanLength();uu!==1/0?eu.multiplyScalar(uu):eu.set(1,0,0,0),tu.setXYZW(su,eu.x,eu.y,eu.z,eu.w)}}updateMatrixWorld(eu){super.updateMatrixWorld(eu),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(eu,tu){const su=this.skeleton,au=this.geometry;_skinIndex.fromBufferAttribute(au.attributes.skinIndex,eu),_skinWeight.fromBufferAttribute(au.attributes.skinWeight,eu),_basePosition.copy(tu).applyMatrix4(this.bindMatrix),tu.set(0,0,0);for(let uu=0;uu<4;uu++){const du=_skinWeight.getComponent(uu);if(du!==0){const fu=_skinIndex.getComponent(uu);_matrix4.multiplyMatrices(su.bones[fu].matrixWorld,su.boneInverses[fu]),tu.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),du)}}return tu.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(eu=null,tu=1,su=1,au,uu,du,fu,gu,yu=NearestFilter,xu=NearestFilter,vu,Su){super(null,du,fu,gu,yu,xu,au,uu,vu,Su),this.isDataTexture=!0,this.image={data:eu,width:tu,height:su},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix=new Matrix4;class Skeleton{constructor(eu=[],tu=[]){this.uuid=generateUUID(),this.bones=eu.slice(0),this.boneInverses=tu,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const eu=this.bones,tu=this.boneInverses;if(this.boneMatrices=new Float32Array(eu.length*16),tu.length===0)this.calculateInverses();else if(eu.length!==tu.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let su=0,au=this.bones.length;su<au;su++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let eu=0,tu=this.bones.length;eu<tu;eu++){const su=new Matrix4;this.bones[eu]&&su.copy(this.bones[eu].matrixWorld).invert(),this.boneInverses.push(su)}}pose(){for(let eu=0,tu=this.bones.length;eu<tu;eu++){const su=this.bones[eu];su&&su.matrixWorld.copy(this.boneInverses[eu]).invert()}for(let eu=0,tu=this.bones.length;eu<tu;eu++){const su=this.bones[eu];su&&(su.parent&&su.parent.isBone?(su.matrix.copy(su.parent.matrixWorld).invert(),su.matrix.multiply(su.matrixWorld)):su.matrix.copy(su.matrixWorld),su.matrix.decompose(su.position,su.quaternion,su.scale))}}update(){const eu=this.bones,tu=this.boneInverses,su=this.boneMatrices,au=this.boneTexture;for(let uu=0,du=eu.length;uu<du;uu++){const fu=eu[uu]?eu[uu].matrixWorld:_identityMatrix;_offsetMatrix.multiplyMatrices(fu,tu[uu]),_offsetMatrix.toArray(su,uu*16)}au!==null&&(au.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let eu=Math.sqrt(this.bones.length*4);eu=Math.ceil(eu/4)*4,eu=Math.max(eu,4);const tu=new Float32Array(eu*eu*4);tu.set(this.boneMatrices);const su=new DataTexture(tu,eu,eu,RGBAFormat,FloatType);return su.needsUpdate=!0,this.boneMatrices=tu,this.boneTexture=su,this}getBoneByName(eu){for(let tu=0,su=this.bones.length;tu<su;tu++){const au=this.bones[tu];if(au.name===eu)return au}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(eu,tu){this.uuid=eu.uuid;for(let su=0,au=eu.bones.length;su<au;su++){const uu=eu.bones[su];let du=tu[uu];du===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",uu),du=new Bone),this.bones.push(du),this.boneInverses.push(new Matrix4().fromArray(eu.boneInverses[su]))}return this.init(),this}toJSON(){const eu={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};eu.uuid=this.uuid;const tu=this.bones,su=this.boneInverses;for(let au=0,uu=tu.length;au<uu;au++){const du=tu[au];eu.bones.push(du.uuid);const fu=su[au];eu.boneInverses.push(fu.toArray())}return eu}}class InstancedBufferAttribute extends BufferAttribute{constructor(eu,tu,su,au=1){super(eu,tu,su),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=au}copy(eu){return super.copy(eu),this.meshPerAttribute=eu.meshPerAttribute,this}toJSON(){const eu=super.toJSON();return eu.meshPerAttribute=this.meshPerAttribute,eu.isInstancedBufferAttribute=!0,eu}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh$1=new Mesh,_sphere$4=new Sphere;class InstancedMesh extends Mesh{constructor(eu,tu,su){super(eu,tu),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(su*16),16),this.instanceColor=null,this.morphTexture=null,this.count=su,this.boundingBox=null,this.boundingSphere=null;for(let au=0;au<su;au++)this.setMatrixAt(au,_identity)}computeBoundingBox(){const eu=this.geometry,tu=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),eu.boundingBox===null&&eu.computeBoundingBox(),this.boundingBox.makeEmpty();for(let su=0;su<tu;su++)this.getMatrixAt(su,_instanceLocalMatrix),_box3.copy(eu.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const eu=this.geometry,tu=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),eu.boundingSphere===null&&eu.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let su=0;su<tu;su++)this.getMatrixAt(su,_instanceLocalMatrix),_sphere$4.copy(eu.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$4)}copy(eu,tu){return super.copy(eu,tu),this.instanceMatrix.copy(eu.instanceMatrix),eu.morphTexture!==null&&(this.morphTexture=eu.morphTexture.clone()),eu.instanceColor!==null&&(this.instanceColor=eu.instanceColor.clone()),this.count=eu.count,eu.boundingBox!==null&&(this.boundingBox=eu.boundingBox.clone()),eu.boundingSphere!==null&&(this.boundingSphere=eu.boundingSphere.clone()),this}getColorAt(eu,tu){tu.fromArray(this.instanceColor.array,eu*3)}getMatrixAt(eu,tu){tu.fromArray(this.instanceMatrix.array,eu*16)}getMorphAt(eu,tu){const su=tu.morphTargetInfluences,au=this.morphTexture.source.data.data,uu=su.length+1,du=eu*uu+1;for(let fu=0;fu<su.length;fu++)su[fu]=au[du+fu]}raycast(eu,tu){const su=this.matrixWorld,au=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,_mesh$1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(su),eu.ray.intersectsSphere(_sphere$4)!==!1))for(let uu=0;uu<au;uu++){this.getMatrixAt(uu,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(su,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(eu,_instanceIntersects);for(let du=0,fu=_instanceIntersects.length;du<fu;du++){const gu=_instanceIntersects[du];gu.instanceId=uu,gu.object=this,tu.push(gu)}_instanceIntersects.length=0}}setColorAt(eu,tu){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),tu.toArray(this.instanceColor.array,eu*3)}setMatrixAt(eu,tu){tu.toArray(this.instanceMatrix.array,eu*16)}setMorphAt(eu,tu){const su=tu.morphTargetInfluences,au=su.length+1;this.morphTexture===null&&(this.morphTexture=new DataTexture(new Float32Array(au*this.count),au,this.count,RedFormat,FloatType));const uu=this.morphTexture.source.data.data;let du=0;for(let yu=0;yu<su.length;yu++)du+=su[yu];const fu=this.geometry.morphTargetsRelative?1:1-du,gu=au*eu;uu[gu]=fu,uu.set(su,gu+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(eu=new Vector3(1,0,0),tu=0){this.isPlane=!0,this.normal=eu,this.constant=tu}set(eu,tu){return this.normal.copy(eu),this.constant=tu,this}setComponents(eu,tu,su,au){return this.normal.set(eu,tu,su),this.constant=au,this}setFromNormalAndCoplanarPoint(eu,tu){return this.normal.copy(eu),this.constant=-tu.dot(this.normal),this}setFromCoplanarPoints(eu,tu,su){const au=_vector1.subVectors(su,tu).cross(_vector2.subVectors(eu,tu)).normalize();return this.setFromNormalAndCoplanarPoint(au,eu),this}copy(eu){return this.normal.copy(eu.normal),this.constant=eu.constant,this}normalize(){const eu=1/this.normal.length();return this.normal.multiplyScalar(eu),this.constant*=eu,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(eu){return this.normal.dot(eu)+this.constant}distanceToSphere(eu){return this.distanceToPoint(eu.center)-eu.radius}projectPoint(eu,tu){return tu.copy(eu).addScaledVector(this.normal,-this.distanceToPoint(eu))}intersectLine(eu,tu){const su=eu.delta(_vector1),au=this.normal.dot(su);if(au===0)return this.distanceToPoint(eu.start)===0?tu.copy(eu.start):null;const uu=-(eu.start.dot(this.normal)+this.constant)/au;return uu<0||uu>1?null:tu.copy(eu.start).addScaledVector(su,uu)}intersectsLine(eu){const tu=this.distanceToPoint(eu.start),su=this.distanceToPoint(eu.end);return tu<0&&su>0||su<0&&tu>0}intersectsBox(eu){return eu.intersectsPlane(this)}intersectsSphere(eu){return eu.intersectsPlane(this)}coplanarPoint(eu){return eu.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(eu,tu){const su=tu||_normalMatrix.getNormalMatrix(eu),au=this.coplanarPoint(_vector1).applyMatrix4(eu),uu=this.normal.applyMatrix3(su).normalize();return this.constant=-au.dot(uu),this}translate(eu){return this.constant-=eu.dot(this.normal),this}equals(eu){return eu.normal.equals(this.normal)&&eu.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$3=new Sphere,_vector$6=new Vector3;class Frustum{constructor(eu=new Plane,tu=new Plane,su=new Plane,au=new Plane,uu=new Plane,du=new Plane){this.planes=[eu,tu,su,au,uu,du]}set(eu,tu,su,au,uu,du){const fu=this.planes;return fu[0].copy(eu),fu[1].copy(tu),fu[2].copy(su),fu[3].copy(au),fu[4].copy(uu),fu[5].copy(du),this}copy(eu){const tu=this.planes;for(let su=0;su<6;su++)tu[su].copy(eu.planes[su]);return this}setFromProjectionMatrix(eu,tu=WebGLCoordinateSystem){const su=this.planes,au=eu.elements,uu=au[0],du=au[1],fu=au[2],gu=au[3],yu=au[4],xu=au[5],vu=au[6],Su=au[7],Iu=au[8],Mu=au[9],ku=au[10],Bu=au[11],_u=au[12],Lu=au[13],Du=au[14],Ou=au[15];if(su[0].setComponents(gu-uu,Su-yu,Bu-Iu,Ou-_u).normalize(),su[1].setComponents(gu+uu,Su+yu,Bu+Iu,Ou+_u).normalize(),su[2].setComponents(gu+du,Su+xu,Bu+Mu,Ou+Lu).normalize(),su[3].setComponents(gu-du,Su-xu,Bu-Mu,Ou-Lu).normalize(),su[4].setComponents(gu-fu,Su-vu,Bu-ku,Ou-Du).normalize(),tu===WebGLCoordinateSystem)su[5].setComponents(gu+fu,Su+vu,Bu+ku,Ou+Du).normalize();else if(tu===WebGPUCoordinateSystem)su[5].setComponents(fu,vu,ku,Du).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+tu);return this}intersectsObject(eu){if(eu.boundingSphere!==void 0)eu.boundingSphere===null&&eu.computeBoundingSphere(),_sphere$3.copy(eu.boundingSphere).applyMatrix4(eu.matrixWorld);else{const tu=eu.geometry;tu.boundingSphere===null&&tu.computeBoundingSphere(),_sphere$3.copy(tu.boundingSphere).applyMatrix4(eu.matrixWorld)}return this.intersectsSphere(_sphere$3)}intersectsSprite(eu){return _sphere$3.center.set(0,0,0),_sphere$3.radius=.7071067811865476,_sphere$3.applyMatrix4(eu.matrixWorld),this.intersectsSphere(_sphere$3)}intersectsSphere(eu){const tu=this.planes,su=eu.center,au=-eu.radius;for(let uu=0;uu<6;uu++)if(tu[uu].distanceToPoint(su)<au)return!1;return!0}intersectsBox(eu){const tu=this.planes;for(let su=0;su<6;su++){const au=tu[su];if(_vector$6.x=au.normal.x>0?eu.max.x:eu.min.x,_vector$6.y=au.normal.y>0?eu.max.y:eu.min.y,_vector$6.z=au.normal.z>0?eu.max.z:eu.min.z,au.distanceToPoint(_vector$6)<0)return!1}return!0}containsPoint(eu){const tu=this.planes;for(let su=0;su<6;su++)if(tu[su].distanceToPoint(eu)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function ascIdSort(iu,eu){return iu-eu}function sortOpaque(iu,eu){return iu.z-eu.z}function sortTransparent(iu,eu){return eu.z-iu.z}class MultiDrawRenderList{constructor(){this.index=0,this.pool=[],this.list=[]}push(eu,tu,su,au){const uu=this.pool,du=this.list;this.index>=uu.length&&uu.push({start:-1,count:-1,z:-1,index:-1});const fu=uu[this.index];du.push(fu),this.index++,fu.start=eu,fu.count=tu,fu.z=su,fu.index=au}reset(){this.list.length=0,this.index=0}}const _matrix$1=new Matrix4,_whiteColor=new Color(1,1,1),_frustum=new Frustum,_box$1=new Box3,_sphere$2=new Sphere,_vector$5=new Vector3,_forward=new Vector3,_temp=new Vector3,_renderList=new MultiDrawRenderList,_mesh=new Mesh,_batchIntersects=[];function copyAttributeData(iu,eu,tu=0){const su=eu.itemSize;if(iu.isInterleavedBufferAttribute||iu.array.constructor!==eu.array.constructor){const au=iu.count;for(let uu=0;uu<au;uu++)for(let du=0;du<su;du++)eu.setComponent(uu+tu,du,iu.getComponent(uu,du))}else eu.array.set(iu.array,tu*su);eu.needsUpdate=!0}function copyArrayContents(iu,eu){if(iu.constructor!==eu.constructor){const tu=Math.min(iu.length,eu.length);for(let su=0;su<tu;su++)eu[su]=iu[su]}else{const tu=Math.min(iu.length,eu.length);eu.set(new iu.constructor(iu.buffer,0,tu))}}class BatchedMesh extends Mesh{get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}constructor(eu,tu,su=tu*2,au){super(new BufferGeometry,au),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=eu,this._maxVertexCount=tu,this._maxIndexCount=su,this._multiDrawCounts=new Int32Array(eu),this._multiDrawStarts=new Int32Array(eu),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}_initMatricesTexture(){let eu=Math.sqrt(this._maxInstanceCount*4);eu=Math.ceil(eu/4)*4,eu=Math.max(eu,4);const tu=new Float32Array(eu*eu*4),su=new DataTexture(tu,eu,eu,RGBAFormat,FloatType);this._matricesTexture=su}_initIndirectTexture(){let eu=Math.sqrt(this._maxInstanceCount);eu=Math.ceil(eu);const tu=new Uint32Array(eu*eu),su=new DataTexture(tu,eu,eu,RedIntegerFormat,UnsignedIntType);this._indirectTexture=su}_initColorsTexture(){let eu=Math.sqrt(this._maxInstanceCount);eu=Math.ceil(eu);const tu=new Float32Array(eu*eu*4).fill(1),su=new DataTexture(tu,eu,eu,RGBAFormat,FloatType);su.colorSpace=ColorManagement.workingColorSpace,this._colorsTexture=su}_initializeGeometry(eu){const tu=this.geometry,su=this._maxVertexCount,au=this._maxIndexCount;if(this._geometryInitialized===!1){for(const uu in eu.attributes){const du=eu.getAttribute(uu),{array:fu,itemSize:gu,normalized:yu}=du,xu=new fu.constructor(su*gu),vu=new BufferAttribute(xu,gu,yu);tu.setAttribute(uu,vu)}if(eu.getIndex()!==null){const uu=su>65535?new Uint32Array(au):new Uint16Array(au);tu.setIndex(new BufferAttribute(uu,1))}this._geometryInitialized=!0}}_validateGeometry(eu){const tu=this.geometry;if(!!eu.getIndex()!=!!tu.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const su in tu.attributes){if(!eu.hasAttribute(su))throw new Error(`THREE.BatchedMesh: Added geometry missing "${su}". All geometries must have consistent attributes.`);const au=eu.getAttribute(su),uu=tu.getAttribute(su);if(au.itemSize!==uu.itemSize||au.normalized!==uu.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(eu){const tu=this._instanceInfo;if(eu<0||eu>=tu.length||tu[eu].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${eu}. Instance is either out of range or has been deleted.`)}validateGeometryId(eu){const tu=this._geometryInfo;if(eu<0||eu>=tu.length||tu[eu].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${eu}. Geometry is either out of range or has been deleted.`)}setCustomSort(eu){return this.customSort=eu,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const eu=this.boundingBox,tu=this._instanceInfo;eu.makeEmpty();for(let su=0,au=tu.length;su<au;su++){if(tu[su].active===!1)continue;const uu=tu[su].geometryIndex;this.getMatrixAt(su,_matrix$1),this.getBoundingBoxAt(uu,_box$1).applyMatrix4(_matrix$1),eu.union(_box$1)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const eu=this.boundingSphere,tu=this._instanceInfo;eu.makeEmpty();for(let su=0,au=tu.length;su<au;su++){if(tu[su].active===!1)continue;const uu=tu[su].geometryIndex;this.getMatrixAt(su,_matrix$1),this.getBoundingSphereAt(uu,_sphere$2).applyMatrix4(_matrix$1),eu.union(_sphere$2)}}addInstance(eu){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const su={visible:!0,active:!0,geometryIndex:eu};let au=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(ascIdSort),au=this._availableInstanceIds.shift(),this._instanceInfo[au]=su):(au=this._instanceInfo.length,this._instanceInfo.push(su));const uu=this._matricesTexture;_matrix$1.identity().toArray(uu.image.data,au*16),uu.needsUpdate=!0;const du=this._colorsTexture;return du&&(_whiteColor.toArray(du.image.data,au*4),du.needsUpdate=!0),this._visibilityChanged=!0,au}addGeometry(eu,tu=-1,su=-1){this._initializeGeometry(eu),this._validateGeometry(eu);const au={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},uu=this._geometryInfo;au.vertexStart=this._nextVertexStart,au.reservedVertexCount=tu===-1?eu.getAttribute("position").count:tu;const du=eu.getIndex();if(du!==null&&(au.indexStart=this._nextIndexStart,au.reservedIndexCount=su===-1?du.count:su),au.indexStart!==-1&&au.indexStart+au.reservedIndexCount>this._maxIndexCount||au.vertexStart+au.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let gu;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(ascIdSort),gu=this._availableGeometryIds.shift(),uu[gu]=au):(gu=this._geometryCount,this._geometryCount++,uu.push(au)),this.setGeometryAt(gu,eu),this._nextIndexStart=au.indexStart+au.reservedIndexCount,this._nextVertexStart=au.vertexStart+au.reservedVertexCount,gu}setGeometryAt(eu,tu){if(eu>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(tu);const su=this.geometry,au=su.getIndex()!==null,uu=su.getIndex(),du=tu.getIndex(),fu=this._geometryInfo[eu];if(au&&du.count>fu.reservedIndexCount||tu.attributes.position.count>fu.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const gu=fu.vertexStart,yu=fu.reservedVertexCount;fu.vertexCount=tu.getAttribute("position").count;for(const xu in su.attributes){const vu=tu.getAttribute(xu),Su=su.getAttribute(xu);copyAttributeData(vu,Su,gu);const Iu=vu.itemSize;for(let Mu=vu.count,ku=yu;Mu<ku;Mu++){const Bu=gu+Mu;for(let _u=0;_u<Iu;_u++)Su.setComponent(Bu,_u,0)}Su.needsUpdate=!0,Su.addUpdateRange(gu*Iu,yu*Iu)}if(au){const xu=fu.indexStart,vu=fu.reservedIndexCount;fu.indexCount=tu.getIndex().count;for(let Su=0;Su<du.count;Su++)uu.setX(xu+Su,gu+du.getX(Su));for(let Su=du.count,Iu=vu;Su<Iu;Su++)uu.setX(xu+Su,gu);uu.needsUpdate=!0,uu.addUpdateRange(xu,fu.reservedIndexCount)}return fu.start=au?fu.indexStart:fu.vertexStart,fu.count=au?fu.indexCount:fu.vertexCount,fu.boundingBox=null,tu.boundingBox!==null&&(fu.boundingBox=tu.boundingBox.clone()),fu.boundingSphere=null,tu.boundingSphere!==null&&(fu.boundingSphere=tu.boundingSphere.clone()),this._visibilityChanged=!0,eu}deleteGeometry(eu){const tu=this._geometryInfo;if(eu>=tu.length||tu[eu].active===!1)return this;const su=this._instanceInfo;for(let au=0,uu=su.length;au<uu;au++)su[au].active&&su[au].geometryIndex===eu&&this.deleteInstance(au);return tu[eu].active=!1,this._availableGeometryIds.push(eu),this._visibilityChanged=!0,this}deleteInstance(eu){return this.validateInstanceId(eu),this._instanceInfo[eu].active=!1,this._availableInstanceIds.push(eu),this._visibilityChanged=!0,this}optimize(){let eu=0,tu=0;const su=this._geometryInfo,au=su.map((du,fu)=>fu).sort((du,fu)=>su[du].vertexStart-su[fu].vertexStart),uu=this.geometry;for(let du=0,fu=su.length;du<fu;du++){const gu=au[du],yu=su[gu];if(yu.active!==!1){if(uu.index!==null){if(yu.indexStart!==tu){const{indexStart:xu,vertexStart:vu,reservedIndexCount:Su}=yu,Iu=uu.index,Mu=Iu.array,ku=eu-vu;for(let Bu=xu;Bu<xu+Su;Bu++)Mu[Bu]=Mu[Bu]+ku;Iu.array.copyWithin(tu,xu,xu+Su),Iu.addUpdateRange(tu,Su),yu.indexStart=tu}tu+=yu.reservedIndexCount}if(yu.vertexStart!==eu){const{vertexStart:xu,reservedVertexCount:vu}=yu,Su=uu.attributes;for(const Iu in Su){const Mu=Su[Iu],{array:ku,itemSize:Bu}=Mu;ku.copyWithin(eu*Bu,xu*Bu,(xu+vu)*Bu),Mu.addUpdateRange(eu*Bu,vu*Bu)}yu.vertexStart=eu}eu+=yu.reservedVertexCount,yu.start=uu.index?yu.indexStart:yu.vertexStart,this._nextIndexStart=uu.index?yu.indexStart+yu.reservedIndexCount:0,this._nextVertexStart=yu.vertexStart+yu.reservedVertexCount}}return this}getBoundingBoxAt(eu,tu){if(eu>=this._geometryCount)return null;const su=this.geometry,au=this._geometryInfo[eu];if(au.boundingBox===null){const uu=new Box3,du=su.index,fu=su.attributes.position;for(let gu=au.start,yu=au.start+au.count;gu<yu;gu++){let xu=gu;du&&(xu=du.getX(xu)),uu.expandByPoint(_vector$5.fromBufferAttribute(fu,xu))}au.boundingBox=uu}return tu.copy(au.boundingBox),tu}getBoundingSphereAt(eu,tu){if(eu>=this._geometryCount)return null;const su=this.geometry,au=this._geometryInfo[eu];if(au.boundingSphere===null){const uu=new Sphere;this.getBoundingBoxAt(eu,_box$1),_box$1.getCenter(uu.center);const du=su.index,fu=su.attributes.position;let gu=0;for(let yu=au.start,xu=au.start+au.count;yu<xu;yu++){let vu=yu;du&&(vu=du.getX(vu)),_vector$5.fromBufferAttribute(fu,vu),gu=Math.max(gu,uu.center.distanceToSquared(_vector$5))}uu.radius=Math.sqrt(gu),au.boundingSphere=uu}return tu.copy(au.boundingSphere),tu}setMatrixAt(eu,tu){this.validateInstanceId(eu);const su=this._matricesTexture,au=this._matricesTexture.image.data;return tu.toArray(au,eu*16),su.needsUpdate=!0,this}getMatrixAt(eu,tu){return this.validateInstanceId(eu),tu.fromArray(this._matricesTexture.image.data,eu*16)}setColorAt(eu,tu){return this.validateInstanceId(eu),this._colorsTexture===null&&this._initColorsTexture(),tu.toArray(this._colorsTexture.image.data,eu*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(eu,tu){return this.validateInstanceId(eu),tu.fromArray(this._colorsTexture.image.data,eu*4)}setVisibleAt(eu,tu){return this.validateInstanceId(eu),this._instanceInfo[eu].visible===tu?this:(this._instanceInfo[eu].visible=tu,this._visibilityChanged=!0,this)}getVisibleAt(eu){return this.validateInstanceId(eu),this._instanceInfo[eu].visible}setGeometryIdAt(eu,tu){return this.validateInstanceId(eu),this.validateGeometryId(tu),this._instanceInfo[eu].geometryIndex=tu,this}getGeometryIdAt(eu){return this.validateInstanceId(eu),this._instanceInfo[eu].geometryIndex}getGeometryRangeAt(eu,tu={}){this.validateGeometryId(eu);const su=this._geometryInfo[eu];return tu.vertexStart=su.vertexStart,tu.vertexCount=su.vertexCount,tu.reservedVertexCount=su.reservedVertexCount,tu.indexStart=su.indexStart,tu.indexCount=su.indexCount,tu.reservedIndexCount=su.reservedIndexCount,tu.start=su.start,tu.count=su.count,tu}setInstanceCount(eu){const tu=this._availableInstanceIds,su=this._instanceInfo;for(tu.sort(ascIdSort);tu[tu.length-1]===su.length;)su.pop(),tu.pop();if(eu<su.length)throw new Error(`BatchedMesh: Instance ids outside the range ${eu} are being used. Cannot shrink instance count.`);const au=new Int32Array(eu),uu=new Int32Array(eu);copyArrayContents(this._multiDrawCounts,au),copyArrayContents(this._multiDrawStarts,uu),this._multiDrawCounts=au,this._multiDrawStarts=uu,this._maxInstanceCount=eu;const du=this._indirectTexture,fu=this._matricesTexture,gu=this._colorsTexture;du.dispose(),this._initIndirectTexture(),copyArrayContents(du.image.data,this._indirectTexture.image.data),fu.dispose(),this._initMatricesTexture(),copyArrayContents(fu.image.data,this._matricesTexture.image.data),gu&&(gu.dispose(),this._initColorsTexture(),copyArrayContents(gu.image.data,this._colorsTexture.image.data))}setGeometrySize(eu,tu){const su=[...this._geometryInfo].filter(fu=>fu.active);if(Math.max(...su.map(fu=>fu.vertexStart+fu.reservedVertexCount))>eu)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${tu}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...su.map(gu=>gu.indexStart+gu.reservedIndexCount))>tu)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${tu}. Cannot shrink further.`);const uu=this.geometry;uu.dispose(),this._maxVertexCount=eu,this._maxIndexCount=tu,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new BufferGeometry,this._initializeGeometry(uu));const du=this.geometry;uu.index&&copyArrayContents(uu.index.array,du.index.array);for(const fu in uu.attributes)copyArrayContents(uu.attributes[fu].array,du.attributes[fu].array)}raycast(eu,tu){const su=this._instanceInfo,au=this._geometryInfo,uu=this.matrixWorld,du=this.geometry;_mesh.material=this.material,_mesh.geometry.index=du.index,_mesh.geometry.attributes=du.attributes,_mesh.geometry.boundingBox===null&&(_mesh.geometry.boundingBox=new Box3),_mesh.geometry.boundingSphere===null&&(_mesh.geometry.boundingSphere=new Sphere);for(let fu=0,gu=su.length;fu<gu;fu++){if(!su[fu].visible||!su[fu].active)continue;const yu=su[fu].geometryIndex,xu=au[yu];_mesh.geometry.setDrawRange(xu.start,xu.count),this.getMatrixAt(fu,_mesh.matrixWorld).premultiply(uu),this.getBoundingBoxAt(yu,_mesh.geometry.boundingBox),this.getBoundingSphereAt(yu,_mesh.geometry.boundingSphere),_mesh.raycast(eu,_batchIntersects);for(let vu=0,Su=_batchIntersects.length;vu<Su;vu++){const Iu=_batchIntersects[vu];Iu.object=this,Iu.batchId=fu,tu.push(Iu)}_batchIntersects.length=0}_mesh.material=null,_mesh.geometry.index=null,_mesh.geometry.attributes={},_mesh.geometry.setDrawRange(0,1/0)}copy(eu){return super.copy(eu),this.geometry=eu.geometry.clone(),this.perObjectFrustumCulled=eu.perObjectFrustumCulled,this.sortObjects=eu.sortObjects,this.boundingBox=eu.boundingBox!==null?eu.boundingBox.clone():null,this.boundingSphere=eu.boundingSphere!==null?eu.boundingSphere.clone():null,this._geometryInfo=eu._geometryInfo.map(tu=>({...tu,boundingBox:tu.boundingBox!==null?tu.boundingBox.clone():null,boundingSphere:tu.boundingSphere!==null?tu.boundingSphere.clone():null})),this._instanceInfo=eu._instanceInfo.map(tu=>({...tu})),this._maxInstanceCount=eu._maxInstanceCount,this._maxVertexCount=eu._maxVertexCount,this._maxIndexCount=eu._maxIndexCount,this._geometryInitialized=eu._geometryInitialized,this._geometryCount=eu._geometryCount,this._multiDrawCounts=eu._multiDrawCounts.slice(),this._multiDrawStarts=eu._multiDrawStarts.slice(),this._matricesTexture=eu._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=eu._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null),this}onBeforeRender(eu,tu,su,au,uu){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const du=au.getIndex(),fu=du===null?1:du.array.BYTES_PER_ELEMENT,gu=this._instanceInfo,yu=this._multiDrawStarts,xu=this._multiDrawCounts,vu=this._geometryInfo,Su=this.perObjectFrustumCulled,Iu=this._indirectTexture,Mu=Iu.image.data;Su&&(_matrix$1.multiplyMatrices(su.projectionMatrix,su.matrixWorldInverse).multiply(this.matrixWorld),_frustum.setFromProjectionMatrix(_matrix$1,eu.coordinateSystem));let ku=0;if(this.sortObjects){_matrix$1.copy(this.matrixWorld).invert(),_vector$5.setFromMatrixPosition(su.matrixWorld).applyMatrix4(_matrix$1),_forward.set(0,0,-1).transformDirection(su.matrixWorld).transformDirection(_matrix$1);for(let Lu=0,Du=gu.length;Lu<Du;Lu++)if(gu[Lu].visible&&gu[Lu].active){const Ou=gu[Lu].geometryIndex;this.getMatrixAt(Lu,_matrix$1),this.getBoundingSphereAt(Ou,_sphere$2).applyMatrix4(_matrix$1);let Wu=!1;if(Su&&(Wu=!_frustum.intersectsSphere(_sphere$2)),!Wu){const Zu=vu[Ou],Hu=_temp.subVectors(_sphere$2.center,_vector$5).dot(_forward);_renderList.push(Zu.start,Zu.count,Hu,Lu)}}const Bu=_renderList.list,_u=this.customSort;_u===null?Bu.sort(uu.transparent?sortTransparent:sortOpaque):_u.call(this,Bu,su);for(let Lu=0,Du=Bu.length;Lu<Du;Lu++){const Ou=Bu[Lu];yu[ku]=Ou.start*fu,xu[ku]=Ou.count,Mu[ku]=Ou.index,ku++}_renderList.reset()}else for(let Bu=0,_u=gu.length;Bu<_u;Bu++)if(gu[Bu].visible&&gu[Bu].active){const Lu=gu[Bu].geometryIndex;let Du=!1;if(Su&&(this.getMatrixAt(Bu,_matrix$1),this.getBoundingSphereAt(Lu,_sphere$2).applyMatrix4(_matrix$1),Du=!_frustum.intersectsSphere(_sphere$2)),!Du){const Ou=vu[Lu];yu[ku]=Ou.start*fu,xu[ku]=Ou.count,Mu[ku]=Bu,ku++}}Iu.needsUpdate=!0,this._multiDrawCount=ku,this._visibilityChanged=!1}onBeforeShadow(eu,tu,su,au,uu,du){this.onBeforeRender(eu,null,au,uu,du)}}class LineBasicMaterial extends Material{constructor(eu){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.map=eu.map,this.linewidth=eu.linewidth,this.linecap=eu.linecap,this.linejoin=eu.linejoin,this.fog=eu.fog,this}}const _vStart=new Vector3,_vEnd=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere,_intersectPointOnRay=new Vector3,_intersectPointOnSegment=new Vector3;class Line extends Object3D{constructor(eu=new BufferGeometry,tu=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=eu,this.material=tu,this.updateMorphTargets()}copy(eu,tu){return super.copy(eu,tu),this.material=Array.isArray(eu.material)?eu.material.slice():eu.material,this.geometry=eu.geometry,this}computeLineDistances(){const eu=this.geometry;if(eu.index===null){const tu=eu.attributes.position,su=[0];for(let au=1,uu=tu.count;au<uu;au++)_vStart.fromBufferAttribute(tu,au-1),_vEnd.fromBufferAttribute(tu,au),su[au]=su[au-1],su[au]+=_vStart.distanceTo(_vEnd);eu.setAttribute("lineDistance",new Float32BufferAttribute(su,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(eu,tu){const su=this.geometry,au=this.matrixWorld,uu=eu.params.Line.threshold,du=su.drawRange;if(su.boundingSphere===null&&su.computeBoundingSphere(),_sphere$1.copy(su.boundingSphere),_sphere$1.applyMatrix4(au),_sphere$1.radius+=uu,eu.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(au).invert(),_ray$1.copy(eu.ray).applyMatrix4(_inverseMatrix$1);const fu=uu/((this.scale.x+this.scale.y+this.scale.z)/3),gu=fu*fu,yu=this.isLineSegments?2:1,xu=su.index,Su=su.attributes.position;if(xu!==null){const Iu=Math.max(0,du.start),Mu=Math.min(xu.count,du.start+du.count);for(let ku=Iu,Bu=Mu-1;ku<Bu;ku+=yu){const _u=xu.getX(ku),Lu=xu.getX(ku+1),Du=checkIntersection(this,eu,_ray$1,gu,_u,Lu,ku);Du&&tu.push(Du)}if(this.isLineLoop){const ku=xu.getX(Mu-1),Bu=xu.getX(Iu),_u=checkIntersection(this,eu,_ray$1,gu,ku,Bu,Mu-1);_u&&tu.push(_u)}}else{const Iu=Math.max(0,du.start),Mu=Math.min(Su.count,du.start+du.count);for(let ku=Iu,Bu=Mu-1;ku<Bu;ku+=yu){const _u=checkIntersection(this,eu,_ray$1,gu,ku,ku+1,ku);_u&&tu.push(_u)}if(this.isLineLoop){const ku=checkIntersection(this,eu,_ray$1,gu,Mu-1,Iu,Mu-1);ku&&tu.push(ku)}}}updateMorphTargets(){const tu=this.geometry.morphAttributes,su=Object.keys(tu);if(su.length>0){const au=tu[su[0]];if(au!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let uu=0,du=au.length;uu<du;uu++){const fu=au[uu].name||String(uu);this.morphTargetInfluences.push(0),this.morphTargetDictionary[fu]=uu}}}}}function checkIntersection(iu,eu,tu,su,au,uu,du){const fu=iu.geometry.attributes.position;if(_vStart.fromBufferAttribute(fu,au),_vEnd.fromBufferAttribute(fu,uu),tu.distanceSqToSegment(_vStart,_vEnd,_intersectPointOnRay,_intersectPointOnSegment)>su)return;_intersectPointOnRay.applyMatrix4(iu.matrixWorld);const yu=eu.ray.origin.distanceTo(_intersectPointOnRay);if(!(yu<eu.near||yu>eu.far))return{distance:yu,point:_intersectPointOnSegment.clone().applyMatrix4(iu.matrixWorld),index:du,face:null,faceIndex:null,barycoord:null,object:iu}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(eu,tu){super(eu,tu),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const eu=this.geometry;if(eu.index===null){const tu=eu.attributes.position,su=[];for(let au=0,uu=tu.count;au<uu;au+=2)_start.fromBufferAttribute(tu,au),_end.fromBufferAttribute(tu,au+1),su[au]=au===0?0:su[au-1],su[au+1]=su[au]+_start.distanceTo(_end);eu.setAttribute("lineDistance",new Float32BufferAttribute(su,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(eu,tu){super(eu,tu),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(eu){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.map=eu.map,this.alphaMap=eu.alphaMap,this.size=eu.size,this.sizeAttenuation=eu.sizeAttenuation,this.fog=eu.fog,this}}const _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(eu=new BufferGeometry,tu=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=eu,this.material=tu,this.updateMorphTargets()}copy(eu,tu){return super.copy(eu,tu),this.material=Array.isArray(eu.material)?eu.material.slice():eu.material,this.geometry=eu.geometry,this}raycast(eu,tu){const su=this.geometry,au=this.matrixWorld,uu=eu.params.Points.threshold,du=su.drawRange;if(su.boundingSphere===null&&su.computeBoundingSphere(),_sphere.copy(su.boundingSphere),_sphere.applyMatrix4(au),_sphere.radius+=uu,eu.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(au).invert(),_ray.copy(eu.ray).applyMatrix4(_inverseMatrix);const fu=uu/((this.scale.x+this.scale.y+this.scale.z)/3),gu=fu*fu,yu=su.index,vu=su.attributes.position;if(yu!==null){const Su=Math.max(0,du.start),Iu=Math.min(yu.count,du.start+du.count);for(let Mu=Su,ku=Iu;Mu<ku;Mu++){const Bu=yu.getX(Mu);_position$2.fromBufferAttribute(vu,Bu),testPoint(_position$2,Bu,gu,au,eu,tu,this)}}else{const Su=Math.max(0,du.start),Iu=Math.min(vu.count,du.start+du.count);for(let Mu=Su,ku=Iu;Mu<ku;Mu++)_position$2.fromBufferAttribute(vu,Mu),testPoint(_position$2,Mu,gu,au,eu,tu,this)}}updateMorphTargets(){const tu=this.geometry.morphAttributes,su=Object.keys(tu);if(su.length>0){const au=tu[su[0]];if(au!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let uu=0,du=au.length;uu<du;uu++){const fu=au[uu].name||String(uu);this.morphTargetInfluences.push(0),this.morphTargetDictionary[fu]=uu}}}}}function testPoint(iu,eu,tu,su,au,uu,du){const fu=_ray.distanceSqToPoint(iu);if(fu<tu){const gu=new Vector3;_ray.closestPointToPoint(iu,gu),gu.applyMatrix4(su);const yu=au.ray.origin.distanceTo(gu);if(yu<au.near||yu>au.far)return;uu.push({distance:yu,distanceToRay:Math.sqrt(fu),point:gu,index:eu,face:null,faceIndex:null,barycoord:null,object:du})}}class VideoTexture extends Texture{constructor(eu,tu,su,au,uu,du,fu,gu,yu){super(eu,tu,su,au,uu,du,fu,gu,yu),this.isVideoTexture=!0,this.minFilter=du!==void 0?du:LinearFilter,this.magFilter=uu!==void 0?uu:LinearFilter,this.generateMipmaps=!1;const xu=this;function vu(){xu.needsUpdate=!0,eu.requestVideoFrameCallback(vu)}"requestVideoFrameCallback"in eu&&eu.requestVideoFrameCallback(vu)}clone(){return new this.constructor(this.image).copy(this)}update(){const eu=this.image;"requestVideoFrameCallback"in eu===!1&&eu.readyState>=eu.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class VideoFrameTexture extends VideoTexture{constructor(eu,tu,su,au,uu,du,fu,gu){super({},eu,tu,su,au,uu,du,fu,gu),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(eu){this.image=eu,this.needsUpdate=!0}}class FramebufferTexture extends Texture{constructor(eu,tu){super({width:eu,height:tu}),this.isFramebufferTexture=!0,this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(eu,tu,su,au,uu,du,fu,gu,yu,xu,vu,Su){super(null,du,fu,gu,yu,xu,au,uu,vu,Su),this.isCompressedTexture=!0,this.image={width:tu,height:su},this.mipmaps=eu,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(eu,tu,su,au,uu,du){super(eu,tu,su,uu,du),this.isCompressedArrayTexture=!0,this.image.depth=au,this.wrapR=ClampToEdgeWrapping,this.layerUpdates=new Set}addLayerUpdate(eu){this.layerUpdates.add(eu)}clearLayerUpdates(){this.layerUpdates.clear()}}class CompressedCubeTexture extends CompressedTexture{constructor(eu,tu,su){super(void 0,eu[0].width,eu[0].height,tu,su,CubeReflectionMapping),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=eu}}class CanvasTexture extends Texture{constructor(eu,tu,su,au,uu,du,fu,gu,yu){super(eu,tu,su,au,uu,du,fu,gu,yu),this.isCanvasTexture=!0,this.needsUpdate=!0}}class DepthTexture extends Texture{constructor(eu,tu,su,au,uu,du,fu,gu,yu,xu=DepthFormat){if(xu!==DepthFormat&&xu!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");su===void 0&&xu===DepthFormat&&(su=UnsignedIntType),su===void 0&&xu===DepthStencilFormat&&(su=UnsignedInt248Type),super(null,au,uu,du,fu,gu,xu,su,yu),this.isDepthTexture=!0,this.image={width:eu,height:tu},this.magFilter=fu!==void 0?fu:NearestFilter,this.minFilter=gu!==void 0?gu:NearestFilter,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(eu){return super.copy(eu),this.compareFunction=eu.compareFunction,this}toJSON(eu){const tu=super.toJSON(eu);return this.compareFunction!==null&&(tu.compareFunction=this.compareFunction),tu}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(eu,tu){const su=this.getUtoTmapping(eu);return this.getPoint(su,tu)}getPoints(eu=5){const tu=[];for(let su=0;su<=eu;su++)tu.push(this.getPoint(su/eu));return tu}getSpacedPoints(eu=5){const tu=[];for(let su=0;su<=eu;su++)tu.push(this.getPointAt(su/eu));return tu}getLength(){const eu=this.getLengths();return eu[eu.length-1]}getLengths(eu=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===eu+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const tu=[];let su,au=this.getPoint(0),uu=0;tu.push(0);for(let du=1;du<=eu;du++)su=this.getPoint(du/eu),uu+=su.distanceTo(au),tu.push(uu),au=su;return this.cacheArcLengths=tu,tu}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(eu,tu){const su=this.getLengths();let au=0;const uu=su.length;let du;tu?du=tu:du=eu*su[uu-1];let fu=0,gu=uu-1,yu;for(;fu<=gu;)if(au=Math.floor(fu+(gu-fu)/2),yu=su[au]-du,yu<0)fu=au+1;else if(yu>0)gu=au-1;else{gu=au;break}if(au=gu,su[au]===du)return au/(uu-1);const xu=su[au],Su=su[au+1]-xu,Iu=(du-xu)/Su;return(au+Iu)/(uu-1)}getTangent(eu,tu){let au=eu-1e-4,uu=eu+1e-4;au<0&&(au=0),uu>1&&(uu=1);const du=this.getPoint(au),fu=this.getPoint(uu),gu=tu||(du.isVector2?new Vector2:new Vector3);return gu.copy(fu).sub(du).normalize(),gu}getTangentAt(eu,tu){const su=this.getUtoTmapping(eu);return this.getTangent(su,tu)}computeFrenetFrames(eu,tu){const su=new Vector3,au=[],uu=[],du=[],fu=new Vector3,gu=new Matrix4;for(let Iu=0;Iu<=eu;Iu++){const Mu=Iu/eu;au[Iu]=this.getTangentAt(Mu,new Vector3)}uu[0]=new Vector3,du[0]=new Vector3;let yu=Number.MAX_VALUE;const xu=Math.abs(au[0].x),vu=Math.abs(au[0].y),Su=Math.abs(au[0].z);xu<=yu&&(yu=xu,su.set(1,0,0)),vu<=yu&&(yu=vu,su.set(0,1,0)),Su<=yu&&su.set(0,0,1),fu.crossVectors(au[0],su).normalize(),uu[0].crossVectors(au[0],fu),du[0].crossVectors(au[0],uu[0]);for(let Iu=1;Iu<=eu;Iu++){if(uu[Iu]=uu[Iu-1].clone(),du[Iu]=du[Iu-1].clone(),fu.crossVectors(au[Iu-1],au[Iu]),fu.length()>Number.EPSILON){fu.normalize();const Mu=Math.acos(clamp(au[Iu-1].dot(au[Iu]),-1,1));uu[Iu].applyMatrix4(gu.makeRotationAxis(fu,Mu))}du[Iu].crossVectors(au[Iu],uu[Iu])}if(tu===!0){let Iu=Math.acos(clamp(uu[0].dot(uu[eu]),-1,1));Iu/=eu,au[0].dot(fu.crossVectors(uu[0],uu[eu]))>0&&(Iu=-Iu);for(let Mu=1;Mu<=eu;Mu++)uu[Mu].applyMatrix4(gu.makeRotationAxis(au[Mu],Iu*Mu)),du[Mu].crossVectors(au[Mu],uu[Mu])}return{tangents:au,normals:uu,binormals:du}}clone(){return new this.constructor().copy(this)}copy(eu){return this.arcLengthDivisions=eu.arcLengthDivisions,this}toJSON(){const eu={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return eu.arcLengthDivisions=this.arcLengthDivisions,eu.type=this.type,eu}fromJSON(eu){return this.arcLengthDivisions=eu.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(eu=0,tu=0,su=1,au=1,uu=0,du=Math.PI*2,fu=!1,gu=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=eu,this.aY=tu,this.xRadius=su,this.yRadius=au,this.aStartAngle=uu,this.aEndAngle=du,this.aClockwise=fu,this.aRotation=gu}getPoint(eu,tu=new Vector2){const su=tu,au=Math.PI*2;let uu=this.aEndAngle-this.aStartAngle;const du=Math.abs(uu)<Number.EPSILON;for(;uu<0;)uu+=au;for(;uu>au;)uu-=au;uu<Number.EPSILON&&(du?uu=0:uu=au),this.aClockwise===!0&&!du&&(uu===au?uu=-au:uu=uu-au);const fu=this.aStartAngle+eu*uu;let gu=this.aX+this.xRadius*Math.cos(fu),yu=this.aY+this.yRadius*Math.sin(fu);if(this.aRotation!==0){const xu=Math.cos(this.aRotation),vu=Math.sin(this.aRotation),Su=gu-this.aX,Iu=yu-this.aY;gu=Su*xu-Iu*vu+this.aX,yu=Su*vu+Iu*xu+this.aY}return su.set(gu,yu)}copy(eu){return super.copy(eu),this.aX=eu.aX,this.aY=eu.aY,this.xRadius=eu.xRadius,this.yRadius=eu.yRadius,this.aStartAngle=eu.aStartAngle,this.aEndAngle=eu.aEndAngle,this.aClockwise=eu.aClockwise,this.aRotation=eu.aRotation,this}toJSON(){const eu=super.toJSON();return eu.aX=this.aX,eu.aY=this.aY,eu.xRadius=this.xRadius,eu.yRadius=this.yRadius,eu.aStartAngle=this.aStartAngle,eu.aEndAngle=this.aEndAngle,eu.aClockwise=this.aClockwise,eu.aRotation=this.aRotation,eu}fromJSON(eu){return super.fromJSON(eu),this.aX=eu.aX,this.aY=eu.aY,this.xRadius=eu.xRadius,this.yRadius=eu.yRadius,this.aStartAngle=eu.aStartAngle,this.aEndAngle=eu.aEndAngle,this.aClockwise=eu.aClockwise,this.aRotation=eu.aRotation,this}}class ArcCurve extends EllipseCurve{constructor(eu,tu,su,au,uu,du){super(eu,tu,su,su,au,uu,du),this.isArcCurve=!0,this.type="ArcCurve"}}function CubicPoly(){let iu=0,eu=0,tu=0,su=0;function au(uu,du,fu,gu){iu=uu,eu=fu,tu=-3*uu+3*du-2*fu-gu,su=2*uu-2*du+fu+gu}return{initCatmullRom:function(uu,du,fu,gu,yu){au(du,fu,yu*(fu-uu),yu*(gu-du))},initNonuniformCatmullRom:function(uu,du,fu,gu,yu,xu,vu){let Su=(du-uu)/yu-(fu-uu)/(yu+xu)+(fu-du)/xu,Iu=(fu-du)/xu-(gu-du)/(xu+vu)+(gu-fu)/vu;Su*=xu,Iu*=xu,au(du,fu,Su,Iu)},calc:function(uu){const du=uu*uu,fu=du*uu;return iu+eu*uu+tu*du+su*fu}}}const tmp=new Vector3,px=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(eu=[],tu=!1,su="centripetal",au=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=eu,this.closed=tu,this.curveType=su,this.tension=au}getPoint(eu,tu=new Vector3){const su=tu,au=this.points,uu=au.length,du=(uu-(this.closed?0:1))*eu;let fu=Math.floor(du),gu=du-fu;this.closed?fu+=fu>0?0:(Math.floor(Math.abs(fu)/uu)+1)*uu:gu===0&&fu===uu-1&&(fu=uu-2,gu=1);let yu,xu;this.closed||fu>0?yu=au[(fu-1)%uu]:(tmp.subVectors(au[0],au[1]).add(au[0]),yu=tmp);const vu=au[fu%uu],Su=au[(fu+1)%uu];if(this.closed||fu+2<uu?xu=au[(fu+2)%uu]:(tmp.subVectors(au[uu-1],au[uu-2]).add(au[uu-1]),xu=tmp),this.curveType==="centripetal"||this.curveType==="chordal"){const Iu=this.curveType==="chordal"?.5:.25;let Mu=Math.pow(yu.distanceToSquared(vu),Iu),ku=Math.pow(vu.distanceToSquared(Su),Iu),Bu=Math.pow(Su.distanceToSquared(xu),Iu);ku<1e-4&&(ku=1),Mu<1e-4&&(Mu=ku),Bu<1e-4&&(Bu=ku),px.initNonuniformCatmullRom(yu.x,vu.x,Su.x,xu.x,Mu,ku,Bu),py.initNonuniformCatmullRom(yu.y,vu.y,Su.y,xu.y,Mu,ku,Bu),pz.initNonuniformCatmullRom(yu.z,vu.z,Su.z,xu.z,Mu,ku,Bu)}else this.curveType==="catmullrom"&&(px.initCatmullRom(yu.x,vu.x,Su.x,xu.x,this.tension),py.initCatmullRom(yu.y,vu.y,Su.y,xu.y,this.tension),pz.initCatmullRom(yu.z,vu.z,Su.z,xu.z,this.tension));return su.set(px.calc(gu),py.calc(gu),pz.calc(gu)),su}copy(eu){super.copy(eu),this.points=[];for(let tu=0,su=eu.points.length;tu<su;tu++){const au=eu.points[tu];this.points.push(au.clone())}return this.closed=eu.closed,this.curveType=eu.curveType,this.tension=eu.tension,this}toJSON(){const eu=super.toJSON();eu.points=[];for(let tu=0,su=this.points.length;tu<su;tu++){const au=this.points[tu];eu.points.push(au.toArray())}return eu.closed=this.closed,eu.curveType=this.curveType,eu.tension=this.tension,eu}fromJSON(eu){super.fromJSON(eu),this.points=[];for(let tu=0,su=eu.points.length;tu<su;tu++){const au=eu.points[tu];this.points.push(new Vector3().fromArray(au))}return this.closed=eu.closed,this.curveType=eu.curveType,this.tension=eu.tension,this}}function CatmullRom(iu,eu,tu,su,au){const uu=(su-eu)*.5,du=(au-tu)*.5,fu=iu*iu,gu=iu*fu;return(2*tu-2*su+uu+du)*gu+(-3*tu+3*su-2*uu-du)*fu+uu*iu+tu}function QuadraticBezierP0(iu,eu){const tu=1-iu;return tu*tu*eu}function QuadraticBezierP1(iu,eu){return 2*(1-iu)*iu*eu}function QuadraticBezierP2(iu,eu){return iu*iu*eu}function QuadraticBezier(iu,eu,tu,su){return QuadraticBezierP0(iu,eu)+QuadraticBezierP1(iu,tu)+QuadraticBezierP2(iu,su)}function CubicBezierP0(iu,eu){const tu=1-iu;return tu*tu*tu*eu}function CubicBezierP1(iu,eu){const tu=1-iu;return 3*tu*tu*iu*eu}function CubicBezierP2(iu,eu){return 3*(1-iu)*iu*iu*eu}function CubicBezierP3(iu,eu){return iu*iu*iu*eu}function CubicBezier(iu,eu,tu,su,au){return CubicBezierP0(iu,eu)+CubicBezierP1(iu,tu)+CubicBezierP2(iu,su)+CubicBezierP3(iu,au)}class CubicBezierCurve extends Curve{constructor(eu=new Vector2,tu=new Vector2,su=new Vector2,au=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=eu,this.v1=tu,this.v2=su,this.v3=au}getPoint(eu,tu=new Vector2){const su=tu,au=this.v0,uu=this.v1,du=this.v2,fu=this.v3;return su.set(CubicBezier(eu,au.x,uu.x,du.x,fu.x),CubicBezier(eu,au.y,uu.y,du.y,fu.y)),su}copy(eu){return super.copy(eu),this.v0.copy(eu.v0),this.v1.copy(eu.v1),this.v2.copy(eu.v2),this.v3.copy(eu.v3),this}toJSON(){const eu=super.toJSON();return eu.v0=this.v0.toArray(),eu.v1=this.v1.toArray(),eu.v2=this.v2.toArray(),eu.v3=this.v3.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.v0.fromArray(eu.v0),this.v1.fromArray(eu.v1),this.v2.fromArray(eu.v2),this.v3.fromArray(eu.v3),this}}class CubicBezierCurve3 extends Curve{constructor(eu=new Vector3,tu=new Vector3,su=new Vector3,au=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=eu,this.v1=tu,this.v2=su,this.v3=au}getPoint(eu,tu=new Vector3){const su=tu,au=this.v0,uu=this.v1,du=this.v2,fu=this.v3;return su.set(CubicBezier(eu,au.x,uu.x,du.x,fu.x),CubicBezier(eu,au.y,uu.y,du.y,fu.y),CubicBezier(eu,au.z,uu.z,du.z,fu.z)),su}copy(eu){return super.copy(eu),this.v0.copy(eu.v0),this.v1.copy(eu.v1),this.v2.copy(eu.v2),this.v3.copy(eu.v3),this}toJSON(){const eu=super.toJSON();return eu.v0=this.v0.toArray(),eu.v1=this.v1.toArray(),eu.v2=this.v2.toArray(),eu.v3=this.v3.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.v0.fromArray(eu.v0),this.v1.fromArray(eu.v1),this.v2.fromArray(eu.v2),this.v3.fromArray(eu.v3),this}}class LineCurve extends Curve{constructor(eu=new Vector2,tu=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=eu,this.v2=tu}getPoint(eu,tu=new Vector2){const su=tu;return eu===1?su.copy(this.v2):(su.copy(this.v2).sub(this.v1),su.multiplyScalar(eu).add(this.v1)),su}getPointAt(eu,tu){return this.getPoint(eu,tu)}getTangent(eu,tu=new Vector2){return tu.subVectors(this.v2,this.v1).normalize()}getTangentAt(eu,tu){return this.getTangent(eu,tu)}copy(eu){return super.copy(eu),this.v1.copy(eu.v1),this.v2.copy(eu.v2),this}toJSON(){const eu=super.toJSON();return eu.v1=this.v1.toArray(),eu.v2=this.v2.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.v1.fromArray(eu.v1),this.v2.fromArray(eu.v2),this}}class LineCurve3 extends Curve{constructor(eu=new Vector3,tu=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=eu,this.v2=tu}getPoint(eu,tu=new Vector3){const su=tu;return eu===1?su.copy(this.v2):(su.copy(this.v2).sub(this.v1),su.multiplyScalar(eu).add(this.v1)),su}getPointAt(eu,tu){return this.getPoint(eu,tu)}getTangent(eu,tu=new Vector3){return tu.subVectors(this.v2,this.v1).normalize()}getTangentAt(eu,tu){return this.getTangent(eu,tu)}copy(eu){return super.copy(eu),this.v1.copy(eu.v1),this.v2.copy(eu.v2),this}toJSON(){const eu=super.toJSON();return eu.v1=this.v1.toArray(),eu.v2=this.v2.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.v1.fromArray(eu.v1),this.v2.fromArray(eu.v2),this}}class QuadraticBezierCurve extends Curve{constructor(eu=new Vector2,tu=new Vector2,su=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=eu,this.v1=tu,this.v2=su}getPoint(eu,tu=new Vector2){const su=tu,au=this.v0,uu=this.v1,du=this.v2;return su.set(QuadraticBezier(eu,au.x,uu.x,du.x),QuadraticBezier(eu,au.y,uu.y,du.y)),su}copy(eu){return super.copy(eu),this.v0.copy(eu.v0),this.v1.copy(eu.v1),this.v2.copy(eu.v2),this}toJSON(){const eu=super.toJSON();return eu.v0=this.v0.toArray(),eu.v1=this.v1.toArray(),eu.v2=this.v2.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.v0.fromArray(eu.v0),this.v1.fromArray(eu.v1),this.v2.fromArray(eu.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(eu=new Vector3,tu=new Vector3,su=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=eu,this.v1=tu,this.v2=su}getPoint(eu,tu=new Vector3){const su=tu,au=this.v0,uu=this.v1,du=this.v2;return su.set(QuadraticBezier(eu,au.x,uu.x,du.x),QuadraticBezier(eu,au.y,uu.y,du.y),QuadraticBezier(eu,au.z,uu.z,du.z)),su}copy(eu){return super.copy(eu),this.v0.copy(eu.v0),this.v1.copy(eu.v1),this.v2.copy(eu.v2),this}toJSON(){const eu=super.toJSON();return eu.v0=this.v0.toArray(),eu.v1=this.v1.toArray(),eu.v2=this.v2.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.v0.fromArray(eu.v0),this.v1.fromArray(eu.v1),this.v2.fromArray(eu.v2),this}}class SplineCurve extends Curve{constructor(eu=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=eu}getPoint(eu,tu=new Vector2){const su=tu,au=this.points,uu=(au.length-1)*eu,du=Math.floor(uu),fu=uu-du,gu=au[du===0?du:du-1],yu=au[du],xu=au[du>au.length-2?au.length-1:du+1],vu=au[du>au.length-3?au.length-1:du+2];return su.set(CatmullRom(fu,gu.x,yu.x,xu.x,vu.x),CatmullRom(fu,gu.y,yu.y,xu.y,vu.y)),su}copy(eu){super.copy(eu),this.points=[];for(let tu=0,su=eu.points.length;tu<su;tu++){const au=eu.points[tu];this.points.push(au.clone())}return this}toJSON(){const eu=super.toJSON();eu.points=[];for(let tu=0,su=this.points.length;tu<su;tu++){const au=this.points[tu];eu.points.push(au.toArray())}return eu}fromJSON(eu){super.fromJSON(eu),this.points=[];for(let tu=0,su=eu.points.length;tu<su;tu++){const au=eu.points[tu];this.points.push(new Vector2().fromArray(au))}return this}}var Curves=Object.freeze({__proto__:null,ArcCurve,CatmullRomCurve3,CubicBezierCurve,CubicBezierCurve3,EllipseCurve,LineCurve,LineCurve3,QuadraticBezierCurve,QuadraticBezierCurve3,SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(eu){this.curves.push(eu)}closePath(){const eu=this.curves[0].getPoint(0),tu=this.curves[this.curves.length-1].getPoint(1);if(!eu.equals(tu)){const su=eu.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Curves[su](tu,eu))}return this}getPoint(eu,tu){const su=eu*this.getLength(),au=this.getCurveLengths();let uu=0;for(;uu<au.length;){if(au[uu]>=su){const du=au[uu]-su,fu=this.curves[uu],gu=fu.getLength(),yu=gu===0?0:1-du/gu;return fu.getPointAt(yu,tu)}uu++}return null}getLength(){const eu=this.getCurveLengths();return eu[eu.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const eu=[];let tu=0;for(let su=0,au=this.curves.length;su<au;su++)tu+=this.curves[su].getLength(),eu.push(tu);return this.cacheLengths=eu,eu}getSpacedPoints(eu=40){const tu=[];for(let su=0;su<=eu;su++)tu.push(this.getPoint(su/eu));return this.autoClose&&tu.push(tu[0]),tu}getPoints(eu=12){const tu=[];let su;for(let au=0,uu=this.curves;au<uu.length;au++){const du=uu[au],fu=du.isEllipseCurve?eu*2:du.isLineCurve||du.isLineCurve3?1:du.isSplineCurve?eu*du.points.length:eu,gu=du.getPoints(fu);for(let yu=0;yu<gu.length;yu++){const xu=gu[yu];su&&su.equals(xu)||(tu.push(xu),su=xu)}}return this.autoClose&&tu.length>1&&!tu[tu.length-1].equals(tu[0])&&tu.push(tu[0]),tu}copy(eu){super.copy(eu),this.curves=[];for(let tu=0,su=eu.curves.length;tu<su;tu++){const au=eu.curves[tu];this.curves.push(au.clone())}return this.autoClose=eu.autoClose,this}toJSON(){const eu=super.toJSON();eu.autoClose=this.autoClose,eu.curves=[];for(let tu=0,su=this.curves.length;tu<su;tu++){const au=this.curves[tu];eu.curves.push(au.toJSON())}return eu}fromJSON(eu){super.fromJSON(eu),this.autoClose=eu.autoClose,this.curves=[];for(let tu=0,su=eu.curves.length;tu<su;tu++){const au=eu.curves[tu];this.curves.push(new Curves[au.type]().fromJSON(au))}return this}}class Path extends CurvePath{constructor(eu){super(),this.type="Path",this.currentPoint=new Vector2,eu&&this.setFromPoints(eu)}setFromPoints(eu){this.moveTo(eu[0].x,eu[0].y);for(let tu=1,su=eu.length;tu<su;tu++)this.lineTo(eu[tu].x,eu[tu].y);return this}moveTo(eu,tu){return this.currentPoint.set(eu,tu),this}lineTo(eu,tu){const su=new LineCurve(this.currentPoint.clone(),new Vector2(eu,tu));return this.curves.push(su),this.currentPoint.set(eu,tu),this}quadraticCurveTo(eu,tu,su,au){const uu=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(eu,tu),new Vector2(su,au));return this.curves.push(uu),this.currentPoint.set(su,au),this}bezierCurveTo(eu,tu,su,au,uu,du){const fu=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(eu,tu),new Vector2(su,au),new Vector2(uu,du));return this.curves.push(fu),this.currentPoint.set(uu,du),this}splineThru(eu){const tu=[this.currentPoint.clone()].concat(eu),su=new SplineCurve(tu);return this.curves.push(su),this.currentPoint.copy(eu[eu.length-1]),this}arc(eu,tu,su,au,uu,du){const fu=this.currentPoint.x,gu=this.currentPoint.y;return this.absarc(eu+fu,tu+gu,su,au,uu,du),this}absarc(eu,tu,su,au,uu,du){return this.absellipse(eu,tu,su,su,au,uu,du),this}ellipse(eu,tu,su,au,uu,du,fu,gu){const yu=this.currentPoint.x,xu=this.currentPoint.y;return this.absellipse(eu+yu,tu+xu,su,au,uu,du,fu,gu),this}absellipse(eu,tu,su,au,uu,du,fu,gu){const yu=new EllipseCurve(eu,tu,su,au,uu,du,fu,gu);if(this.curves.length>0){const vu=yu.getPoint(0);vu.equals(this.currentPoint)||this.lineTo(vu.x,vu.y)}this.curves.push(yu);const xu=yu.getPoint(1);return this.currentPoint.copy(xu),this}copy(eu){return super.copy(eu),this.currentPoint.copy(eu.currentPoint),this}toJSON(){const eu=super.toJSON();return eu.currentPoint=this.currentPoint.toArray(),eu}fromJSON(eu){return super.fromJSON(eu),this.currentPoint.fromArray(eu.currentPoint),this}}class LatheGeometry extends BufferGeometry{constructor(eu=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],tu=12,su=0,au=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:eu,segments:tu,phiStart:su,phiLength:au},tu=Math.floor(tu),au=clamp(au,0,Math.PI*2);const uu=[],du=[],fu=[],gu=[],yu=[],xu=1/tu,vu=new Vector3,Su=new Vector2,Iu=new Vector3,Mu=new Vector3,ku=new Vector3;let Bu=0,_u=0;for(let Lu=0;Lu<=eu.length-1;Lu++)switch(Lu){case 0:Bu=eu[Lu+1].x-eu[Lu].x,_u=eu[Lu+1].y-eu[Lu].y,Iu.x=_u*1,Iu.y=-Bu,Iu.z=_u*0,ku.copy(Iu),Iu.normalize(),gu.push(Iu.x,Iu.y,Iu.z);break;case eu.length-1:gu.push(ku.x,ku.y,ku.z);break;default:Bu=eu[Lu+1].x-eu[Lu].x,_u=eu[Lu+1].y-eu[Lu].y,Iu.x=_u*1,Iu.y=-Bu,Iu.z=_u*0,Mu.copy(Iu),Iu.x+=ku.x,Iu.y+=ku.y,Iu.z+=ku.z,Iu.normalize(),gu.push(Iu.x,Iu.y,Iu.z),ku.copy(Mu)}for(let Lu=0;Lu<=tu;Lu++){const Du=su+Lu*xu*au,Ou=Math.sin(Du),Wu=Math.cos(Du);for(let Zu=0;Zu<=eu.length-1;Zu++){vu.x=eu[Zu].x*Ou,vu.y=eu[Zu].y,vu.z=eu[Zu].x*Wu,du.push(vu.x,vu.y,vu.z),Su.x=Lu/tu,Su.y=Zu/(eu.length-1),fu.push(Su.x,Su.y);const Hu=gu[3*Zu+0]*Ou,Yu=gu[3*Zu+1],Ku=gu[3*Zu+0]*Wu;yu.push(Hu,Yu,Ku)}}for(let Lu=0;Lu<tu;Lu++)for(let Du=0;Du<eu.length-1;Du++){const Ou=Du+Lu*eu.length,Wu=Ou,Zu=Ou+eu.length,Hu=Ou+eu.length+1,Yu=Ou+1;uu.push(Wu,Zu,Yu),uu.push(Hu,Yu,Zu)}this.setIndex(uu),this.setAttribute("position",new Float32BufferAttribute(du,3)),this.setAttribute("uv",new Float32BufferAttribute(fu,2)),this.setAttribute("normal",new Float32BufferAttribute(yu,3))}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new LatheGeometry(eu.points,eu.segments,eu.phiStart,eu.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(eu=1,tu=1,su=4,au=8){const uu=new Path;uu.absarc(0,-tu/2,eu,Math.PI*1.5,0),uu.absarc(0,tu/2,eu,0,Math.PI*.5),super(uu.getPoints(su),au),this.type="CapsuleGeometry",this.parameters={radius:eu,length:tu,capSegments:su,radialSegments:au}}static fromJSON(eu){return new CapsuleGeometry(eu.radius,eu.length,eu.capSegments,eu.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(eu=1,tu=32,su=0,au=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:eu,segments:tu,thetaStart:su,thetaLength:au},tu=Math.max(3,tu);const uu=[],du=[],fu=[],gu=[],yu=new Vector3,xu=new Vector2;du.push(0,0,0),fu.push(0,0,1),gu.push(.5,.5);for(let vu=0,Su=3;vu<=tu;vu++,Su+=3){const Iu=su+vu/tu*au;yu.x=eu*Math.cos(Iu),yu.y=eu*Math.sin(Iu),du.push(yu.x,yu.y,yu.z),fu.push(0,0,1),xu.x=(du[Su]/eu+1)/2,xu.y=(du[Su+1]/eu+1)/2,gu.push(xu.x,xu.y)}for(let vu=1;vu<=tu;vu++)uu.push(vu,vu+1,0);this.setIndex(uu),this.setAttribute("position",new Float32BufferAttribute(du,3)),this.setAttribute("normal",new Float32BufferAttribute(fu,3)),this.setAttribute("uv",new Float32BufferAttribute(gu,2))}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new CircleGeometry(eu.radius,eu.segments,eu.thetaStart,eu.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(eu=1,tu=1,su=1,au=32,uu=1,du=!1,fu=0,gu=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:eu,radiusBottom:tu,height:su,radialSegments:au,heightSegments:uu,openEnded:du,thetaStart:fu,thetaLength:gu};const yu=this;au=Math.floor(au),uu=Math.floor(uu);const xu=[],vu=[],Su=[],Iu=[];let Mu=0;const ku=[],Bu=su/2;let _u=0;Lu(),du===!1&&(eu>0&&Du(!0),tu>0&&Du(!1)),this.setIndex(xu),this.setAttribute("position",new Float32BufferAttribute(vu,3)),this.setAttribute("normal",new Float32BufferAttribute(Su,3)),this.setAttribute("uv",new Float32BufferAttribute(Iu,2));function Lu(){const Ou=new Vector3,Wu=new Vector3;let Zu=0;const Hu=(tu-eu)/su;for(let Yu=0;Yu<=uu;Yu++){const Ku=[],ju=Yu/uu,tp=ju*(tu-eu)+eu;for(let gp=0;gp<=au;gp++){const yp=gp/au,Cp=yp*gu+fu,Hp=Math.sin(Cp),wp=Math.cos(Cp);Wu.x=tp*Hp,Wu.y=-ju*su+Bu,Wu.z=tp*wp,vu.push(Wu.x,Wu.y,Wu.z),Ou.set(Hp,Hu,wp).normalize(),Su.push(Ou.x,Ou.y,Ou.z),Iu.push(yp,1-ju),Ku.push(Mu++)}ku.push(Ku)}for(let Yu=0;Yu<au;Yu++)for(let Ku=0;Ku<uu;Ku++){const ju=ku[Ku][Yu],tp=ku[Ku+1][Yu],gp=ku[Ku+1][Yu+1],yp=ku[Ku][Yu+1];(eu>0||Ku!==0)&&(xu.push(ju,tp,yp),Zu+=3),(tu>0||Ku!==uu-1)&&(xu.push(tp,gp,yp),Zu+=3)}yu.addGroup(_u,Zu,0),_u+=Zu}function Du(Ou){const Wu=Mu,Zu=new Vector2,Hu=new Vector3;let Yu=0;const Ku=Ou===!0?eu:tu,ju=Ou===!0?1:-1;for(let gp=1;gp<=au;gp++)vu.push(0,Bu*ju,0),Su.push(0,ju,0),Iu.push(.5,.5),Mu++;const tp=Mu;for(let gp=0;gp<=au;gp++){const Cp=gp/au*gu+fu,Hp=Math.cos(Cp),wp=Math.sin(Cp);Hu.x=Ku*wp,Hu.y=Bu*ju,Hu.z=Ku*Hp,vu.push(Hu.x,Hu.y,Hu.z),Su.push(0,ju,0),Zu.x=Hp*.5+.5,Zu.y=wp*.5*ju+.5,Iu.push(Zu.x,Zu.y),Mu++}for(let gp=0;gp<au;gp++){const yp=Wu+gp,Cp=tp+gp;Ou===!0?xu.push(Cp,Cp+1,yp):xu.push(Cp+1,Cp,yp),Yu+=3}yu.addGroup(_u,Yu,Ou===!0?1:2),_u+=Yu}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new CylinderGeometry(eu.radiusTop,eu.radiusBottom,eu.height,eu.radialSegments,eu.heightSegments,eu.openEnded,eu.thetaStart,eu.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(eu=1,tu=1,su=32,au=1,uu=!1,du=0,fu=Math.PI*2){super(0,eu,tu,su,au,uu,du,fu),this.type="ConeGeometry",this.parameters={radius:eu,height:tu,radialSegments:su,heightSegments:au,openEnded:uu,thetaStart:du,thetaLength:fu}}static fromJSON(eu){return new ConeGeometry(eu.radius,eu.height,eu.radialSegments,eu.heightSegments,eu.openEnded,eu.thetaStart,eu.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(eu=[],tu=[],su=1,au=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:eu,indices:tu,radius:su,detail:au};const uu=[],du=[];fu(au),yu(su),xu(),this.setAttribute("position",new Float32BufferAttribute(uu,3)),this.setAttribute("normal",new Float32BufferAttribute(uu.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(du,2)),au===0?this.computeVertexNormals():this.normalizeNormals();function fu(Lu){const Du=new Vector3,Ou=new Vector3,Wu=new Vector3;for(let Zu=0;Zu<tu.length;Zu+=3)Iu(tu[Zu+0],Du),Iu(tu[Zu+1],Ou),Iu(tu[Zu+2],Wu),gu(Du,Ou,Wu,Lu)}function gu(Lu,Du,Ou,Wu){const Zu=Wu+1,Hu=[];for(let Yu=0;Yu<=Zu;Yu++){Hu[Yu]=[];const Ku=Lu.clone().lerp(Ou,Yu/Zu),ju=Du.clone().lerp(Ou,Yu/Zu),tp=Zu-Yu;for(let gp=0;gp<=tp;gp++)gp===0&&Yu===Zu?Hu[Yu][gp]=Ku:Hu[Yu][gp]=Ku.clone().lerp(ju,gp/tp)}for(let Yu=0;Yu<Zu;Yu++)for(let Ku=0;Ku<2*(Zu-Yu)-1;Ku++){const ju=Math.floor(Ku/2);Ku%2===0?(Su(Hu[Yu][ju+1]),Su(Hu[Yu+1][ju]),Su(Hu[Yu][ju])):(Su(Hu[Yu][ju+1]),Su(Hu[Yu+1][ju+1]),Su(Hu[Yu+1][ju]))}}function yu(Lu){const Du=new Vector3;for(let Ou=0;Ou<uu.length;Ou+=3)Du.x=uu[Ou+0],Du.y=uu[Ou+1],Du.z=uu[Ou+2],Du.normalize().multiplyScalar(Lu),uu[Ou+0]=Du.x,uu[Ou+1]=Du.y,uu[Ou+2]=Du.z}function xu(){const Lu=new Vector3;for(let Du=0;Du<uu.length;Du+=3){Lu.x=uu[Du+0],Lu.y=uu[Du+1],Lu.z=uu[Du+2];const Ou=Bu(Lu)/2/Math.PI+.5,Wu=_u(Lu)/Math.PI+.5;du.push(Ou,1-Wu)}Mu(),vu()}function vu(){for(let Lu=0;Lu<du.length;Lu+=6){const Du=du[Lu+0],Ou=du[Lu+2],Wu=du[Lu+4],Zu=Math.max(Du,Ou,Wu),Hu=Math.min(Du,Ou,Wu);Zu>.9&&Hu<.1&&(Du<.2&&(du[Lu+0]+=1),Ou<.2&&(du[Lu+2]+=1),Wu<.2&&(du[Lu+4]+=1))}}function Su(Lu){uu.push(Lu.x,Lu.y,Lu.z)}function Iu(Lu,Du){const Ou=Lu*3;Du.x=eu[Ou+0],Du.y=eu[Ou+1],Du.z=eu[Ou+2]}function Mu(){const Lu=new Vector3,Du=new Vector3,Ou=new Vector3,Wu=new Vector3,Zu=new Vector2,Hu=new Vector2,Yu=new Vector2;for(let Ku=0,ju=0;Ku<uu.length;Ku+=9,ju+=6){Lu.set(uu[Ku+0],uu[Ku+1],uu[Ku+2]),Du.set(uu[Ku+3],uu[Ku+4],uu[Ku+5]),Ou.set(uu[Ku+6],uu[Ku+7],uu[Ku+8]),Zu.set(du[ju+0],du[ju+1]),Hu.set(du[ju+2],du[ju+3]),Yu.set(du[ju+4],du[ju+5]),Wu.copy(Lu).add(Du).add(Ou).divideScalar(3);const tp=Bu(Wu);ku(Zu,ju+0,Lu,tp),ku(Hu,ju+2,Du,tp),ku(Yu,ju+4,Ou,tp)}}function ku(Lu,Du,Ou,Wu){Wu<0&&Lu.x===1&&(du[Du]=Lu.x-1),Ou.x===0&&Ou.z===0&&(du[Du]=Wu/2/Math.PI+.5)}function Bu(Lu){return Math.atan2(Lu.z,-Lu.x)}function _u(Lu){return Math.atan2(-Lu.y,Math.sqrt(Lu.x*Lu.x+Lu.z*Lu.z))}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new PolyhedronGeometry(eu.vertices,eu.indices,eu.radius,eu.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(eu=1,tu=0){const su=(1+Math.sqrt(5))/2,au=1/su,uu=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-au,-su,0,-au,su,0,au,-su,0,au,su,-au,-su,0,-au,su,0,au,-su,0,au,su,0,-su,0,-au,su,0,-au,-su,0,au,su,0,au],du=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(uu,du,eu,tu),this.type="DodecahedronGeometry",this.parameters={radius:eu,detail:tu}}static fromJSON(eu){return new DodecahedronGeometry(eu.radius,eu.detail)}}const _v0$3=new Vector3,_v1$1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(eu=null,tu=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:eu,thresholdAngle:tu},eu!==null){const au=Math.pow(10,4),uu=Math.cos(DEG2RAD*tu),du=eu.getIndex(),fu=eu.getAttribute("position"),gu=du?du.count:fu.count,yu=[0,0,0],xu=["a","b","c"],vu=new Array(3),Su={},Iu=[];for(let Mu=0;Mu<gu;Mu+=3){du?(yu[0]=du.getX(Mu),yu[1]=du.getX(Mu+1),yu[2]=du.getX(Mu+2)):(yu[0]=Mu,yu[1]=Mu+1,yu[2]=Mu+2);const{a:ku,b:Bu,c:_u}=_triangle;if(ku.fromBufferAttribute(fu,yu[0]),Bu.fromBufferAttribute(fu,yu[1]),_u.fromBufferAttribute(fu,yu[2]),_triangle.getNormal(_normal),vu[0]=`${Math.round(ku.x*au)},${Math.round(ku.y*au)},${Math.round(ku.z*au)}`,vu[1]=`${Math.round(Bu.x*au)},${Math.round(Bu.y*au)},${Math.round(Bu.z*au)}`,vu[2]=`${Math.round(_u.x*au)},${Math.round(_u.y*au)},${Math.round(_u.z*au)}`,!(vu[0]===vu[1]||vu[1]===vu[2]||vu[2]===vu[0]))for(let Lu=0;Lu<3;Lu++){const Du=(Lu+1)%3,Ou=vu[Lu],Wu=vu[Du],Zu=_triangle[xu[Lu]],Hu=_triangle[xu[Du]],Yu=`${Ou}_${Wu}`,Ku=`${Wu}_${Ou}`;Ku in Su&&Su[Ku]?(_normal.dot(Su[Ku].normal)<=uu&&(Iu.push(Zu.x,Zu.y,Zu.z),Iu.push(Hu.x,Hu.y,Hu.z)),Su[Ku]=null):Yu in Su||(Su[Yu]={index0:yu[Lu],index1:yu[Du],normal:_normal.clone()})}}for(const Mu in Su)if(Su[Mu]){const{index0:ku,index1:Bu}=Su[Mu];_v0$3.fromBufferAttribute(fu,ku),_v1$1.fromBufferAttribute(fu,Bu),Iu.push(_v0$3.x,_v0$3.y,_v0$3.z),Iu.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(Iu,3))}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}}class Shape extends Path{constructor(eu){super(eu),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(eu){const tu=[];for(let su=0,au=this.holes.length;su<au;su++)tu[su]=this.holes[su].getPoints(eu);return tu}extractPoints(eu){return{shape:this.getPoints(eu),holes:this.getPointsHoles(eu)}}copy(eu){super.copy(eu),this.holes=[];for(let tu=0,su=eu.holes.length;tu<su;tu++){const au=eu.holes[tu];this.holes.push(au.clone())}return this}toJSON(){const eu=super.toJSON();eu.uuid=this.uuid,eu.holes=[];for(let tu=0,su=this.holes.length;tu<su;tu++){const au=this.holes[tu];eu.holes.push(au.toJSON())}return eu}fromJSON(eu){super.fromJSON(eu),this.uuid=eu.uuid,this.holes=[];for(let tu=0,su=eu.holes.length;tu<su;tu++){const au=eu.holes[tu];this.holes.push(new Path().fromJSON(au))}return this}}const Earcut={triangulate:function(iu,eu,tu=2){const su=eu&&eu.length,au=su?eu[0]*tu:iu.length;let uu=linkedList(iu,0,au,tu,!0);const du=[];if(!uu||uu.next===uu.prev)return du;let fu,gu,yu,xu,vu,Su,Iu;if(su&&(uu=eliminateHoles(iu,eu,uu,tu)),iu.length>80*tu){fu=yu=iu[0],gu=xu=iu[1];for(let Mu=tu;Mu<au;Mu+=tu)vu=iu[Mu],Su=iu[Mu+1],vu<fu&&(fu=vu),Su<gu&&(gu=Su),vu>yu&&(yu=vu),Su>xu&&(xu=Su);Iu=Math.max(yu-fu,xu-gu),Iu=Iu!==0?32767/Iu:0}return earcutLinked(uu,du,tu,fu,gu,Iu,0),du}};function linkedList(iu,eu,tu,su,au){let uu,du;if(au===signedArea(iu,eu,tu,su)>0)for(uu=eu;uu<tu;uu+=su)du=insertNode(uu,iu[uu],iu[uu+1],du);else for(uu=tu-su;uu>=eu;uu-=su)du=insertNode(uu,iu[uu],iu[uu+1],du);return du&&equals(du,du.next)&&(removeNode(du),du=du.next),du}function filterPoints(iu,eu){if(!iu)return iu;eu||(eu=iu);let tu=iu,su;do if(su=!1,!tu.steiner&&(equals(tu,tu.next)||area(tu.prev,tu,tu.next)===0)){if(removeNode(tu),tu=eu=tu.prev,tu===tu.next)break;su=!0}else tu=tu.next;while(su||tu!==eu);return eu}function earcutLinked(iu,eu,tu,su,au,uu,du){if(!iu)return;!du&&uu&&indexCurve(iu,su,au,uu);let fu=iu,gu,yu;for(;iu.prev!==iu.next;){if(gu=iu.prev,yu=iu.next,uu?isEarHashed(iu,su,au,uu):isEar(iu)){eu.push(gu.i/tu|0),eu.push(iu.i/tu|0),eu.push(yu.i/tu|0),removeNode(iu),iu=yu.next,fu=yu.next;continue}if(iu=yu,iu===fu){du?du===1?(iu=cureLocalIntersections(filterPoints(iu),eu,tu),earcutLinked(iu,eu,tu,su,au,uu,2)):du===2&&splitEarcut(iu,eu,tu,su,au,uu):earcutLinked(filterPoints(iu),eu,tu,su,au,uu,1);break}}}function isEar(iu){const eu=iu.prev,tu=iu,su=iu.next;if(area(eu,tu,su)>=0)return!1;const au=eu.x,uu=tu.x,du=su.x,fu=eu.y,gu=tu.y,yu=su.y,xu=au<uu?au<du?au:du:uu<du?uu:du,vu=fu<gu?fu<yu?fu:yu:gu<yu?gu:yu,Su=au>uu?au>du?au:du:uu>du?uu:du,Iu=fu>gu?fu>yu?fu:yu:gu>yu?gu:yu;let Mu=su.next;for(;Mu!==eu;){if(Mu.x>=xu&&Mu.x<=Su&&Mu.y>=vu&&Mu.y<=Iu&&pointInTriangle(au,fu,uu,gu,du,yu,Mu.x,Mu.y)&&area(Mu.prev,Mu,Mu.next)>=0)return!1;Mu=Mu.next}return!0}function isEarHashed(iu,eu,tu,su){const au=iu.prev,uu=iu,du=iu.next;if(area(au,uu,du)>=0)return!1;const fu=au.x,gu=uu.x,yu=du.x,xu=au.y,vu=uu.y,Su=du.y,Iu=fu<gu?fu<yu?fu:yu:gu<yu?gu:yu,Mu=xu<vu?xu<Su?xu:Su:vu<Su?vu:Su,ku=fu>gu?fu>yu?fu:yu:gu>yu?gu:yu,Bu=xu>vu?xu>Su?xu:Su:vu>Su?vu:Su,_u=zOrder(Iu,Mu,eu,tu,su),Lu=zOrder(ku,Bu,eu,tu,su);let Du=iu.prevZ,Ou=iu.nextZ;for(;Du&&Du.z>=_u&&Ou&&Ou.z<=Lu;){if(Du.x>=Iu&&Du.x<=ku&&Du.y>=Mu&&Du.y<=Bu&&Du!==au&&Du!==du&&pointInTriangle(fu,xu,gu,vu,yu,Su,Du.x,Du.y)&&area(Du.prev,Du,Du.next)>=0||(Du=Du.prevZ,Ou.x>=Iu&&Ou.x<=ku&&Ou.y>=Mu&&Ou.y<=Bu&&Ou!==au&&Ou!==du&&pointInTriangle(fu,xu,gu,vu,yu,Su,Ou.x,Ou.y)&&area(Ou.prev,Ou,Ou.next)>=0))return!1;Ou=Ou.nextZ}for(;Du&&Du.z>=_u;){if(Du.x>=Iu&&Du.x<=ku&&Du.y>=Mu&&Du.y<=Bu&&Du!==au&&Du!==du&&pointInTriangle(fu,xu,gu,vu,yu,Su,Du.x,Du.y)&&area(Du.prev,Du,Du.next)>=0)return!1;Du=Du.prevZ}for(;Ou&&Ou.z<=Lu;){if(Ou.x>=Iu&&Ou.x<=ku&&Ou.y>=Mu&&Ou.y<=Bu&&Ou!==au&&Ou!==du&&pointInTriangle(fu,xu,gu,vu,yu,Su,Ou.x,Ou.y)&&area(Ou.prev,Ou,Ou.next)>=0)return!1;Ou=Ou.nextZ}return!0}function cureLocalIntersections(iu,eu,tu){let su=iu;do{const au=su.prev,uu=su.next.next;!equals(au,uu)&&intersects(au,su,su.next,uu)&&locallyInside(au,uu)&&locallyInside(uu,au)&&(eu.push(au.i/tu|0),eu.push(su.i/tu|0),eu.push(uu.i/tu|0),removeNode(su),removeNode(su.next),su=iu=uu),su=su.next}while(su!==iu);return filterPoints(su)}function splitEarcut(iu,eu,tu,su,au,uu){let du=iu;do{let fu=du.next.next;for(;fu!==du.prev;){if(du.i!==fu.i&&isValidDiagonal(du,fu)){let gu=splitPolygon(du,fu);du=filterPoints(du,du.next),gu=filterPoints(gu,gu.next),earcutLinked(du,eu,tu,su,au,uu,0),earcutLinked(gu,eu,tu,su,au,uu,0);return}fu=fu.next}du=du.next}while(du!==iu)}function eliminateHoles(iu,eu,tu,su){const au=[];let uu,du,fu,gu,yu;for(uu=0,du=eu.length;uu<du;uu++)fu=eu[uu]*su,gu=uu<du-1?eu[uu+1]*su:iu.length,yu=linkedList(iu,fu,gu,su,!1),yu===yu.next&&(yu.steiner=!0),au.push(getLeftmost(yu));for(au.sort(compareX),uu=0;uu<au.length;uu++)tu=eliminateHole(au[uu],tu);return tu}function compareX(iu,eu){return iu.x-eu.x}function eliminateHole(iu,eu){const tu=findHoleBridge(iu,eu);if(!tu)return eu;const su=splitPolygon(tu,iu);return filterPoints(su,su.next),filterPoints(tu,tu.next)}function findHoleBridge(iu,eu){let tu=eu,su=-1/0,au;const uu=iu.x,du=iu.y;do{if(du<=tu.y&&du>=tu.next.y&&tu.next.y!==tu.y){const Su=tu.x+(du-tu.y)*(tu.next.x-tu.x)/(tu.next.y-tu.y);if(Su<=uu&&Su>su&&(su=Su,au=tu.x<tu.next.x?tu:tu.next,Su===uu))return au}tu=tu.next}while(tu!==eu);if(!au)return null;const fu=au,gu=au.x,yu=au.y;let xu=1/0,vu;tu=au;do uu>=tu.x&&tu.x>=gu&&uu!==tu.x&&pointInTriangle(du<yu?uu:su,du,gu,yu,du<yu?su:uu,du,tu.x,tu.y)&&(vu=Math.abs(du-tu.y)/(uu-tu.x),locallyInside(tu,iu)&&(vu<xu||vu===xu&&(tu.x>au.x||tu.x===au.x&&sectorContainsSector(au,tu)))&&(au=tu,xu=vu)),tu=tu.next;while(tu!==fu);return au}function sectorContainsSector(iu,eu){return area(iu.prev,iu,eu.prev)<0&&area(eu.next,iu,iu.next)<0}function indexCurve(iu,eu,tu,su){let au=iu;do au.z===0&&(au.z=zOrder(au.x,au.y,eu,tu,su)),au.prevZ=au.prev,au.nextZ=au.next,au=au.next;while(au!==iu);au.prevZ.nextZ=null,au.prevZ=null,sortLinked(au)}function sortLinked(iu){let eu,tu,su,au,uu,du,fu,gu,yu=1;do{for(tu=iu,iu=null,uu=null,du=0;tu;){for(du++,su=tu,fu=0,eu=0;eu<yu&&(fu++,su=su.nextZ,!!su);eu++);for(gu=yu;fu>0||gu>0&&su;)fu!==0&&(gu===0||!su||tu.z<=su.z)?(au=tu,tu=tu.nextZ,fu--):(au=su,su=su.nextZ,gu--),uu?uu.nextZ=au:iu=au,au.prevZ=uu,uu=au;tu=su}uu.nextZ=null,yu*=2}while(du>1);return iu}function zOrder(iu,eu,tu,su,au){return iu=(iu-tu)*au|0,eu=(eu-su)*au|0,iu=(iu|iu<<8)&16711935,iu=(iu|iu<<4)&252645135,iu=(iu|iu<<2)&858993459,iu=(iu|iu<<1)&1431655765,eu=(eu|eu<<8)&16711935,eu=(eu|eu<<4)&252645135,eu=(eu|eu<<2)&858993459,eu=(eu|eu<<1)&1431655765,iu|eu<<1}function getLeftmost(iu){let eu=iu,tu=iu;do(eu.x<tu.x||eu.x===tu.x&&eu.y<tu.y)&&(tu=eu),eu=eu.next;while(eu!==iu);return tu}function pointInTriangle(iu,eu,tu,su,au,uu,du,fu){return(au-du)*(eu-fu)>=(iu-du)*(uu-fu)&&(iu-du)*(su-fu)>=(tu-du)*(eu-fu)&&(tu-du)*(uu-fu)>=(au-du)*(su-fu)}function isValidDiagonal(iu,eu){return iu.next.i!==eu.i&&iu.prev.i!==eu.i&&!intersectsPolygon(iu,eu)&&(locallyInside(iu,eu)&&locallyInside(eu,iu)&&middleInside(iu,eu)&&(area(iu.prev,iu,eu.prev)||area(iu,eu.prev,eu))||equals(iu,eu)&&area(iu.prev,iu,iu.next)>0&&area(eu.prev,eu,eu.next)>0)}function area(iu,eu,tu){return(eu.y-iu.y)*(tu.x-eu.x)-(eu.x-iu.x)*(tu.y-eu.y)}function equals(iu,eu){return iu.x===eu.x&&iu.y===eu.y}function intersects(iu,eu,tu,su){const au=sign$1(area(iu,eu,tu)),uu=sign$1(area(iu,eu,su)),du=sign$1(area(tu,su,iu)),fu=sign$1(area(tu,su,eu));return!!(au!==uu&&du!==fu||au===0&&onSegment(iu,tu,eu)||uu===0&&onSegment(iu,su,eu)||du===0&&onSegment(tu,iu,su)||fu===0&&onSegment(tu,eu,su))}function onSegment(iu,eu,tu){return eu.x<=Math.max(iu.x,tu.x)&&eu.x>=Math.min(iu.x,tu.x)&&eu.y<=Math.max(iu.y,tu.y)&&eu.y>=Math.min(iu.y,tu.y)}function sign$1(iu){return iu>0?1:iu<0?-1:0}function intersectsPolygon(iu,eu){let tu=iu;do{if(tu.i!==iu.i&&tu.next.i!==iu.i&&tu.i!==eu.i&&tu.next.i!==eu.i&&intersects(tu,tu.next,iu,eu))return!0;tu=tu.next}while(tu!==iu);return!1}function locallyInside(iu,eu){return area(iu.prev,iu,iu.next)<0?area(iu,eu,iu.next)>=0&&area(iu,iu.prev,eu)>=0:area(iu,eu,iu.prev)<0||area(iu,iu.next,eu)<0}function middleInside(iu,eu){let tu=iu,su=!1;const au=(iu.x+eu.x)/2,uu=(iu.y+eu.y)/2;do tu.y>uu!=tu.next.y>uu&&tu.next.y!==tu.y&&au<(tu.next.x-tu.x)*(uu-tu.y)/(tu.next.y-tu.y)+tu.x&&(su=!su),tu=tu.next;while(tu!==iu);return su}function splitPolygon(iu,eu){const tu=new Node$1(iu.i,iu.x,iu.y),su=new Node$1(eu.i,eu.x,eu.y),au=iu.next,uu=eu.prev;return iu.next=eu,eu.prev=iu,tu.next=au,au.prev=tu,su.next=tu,tu.prev=su,uu.next=su,su.prev=uu,su}function insertNode(iu,eu,tu,su){const au=new Node$1(iu,eu,tu);return su?(au.next=su.next,au.prev=su,su.next.prev=au,su.next=au):(au.prev=au,au.next=au),au}function removeNode(iu){iu.next.prev=iu.prev,iu.prev.next=iu.next,iu.prevZ&&(iu.prevZ.nextZ=iu.nextZ),iu.nextZ&&(iu.nextZ.prevZ=iu.prevZ)}function Node$1(iu,eu,tu){this.i=iu,this.x=eu,this.y=tu,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(iu,eu,tu,su){let au=0;for(let uu=eu,du=tu-su;uu<tu;uu+=su)au+=(iu[du]-iu[uu])*(iu[uu+1]+iu[du+1]),du=uu;return au}class ShapeUtils{static area(eu){const tu=eu.length;let su=0;for(let au=tu-1,uu=0;uu<tu;au=uu++)su+=eu[au].x*eu[uu].y-eu[uu].x*eu[au].y;return su*.5}static isClockWise(eu){return ShapeUtils.area(eu)<0}static triangulateShape(eu,tu){const su=[],au=[],uu=[];removeDupEndPts(eu),addContour(su,eu);let du=eu.length;tu.forEach(removeDupEndPts);for(let gu=0;gu<tu.length;gu++)au.push(du),du+=tu[gu].length,addContour(su,tu[gu]);const fu=Earcut.triangulate(su,au);for(let gu=0;gu<fu.length;gu+=3)uu.push(fu.slice(gu,gu+3));return uu}}function removeDupEndPts(iu){const eu=iu.length;eu>2&&iu[eu-1].equals(iu[0])&&iu.pop()}function addContour(iu,eu){for(let tu=0;tu<eu.length;tu++)iu.push(eu[tu].x),iu.push(eu[tu].y)}class ExtrudeGeometry extends BufferGeometry{constructor(eu=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),tu={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:eu,options:tu},eu=Array.isArray(eu)?eu:[eu];const su=this,au=[],uu=[];for(let fu=0,gu=eu.length;fu<gu;fu++){const yu=eu[fu];du(yu)}this.setAttribute("position",new Float32BufferAttribute(au,3)),this.setAttribute("uv",new Float32BufferAttribute(uu,2)),this.computeVertexNormals();function du(fu){const gu=[],yu=tu.curveSegments!==void 0?tu.curveSegments:12,xu=tu.steps!==void 0?tu.steps:1,vu=tu.depth!==void 0?tu.depth:1;let Su=tu.bevelEnabled!==void 0?tu.bevelEnabled:!0,Iu=tu.bevelThickness!==void 0?tu.bevelThickness:.2,Mu=tu.bevelSize!==void 0?tu.bevelSize:Iu-.1,ku=tu.bevelOffset!==void 0?tu.bevelOffset:0,Bu=tu.bevelSegments!==void 0?tu.bevelSegments:3;const _u=tu.extrudePath,Lu=tu.UVGenerator!==void 0?tu.UVGenerator:WorldUVGenerator;let Du,Ou=!1,Wu,Zu,Hu,Yu;_u&&(Du=_u.getSpacedPoints(xu),Ou=!0,Su=!1,Wu=_u.computeFrenetFrames(xu,!1),Zu=new Vector3,Hu=new Vector3,Yu=new Vector3),Su||(Bu=0,Iu=0,Mu=0,ku=0);const Ku=fu.extractPoints(yu);let ju=Ku.shape;const tp=Ku.holes;if(!ShapeUtils.isClockWise(ju)){ju=ju.reverse();for(let $p=0,_f=tp.length;$p<_f;$p++){const rm=tp[$p];ShapeUtils.isClockWise(rm)&&(tp[$p]=rm.reverse())}}const yp=ShapeUtils.triangulateShape(ju,tp),Cp=ju;for(let $p=0,_f=tp.length;$p<_f;$p++){const rm=tp[$p];ju=ju.concat(rm)}function Hp($p,_f,rm){return _f||console.error("THREE.ExtrudeGeometry: vec does not exist"),$p.clone().addScaledVector(_f,rm)}const wp=ju.length,Dp=yp.length;function dp($p,_f,rm){let lp,cp,mm;const $u=$p.x-_f.x,Vu=$p.y-_f.y,_h=rm.x-$p.x,ap=rm.y-$p.y,mp=$u*$u+Vu*Vu,Lp=$u*ap-Vu*_h;if(Math.abs(Lp)>Number.EPSILON){const Kp=Math.sqrt(mp),vm=Math.sqrt(_h*_h+ap*ap),sp=_f.x-Vu/Kp,_d=_f.y+$u/Kp,Sp=rm.x-ap/vm,tm=rm.y+_h/vm,qu=((Sp-sp)*ap-(tm-_d)*_h)/($u*ap-Vu*_h);lp=sp+$u*qu-$p.x,cp=_d+Vu*qu-$p.y;const Uu=lp*lp+cp*cp;if(Uu<=2)return new Vector2(lp,cp);mm=Math.sqrt(Uu/2)}else{let Kp=!1;$u>Number.EPSILON?_h>Number.EPSILON&&(Kp=!0):$u<-Number.EPSILON?_h<-Number.EPSILON&&(Kp=!0):Math.sign(Vu)===Math.sign(ap)&&(Kp=!0),Kp?(lp=-Vu,cp=$u,mm=Math.sqrt(mp)):(lp=$u,cp=Vu,mm=Math.sqrt(mp/2))}return new Vector2(lp/mm,cp/mm)}const Rp=[];for(let $p=0,_f=Cp.length,rm=_f-1,lp=$p+1;$p<_f;$p++,rm++,lp++)rm===_f&&(rm=0),lp===_f&&(lp=0),Rp[$p]=dp(Cp[$p],Cp[rm],Cp[lp]);const xp=[];let cm,lm=Rp.concat();for(let $p=0,_f=tp.length;$p<_f;$p++){const rm=tp[$p];cm=[];for(let lp=0,cp=rm.length,mm=cp-1,$u=lp+1;lp<cp;lp++,mm++,$u++)mm===cp&&(mm=0),$u===cp&&($u=0),cm[lp]=dp(rm[lp],rm[mm],rm[$u]);xp.push(cm),lm=lm.concat(cm)}for(let $p=0;$p<Bu;$p++){const _f=$p/Bu,rm=Iu*Math.cos(_f*Math.PI/2),lp=Mu*Math.sin(_f*Math.PI/2)+ku;for(let cp=0,mm=Cp.length;cp<mm;cp++){const $u=Hp(Cp[cp],Rp[cp],lp);nm($u.x,$u.y,-rm)}for(let cp=0,mm=tp.length;cp<mm;cp++){const $u=tp[cp];cm=xp[cp];for(let Vu=0,_h=$u.length;Vu<_h;Vu++){const ap=Hp($u[Vu],cm[Vu],lp);nm(ap.x,ap.y,-rm)}}}const vp=Mu+ku;for(let $p=0;$p<wp;$p++){const _f=Su?Hp(ju[$p],lm[$p],vp):ju[$p];Ou?(Hu.copy(Wu.normals[0]).multiplyScalar(_f.x),Zu.copy(Wu.binormals[0]).multiplyScalar(_f.y),Yu.copy(Du[0]).add(Hu).add(Zu),nm(Yu.x,Yu.y,Yu.z)):nm(_f.x,_f.y,0)}for(let $p=1;$p<=xu;$p++)for(let _f=0;_f<wp;_f++){const rm=Su?Hp(ju[_f],lm[_f],vp):ju[_f];Ou?(Hu.copy(Wu.normals[$p]).multiplyScalar(rm.x),Zu.copy(Wu.binormals[$p]).multiplyScalar(rm.y),Yu.copy(Du[$p]).add(Hu).add(Zu),nm(Yu.x,Yu.y,Yu.z)):nm(rm.x,rm.y,vu/xu*$p)}for(let $p=Bu-1;$p>=0;$p--){const _f=$p/Bu,rm=Iu*Math.cos(_f*Math.PI/2),lp=Mu*Math.sin(_f*Math.PI/2)+ku;for(let cp=0,mm=Cp.length;cp<mm;cp++){const $u=Hp(Cp[cp],Rp[cp],lp);nm($u.x,$u.y,vu+rm)}for(let cp=0,mm=tp.length;cp<mm;cp++){const $u=tp[cp];cm=xp[cp];for(let Vu=0,_h=$u.length;Vu<_h;Vu++){const ap=Hp($u[Vu],cm[Vu],lp);Ou?nm(ap.x,ap.y+Du[xu-1].y,Du[xu-1].x+rm):nm(ap.x,ap.y,vu+rm)}}}bp(),kp();function bp(){const $p=au.length/3;if(Su){let _f=0,rm=wp*_f;for(let lp=0;lp<Dp;lp++){const cp=yp[lp];Bp(cp[2]+rm,cp[1]+rm,cp[0]+rm)}_f=xu+Bu*2,rm=wp*_f;for(let lp=0;lp<Dp;lp++){const cp=yp[lp];Bp(cp[0]+rm,cp[1]+rm,cp[2]+rm)}}else{for(let _f=0;_f<Dp;_f++){const rm=yp[_f];Bp(rm[2],rm[1],rm[0])}for(let _f=0;_f<Dp;_f++){const rm=yp[_f];Bp(rm[0]+wp*xu,rm[1]+wp*xu,rm[2]+wp*xu)}}su.addGroup($p,au.length/3-$p,0)}function kp(){const $p=au.length/3;let _f=0;dm(Cp,_f),_f+=Cp.length;for(let rm=0,lp=tp.length;rm<lp;rm++){const cp=tp[rm];dm(cp,_f),_f+=cp.length}su.addGroup($p,au.length/3-$p,1)}function dm($p,_f){let rm=$p.length;for(;--rm>=0;){const lp=rm;let cp=rm-1;cp<0&&(cp=$p.length-1);for(let mm=0,$u=xu+Bu*2;mm<$u;mm++){const Vu=wp*mm,_h=wp*(mm+1),ap=_f+lp+Vu,mp=_f+cp+Vu,Lp=_f+cp+_h,Kp=_f+lp+_h;Qp(ap,mp,Lp,Kp)}}}function nm($p,_f,rm){gu.push($p),gu.push(_f),gu.push(rm)}function Bp($p,_f,rm){Xp($p),Xp(_f),Xp(rm);const lp=au.length/3,cp=Lu.generateTopUV(su,au,lp-3,lp-2,lp-1);sm(cp[0]),sm(cp[1]),sm(cp[2])}function Qp($p,_f,rm,lp){Xp($p),Xp(_f),Xp(lp),Xp(_f),Xp(rm),Xp(lp);const cp=au.length/3,mm=Lu.generateSideWallUV(su,au,cp-6,cp-3,cp-2,cp-1);sm(mm[0]),sm(mm[1]),sm(mm[3]),sm(mm[1]),sm(mm[2]),sm(mm[3])}function Xp($p){au.push(gu[$p*3+0]),au.push(gu[$p*3+1]),au.push(gu[$p*3+2])}function sm($p){uu.push($p.x),uu.push($p.y)}}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}toJSON(){const eu=super.toJSON(),tu=this.parameters.shapes,su=this.parameters.options;return toJSON$1(tu,su,eu)}static fromJSON(eu,tu){const su=[];for(let uu=0,du=eu.shapes.length;uu<du;uu++){const fu=tu[eu.shapes[uu]];su.push(fu)}const au=eu.options.extrudePath;return au!==void 0&&(eu.options.extrudePath=new Curves[au.type]().fromJSON(au)),new ExtrudeGeometry(su,eu.options)}}const WorldUVGenerator={generateTopUV:function(iu,eu,tu,su,au){const uu=eu[tu*3],du=eu[tu*3+1],fu=eu[su*3],gu=eu[su*3+1],yu=eu[au*3],xu=eu[au*3+1];return[new Vector2(uu,du),new Vector2(fu,gu),new Vector2(yu,xu)]},generateSideWallUV:function(iu,eu,tu,su,au,uu){const du=eu[tu*3],fu=eu[tu*3+1],gu=eu[tu*3+2],yu=eu[su*3],xu=eu[su*3+1],vu=eu[su*3+2],Su=eu[au*3],Iu=eu[au*3+1],Mu=eu[au*3+2],ku=eu[uu*3],Bu=eu[uu*3+1],_u=eu[uu*3+2];return Math.abs(fu-xu)<Math.abs(du-yu)?[new Vector2(du,1-gu),new Vector2(yu,1-vu),new Vector2(Su,1-Mu),new Vector2(ku,1-_u)]:[new Vector2(fu,1-gu),new Vector2(xu,1-vu),new Vector2(Iu,1-Mu),new Vector2(Bu,1-_u)]}};function toJSON$1(iu,eu,tu){if(tu.shapes=[],Array.isArray(iu))for(let su=0,au=iu.length;su<au;su++){const uu=iu[su];tu.shapes.push(uu.uuid)}else tu.shapes.push(iu.uuid);return tu.options=Object.assign({},eu),eu.extrudePath!==void 0&&(tu.options.extrudePath=eu.extrudePath.toJSON()),tu}class IcosahedronGeometry extends PolyhedronGeometry{constructor(eu=1,tu=0){const su=(1+Math.sqrt(5))/2,au=[-1,su,0,1,su,0,-1,-su,0,1,-su,0,0,-1,su,0,1,su,0,-1,-su,0,1,-su,su,0,-1,su,0,1,-su,0,-1,-su,0,1],uu=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(au,uu,eu,tu),this.type="IcosahedronGeometry",this.parameters={radius:eu,detail:tu}}static fromJSON(eu){return new IcosahedronGeometry(eu.radius,eu.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(eu=1,tu=0){const su=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],au=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(su,au,eu,tu),this.type="OctahedronGeometry",this.parameters={radius:eu,detail:tu}}static fromJSON(eu){return new OctahedronGeometry(eu.radius,eu.detail)}}class PlaneGeometry extends BufferGeometry{constructor(eu=1,tu=1,su=1,au=1){super(),this.type="PlaneGeometry",this.parameters={width:eu,height:tu,widthSegments:su,heightSegments:au};const uu=eu/2,du=tu/2,fu=Math.floor(su),gu=Math.floor(au),yu=fu+1,xu=gu+1,vu=eu/fu,Su=tu/gu,Iu=[],Mu=[],ku=[],Bu=[];for(let _u=0;_u<xu;_u++){const Lu=_u*Su-du;for(let Du=0;Du<yu;Du++){const Ou=Du*vu-uu;Mu.push(Ou,-Lu,0),ku.push(0,0,1),Bu.push(Du/fu),Bu.push(1-_u/gu)}}for(let _u=0;_u<gu;_u++)for(let Lu=0;Lu<fu;Lu++){const Du=Lu+yu*_u,Ou=Lu+yu*(_u+1),Wu=Lu+1+yu*(_u+1),Zu=Lu+1+yu*_u;Iu.push(Du,Ou,Zu),Iu.push(Ou,Wu,Zu)}this.setIndex(Iu),this.setAttribute("position",new Float32BufferAttribute(Mu,3)),this.setAttribute("normal",new Float32BufferAttribute(ku,3)),this.setAttribute("uv",new Float32BufferAttribute(Bu,2))}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new PlaneGeometry(eu.width,eu.height,eu.widthSegments,eu.heightSegments)}}class RingGeometry extends BufferGeometry{constructor(eu=.5,tu=1,su=32,au=1,uu=0,du=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:eu,outerRadius:tu,thetaSegments:su,phiSegments:au,thetaStart:uu,thetaLength:du},su=Math.max(3,su),au=Math.max(1,au);const fu=[],gu=[],yu=[],xu=[];let vu=eu;const Su=(tu-eu)/au,Iu=new Vector3,Mu=new Vector2;for(let ku=0;ku<=au;ku++){for(let Bu=0;Bu<=su;Bu++){const _u=uu+Bu/su*du;Iu.x=vu*Math.cos(_u),Iu.y=vu*Math.sin(_u),gu.push(Iu.x,Iu.y,Iu.z),yu.push(0,0,1),Mu.x=(Iu.x/tu+1)/2,Mu.y=(Iu.y/tu+1)/2,xu.push(Mu.x,Mu.y)}vu+=Su}for(let ku=0;ku<au;ku++){const Bu=ku*(su+1);for(let _u=0;_u<su;_u++){const Lu=_u+Bu,Du=Lu,Ou=Lu+su+1,Wu=Lu+su+2,Zu=Lu+1;fu.push(Du,Ou,Zu),fu.push(Ou,Wu,Zu)}}this.setIndex(fu),this.setAttribute("position",new Float32BufferAttribute(gu,3)),this.setAttribute("normal",new Float32BufferAttribute(yu,3)),this.setAttribute("uv",new Float32BufferAttribute(xu,2))}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new RingGeometry(eu.innerRadius,eu.outerRadius,eu.thetaSegments,eu.phiSegments,eu.thetaStart,eu.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(eu=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),tu=12){super(),this.type="ShapeGeometry",this.parameters={shapes:eu,curveSegments:tu};const su=[],au=[],uu=[],du=[];let fu=0,gu=0;if(Array.isArray(eu)===!1)yu(eu);else for(let xu=0;xu<eu.length;xu++)yu(eu[xu]),this.addGroup(fu,gu,xu),fu+=gu,gu=0;this.setIndex(su),this.setAttribute("position",new Float32BufferAttribute(au,3)),this.setAttribute("normal",new Float32BufferAttribute(uu,3)),this.setAttribute("uv",new Float32BufferAttribute(du,2));function yu(xu){const vu=au.length/3,Su=xu.extractPoints(tu);let Iu=Su.shape;const Mu=Su.holes;ShapeUtils.isClockWise(Iu)===!1&&(Iu=Iu.reverse());for(let Bu=0,_u=Mu.length;Bu<_u;Bu++){const Lu=Mu[Bu];ShapeUtils.isClockWise(Lu)===!0&&(Mu[Bu]=Lu.reverse())}const ku=ShapeUtils.triangulateShape(Iu,Mu);for(let Bu=0,_u=Mu.length;Bu<_u;Bu++){const Lu=Mu[Bu];Iu=Iu.concat(Lu)}for(let Bu=0,_u=Iu.length;Bu<_u;Bu++){const Lu=Iu[Bu];au.push(Lu.x,Lu.y,0),uu.push(0,0,1),du.push(Lu.x,Lu.y)}for(let Bu=0,_u=ku.length;Bu<_u;Bu++){const Lu=ku[Bu],Du=Lu[0]+vu,Ou=Lu[1]+vu,Wu=Lu[2]+vu;su.push(Du,Ou,Wu),gu+=3}}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}toJSON(){const eu=super.toJSON(),tu=this.parameters.shapes;return toJSON(tu,eu)}static fromJSON(eu,tu){const su=[];for(let au=0,uu=eu.shapes.length;au<uu;au++){const du=tu[eu.shapes[au]];su.push(du)}return new ShapeGeometry(su,eu.curveSegments)}}function toJSON(iu,eu){if(eu.shapes=[],Array.isArray(iu))for(let tu=0,su=iu.length;tu<su;tu++){const au=iu[tu];eu.shapes.push(au.uuid)}else eu.shapes.push(iu.uuid);return eu}class SphereGeometry extends BufferGeometry{constructor(eu=1,tu=32,su=16,au=0,uu=Math.PI*2,du=0,fu=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:eu,widthSegments:tu,heightSegments:su,phiStart:au,phiLength:uu,thetaStart:du,thetaLength:fu},tu=Math.max(3,Math.floor(tu)),su=Math.max(2,Math.floor(su));const gu=Math.min(du+fu,Math.PI);let yu=0;const xu=[],vu=new Vector3,Su=new Vector3,Iu=[],Mu=[],ku=[],Bu=[];for(let _u=0;_u<=su;_u++){const Lu=[],Du=_u/su;let Ou=0;_u===0&&du===0?Ou=.5/tu:_u===su&&gu===Math.PI&&(Ou=-.5/tu);for(let Wu=0;Wu<=tu;Wu++){const Zu=Wu/tu;vu.x=-eu*Math.cos(au+Zu*uu)*Math.sin(du+Du*fu),vu.y=eu*Math.cos(du+Du*fu),vu.z=eu*Math.sin(au+Zu*uu)*Math.sin(du+Du*fu),Mu.push(vu.x,vu.y,vu.z),Su.copy(vu).normalize(),ku.push(Su.x,Su.y,Su.z),Bu.push(Zu+Ou,1-Du),Lu.push(yu++)}xu.push(Lu)}for(let _u=0;_u<su;_u++)for(let Lu=0;Lu<tu;Lu++){const Du=xu[_u][Lu+1],Ou=xu[_u][Lu],Wu=xu[_u+1][Lu],Zu=xu[_u+1][Lu+1];(_u!==0||du>0)&&Iu.push(Du,Ou,Zu),(_u!==su-1||gu<Math.PI)&&Iu.push(Ou,Wu,Zu)}this.setIndex(Iu),this.setAttribute("position",new Float32BufferAttribute(Mu,3)),this.setAttribute("normal",new Float32BufferAttribute(ku,3)),this.setAttribute("uv",new Float32BufferAttribute(Bu,2))}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new SphereGeometry(eu.radius,eu.widthSegments,eu.heightSegments,eu.phiStart,eu.phiLength,eu.thetaStart,eu.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(eu=1,tu=0){const su=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],au=[2,1,0,0,3,2,1,3,0,2,3,1];super(su,au,eu,tu),this.type="TetrahedronGeometry",this.parameters={radius:eu,detail:tu}}static fromJSON(eu){return new TetrahedronGeometry(eu.radius,eu.detail)}}class TorusGeometry extends BufferGeometry{constructor(eu=1,tu=.4,su=12,au=48,uu=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:eu,tube:tu,radialSegments:su,tubularSegments:au,arc:uu},su=Math.floor(su),au=Math.floor(au);const du=[],fu=[],gu=[],yu=[],xu=new Vector3,vu=new Vector3,Su=new Vector3;for(let Iu=0;Iu<=su;Iu++)for(let Mu=0;Mu<=au;Mu++){const ku=Mu/au*uu,Bu=Iu/su*Math.PI*2;vu.x=(eu+tu*Math.cos(Bu))*Math.cos(ku),vu.y=(eu+tu*Math.cos(Bu))*Math.sin(ku),vu.z=tu*Math.sin(Bu),fu.push(vu.x,vu.y,vu.z),xu.x=eu*Math.cos(ku),xu.y=eu*Math.sin(ku),Su.subVectors(vu,xu).normalize(),gu.push(Su.x,Su.y,Su.z),yu.push(Mu/au),yu.push(Iu/su)}for(let Iu=1;Iu<=su;Iu++)for(let Mu=1;Mu<=au;Mu++){const ku=(au+1)*Iu+Mu-1,Bu=(au+1)*(Iu-1)+Mu-1,_u=(au+1)*(Iu-1)+Mu,Lu=(au+1)*Iu+Mu;du.push(ku,Bu,Lu),du.push(Bu,_u,Lu)}this.setIndex(du),this.setAttribute("position",new Float32BufferAttribute(fu,3)),this.setAttribute("normal",new Float32BufferAttribute(gu,3)),this.setAttribute("uv",new Float32BufferAttribute(yu,2))}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new TorusGeometry(eu.radius,eu.tube,eu.radialSegments,eu.tubularSegments,eu.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(eu=1,tu=.4,su=64,au=8,uu=2,du=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:eu,tube:tu,tubularSegments:su,radialSegments:au,p:uu,q:du},su=Math.floor(su),au=Math.floor(au);const fu=[],gu=[],yu=[],xu=[],vu=new Vector3,Su=new Vector3,Iu=new Vector3,Mu=new Vector3,ku=new Vector3,Bu=new Vector3,_u=new Vector3;for(let Du=0;Du<=su;++Du){const Ou=Du/su*uu*Math.PI*2;Lu(Ou,uu,du,eu,Iu),Lu(Ou+.01,uu,du,eu,Mu),Bu.subVectors(Mu,Iu),_u.addVectors(Mu,Iu),ku.crossVectors(Bu,_u),_u.crossVectors(ku,Bu),ku.normalize(),_u.normalize();for(let Wu=0;Wu<=au;++Wu){const Zu=Wu/au*Math.PI*2,Hu=-tu*Math.cos(Zu),Yu=tu*Math.sin(Zu);vu.x=Iu.x+(Hu*_u.x+Yu*ku.x),vu.y=Iu.y+(Hu*_u.y+Yu*ku.y),vu.z=Iu.z+(Hu*_u.z+Yu*ku.z),gu.push(vu.x,vu.y,vu.z),Su.subVectors(vu,Iu).normalize(),yu.push(Su.x,Su.y,Su.z),xu.push(Du/su),xu.push(Wu/au)}}for(let Du=1;Du<=su;Du++)for(let Ou=1;Ou<=au;Ou++){const Wu=(au+1)*(Du-1)+(Ou-1),Zu=(au+1)*Du+(Ou-1),Hu=(au+1)*Du+Ou,Yu=(au+1)*(Du-1)+Ou;fu.push(Wu,Zu,Yu),fu.push(Zu,Hu,Yu)}this.setIndex(fu),this.setAttribute("position",new Float32BufferAttribute(gu,3)),this.setAttribute("normal",new Float32BufferAttribute(yu,3)),this.setAttribute("uv",new Float32BufferAttribute(xu,2));function Lu(Du,Ou,Wu,Zu,Hu){const Yu=Math.cos(Du),Ku=Math.sin(Du),ju=Wu/Ou*Du,tp=Math.cos(ju);Hu.x=Zu*(2+tp)*.5*Yu,Hu.y=Zu*(2+tp)*Ku*.5,Hu.z=Zu*Math.sin(ju)*.5}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}static fromJSON(eu){return new TorusKnotGeometry(eu.radius,eu.tube,eu.tubularSegments,eu.radialSegments,eu.p,eu.q)}}class TubeGeometry extends BufferGeometry{constructor(eu=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),tu=64,su=1,au=8,uu=!1){super(),this.type="TubeGeometry",this.parameters={path:eu,tubularSegments:tu,radius:su,radialSegments:au,closed:uu};const du=eu.computeFrenetFrames(tu,uu);this.tangents=du.tangents,this.normals=du.normals,this.binormals=du.binormals;const fu=new Vector3,gu=new Vector3,yu=new Vector2;let xu=new Vector3;const vu=[],Su=[],Iu=[],Mu=[];ku(),this.setIndex(Mu),this.setAttribute("position",new Float32BufferAttribute(vu,3)),this.setAttribute("normal",new Float32BufferAttribute(Su,3)),this.setAttribute("uv",new Float32BufferAttribute(Iu,2));function ku(){for(let Du=0;Du<tu;Du++)Bu(Du);Bu(uu===!1?tu:0),Lu(),_u()}function Bu(Du){xu=eu.getPointAt(Du/tu,xu);const Ou=du.normals[Du],Wu=du.binormals[Du];for(let Zu=0;Zu<=au;Zu++){const Hu=Zu/au*Math.PI*2,Yu=Math.sin(Hu),Ku=-Math.cos(Hu);gu.x=Ku*Ou.x+Yu*Wu.x,gu.y=Ku*Ou.y+Yu*Wu.y,gu.z=Ku*Ou.z+Yu*Wu.z,gu.normalize(),Su.push(gu.x,gu.y,gu.z),fu.x=xu.x+su*gu.x,fu.y=xu.y+su*gu.y,fu.z=xu.z+su*gu.z,vu.push(fu.x,fu.y,fu.z)}}function _u(){for(let Du=1;Du<=tu;Du++)for(let Ou=1;Ou<=au;Ou++){const Wu=(au+1)*(Du-1)+(Ou-1),Zu=(au+1)*Du+(Ou-1),Hu=(au+1)*Du+Ou,Yu=(au+1)*(Du-1)+Ou;Mu.push(Wu,Zu,Yu),Mu.push(Zu,Hu,Yu)}}function Lu(){for(let Du=0;Du<=tu;Du++)for(let Ou=0;Ou<=au;Ou++)yu.x=Du/tu,yu.y=Ou/au,Iu.push(yu.x,yu.y)}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}toJSON(){const eu=super.toJSON();return eu.path=this.parameters.path.toJSON(),eu}static fromJSON(eu){return new TubeGeometry(new Curves[eu.path.type]().fromJSON(eu.path),eu.tubularSegments,eu.radius,eu.radialSegments,eu.closed)}}class WireframeGeometry extends BufferGeometry{constructor(eu=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:eu},eu!==null){const tu=[],su=new Set,au=new Vector3,uu=new Vector3;if(eu.index!==null){const du=eu.attributes.position,fu=eu.index;let gu=eu.groups;gu.length===0&&(gu=[{start:0,count:fu.count,materialIndex:0}]);for(let yu=0,xu=gu.length;yu<xu;++yu){const vu=gu[yu],Su=vu.start,Iu=vu.count;for(let Mu=Su,ku=Su+Iu;Mu<ku;Mu+=3)for(let Bu=0;Bu<3;Bu++){const _u=fu.getX(Mu+Bu),Lu=fu.getX(Mu+(Bu+1)%3);au.fromBufferAttribute(du,_u),uu.fromBufferAttribute(du,Lu),isUniqueEdge(au,uu,su)===!0&&(tu.push(au.x,au.y,au.z),tu.push(uu.x,uu.y,uu.z))}}}else{const du=eu.attributes.position;for(let fu=0,gu=du.count/3;fu<gu;fu++)for(let yu=0;yu<3;yu++){const xu=3*fu+yu,vu=3*fu+(yu+1)%3;au.fromBufferAttribute(du,xu),uu.fromBufferAttribute(du,vu),isUniqueEdge(au,uu,su)===!0&&(tu.push(au.x,au.y,au.z),tu.push(uu.x,uu.y,uu.z))}}this.setAttribute("position",new Float32BufferAttribute(tu,3))}}copy(eu){return super.copy(eu),this.parameters=Object.assign({},eu.parameters),this}}function isUniqueEdge(iu,eu,tu){const su=`${iu.x},${iu.y},${iu.z}-${eu.x},${eu.y},${eu.z}`,au=`${eu.x},${eu.y},${eu.z}-${iu.x},${iu.y},${iu.z}`;return tu.has(su)===!0||tu.has(au)===!0?!1:(tu.add(su),tu.add(au),!0)}var Geometries=Object.freeze({__proto__:null,BoxGeometry,CapsuleGeometry,CircleGeometry,ConeGeometry,CylinderGeometry,DodecahedronGeometry,EdgesGeometry,ExtrudeGeometry,IcosahedronGeometry,LatheGeometry,OctahedronGeometry,PlaneGeometry,PolyhedronGeometry,RingGeometry,ShapeGeometry,SphereGeometry,TetrahedronGeometry,TorusGeometry,TorusKnotGeometry,TubeGeometry,WireframeGeometry});class ShadowMaterial extends Material{constructor(eu){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.fog=eu.fog,this}}class RawShaderMaterial extends ShaderMaterial{constructor(eu){super(eu),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(eu){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.defines={STANDARD:""},this.color.copy(eu.color),this.roughness=eu.roughness,this.metalness=eu.metalness,this.map=eu.map,this.lightMap=eu.lightMap,this.lightMapIntensity=eu.lightMapIntensity,this.aoMap=eu.aoMap,this.aoMapIntensity=eu.aoMapIntensity,this.emissive.copy(eu.emissive),this.emissiveMap=eu.emissiveMap,this.emissiveIntensity=eu.emissiveIntensity,this.bumpMap=eu.bumpMap,this.bumpScale=eu.bumpScale,this.normalMap=eu.normalMap,this.normalMapType=eu.normalMapType,this.normalScale.copy(eu.normalScale),this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.roughnessMap=eu.roughnessMap,this.metalnessMap=eu.metalnessMap,this.alphaMap=eu.alphaMap,this.envMap=eu.envMap,this.envMapRotation.copy(eu.envMapRotation),this.envMapIntensity=eu.envMapIntensity,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.wireframeLinecap=eu.wireframeLinecap,this.wireframeLinejoin=eu.wireframeLinejoin,this.flatShading=eu.flatShading,this.fog=eu.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(eu){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(tu){this.ior=(1+.4*tu)/(1-.4*tu)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(eu)}get anisotropy(){return this._anisotropy}set anisotropy(eu){this._anisotropy>0!=eu>0&&this.version++,this._anisotropy=eu}get clearcoat(){return this._clearcoat}set clearcoat(eu){this._clearcoat>0!=eu>0&&this.version++,this._clearcoat=eu}get iridescence(){return this._iridescence}set iridescence(eu){this._iridescence>0!=eu>0&&this.version++,this._iridescence=eu}get dispersion(){return this._dispersion}set dispersion(eu){this._dispersion>0!=eu>0&&this.version++,this._dispersion=eu}get sheen(){return this._sheen}set sheen(eu){this._sheen>0!=eu>0&&this.version++,this._sheen=eu}get transmission(){return this._transmission}set transmission(eu){this._transmission>0!=eu>0&&this.version++,this._transmission=eu}copy(eu){return super.copy(eu),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=eu.anisotropy,this.anisotropyRotation=eu.anisotropyRotation,this.anisotropyMap=eu.anisotropyMap,this.clearcoat=eu.clearcoat,this.clearcoatMap=eu.clearcoatMap,this.clearcoatRoughness=eu.clearcoatRoughness,this.clearcoatRoughnessMap=eu.clearcoatRoughnessMap,this.clearcoatNormalMap=eu.clearcoatNormalMap,this.clearcoatNormalScale.copy(eu.clearcoatNormalScale),this.dispersion=eu.dispersion,this.ior=eu.ior,this.iridescence=eu.iridescence,this.iridescenceMap=eu.iridescenceMap,this.iridescenceIOR=eu.iridescenceIOR,this.iridescenceThicknessRange=[...eu.iridescenceThicknessRange],this.iridescenceThicknessMap=eu.iridescenceThicknessMap,this.sheen=eu.sheen,this.sheenColor.copy(eu.sheenColor),this.sheenColorMap=eu.sheenColorMap,this.sheenRoughness=eu.sheenRoughness,this.sheenRoughnessMap=eu.sheenRoughnessMap,this.transmission=eu.transmission,this.transmissionMap=eu.transmissionMap,this.thickness=eu.thickness,this.thicknessMap=eu.thicknessMap,this.attenuationDistance=eu.attenuationDistance,this.attenuationColor.copy(eu.attenuationColor),this.specularIntensity=eu.specularIntensity,this.specularIntensityMap=eu.specularIntensityMap,this.specularColor.copy(eu.specularColor),this.specularColorMap=eu.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(eu){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.specular.copy(eu.specular),this.shininess=eu.shininess,this.map=eu.map,this.lightMap=eu.lightMap,this.lightMapIntensity=eu.lightMapIntensity,this.aoMap=eu.aoMap,this.aoMapIntensity=eu.aoMapIntensity,this.emissive.copy(eu.emissive),this.emissiveMap=eu.emissiveMap,this.emissiveIntensity=eu.emissiveIntensity,this.bumpMap=eu.bumpMap,this.bumpScale=eu.bumpScale,this.normalMap=eu.normalMap,this.normalMapType=eu.normalMapType,this.normalScale.copy(eu.normalScale),this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.specularMap=eu.specularMap,this.alphaMap=eu.alphaMap,this.envMap=eu.envMap,this.envMapRotation.copy(eu.envMapRotation),this.combine=eu.combine,this.reflectivity=eu.reflectivity,this.refractionRatio=eu.refractionRatio,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.wireframeLinecap=eu.wireframeLinecap,this.wireframeLinejoin=eu.wireframeLinejoin,this.flatShading=eu.flatShading,this.fog=eu.fog,this}}class MeshToonMaterial extends Material{constructor(eu){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.map=eu.map,this.gradientMap=eu.gradientMap,this.lightMap=eu.lightMap,this.lightMapIntensity=eu.lightMapIntensity,this.aoMap=eu.aoMap,this.aoMapIntensity=eu.aoMapIntensity,this.emissive.copy(eu.emissive),this.emissiveMap=eu.emissiveMap,this.emissiveIntensity=eu.emissiveIntensity,this.bumpMap=eu.bumpMap,this.bumpScale=eu.bumpScale,this.normalMap=eu.normalMap,this.normalMapType=eu.normalMapType,this.normalScale.copy(eu.normalScale),this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.alphaMap=eu.alphaMap,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.wireframeLinecap=eu.wireframeLinecap,this.wireframeLinejoin=eu.wireframeLinejoin,this.fog=eu.fog,this}}class MeshNormalMaterial extends Material{constructor(eu){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(eu)}copy(eu){return super.copy(eu),this.bumpMap=eu.bumpMap,this.bumpScale=eu.bumpScale,this.normalMap=eu.normalMap,this.normalMapType=eu.normalMapType,this.normalScale.copy(eu.normalScale),this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.flatShading=eu.flatShading,this}}class MeshLambertMaterial extends Material{constructor(eu){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.color.copy(eu.color),this.map=eu.map,this.lightMap=eu.lightMap,this.lightMapIntensity=eu.lightMapIntensity,this.aoMap=eu.aoMap,this.aoMapIntensity=eu.aoMapIntensity,this.emissive.copy(eu.emissive),this.emissiveMap=eu.emissiveMap,this.emissiveIntensity=eu.emissiveIntensity,this.bumpMap=eu.bumpMap,this.bumpScale=eu.bumpScale,this.normalMap=eu.normalMap,this.normalMapType=eu.normalMapType,this.normalScale.copy(eu.normalScale),this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.specularMap=eu.specularMap,this.alphaMap=eu.alphaMap,this.envMap=eu.envMap,this.envMapRotation.copy(eu.envMapRotation),this.combine=eu.combine,this.reflectivity=eu.reflectivity,this.refractionRatio=eu.refractionRatio,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this.wireframeLinecap=eu.wireframeLinecap,this.wireframeLinejoin=eu.wireframeLinejoin,this.flatShading=eu.flatShading,this.fog=eu.fog,this}}class MeshDepthMaterial extends Material{constructor(eu){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(eu)}copy(eu){return super.copy(eu),this.depthPacking=eu.depthPacking,this.map=eu.map,this.alphaMap=eu.alphaMap,this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.wireframe=eu.wireframe,this.wireframeLinewidth=eu.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(eu){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(eu)}copy(eu){return super.copy(eu),this.map=eu.map,this.alphaMap=eu.alphaMap,this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this}}class MeshMatcapMaterial extends Material{constructor(eu){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(eu)}copy(eu){return super.copy(eu),this.defines={MATCAP:""},this.color.copy(eu.color),this.matcap=eu.matcap,this.map=eu.map,this.bumpMap=eu.bumpMap,this.bumpScale=eu.bumpScale,this.normalMap=eu.normalMap,this.normalMapType=eu.normalMapType,this.normalScale.copy(eu.normalScale),this.displacementMap=eu.displacementMap,this.displacementScale=eu.displacementScale,this.displacementBias=eu.displacementBias,this.alphaMap=eu.alphaMap,this.flatShading=eu.flatShading,this.fog=eu.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(eu){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(eu)}copy(eu){return super.copy(eu),this.scale=eu.scale,this.dashSize=eu.dashSize,this.gapSize=eu.gapSize,this}}function convertArray(iu,eu,tu){return!iu||!tu&&iu.constructor===eu?iu:typeof eu.BYTES_PER_ELEMENT=="number"?new eu(iu):Array.prototype.slice.call(iu)}function isTypedArray$1(iu){return ArrayBuffer.isView(iu)&&!(iu instanceof DataView)}function getKeyframeOrder(iu){function eu(au,uu){return iu[au]-iu[uu]}const tu=iu.length,su=new Array(tu);for(let au=0;au!==tu;++au)su[au]=au;return su.sort(eu),su}function sortedArray(iu,eu,tu){const su=iu.length,au=new iu.constructor(su);for(let uu=0,du=0;du!==su;++uu){const fu=tu[uu]*eu;for(let gu=0;gu!==eu;++gu)au[du++]=iu[fu+gu]}return au}function flattenJSON(iu,eu,tu,su){let au=1,uu=iu[0];for(;uu!==void 0&&uu[su]===void 0;)uu=iu[au++];if(uu===void 0)return;let du=uu[su];if(du!==void 0)if(Array.isArray(du))do du=uu[su],du!==void 0&&(eu.push(uu.time),tu.push.apply(tu,du)),uu=iu[au++];while(uu!==void 0);else if(du.toArray!==void 0)do du=uu[su],du!==void 0&&(eu.push(uu.time),du.toArray(tu,tu.length)),uu=iu[au++];while(uu!==void 0);else do du=uu[su],du!==void 0&&(eu.push(uu.time),tu.push(du)),uu=iu[au++];while(uu!==void 0)}function subclip(iu,eu,tu,su,au=30){const uu=iu.clone();uu.name=eu;const du=[];for(let gu=0;gu<uu.tracks.length;++gu){const yu=uu.tracks[gu],xu=yu.getValueSize(),vu=[],Su=[];for(let Iu=0;Iu<yu.times.length;++Iu){const Mu=yu.times[Iu]*au;if(!(Mu<tu||Mu>=su)){vu.push(yu.times[Iu]);for(let ku=0;ku<xu;++ku)Su.push(yu.values[Iu*xu+ku])}}vu.length!==0&&(yu.times=convertArray(vu,yu.times.constructor),yu.values=convertArray(Su,yu.values.constructor),du.push(yu))}uu.tracks=du;let fu=1/0;for(let gu=0;gu<uu.tracks.length;++gu)fu>uu.tracks[gu].times[0]&&(fu=uu.tracks[gu].times[0]);for(let gu=0;gu<uu.tracks.length;++gu)uu.tracks[gu].shift(-1*fu);return uu.resetDuration(),uu}function makeClipAdditive(iu,eu=0,tu=iu,su=30){su<=0&&(su=30);const au=tu.tracks.length,uu=eu/su;for(let du=0;du<au;++du){const fu=tu.tracks[du],gu=fu.ValueTypeName;if(gu==="bool"||gu==="string")continue;const yu=iu.tracks.find(function(_u){return _u.name===fu.name&&_u.ValueTypeName===gu});if(yu===void 0)continue;let xu=0;const vu=fu.getValueSize();fu.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(xu=vu/3);let Su=0;const Iu=yu.getValueSize();yu.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(Su=Iu/3);const Mu=fu.times.length-1;let ku;if(uu<=fu.times[0]){const _u=xu,Lu=vu-xu;ku=fu.values.slice(_u,Lu)}else if(uu>=fu.times[Mu]){const _u=Mu*vu+xu,Lu=_u+vu-xu;ku=fu.values.slice(_u,Lu)}else{const _u=fu.createInterpolant(),Lu=xu,Du=vu-xu;_u.evaluate(uu),ku=_u.resultBuffer.slice(Lu,Du)}gu==="quaternion"&&new Quaternion().fromArray(ku).normalize().conjugate().toArray(ku);const Bu=yu.times.length;for(let _u=0;_u<Bu;++_u){const Lu=_u*Iu+Su;if(gu==="quaternion")Quaternion.multiplyQuaternionsFlat(yu.values,Lu,ku,0,yu.values,Lu);else{const Du=Iu-Su*2;for(let Ou=0;Ou<Du;++Ou)yu.values[Lu+Ou]-=ku[Ou]}}}return iu.blendMode=AdditiveAnimationBlendMode,iu}const AnimationUtils={convertArray,isTypedArray:isTypedArray$1,getKeyframeOrder,sortedArray,flattenJSON,subclip,makeClipAdditive};class Interpolant{constructor(eu,tu,su,au){this.parameterPositions=eu,this._cachedIndex=0,this.resultBuffer=au!==void 0?au:new tu.constructor(su),this.sampleValues=tu,this.valueSize=su,this.settings=null,this.DefaultSettings_={}}evaluate(eu){const tu=this.parameterPositions;let su=this._cachedIndex,au=tu[su],uu=tu[su-1];e:{t:{let du;n:{i:if(!(eu<au)){for(let fu=su+2;;){if(au===void 0){if(eu<uu)break i;return su=tu.length,this._cachedIndex=su,this.copySampleValue_(su-1)}if(su===fu)break;if(uu=au,au=tu[++su],eu<au)break t}du=tu.length;break n}if(!(eu>=uu)){const fu=tu[1];eu<fu&&(su=2,uu=fu);for(let gu=su-2;;){if(uu===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(su===gu)break;if(au=uu,uu=tu[--su-1],eu>=uu)break t}du=su,su=0;break n}break e}for(;su<du;){const fu=su+du>>>1;eu<tu[fu]?du=fu:su=fu+1}if(au=tu[su],uu=tu[su-1],uu===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(au===void 0)return su=tu.length,this._cachedIndex=su,this.copySampleValue_(su-1)}this._cachedIndex=su,this.intervalChanged_(su,uu,au)}return this.interpolate_(su,uu,eu,au)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(eu){const tu=this.resultBuffer,su=this.sampleValues,au=this.valueSize,uu=eu*au;for(let du=0;du!==au;++du)tu[du]=su[uu+du];return tu}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(eu,tu,su,au){super(eu,tu,su,au),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(eu,tu,su){const au=this.parameterPositions;let uu=eu-2,du=eu+1,fu=au[uu],gu=au[du];if(fu===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:uu=eu,fu=2*tu-su;break;case WrapAroundEnding:uu=au.length-2,fu=tu+au[uu]-au[uu+1];break;default:uu=eu,fu=su}if(gu===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:du=eu,gu=2*su-tu;break;case WrapAroundEnding:du=1,gu=su+au[1]-au[0];break;default:du=eu-1,gu=tu}const yu=(su-tu)*.5,xu=this.valueSize;this._weightPrev=yu/(tu-fu),this._weightNext=yu/(gu-su),this._offsetPrev=uu*xu,this._offsetNext=du*xu}interpolate_(eu,tu,su,au){const uu=this.resultBuffer,du=this.sampleValues,fu=this.valueSize,gu=eu*fu,yu=gu-fu,xu=this._offsetPrev,vu=this._offsetNext,Su=this._weightPrev,Iu=this._weightNext,Mu=(su-tu)/(au-tu),ku=Mu*Mu,Bu=ku*Mu,_u=-Su*Bu+2*Su*ku-Su*Mu,Lu=(1+Su)*Bu+(-1.5-2*Su)*ku+(-.5+Su)*Mu+1,Du=(-1-Iu)*Bu+(1.5+Iu)*ku+.5*Mu,Ou=Iu*Bu-Iu*ku;for(let Wu=0;Wu!==fu;++Wu)uu[Wu]=_u*du[xu+Wu]+Lu*du[yu+Wu]+Du*du[gu+Wu]+Ou*du[vu+Wu];return uu}}class LinearInterpolant extends Interpolant{constructor(eu,tu,su,au){super(eu,tu,su,au)}interpolate_(eu,tu,su,au){const uu=this.resultBuffer,du=this.sampleValues,fu=this.valueSize,gu=eu*fu,yu=gu-fu,xu=(su-tu)/(au-tu),vu=1-xu;for(let Su=0;Su!==fu;++Su)uu[Su]=du[yu+Su]*vu+du[gu+Su]*xu;return uu}}class DiscreteInterpolant extends Interpolant{constructor(eu,tu,su,au){super(eu,tu,su,au)}interpolate_(eu){return this.copySampleValue_(eu-1)}}class KeyframeTrack{constructor(eu,tu,su,au){if(eu===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(tu===void 0||tu.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+eu);this.name=eu,this.times=convertArray(tu,this.TimeBufferType),this.values=convertArray(su,this.ValueBufferType),this.setInterpolation(au||this.DefaultInterpolation)}static toJSON(eu){const tu=eu.constructor;let su;if(tu.toJSON!==this.toJSON)su=tu.toJSON(eu);else{su={name:eu.name,times:convertArray(eu.times,Array),values:convertArray(eu.values,Array)};const au=eu.getInterpolation();au!==eu.DefaultInterpolation&&(su.interpolation=au)}return su.type=eu.ValueTypeName,su}InterpolantFactoryMethodDiscrete(eu){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),eu)}InterpolantFactoryMethodLinear(eu){return new LinearInterpolant(this.times,this.values,this.getValueSize(),eu)}InterpolantFactoryMethodSmooth(eu){return new CubicInterpolant(this.times,this.values,this.getValueSize(),eu)}setInterpolation(eu){let tu;switch(eu){case InterpolateDiscrete:tu=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:tu=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:tu=this.InterpolantFactoryMethodSmooth;break}if(tu===void 0){const su="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(eu!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(su);return console.warn("THREE.KeyframeTrack:",su),this}return this.createInterpolant=tu,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(eu){if(eu!==0){const tu=this.times;for(let su=0,au=tu.length;su!==au;++su)tu[su]+=eu}return this}scale(eu){if(eu!==1){const tu=this.times;for(let su=0,au=tu.length;su!==au;++su)tu[su]*=eu}return this}trim(eu,tu){const su=this.times,au=su.length;let uu=0,du=au-1;for(;uu!==au&&su[uu]<eu;)++uu;for(;du!==-1&&su[du]>tu;)--du;if(++du,uu!==0||du!==au){uu>=du&&(du=Math.max(du,1),uu=du-1);const fu=this.getValueSize();this.times=su.slice(uu,du),this.values=this.values.slice(uu*fu,du*fu)}return this}validate(){let eu=!0;const tu=this.getValueSize();tu-Math.floor(tu)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),eu=!1);const su=this.times,au=this.values,uu=su.length;uu===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),eu=!1);let du=null;for(let fu=0;fu!==uu;fu++){const gu=su[fu];if(typeof gu=="number"&&isNaN(gu)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,fu,gu),eu=!1;break}if(du!==null&&du>gu){console.error("THREE.KeyframeTrack: Out of order keys.",this,fu,gu,du),eu=!1;break}du=gu}if(au!==void 0&&isTypedArray$1(au))for(let fu=0,gu=au.length;fu!==gu;++fu){const yu=au[fu];if(isNaN(yu)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,fu,yu),eu=!1;break}}return eu}optimize(){const eu=this.times.slice(),tu=this.values.slice(),su=this.getValueSize(),au=this.getInterpolation()===InterpolateSmooth,uu=eu.length-1;let du=1;for(let fu=1;fu<uu;++fu){let gu=!1;const yu=eu[fu],xu=eu[fu+1];if(yu!==xu&&(fu!==1||yu!==eu[0]))if(au)gu=!0;else{const vu=fu*su,Su=vu-su,Iu=vu+su;for(let Mu=0;Mu!==su;++Mu){const ku=tu[vu+Mu];if(ku!==tu[Su+Mu]||ku!==tu[Iu+Mu]){gu=!0;break}}}if(gu){if(fu!==du){eu[du]=eu[fu];const vu=fu*su,Su=du*su;for(let Iu=0;Iu!==su;++Iu)tu[Su+Iu]=tu[vu+Iu]}++du}}if(uu>0){eu[du]=eu[uu];for(let fu=uu*su,gu=du*su,yu=0;yu!==su;++yu)tu[gu+yu]=tu[fu+yu];++du}return du!==eu.length?(this.times=eu.slice(0,du),this.values=tu.slice(0,du*su)):(this.times=eu,this.values=tu),this}clone(){const eu=this.times.slice(),tu=this.values.slice(),su=this.constructor,au=new su(this.name,eu,tu);return au.createInterpolant=this.createInterpolant,au}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{constructor(eu,tu,su){super(eu,tu,su)}}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(eu,tu,su,au){super(eu,tu,su,au)}interpolate_(eu,tu,su,au){const uu=this.resultBuffer,du=this.sampleValues,fu=this.valueSize,gu=(su-tu)/(au-tu);let yu=eu*fu;for(let xu=yu+fu;yu!==xu;yu+=4)Quaternion.slerpFlat(uu,0,du,yu-fu,du,yu,gu);return uu}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(eu){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),eu)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{constructor(eu,tu,su){super(eu,tu,su)}}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(eu="",tu=-1,su=[],au=NormalAnimationBlendMode){this.name=eu,this.tracks=su,this.duration=tu,this.blendMode=au,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(eu){const tu=[],su=eu.tracks,au=1/(eu.fps||1);for(let du=0,fu=su.length;du!==fu;++du)tu.push(parseKeyframeTrack(su[du]).scale(au));const uu=new this(eu.name,eu.duration,tu,eu.blendMode);return uu.uuid=eu.uuid,uu}static toJSON(eu){const tu=[],su=eu.tracks,au={name:eu.name,duration:eu.duration,tracks:tu,uuid:eu.uuid,blendMode:eu.blendMode};for(let uu=0,du=su.length;uu!==du;++uu)tu.push(KeyframeTrack.toJSON(su[uu]));return au}static CreateFromMorphTargetSequence(eu,tu,su,au){const uu=tu.length,du=[];for(let fu=0;fu<uu;fu++){let gu=[],yu=[];gu.push((fu+uu-1)%uu,fu,(fu+1)%uu),yu.push(0,1,0);const xu=getKeyframeOrder(gu);gu=sortedArray(gu,1,xu),yu=sortedArray(yu,1,xu),!au&&gu[0]===0&&(gu.push(uu),yu.push(yu[0])),du.push(new NumberKeyframeTrack(".morphTargetInfluences["+tu[fu].name+"]",gu,yu).scale(1/su))}return new this(eu,-1,du)}static findByName(eu,tu){let su=eu;if(!Array.isArray(eu)){const au=eu;su=au.geometry&&au.geometry.animations||au.animations}for(let au=0;au<su.length;au++)if(su[au].name===tu)return su[au];return null}static CreateClipsFromMorphTargetSequences(eu,tu,su){const au={},uu=/^([\w-]*?)([\d]+)$/;for(let fu=0,gu=eu.length;fu<gu;fu++){const yu=eu[fu],xu=yu.name.match(uu);if(xu&&xu.length>1){const vu=xu[1];let Su=au[vu];Su||(au[vu]=Su=[]),Su.push(yu)}}const du=[];for(const fu in au)du.push(this.CreateFromMorphTargetSequence(fu,au[fu],tu,su));return du}static parseAnimation(eu,tu){if(!eu)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const su=function(vu,Su,Iu,Mu,ku){if(Iu.length!==0){const Bu=[],_u=[];flattenJSON(Iu,Bu,_u,Mu),Bu.length!==0&&ku.push(new vu(Su,Bu,_u))}},au=[],uu=eu.name||"default",du=eu.fps||30,fu=eu.blendMode;let gu=eu.length||-1;const yu=eu.hierarchy||[];for(let vu=0;vu<yu.length;vu++){const Su=yu[vu].keys;if(!(!Su||Su.length===0))if(Su[0].morphTargets){const Iu={};let Mu;for(Mu=0;Mu<Su.length;Mu++)if(Su[Mu].morphTargets)for(let ku=0;ku<Su[Mu].morphTargets.length;ku++)Iu[Su[Mu].morphTargets[ku]]=-1;for(const ku in Iu){const Bu=[],_u=[];for(let Lu=0;Lu!==Su[Mu].morphTargets.length;++Lu){const Du=Su[Mu];Bu.push(Du.time),_u.push(Du.morphTarget===ku?1:0)}au.push(new NumberKeyframeTrack(".morphTargetInfluence["+ku+"]",Bu,_u))}gu=Iu.length*du}else{const Iu=".bones["+tu[vu].name+"]";su(VectorKeyframeTrack,Iu+".position",Su,"pos",au),su(QuaternionKeyframeTrack,Iu+".quaternion",Su,"rot",au),su(VectorKeyframeTrack,Iu+".scale",Su,"scl",au)}}return au.length===0?null:new this(uu,gu,au,fu)}resetDuration(){const eu=this.tracks;let tu=0;for(let su=0,au=eu.length;su!==au;++su){const uu=this.tracks[su];tu=Math.max(tu,uu.times[uu.times.length-1])}return this.duration=tu,this}trim(){for(let eu=0;eu<this.tracks.length;eu++)this.tracks[eu].trim(0,this.duration);return this}validate(){let eu=!0;for(let tu=0;tu<this.tracks.length;tu++)eu=eu&&this.tracks[tu].validate();return eu}optimize(){for(let eu=0;eu<this.tracks.length;eu++)this.tracks[eu].optimize();return this}clone(){const eu=[];for(let tu=0;tu<this.tracks.length;tu++)eu.push(this.tracks[tu].clone());return new this.constructor(this.name,this.duration,eu,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(iu){switch(iu.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+iu)}function parseKeyframeTrack(iu){if(iu.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const eu=getTrackTypeForValueTypeName(iu.type);if(iu.times===void 0){const tu=[],su=[];flattenJSON(iu.keys,tu,su,"value"),iu.times=tu,iu.values=su}return eu.parse!==void 0?eu.parse(iu):new eu(iu.name,iu.times,iu.values,iu.interpolation)}const Cache={enabled:!1,files:{},add:function(iu,eu){this.enabled!==!1&&(this.files[iu]=eu)},get:function(iu){if(this.enabled!==!1)return this.files[iu]},remove:function(iu){delete this.files[iu]},clear:function(){this.files={}}};class LoadingManager{constructor(eu,tu,su){const au=this;let uu=!1,du=0,fu=0,gu;const yu=[];this.onStart=void 0,this.onLoad=eu,this.onProgress=tu,this.onError=su,this.itemStart=function(xu){fu++,uu===!1&&au.onStart!==void 0&&au.onStart(xu,du,fu),uu=!0},this.itemEnd=function(xu){du++,au.onProgress!==void 0&&au.onProgress(xu,du,fu),du===fu&&(uu=!1,au.onLoad!==void 0&&au.onLoad())},this.itemError=function(xu){au.onError!==void 0&&au.onError(xu)},this.resolveURL=function(xu){return gu?gu(xu):xu},this.setURLModifier=function(xu){return gu=xu,this},this.addHandler=function(xu,vu){return yu.push(xu,vu),this},this.removeHandler=function(xu){const vu=yu.indexOf(xu);return vu!==-1&&yu.splice(vu,2),this},this.getHandler=function(xu){for(let vu=0,Su=yu.length;vu<Su;vu+=2){const Iu=yu[vu],Mu=yu[vu+1];if(Iu.global&&(Iu.lastIndex=0),Iu.test(xu))return Mu}return null}}}const DefaultLoadingManager=new LoadingManager;let Loader$1=class{constructor(eu){this.manager=eu!==void 0?eu:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(eu,tu){const su=this;return new Promise(function(au,uu){su.load(eu,au,tu,uu)})}parse(){}setCrossOrigin(eu){return this.crossOrigin=eu,this}setWithCredentials(eu){return this.withCredentials=eu,this}setPath(eu){return this.path=eu,this}setResourcePath(eu){return this.resourcePath=eu,this}setRequestHeader(eu){return this.requestHeader=eu,this}};Loader$1.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(eu,tu){super(eu),this.response=tu}}class FileLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){eu===void 0&&(eu=""),this.path!==void 0&&(eu=this.path+eu),eu=this.manager.resolveURL(eu);const uu=Cache.get(eu);if(uu!==void 0)return this.manager.itemStart(eu),setTimeout(()=>{tu&&tu(uu),this.manager.itemEnd(eu)},0),uu;if(loading[eu]!==void 0){loading[eu].push({onLoad:tu,onProgress:su,onError:au});return}loading[eu]=[],loading[eu].push({onLoad:tu,onProgress:su,onError:au});const du=new Request(eu,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),fu=this.mimeType,gu=this.responseType;fetch(du).then(yu=>{if(yu.status===200||yu.status===0){if(yu.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||yu.body===void 0||yu.body.getReader===void 0)return yu;const xu=loading[eu],vu=yu.body.getReader(),Su=yu.headers.get("X-File-Size")||yu.headers.get("Content-Length"),Iu=Su?parseInt(Su):0,Mu=Iu!==0;let ku=0;const Bu=new ReadableStream({start(_u){Lu();function Lu(){vu.read().then(({done:Du,value:Ou})=>{if(Du)_u.close();else{ku+=Ou.byteLength;const Wu=new ProgressEvent("progress",{lengthComputable:Mu,loaded:ku,total:Iu});for(let Zu=0,Hu=xu.length;Zu<Hu;Zu++){const Yu=xu[Zu];Yu.onProgress&&Yu.onProgress(Wu)}_u.enqueue(Ou),Lu()}},Du=>{_u.error(Du)})}}});return new Response(Bu)}else throw new HttpError(`fetch for "${yu.url}" responded with ${yu.status}: ${yu.statusText}`,yu)}).then(yu=>{switch(gu){case"arraybuffer":return yu.arrayBuffer();case"blob":return yu.blob();case"document":return yu.text().then(xu=>new DOMParser().parseFromString(xu,fu));case"json":return yu.json();default:if(fu===void 0)return yu.text();{const vu=/charset="?([^;"\s]*)"?/i.exec(fu),Su=vu&&vu[1]?vu[1].toLowerCase():void 0,Iu=new TextDecoder(Su);return yu.arrayBuffer().then(Mu=>Iu.decode(Mu))}}}).then(yu=>{Cache.add(eu,yu);const xu=loading[eu];delete loading[eu];for(let vu=0,Su=xu.length;vu<Su;vu++){const Iu=xu[vu];Iu.onLoad&&Iu.onLoad(yu)}}).catch(yu=>{const xu=loading[eu];if(xu===void 0)throw this.manager.itemError(eu),yu;delete loading[eu];for(let vu=0,Su=xu.length;vu<Su;vu++){const Iu=xu[vu];Iu.onError&&Iu.onError(yu)}this.manager.itemError(eu)}).finally(()=>{this.manager.itemEnd(eu)}),this.manager.itemStart(eu)}setResponseType(eu){return this.responseType=eu,this}setMimeType(eu){return this.mimeType=eu,this}}class AnimationLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=new FileLoader(this.manager);du.setPath(this.path),du.setRequestHeader(this.requestHeader),du.setWithCredentials(this.withCredentials),du.load(eu,function(fu){try{tu(uu.parse(JSON.parse(fu)))}catch(gu){au?au(gu):console.error(gu),uu.manager.itemError(eu)}},su,au)}parse(eu){const tu=[];for(let su=0;su<eu.length;su++){const au=AnimationClip.parse(eu[su]);tu.push(au)}return tu}}class CompressedTextureLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=[],fu=new CompressedTexture,gu=new FileLoader(this.manager);gu.setPath(this.path),gu.setResponseType("arraybuffer"),gu.setRequestHeader(this.requestHeader),gu.setWithCredentials(uu.withCredentials);let yu=0;function xu(vu){gu.load(eu[vu],function(Su){const Iu=uu.parse(Su,!0);du[vu]={width:Iu.width,height:Iu.height,format:Iu.format,mipmaps:Iu.mipmaps},yu+=1,yu===6&&(Iu.mipmapCount===1&&(fu.minFilter=LinearFilter),fu.image=du,fu.format=Iu.format,fu.needsUpdate=!0,tu&&tu(fu))},su,au)}if(Array.isArray(eu))for(let vu=0,Su=eu.length;vu<Su;++vu)xu(vu);else gu.load(eu,function(vu){const Su=uu.parse(vu,!0);if(Su.isCubemap){const Iu=Su.mipmaps.length/Su.mipmapCount;for(let Mu=0;Mu<Iu;Mu++){du[Mu]={mipmaps:[]};for(let ku=0;ku<Su.mipmapCount;ku++)du[Mu].mipmaps.push(Su.mipmaps[Mu*Su.mipmapCount+ku]),du[Mu].format=Su.format,du[Mu].width=Su.width,du[Mu].height=Su.height}fu.image=du}else fu.image.width=Su.width,fu.image.height=Su.height,fu.mipmaps=Su.mipmaps;Su.mipmapCount===1&&(fu.minFilter=LinearFilter),fu.format=Su.format,fu.needsUpdate=!0,tu&&tu(fu)},su,au);return fu}}class ImageLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){this.path!==void 0&&(eu=this.path+eu),eu=this.manager.resolveURL(eu);const uu=this,du=Cache.get(eu);if(du!==void 0)return uu.manager.itemStart(eu),setTimeout(function(){tu&&tu(du),uu.manager.itemEnd(eu)},0),du;const fu=createElementNS("img");function gu(){xu(),Cache.add(eu,this),tu&&tu(this),uu.manager.itemEnd(eu)}function yu(vu){xu(),au&&au(vu),uu.manager.itemError(eu),uu.manager.itemEnd(eu)}function xu(){fu.removeEventListener("load",gu,!1),fu.removeEventListener("error",yu,!1)}return fu.addEventListener("load",gu,!1),fu.addEventListener("error",yu,!1),eu.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(fu.crossOrigin=this.crossOrigin),uu.manager.itemStart(eu),fu.src=eu,fu}}class CubeTextureLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=new CubeTexture;uu.colorSpace=SRGBColorSpace;const du=new ImageLoader(this.manager);du.setCrossOrigin(this.crossOrigin),du.setPath(this.path);let fu=0;function gu(yu){du.load(eu[yu],function(xu){uu.images[yu]=xu,fu++,fu===6&&(uu.needsUpdate=!0,tu&&tu(uu))},void 0,au)}for(let yu=0;yu<eu.length;++yu)gu(yu);return uu}}class DataTextureLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=new DataTexture,fu=new FileLoader(this.manager);return fu.setResponseType("arraybuffer"),fu.setRequestHeader(this.requestHeader),fu.setPath(this.path),fu.setWithCredentials(uu.withCredentials),fu.load(eu,function(gu){let yu;try{yu=uu.parse(gu)}catch(xu){if(au!==void 0)au(xu);else{console.error(xu);return}}yu.image!==void 0?du.image=yu.image:yu.data!==void 0&&(du.image.width=yu.width,du.image.height=yu.height,du.image.data=yu.data),du.wrapS=yu.wrapS!==void 0?yu.wrapS:ClampToEdgeWrapping,du.wrapT=yu.wrapT!==void 0?yu.wrapT:ClampToEdgeWrapping,du.magFilter=yu.magFilter!==void 0?yu.magFilter:LinearFilter,du.minFilter=yu.minFilter!==void 0?yu.minFilter:LinearFilter,du.anisotropy=yu.anisotropy!==void 0?yu.anisotropy:1,yu.colorSpace!==void 0&&(du.colorSpace=yu.colorSpace),yu.flipY!==void 0&&(du.flipY=yu.flipY),yu.format!==void 0&&(du.format=yu.format),yu.type!==void 0&&(du.type=yu.type),yu.mipmaps!==void 0&&(du.mipmaps=yu.mipmaps,du.minFilter=LinearMipmapLinearFilter),yu.mipmapCount===1&&(du.minFilter=LinearFilter),yu.generateMipmaps!==void 0&&(du.generateMipmaps=yu.generateMipmaps),du.needsUpdate=!0,tu&&tu(du,yu)},su,au),du}}class TextureLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=new Texture,du=new ImageLoader(this.manager);return du.setCrossOrigin(this.crossOrigin),du.setPath(this.path),du.load(eu,function(fu){uu.image=fu,uu.needsUpdate=!0,tu!==void 0&&tu(uu)},su,au),uu}}class Light extends Object3D{constructor(eu,tu=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(eu),this.intensity=tu}dispose(){}copy(eu,tu){return super.copy(eu,tu),this.color.copy(eu.color),this.intensity=eu.intensity,this}toJSON(eu){const tu=super.toJSON(eu);return tu.object.color=this.color.getHex(),tu.object.intensity=this.intensity,this.groundColor!==void 0&&(tu.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(tu.object.distance=this.distance),this.angle!==void 0&&(tu.object.angle=this.angle),this.decay!==void 0&&(tu.object.decay=this.decay),this.penumbra!==void 0&&(tu.object.penumbra=this.penumbra),this.shadow!==void 0&&(tu.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(tu.object.target=this.target.uuid),tu}}class HemisphereLight extends Light{constructor(eu,tu,su){super(eu,su),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Color(tu)}copy(eu,tu){return super.copy(eu,tu),this.groundColor.copy(eu.groundColor),this}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(eu){this.camera=eu,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(eu){const tu=this.camera,su=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(eu.matrixWorld),tu.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(eu.target.matrixWorld),tu.lookAt(_lookTarget$1),tu.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(tu.projectionMatrix,tu.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),su.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),su.multiply(_projScreenMatrix$1)}getViewport(eu){return this._viewports[eu]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(eu){return this.camera=eu.camera.clone(),this.intensity=eu.intensity,this.bias=eu.bias,this.radius=eu.radius,this.mapSize.copy(eu.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const eu={};return this.intensity!==1&&(eu.intensity=this.intensity),this.bias!==0&&(eu.bias=this.bias),this.normalBias!==0&&(eu.normalBias=this.normalBias),this.radius!==1&&(eu.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(eu.mapSize=this.mapSize.toArray()),eu.camera=this.camera.toJSON(!1).object,delete eu.camera.matrix,eu}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(eu){const tu=this.camera,su=RAD2DEG*2*eu.angle*this.focus,au=this.mapSize.width/this.mapSize.height,uu=eu.distance||tu.far;(su!==tu.fov||au!==tu.aspect||uu!==tu.far)&&(tu.fov=su,tu.aspect=au,tu.far=uu,tu.updateProjectionMatrix()),super.updateMatrices(eu)}copy(eu){return super.copy(eu),this.focus=eu.focus,this}}class SpotLight extends Light{constructor(eu,tu,su=0,au=Math.PI/3,uu=0,du=2){super(eu,tu),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=su,this.angle=au,this.penumbra=uu,this.decay=du,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(eu){this.intensity=eu/Math.PI}dispose(){this.shadow.dispose()}copy(eu,tu){return super.copy(eu,tu),this.distance=eu.distance,this.angle=eu.angle,this.penumbra=eu.penumbra,this.decay=eu.decay,this.target=eu.target.clone(),this.shadow=eu.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(eu,tu=0){const su=this.camera,au=this.matrix,uu=eu.distance||su.far;uu!==su.far&&(su.far=uu,su.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(eu.matrixWorld),su.position.copy(_lightPositionWorld),_lookTarget.copy(su.position),_lookTarget.add(this._cubeDirections[tu]),su.up.copy(this._cubeUps[tu]),su.lookAt(_lookTarget),su.updateMatrixWorld(),au.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(su.projectionMatrix,su.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(eu,tu,su=0,au=2){super(eu,tu),this.isPointLight=!0,this.type="PointLight",this.distance=su,this.decay=au,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(eu){this.intensity=eu/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(eu,tu){return super.copy(eu,tu),this.distance=eu.distance,this.decay=eu.decay,this.shadow=eu.shadow.clone(),this}}class OrthographicCamera extends Camera{constructor(eu=-1,tu=1,su=1,au=-1,uu=.1,du=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=eu,this.right=tu,this.top=su,this.bottom=au,this.near=uu,this.far=du,this.updateProjectionMatrix()}copy(eu,tu){return super.copy(eu,tu),this.left=eu.left,this.right=eu.right,this.top=eu.top,this.bottom=eu.bottom,this.near=eu.near,this.far=eu.far,this.zoom=eu.zoom,this.view=eu.view===null?null:Object.assign({},eu.view),this}setViewOffset(eu,tu,su,au,uu,du){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=eu,this.view.fullHeight=tu,this.view.offsetX=su,this.view.offsetY=au,this.view.width=uu,this.view.height=du,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const eu=(this.right-this.left)/(2*this.zoom),tu=(this.top-this.bottom)/(2*this.zoom),su=(this.right+this.left)/2,au=(this.top+this.bottom)/2;let uu=su-eu,du=su+eu,fu=au+tu,gu=au-tu;if(this.view!==null&&this.view.enabled){const yu=(this.right-this.left)/this.view.fullWidth/this.zoom,xu=(this.top-this.bottom)/this.view.fullHeight/this.zoom;uu+=yu*this.view.offsetX,du=uu+yu*this.view.width,fu-=xu*this.view.offsetY,gu=fu-xu*this.view.height}this.projectionMatrix.makeOrthographic(uu,du,fu,gu,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(eu){const tu=super.toJSON(eu);return tu.object.zoom=this.zoom,tu.object.left=this.left,tu.object.right=this.right,tu.object.top=this.top,tu.object.bottom=this.bottom,tu.object.near=this.near,tu.object.far=this.far,this.view!==null&&(tu.object.view=Object.assign({},this.view)),tu}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(eu,tu){super(eu,tu),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(eu){return super.copy(eu),this.target=eu.target.clone(),this.shadow=eu.shadow.clone(),this}}class AmbientLight extends Light{constructor(eu,tu){super(eu,tu),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(eu,tu,su=10,au=10){super(eu,tu),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=su,this.height=au}get power(){return this.intensity*this.width*this.height*Math.PI}set power(eu){this.intensity=eu/(this.width*this.height*Math.PI)}copy(eu){return super.copy(eu),this.width=eu.width,this.height=eu.height,this}toJSON(eu){const tu=super.toJSON(eu);return tu.object.width=this.width,tu.object.height=this.height,tu}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let eu=0;eu<9;eu++)this.coefficients.push(new Vector3)}set(eu){for(let tu=0;tu<9;tu++)this.coefficients[tu].copy(eu[tu]);return this}zero(){for(let eu=0;eu<9;eu++)this.coefficients[eu].set(0,0,0);return this}getAt(eu,tu){const su=eu.x,au=eu.y,uu=eu.z,du=this.coefficients;return tu.copy(du[0]).multiplyScalar(.282095),tu.addScaledVector(du[1],.488603*au),tu.addScaledVector(du[2],.488603*uu),tu.addScaledVector(du[3],.488603*su),tu.addScaledVector(du[4],1.092548*(su*au)),tu.addScaledVector(du[5],1.092548*(au*uu)),tu.addScaledVector(du[6],.315392*(3*uu*uu-1)),tu.addScaledVector(du[7],1.092548*(su*uu)),tu.addScaledVector(du[8],.546274*(su*su-au*au)),tu}getIrradianceAt(eu,tu){const su=eu.x,au=eu.y,uu=eu.z,du=this.coefficients;return tu.copy(du[0]).multiplyScalar(.886227),tu.addScaledVector(du[1],2*.511664*au),tu.addScaledVector(du[2],2*.511664*uu),tu.addScaledVector(du[3],2*.511664*su),tu.addScaledVector(du[4],2*.429043*su*au),tu.addScaledVector(du[5],2*.429043*au*uu),tu.addScaledVector(du[6],.743125*uu*uu-.247708),tu.addScaledVector(du[7],2*.429043*su*uu),tu.addScaledVector(du[8],.429043*(su*su-au*au)),tu}add(eu){for(let tu=0;tu<9;tu++)this.coefficients[tu].add(eu.coefficients[tu]);return this}addScaledSH(eu,tu){for(let su=0;su<9;su++)this.coefficients[su].addScaledVector(eu.coefficients[su],tu);return this}scale(eu){for(let tu=0;tu<9;tu++)this.coefficients[tu].multiplyScalar(eu);return this}lerp(eu,tu){for(let su=0;su<9;su++)this.coefficients[su].lerp(eu.coefficients[su],tu);return this}equals(eu){for(let tu=0;tu<9;tu++)if(!this.coefficients[tu].equals(eu.coefficients[tu]))return!1;return!0}copy(eu){return this.set(eu.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(eu,tu=0){const su=this.coefficients;for(let au=0;au<9;au++)su[au].fromArray(eu,tu+au*3);return this}toArray(eu=[],tu=0){const su=this.coefficients;for(let au=0;au<9;au++)su[au].toArray(eu,tu+au*3);return eu}static getBasisAt(eu,tu){const su=eu.x,au=eu.y,uu=eu.z;tu[0]=.282095,tu[1]=.488603*au,tu[2]=.488603*uu,tu[3]=.488603*su,tu[4]=1.092548*su*au,tu[5]=1.092548*au*uu,tu[6]=.315392*(3*uu*uu-1),tu[7]=1.092548*su*uu,tu[8]=.546274*(su*su-au*au)}}class LightProbe extends Light{constructor(eu=new SphericalHarmonics3,tu=1){super(void 0,tu),this.isLightProbe=!0,this.sh=eu}copy(eu){return super.copy(eu),this.sh.copy(eu.sh),this}fromJSON(eu){return this.intensity=eu.intensity,this.sh.fromArray(eu.sh),this}toJSON(eu){const tu=super.toJSON(eu);return tu.object.sh=this.sh.toArray(),tu}}class MaterialLoader extends Loader$1{constructor(eu){super(eu),this.textures={}}load(eu,tu,su,au){const uu=this,du=new FileLoader(uu.manager);du.setPath(uu.path),du.setRequestHeader(uu.requestHeader),du.setWithCredentials(uu.withCredentials),du.load(eu,function(fu){try{tu(uu.parse(JSON.parse(fu)))}catch(gu){au?au(gu):console.error(gu),uu.manager.itemError(eu)}},su,au)}parse(eu){const tu=this.textures;function su(uu){return tu[uu]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",uu),tu[uu]}const au=this.createMaterialFromType(eu.type);if(eu.uuid!==void 0&&(au.uuid=eu.uuid),eu.name!==void 0&&(au.name=eu.name),eu.color!==void 0&&au.color!==void 0&&au.color.setHex(eu.color),eu.roughness!==void 0&&(au.roughness=eu.roughness),eu.metalness!==void 0&&(au.metalness=eu.metalness),eu.sheen!==void 0&&(au.sheen=eu.sheen),eu.sheenColor!==void 0&&(au.sheenColor=new Color().setHex(eu.sheenColor)),eu.sheenRoughness!==void 0&&(au.sheenRoughness=eu.sheenRoughness),eu.emissive!==void 0&&au.emissive!==void 0&&au.emissive.setHex(eu.emissive),eu.specular!==void 0&&au.specular!==void 0&&au.specular.setHex(eu.specular),eu.specularIntensity!==void 0&&(au.specularIntensity=eu.specularIntensity),eu.specularColor!==void 0&&au.specularColor!==void 0&&au.specularColor.setHex(eu.specularColor),eu.shininess!==void 0&&(au.shininess=eu.shininess),eu.clearcoat!==void 0&&(au.clearcoat=eu.clearcoat),eu.clearcoatRoughness!==void 0&&(au.clearcoatRoughness=eu.clearcoatRoughness),eu.dispersion!==void 0&&(au.dispersion=eu.dispersion),eu.iridescence!==void 0&&(au.iridescence=eu.iridescence),eu.iridescenceIOR!==void 0&&(au.iridescenceIOR=eu.iridescenceIOR),eu.iridescenceThicknessRange!==void 0&&(au.iridescenceThicknessRange=eu.iridescenceThicknessRange),eu.transmission!==void 0&&(au.transmission=eu.transmission),eu.thickness!==void 0&&(au.thickness=eu.thickness),eu.attenuationDistance!==void 0&&(au.attenuationDistance=eu.attenuationDistance),eu.attenuationColor!==void 0&&au.attenuationColor!==void 0&&au.attenuationColor.setHex(eu.attenuationColor),eu.anisotropy!==void 0&&(au.anisotropy=eu.anisotropy),eu.anisotropyRotation!==void 0&&(au.anisotropyRotation=eu.anisotropyRotation),eu.fog!==void 0&&(au.fog=eu.fog),eu.flatShading!==void 0&&(au.flatShading=eu.flatShading),eu.blending!==void 0&&(au.blending=eu.blending),eu.combine!==void 0&&(au.combine=eu.combine),eu.side!==void 0&&(au.side=eu.side),eu.shadowSide!==void 0&&(au.shadowSide=eu.shadowSide),eu.opacity!==void 0&&(au.opacity=eu.opacity),eu.transparent!==void 0&&(au.transparent=eu.transparent),eu.alphaTest!==void 0&&(au.alphaTest=eu.alphaTest),eu.alphaHash!==void 0&&(au.alphaHash=eu.alphaHash),eu.depthFunc!==void 0&&(au.depthFunc=eu.depthFunc),eu.depthTest!==void 0&&(au.depthTest=eu.depthTest),eu.depthWrite!==void 0&&(au.depthWrite=eu.depthWrite),eu.colorWrite!==void 0&&(au.colorWrite=eu.colorWrite),eu.blendSrc!==void 0&&(au.blendSrc=eu.blendSrc),eu.blendDst!==void 0&&(au.blendDst=eu.blendDst),eu.blendEquation!==void 0&&(au.blendEquation=eu.blendEquation),eu.blendSrcAlpha!==void 0&&(au.blendSrcAlpha=eu.blendSrcAlpha),eu.blendDstAlpha!==void 0&&(au.blendDstAlpha=eu.blendDstAlpha),eu.blendEquationAlpha!==void 0&&(au.blendEquationAlpha=eu.blendEquationAlpha),eu.blendColor!==void 0&&au.blendColor!==void 0&&au.blendColor.setHex(eu.blendColor),eu.blendAlpha!==void 0&&(au.blendAlpha=eu.blendAlpha),eu.stencilWriteMask!==void 0&&(au.stencilWriteMask=eu.stencilWriteMask),eu.stencilFunc!==void 0&&(au.stencilFunc=eu.stencilFunc),eu.stencilRef!==void 0&&(au.stencilRef=eu.stencilRef),eu.stencilFuncMask!==void 0&&(au.stencilFuncMask=eu.stencilFuncMask),eu.stencilFail!==void 0&&(au.stencilFail=eu.stencilFail),eu.stencilZFail!==void 0&&(au.stencilZFail=eu.stencilZFail),eu.stencilZPass!==void 0&&(au.stencilZPass=eu.stencilZPass),eu.stencilWrite!==void 0&&(au.stencilWrite=eu.stencilWrite),eu.wireframe!==void 0&&(au.wireframe=eu.wireframe),eu.wireframeLinewidth!==void 0&&(au.wireframeLinewidth=eu.wireframeLinewidth),eu.wireframeLinecap!==void 0&&(au.wireframeLinecap=eu.wireframeLinecap),eu.wireframeLinejoin!==void 0&&(au.wireframeLinejoin=eu.wireframeLinejoin),eu.rotation!==void 0&&(au.rotation=eu.rotation),eu.linewidth!==void 0&&(au.linewidth=eu.linewidth),eu.dashSize!==void 0&&(au.dashSize=eu.dashSize),eu.gapSize!==void 0&&(au.gapSize=eu.gapSize),eu.scale!==void 0&&(au.scale=eu.scale),eu.polygonOffset!==void 0&&(au.polygonOffset=eu.polygonOffset),eu.polygonOffsetFactor!==void 0&&(au.polygonOffsetFactor=eu.polygonOffsetFactor),eu.polygonOffsetUnits!==void 0&&(au.polygonOffsetUnits=eu.polygonOffsetUnits),eu.dithering!==void 0&&(au.dithering=eu.dithering),eu.alphaToCoverage!==void 0&&(au.alphaToCoverage=eu.alphaToCoverage),eu.premultipliedAlpha!==void 0&&(au.premultipliedAlpha=eu.premultipliedAlpha),eu.forceSinglePass!==void 0&&(au.forceSinglePass=eu.forceSinglePass),eu.visible!==void 0&&(au.visible=eu.visible),eu.toneMapped!==void 0&&(au.toneMapped=eu.toneMapped),eu.userData!==void 0&&(au.userData=eu.userData),eu.vertexColors!==void 0&&(typeof eu.vertexColors=="number"?au.vertexColors=eu.vertexColors>0:au.vertexColors=eu.vertexColors),eu.uniforms!==void 0)for(const uu in eu.uniforms){const du=eu.uniforms[uu];switch(au.uniforms[uu]={},du.type){case"t":au.uniforms[uu].value=su(du.value);break;case"c":au.uniforms[uu].value=new Color().setHex(du.value);break;case"v2":au.uniforms[uu].value=new Vector2().fromArray(du.value);break;case"v3":au.uniforms[uu].value=new Vector3().fromArray(du.value);break;case"v4":au.uniforms[uu].value=new Vector4().fromArray(du.value);break;case"m3":au.uniforms[uu].value=new Matrix3().fromArray(du.value);break;case"m4":au.uniforms[uu].value=new Matrix4().fromArray(du.value);break;default:au.uniforms[uu].value=du.value}}if(eu.defines!==void 0&&(au.defines=eu.defines),eu.vertexShader!==void 0&&(au.vertexShader=eu.vertexShader),eu.fragmentShader!==void 0&&(au.fragmentShader=eu.fragmentShader),eu.glslVersion!==void 0&&(au.glslVersion=eu.glslVersion),eu.extensions!==void 0)for(const uu in eu.extensions)au.extensions[uu]=eu.extensions[uu];if(eu.lights!==void 0&&(au.lights=eu.lights),eu.clipping!==void 0&&(au.clipping=eu.clipping),eu.size!==void 0&&(au.size=eu.size),eu.sizeAttenuation!==void 0&&(au.sizeAttenuation=eu.sizeAttenuation),eu.map!==void 0&&(au.map=su(eu.map)),eu.matcap!==void 0&&(au.matcap=su(eu.matcap)),eu.alphaMap!==void 0&&(au.alphaMap=su(eu.alphaMap)),eu.bumpMap!==void 0&&(au.bumpMap=su(eu.bumpMap)),eu.bumpScale!==void 0&&(au.bumpScale=eu.bumpScale),eu.normalMap!==void 0&&(au.normalMap=su(eu.normalMap)),eu.normalMapType!==void 0&&(au.normalMapType=eu.normalMapType),eu.normalScale!==void 0){let uu=eu.normalScale;Array.isArray(uu)===!1&&(uu=[uu,uu]),au.normalScale=new Vector2().fromArray(uu)}return eu.displacementMap!==void 0&&(au.displacementMap=su(eu.displacementMap)),eu.displacementScale!==void 0&&(au.displacementScale=eu.displacementScale),eu.displacementBias!==void 0&&(au.displacementBias=eu.displacementBias),eu.roughnessMap!==void 0&&(au.roughnessMap=su(eu.roughnessMap)),eu.metalnessMap!==void 0&&(au.metalnessMap=su(eu.metalnessMap)),eu.emissiveMap!==void 0&&(au.emissiveMap=su(eu.emissiveMap)),eu.emissiveIntensity!==void 0&&(au.emissiveIntensity=eu.emissiveIntensity),eu.specularMap!==void 0&&(au.specularMap=su(eu.specularMap)),eu.specularIntensityMap!==void 0&&(au.specularIntensityMap=su(eu.specularIntensityMap)),eu.specularColorMap!==void 0&&(au.specularColorMap=su(eu.specularColorMap)),eu.envMap!==void 0&&(au.envMap=su(eu.envMap)),eu.envMapRotation!==void 0&&au.envMapRotation.fromArray(eu.envMapRotation),eu.envMapIntensity!==void 0&&(au.envMapIntensity=eu.envMapIntensity),eu.reflectivity!==void 0&&(au.reflectivity=eu.reflectivity),eu.refractionRatio!==void 0&&(au.refractionRatio=eu.refractionRatio),eu.lightMap!==void 0&&(au.lightMap=su(eu.lightMap)),eu.lightMapIntensity!==void 0&&(au.lightMapIntensity=eu.lightMapIntensity),eu.aoMap!==void 0&&(au.aoMap=su(eu.aoMap)),eu.aoMapIntensity!==void 0&&(au.aoMapIntensity=eu.aoMapIntensity),eu.gradientMap!==void 0&&(au.gradientMap=su(eu.gradientMap)),eu.clearcoatMap!==void 0&&(au.clearcoatMap=su(eu.clearcoatMap)),eu.clearcoatRoughnessMap!==void 0&&(au.clearcoatRoughnessMap=su(eu.clearcoatRoughnessMap)),eu.clearcoatNormalMap!==void 0&&(au.clearcoatNormalMap=su(eu.clearcoatNormalMap)),eu.clearcoatNormalScale!==void 0&&(au.clearcoatNormalScale=new Vector2().fromArray(eu.clearcoatNormalScale)),eu.iridescenceMap!==void 0&&(au.iridescenceMap=su(eu.iridescenceMap)),eu.iridescenceThicknessMap!==void 0&&(au.iridescenceThicknessMap=su(eu.iridescenceThicknessMap)),eu.transmissionMap!==void 0&&(au.transmissionMap=su(eu.transmissionMap)),eu.thicknessMap!==void 0&&(au.thicknessMap=su(eu.thicknessMap)),eu.anisotropyMap!==void 0&&(au.anisotropyMap=su(eu.anisotropyMap)),eu.sheenColorMap!==void 0&&(au.sheenColorMap=su(eu.sheenColorMap)),eu.sheenRoughnessMap!==void 0&&(au.sheenRoughnessMap=su(eu.sheenRoughnessMap)),au}setTextures(eu){return this.textures=eu,this}createMaterialFromType(eu){return MaterialLoader.createMaterialFromType(eu)}static createMaterialFromType(eu){const tu={ShadowMaterial,SpriteMaterial,RawShaderMaterial,ShaderMaterial,PointsMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshPhongMaterial,MeshToonMaterial,MeshNormalMaterial,MeshLambertMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshBasicMaterial,MeshMatcapMaterial,LineDashedMaterial,LineBasicMaterial,Material};return new tu[eu]}}class LoaderUtils{static decodeText(eu){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(eu);let tu="";for(let su=0,au=eu.length;su<au;su++)tu+=String.fromCharCode(eu[su]);try{return decodeURIComponent(escape(tu))}catch{return tu}}static extractUrlBase(eu){const tu=eu.lastIndexOf("/");return tu===-1?"./":eu.slice(0,tu+1)}static resolveURL(eu,tu){return typeof eu!="string"||eu===""?"":(/^https?:\/\//i.test(tu)&&/^\//.test(eu)&&(tu=tu.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(eu)||/^data:.*,.*$/i.test(eu)||/^blob:.*$/i.test(eu)?eu:tu+eu)}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(eu){return super.copy(eu),this.instanceCount=eu.instanceCount,this}toJSON(){const eu=super.toJSON();return eu.instanceCount=this.instanceCount,eu.isInstancedBufferGeometry=!0,eu}}class BufferGeometryLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=new FileLoader(uu.manager);du.setPath(uu.path),du.setRequestHeader(uu.requestHeader),du.setWithCredentials(uu.withCredentials),du.load(eu,function(fu){try{tu(uu.parse(JSON.parse(fu)))}catch(gu){au?au(gu):console.error(gu),uu.manager.itemError(eu)}},su,au)}parse(eu){const tu={},su={};function au(Iu,Mu){if(tu[Mu]!==void 0)return tu[Mu];const Bu=Iu.interleavedBuffers[Mu],_u=uu(Iu,Bu.buffer),Lu=getTypedArray(Bu.type,_u),Du=new InterleavedBuffer(Lu,Bu.stride);return Du.uuid=Bu.uuid,tu[Mu]=Du,Du}function uu(Iu,Mu){if(su[Mu]!==void 0)return su[Mu];const Bu=Iu.arrayBuffers[Mu],_u=new Uint32Array(Bu).buffer;return su[Mu]=_u,_u}const du=eu.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,fu=eu.data.index;if(fu!==void 0){const Iu=getTypedArray(fu.type,fu.array);du.setIndex(new BufferAttribute(Iu,1))}const gu=eu.data.attributes;for(const Iu in gu){const Mu=gu[Iu];let ku;if(Mu.isInterleavedBufferAttribute){const Bu=au(eu.data,Mu.data);ku=new InterleavedBufferAttribute(Bu,Mu.itemSize,Mu.offset,Mu.normalized)}else{const Bu=getTypedArray(Mu.type,Mu.array),_u=Mu.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;ku=new _u(Bu,Mu.itemSize,Mu.normalized)}Mu.name!==void 0&&(ku.name=Mu.name),Mu.usage!==void 0&&ku.setUsage(Mu.usage),du.setAttribute(Iu,ku)}const yu=eu.data.morphAttributes;if(yu)for(const Iu in yu){const Mu=yu[Iu],ku=[];for(let Bu=0,_u=Mu.length;Bu<_u;Bu++){const Lu=Mu[Bu];let Du;if(Lu.isInterleavedBufferAttribute){const Ou=au(eu.data,Lu.data);Du=new InterleavedBufferAttribute(Ou,Lu.itemSize,Lu.offset,Lu.normalized)}else{const Ou=getTypedArray(Lu.type,Lu.array);Du=new BufferAttribute(Ou,Lu.itemSize,Lu.normalized)}Lu.name!==void 0&&(Du.name=Lu.name),ku.push(Du)}du.morphAttributes[Iu]=ku}eu.data.morphTargetsRelative&&(du.morphTargetsRelative=!0);const vu=eu.data.groups||eu.data.drawcalls||eu.data.offsets;if(vu!==void 0)for(let Iu=0,Mu=vu.length;Iu!==Mu;++Iu){const ku=vu[Iu];du.addGroup(ku.start,ku.count,ku.materialIndex)}const Su=eu.data.boundingSphere;if(Su!==void 0){const Iu=new Vector3;Su.center!==void 0&&Iu.fromArray(Su.center),du.boundingSphere=new Sphere(Iu,Su.radius)}return eu.name&&(du.name=eu.name),eu.userData&&(du.userData=eu.userData),du}}class ObjectLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=this.path===""?LoaderUtils.extractUrlBase(eu):this.path;this.resourcePath=this.resourcePath||du;const fu=new FileLoader(this.manager);fu.setPath(this.path),fu.setRequestHeader(this.requestHeader),fu.setWithCredentials(this.withCredentials),fu.load(eu,function(gu){let yu=null;try{yu=JSON.parse(gu)}catch(vu){au!==void 0&&au(vu),console.error("THREE:ObjectLoader: Can't parse "+eu+".",vu.message);return}const xu=yu.metadata;if(xu===void 0||xu.type===void 0||xu.type.toLowerCase()==="geometry"){au!==void 0&&au(new Error("THREE.ObjectLoader: Can't load "+eu)),console.error("THREE.ObjectLoader: Can't load "+eu);return}uu.parse(yu,tu)},su,au)}async loadAsync(eu,tu){const su=this,au=this.path===""?LoaderUtils.extractUrlBase(eu):this.path;this.resourcePath=this.resourcePath||au;const uu=new FileLoader(this.manager);uu.setPath(this.path),uu.setRequestHeader(this.requestHeader),uu.setWithCredentials(this.withCredentials);const du=await uu.loadAsync(eu,tu),fu=JSON.parse(du),gu=fu.metadata;if(gu===void 0||gu.type===void 0||gu.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+eu);return await su.parseAsync(fu)}parse(eu,tu){const su=this.parseAnimations(eu.animations),au=this.parseShapes(eu.shapes),uu=this.parseGeometries(eu.geometries,au),du=this.parseImages(eu.images,function(){tu!==void 0&&tu(yu)}),fu=this.parseTextures(eu.textures,du),gu=this.parseMaterials(eu.materials,fu),yu=this.parseObject(eu.object,uu,gu,fu,su),xu=this.parseSkeletons(eu.skeletons,yu);if(this.bindSkeletons(yu,xu),this.bindLightTargets(yu),tu!==void 0){let vu=!1;for(const Su in du)if(du[Su].data instanceof HTMLImageElement){vu=!0;break}vu===!1&&tu(yu)}return yu}async parseAsync(eu){const tu=this.parseAnimations(eu.animations),su=this.parseShapes(eu.shapes),au=this.parseGeometries(eu.geometries,su),uu=await this.parseImagesAsync(eu.images),du=this.parseTextures(eu.textures,uu),fu=this.parseMaterials(eu.materials,du),gu=this.parseObject(eu.object,au,fu,du,tu),yu=this.parseSkeletons(eu.skeletons,gu);return this.bindSkeletons(gu,yu),this.bindLightTargets(gu),gu}parseShapes(eu){const tu={};if(eu!==void 0)for(let su=0,au=eu.length;su<au;su++){const uu=new Shape().fromJSON(eu[su]);tu[uu.uuid]=uu}return tu}parseSkeletons(eu,tu){const su={},au={};if(tu.traverse(function(uu){uu.isBone&&(au[uu.uuid]=uu)}),eu!==void 0)for(let uu=0,du=eu.length;uu<du;uu++){const fu=new Skeleton().fromJSON(eu[uu],au);su[fu.uuid]=fu}return su}parseGeometries(eu,tu){const su={};if(eu!==void 0){const uu=new BufferGeometryLoader;for(let du=0,fu=eu.length;du<fu;du++){let gu;const yu=eu[du];switch(yu.type){case"BufferGeometry":case"InstancedBufferGeometry":gu=uu.parse(yu);break;case"Geometry":if("THREE"in window&&"LegacyJSONLoader"in THREE){var au=new THREE.LegacyJSONLoader;gu=au.parse(yu,this.resourcePath).geometry}else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');break;default:yu.type in Geometries?gu=Geometries[yu.type].fromJSON(yu,tu):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${yu.type}"`)}gu.uuid=yu.uuid,yu.name!==void 0&&(gu.name=yu.name),yu.userData!==void 0&&(gu.userData=yu.userData),su[yu.uuid]=gu}}return su}parseMaterials(eu,tu){const su={},au={};if(eu!==void 0){const uu=new MaterialLoader;uu.setTextures(tu);for(let du=0,fu=eu.length;du<fu;du++){const gu=eu[du];su[gu.uuid]===void 0&&(su[gu.uuid]=uu.parse(gu)),au[gu.uuid]=su[gu.uuid]}}return au}parseAnimations(eu){const tu={};if(eu!==void 0)for(let su=0;su<eu.length;su++){const au=eu[su],uu=AnimationClip.parse(au);tu[uu.uuid]=uu}return tu}parseImages(eu,tu){const su=this,au={};let uu;function du(gu){return su.manager.itemStart(gu),uu.load(gu,function(){su.manager.itemEnd(gu)},void 0,function(){su.manager.itemError(gu),su.manager.itemEnd(gu)})}function fu(gu){if(typeof gu=="string"){const yu=gu,xu=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(yu)?yu:su.resourcePath+yu;return du(xu)}else return gu.data?{data:getTypedArray(gu.type,gu.data),width:gu.width,height:gu.height}:null}if(eu!==void 0&&eu.length>0){const gu=new LoadingManager(tu);uu=new ImageLoader(gu),uu.setCrossOrigin(this.crossOrigin);for(let yu=0,xu=eu.length;yu<xu;yu++){const vu=eu[yu],Su=vu.url;if(Array.isArray(Su)){const Iu=[];for(let Mu=0,ku=Su.length;Mu<ku;Mu++){const Bu=Su[Mu],_u=fu(Bu);_u!==null&&(_u instanceof HTMLImageElement?Iu.push(_u):Iu.push(new DataTexture(_u.data,_u.width,_u.height)))}au[vu.uuid]=new Source(Iu)}else{const Iu=fu(vu.url);au[vu.uuid]=new Source(Iu)}}}return au}async parseImagesAsync(eu){const tu=this,su={};let au;async function uu(du){if(typeof du=="string"){const fu=du,gu=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(fu)?fu:tu.resourcePath+fu;return await au.loadAsync(gu)}else return du.data?{data:getTypedArray(du.type,du.data),width:du.width,height:du.height}:null}if(eu!==void 0&&eu.length>0){au=new ImageLoader(this.manager),au.setCrossOrigin(this.crossOrigin);for(let du=0,fu=eu.length;du<fu;du++){const gu=eu[du],yu=gu.url;if(Array.isArray(yu)){const xu=[];for(let vu=0,Su=yu.length;vu<Su;vu++){const Iu=yu[vu],Mu=await uu(Iu);Mu!==null&&(Mu instanceof HTMLImageElement?xu.push(Mu):xu.push(new DataTexture(Mu.data,Mu.width,Mu.height)))}su[gu.uuid]=new Source(xu)}else{const xu=await uu(gu.url);su[gu.uuid]=new Source(xu)}}}return su}parseTextures(eu,tu){function su(uu,du){return typeof uu=="number"?uu:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",uu),du[uu])}const au={};if(eu!==void 0)for(let uu=0,du=eu.length;uu<du;uu++){const fu=eu[uu];fu.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',fu.uuid),tu[fu.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",fu.image);const gu=tu[fu.image],yu=gu.data;let xu;Array.isArray(yu)?(xu=new CubeTexture,yu.length===6&&(xu.needsUpdate=!0)):(yu&&yu.data?xu=new DataTexture:xu=new Texture,yu&&(xu.needsUpdate=!0)),xu.source=gu,xu.uuid=fu.uuid,fu.name!==void 0&&(xu.name=fu.name),fu.mapping!==void 0&&(xu.mapping=su(fu.mapping,TEXTURE_MAPPING)),fu.channel!==void 0&&(xu.channel=fu.channel),fu.offset!==void 0&&xu.offset.fromArray(fu.offset),fu.repeat!==void 0&&xu.repeat.fromArray(fu.repeat),fu.center!==void 0&&xu.center.fromArray(fu.center),fu.rotation!==void 0&&(xu.rotation=fu.rotation),fu.wrap!==void 0&&(xu.wrapS=su(fu.wrap[0],TEXTURE_WRAPPING),xu.wrapT=su(fu.wrap[1],TEXTURE_WRAPPING)),fu.format!==void 0&&(xu.format=fu.format),fu.internalFormat!==void 0&&(xu.internalFormat=fu.internalFormat),fu.type!==void 0&&(xu.type=fu.type),fu.colorSpace!==void 0&&(xu.colorSpace=fu.colorSpace),fu.minFilter!==void 0&&(xu.minFilter=su(fu.minFilter,TEXTURE_FILTER)),fu.magFilter!==void 0&&(xu.magFilter=su(fu.magFilter,TEXTURE_FILTER)),fu.anisotropy!==void 0&&(xu.anisotropy=fu.anisotropy),fu.flipY!==void 0&&(xu.flipY=fu.flipY),fu.generateMipmaps!==void 0&&(xu.generateMipmaps=fu.generateMipmaps),fu.premultiplyAlpha!==void 0&&(xu.premultiplyAlpha=fu.premultiplyAlpha),fu.unpackAlignment!==void 0&&(xu.unpackAlignment=fu.unpackAlignment),fu.compareFunction!==void 0&&(xu.compareFunction=fu.compareFunction),fu.userData!==void 0&&(xu.userData=fu.userData),au[fu.uuid]=xu}return au}parseObject(eu,tu,su,au,uu){let du;function fu(Su){return tu[Su]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",Su),tu[Su]}function gu(Su){if(Su!==void 0){if(Array.isArray(Su)){const Iu=[];for(let Mu=0,ku=Su.length;Mu<ku;Mu++){const Bu=Su[Mu];su[Bu]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",Bu),Iu.push(su[Bu])}return Iu}return su[Su]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",Su),su[Su]}}function yu(Su){return au[Su]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",Su),au[Su]}let xu,vu;switch(eu.type){case"Scene":du=new Scene,eu.background!==void 0&&(Number.isInteger(eu.background)?du.background=new Color(eu.background):du.background=yu(eu.background)),eu.environment!==void 0&&(du.environment=yu(eu.environment)),eu.fog!==void 0&&(eu.fog.type==="Fog"?du.fog=new Fog(eu.fog.color,eu.fog.near,eu.fog.far):eu.fog.type==="FogExp2"&&(du.fog=new FogExp2(eu.fog.color,eu.fog.density)),eu.fog.name!==""&&(du.fog.name=eu.fog.name)),eu.backgroundBlurriness!==void 0&&(du.backgroundBlurriness=eu.backgroundBlurriness),eu.backgroundIntensity!==void 0&&(du.backgroundIntensity=eu.backgroundIntensity),eu.backgroundRotation!==void 0&&du.backgroundRotation.fromArray(eu.backgroundRotation),eu.environmentIntensity!==void 0&&(du.environmentIntensity=eu.environmentIntensity),eu.environmentRotation!==void 0&&du.environmentRotation.fromArray(eu.environmentRotation);break;case"PerspectiveCamera":du=new PerspectiveCamera(eu.fov,eu.aspect,eu.near,eu.far),eu.focus!==void 0&&(du.focus=eu.focus),eu.zoom!==void 0&&(du.zoom=eu.zoom),eu.filmGauge!==void 0&&(du.filmGauge=eu.filmGauge),eu.filmOffset!==void 0&&(du.filmOffset=eu.filmOffset),eu.view!==void 0&&(du.view=Object.assign({},eu.view));break;case"OrthographicCamera":du=new OrthographicCamera(eu.left,eu.right,eu.top,eu.bottom,eu.near,eu.far),eu.zoom!==void 0&&(du.zoom=eu.zoom),eu.view!==void 0&&(du.view=Object.assign({},eu.view));break;case"AmbientLight":du=new AmbientLight(eu.color,eu.intensity);break;case"DirectionalLight":du=new DirectionalLight(eu.color,eu.intensity),du.target=eu.target||"";break;case"PointLight":du=new PointLight(eu.color,eu.intensity,eu.distance,eu.decay);break;case"RectAreaLight":du=new RectAreaLight(eu.color,eu.intensity,eu.width,eu.height);break;case"SpotLight":du=new SpotLight(eu.color,eu.intensity,eu.distance,eu.angle,eu.penumbra,eu.decay),du.target=eu.target||"";break;case"HemisphereLight":du=new HemisphereLight(eu.color,eu.groundColor,eu.intensity);break;case"LightProbe":du=new LightProbe().fromJSON(eu);break;case"SkinnedMesh":xu=fu(eu.geometry),vu=gu(eu.material),du=new SkinnedMesh(xu,vu),eu.bindMode!==void 0&&(du.bindMode=eu.bindMode),eu.bindMatrix!==void 0&&du.bindMatrix.fromArray(eu.bindMatrix),eu.skeleton!==void 0&&(du.skeleton=eu.skeleton);break;case"Mesh":xu=fu(eu.geometry),vu=gu(eu.material),du=new Mesh(xu,vu);break;case"InstancedMesh":xu=fu(eu.geometry),vu=gu(eu.material);const Su=eu.count,Iu=eu.instanceMatrix,Mu=eu.instanceColor;du=new InstancedMesh(xu,vu,Su),du.instanceMatrix=new InstancedBufferAttribute(new Float32Array(Iu.array),16),Mu!==void 0&&(du.instanceColor=new InstancedBufferAttribute(new Float32Array(Mu.array),Mu.itemSize));break;case"BatchedMesh":xu=fu(eu.geometry),vu=gu(eu.material),du=new BatchedMesh(eu.maxInstanceCount,eu.maxVertexCount,eu.maxIndexCount,vu),du.geometry=xu,du.perObjectFrustumCulled=eu.perObjectFrustumCulled,du.sortObjects=eu.sortObjects,du._drawRanges=eu.drawRanges,du._reservedRanges=eu.reservedRanges,du._visibility=eu.visibility,du._active=eu.active,du._bounds=eu.bounds.map(ku=>{const Bu=new Box3;Bu.min.fromArray(ku.boxMin),Bu.max.fromArray(ku.boxMax);const _u=new Sphere;return _u.radius=ku.sphereRadius,_u.center.fromArray(ku.sphereCenter),{boxInitialized:ku.boxInitialized,box:Bu,sphereInitialized:ku.sphereInitialized,sphere:_u}}),du._maxInstanceCount=eu.maxInstanceCount,du._maxVertexCount=eu.maxVertexCount,du._maxIndexCount=eu.maxIndexCount,du._geometryInitialized=eu.geometryInitialized,du._geometryCount=eu.geometryCount,du._matricesTexture=yu(eu.matricesTexture.uuid),eu.colorsTexture!==void 0&&(du._colorsTexture=yu(eu.colorsTexture.uuid));break;case"LOD":du=new LOD;break;case"Line":du=new Line(fu(eu.geometry),gu(eu.material));break;case"LineLoop":du=new LineLoop(fu(eu.geometry),gu(eu.material));break;case"LineSegments":du=new LineSegments(fu(eu.geometry),gu(eu.material));break;case"PointCloud":case"Points":du=new Points(fu(eu.geometry),gu(eu.material));break;case"Sprite":du=new Sprite(gu(eu.material));break;case"Group":du=new Group;break;case"Bone":du=new Bone;break;default:du=new Object3D}if(du.uuid=eu.uuid,eu.name!==void 0&&(du.name=eu.name),eu.matrix!==void 0?(du.matrix.fromArray(eu.matrix),eu.matrixAutoUpdate!==void 0&&(du.matrixAutoUpdate=eu.matrixAutoUpdate),du.matrixAutoUpdate&&du.matrix.decompose(du.position,du.quaternion,du.scale)):(eu.position!==void 0&&du.position.fromArray(eu.position),eu.rotation!==void 0&&du.rotation.fromArray(eu.rotation),eu.quaternion!==void 0&&du.quaternion.fromArray(eu.quaternion),eu.scale!==void 0&&du.scale.fromArray(eu.scale)),eu.up!==void 0&&du.up.fromArray(eu.up),eu.castShadow!==void 0&&(du.castShadow=eu.castShadow),eu.receiveShadow!==void 0&&(du.receiveShadow=eu.receiveShadow),eu.shadow&&(eu.shadow.intensity!==void 0&&(du.shadow.intensity=eu.shadow.intensity),eu.shadow.bias!==void 0&&(du.shadow.bias=eu.shadow.bias),eu.shadow.normalBias!==void 0&&(du.shadow.normalBias=eu.shadow.normalBias),eu.shadow.radius!==void 0&&(du.shadow.radius=eu.shadow.radius),eu.shadow.mapSize!==void 0&&du.shadow.mapSize.fromArray(eu.shadow.mapSize),eu.shadow.camera!==void 0&&(du.shadow.camera=this.parseObject(eu.shadow.camera))),eu.visible!==void 0&&(du.visible=eu.visible),eu.frustumCulled!==void 0&&(du.frustumCulled=eu.frustumCulled),eu.renderOrder!==void 0&&(du.renderOrder=eu.renderOrder),eu.userData!==void 0&&(du.userData=eu.userData),eu.layers!==void 0&&(du.layers.mask=eu.layers),eu.children!==void 0){const Su=eu.children;for(let Iu=0;Iu<Su.length;Iu++)du.add(this.parseObject(Su[Iu],tu,su,au,uu))}if(eu.animations!==void 0){const Su=eu.animations;for(let Iu=0;Iu<Su.length;Iu++){const Mu=Su[Iu];du.animations.push(uu[Mu])}}if(eu.type==="LOD"){eu.autoUpdate!==void 0&&(du.autoUpdate=eu.autoUpdate);const Su=eu.levels;for(let Iu=0;Iu<Su.length;Iu++){const Mu=Su[Iu],ku=du.getObjectByProperty("uuid",Mu.object);ku!==void 0&&du.addLevel(ku,Mu.distance,Mu.hysteresis)}}return du}bindSkeletons(eu,tu){Object.keys(tu).length!==0&&eu.traverse(function(su){if(su.isSkinnedMesh===!0&&su.skeleton!==void 0){const au=tu[su.skeleton];au===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",su.skeleton):su.bind(au,su.bindMatrix)}})}bindLightTargets(eu){eu.traverse(function(tu){if(tu.isDirectionalLight||tu.isSpotLight){const su=tu.target,au=eu.getObjectByProperty("uuid",su);au!==void 0?tu.target=au:tu.target=new Object3D}})}}const TEXTURE_MAPPING={UVMapping,CubeReflectionMapping,CubeRefractionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping,CubeUVReflectionMapping},TEXTURE_WRAPPING={RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping},TEXTURE_FILTER={NearestFilter,NearestMipmapNearestFilter,NearestMipmapLinearFilter,LinearFilter,LinearMipmapNearestFilter,LinearMipmapLinearFilter};class ImageBitmapLoader extends Loader$1{constructor(eu){super(eu),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(eu){return this.options=eu,this}load(eu,tu,su,au){eu===void 0&&(eu=""),this.path!==void 0&&(eu=this.path+eu),eu=this.manager.resolveURL(eu);const uu=this,du=Cache.get(eu);if(du!==void 0){if(uu.manager.itemStart(eu),du.then){du.then(yu=>{tu&&tu(yu),uu.manager.itemEnd(eu)}).catch(yu=>{au&&au(yu)});return}return setTimeout(function(){tu&&tu(du),uu.manager.itemEnd(eu)},0),du}const fu={};fu.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fu.headers=this.requestHeader;const gu=fetch(eu,fu).then(function(yu){return yu.blob()}).then(function(yu){return createImageBitmap(yu,Object.assign(uu.options,{colorSpaceConversion:"none"}))}).then(function(yu){return Cache.add(eu,yu),tu&&tu(yu),uu.manager.itemEnd(eu),yu}).catch(function(yu){au&&au(yu),Cache.remove(eu),uu.manager.itemError(eu),uu.manager.itemEnd(eu)});Cache.add(eu,gu),uu.manager.itemStart(eu)}}let _context;class AudioContext{static getContext(){return _context===void 0&&(_context=new(window.AudioContext||window.webkitAudioContext)),_context}static setContext(eu){_context=eu}}class AudioLoader extends Loader$1{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=new FileLoader(this.manager);du.setResponseType("arraybuffer"),du.setPath(this.path),du.setRequestHeader(this.requestHeader),du.setWithCredentials(this.withCredentials),du.load(eu,function(gu){try{const yu=gu.slice(0);AudioContext.getContext().decodeAudioData(yu,function(vu){tu(vu)}).catch(fu)}catch(yu){fu(yu)}},su,au);function fu(gu){au?au(gu):console.error(gu),uu.manager.itemError(eu)}}}const _eyeRight=new Matrix4,_eyeLeft=new Matrix4,_projectionMatrix=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(eu){const tu=this._cache;if(tu.focus!==eu.focus||tu.fov!==eu.fov||tu.aspect!==eu.aspect*this.aspect||tu.near!==eu.near||tu.far!==eu.far||tu.zoom!==eu.zoom||tu.eyeSep!==this.eyeSep){tu.focus=eu.focus,tu.fov=eu.fov,tu.aspect=eu.aspect*this.aspect,tu.near=eu.near,tu.far=eu.far,tu.zoom=eu.zoom,tu.eyeSep=this.eyeSep,_projectionMatrix.copy(eu.projectionMatrix);const au=tu.eyeSep/2,uu=au*tu.near/tu.focus,du=tu.near*Math.tan(DEG2RAD*tu.fov*.5)/tu.zoom;let fu,gu;_eyeLeft.elements[12]=-au,_eyeRight.elements[12]=au,fu=-du*tu.aspect+uu,gu=du*tu.aspect+uu,_projectionMatrix.elements[0]=2*tu.near/(gu-fu),_projectionMatrix.elements[8]=(gu+fu)/(gu-fu),this.cameraL.projectionMatrix.copy(_projectionMatrix),fu=-du*tu.aspect-uu,gu=du*tu.aspect-uu,_projectionMatrix.elements[0]=2*tu.near/(gu-fu),_projectionMatrix.elements[8]=(gu+fu)/(gu-fu),this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(eu.matrixWorld).multiply(_eyeLeft),this.cameraR.matrixWorld.copy(eu.matrixWorld).multiply(_eyeRight)}}class ArrayCamera extends PerspectiveCamera{constructor(eu=[]){super(),this.isArrayCamera=!0,this.cameras=eu,this.index=0}}class Clock{constructor(eu=!0){this.autoStart=eu,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let eu=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const tu=now();eu=(tu-this.oldTime)/1e3,this.oldTime=tu,this.elapsedTime+=eu}return eu}}function now(){return performance.now()}const _position$1=new Vector3,_quaternion$1=new Quaternion,_scale$1=new Vector3,_orientation$1=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=AudioContext.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(eu){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=eu,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(eu){return this.gain.gain.setTargetAtTime(eu,this.context.currentTime,.01),this}updateMatrixWorld(eu){super.updateMatrixWorld(eu);const tu=this.context.listener,su=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1),_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1),tu.positionX){const au=this.context.currentTime+this.timeDelta;tu.positionX.linearRampToValueAtTime(_position$1.x,au),tu.positionY.linearRampToValueAtTime(_position$1.y,au),tu.positionZ.linearRampToValueAtTime(_position$1.z,au),tu.forwardX.linearRampToValueAtTime(_orientation$1.x,au),tu.forwardY.linearRampToValueAtTime(_orientation$1.y,au),tu.forwardZ.linearRampToValueAtTime(_orientation$1.z,au),tu.upX.linearRampToValueAtTime(su.x,au),tu.upY.linearRampToValueAtTime(su.y,au),tu.upZ.linearRampToValueAtTime(su.z,au)}else tu.setPosition(_position$1.x,_position$1.y,_position$1.z),tu.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,su.x,su.y,su.z)}}class Audio extends Object3D{constructor(eu){super(),this.type="Audio",this.listener=eu,this.context=eu.context,this.gain=this.context.createGain(),this.gain.connect(eu.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(eu){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=eu,this.connect(),this}setMediaElementSource(eu){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(eu),this.connect(),this}setMediaStreamSource(eu){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(eu),this.connect(),this}setBuffer(eu){return this.buffer=eu,this.sourceType="buffer",this.autoplay&&this.play(),this}play(eu=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+eu;const tu=this.context.createBufferSource();return tu.buffer=this.buffer,tu.loop=this.loop,tu.loopStart=this.loopStart,tu.loopEnd=this.loopEnd,tu.onended=this.onEnded.bind(this),tu.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=tu,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(eu=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+eu),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let eu=1,tu=this.filters.length;eu<tu;eu++)this.filters[eu-1].connect(this.filters[eu]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let eu=1,tu=this.filters.length;eu<tu;eu++)this.filters[eu-1].disconnect(this.filters[eu]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(eu){return eu||(eu=[]),this._connected===!0?(this.disconnect(),this.filters=eu.slice(),this.connect()):this.filters=eu.slice(),this}setDetune(eu){return this.detune=eu,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(eu){return this.setFilters(eu?[eu]:[])}setPlaybackRate(eu){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=eu,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(eu){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=eu,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(eu){return this.loopStart=eu,this}setLoopEnd(eu){return this.loopEnd=eu,this}getVolume(){return this.gain.gain.value}setVolume(eu){return this.gain.gain.setTargetAtTime(eu,this.context.currentTime,.01),this}copy(eu,tu){return super.copy(eu,tu),eu.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=eu.autoplay,this.buffer=eu.buffer,this.detune=eu.detune,this.loop=eu.loop,this.loopStart=eu.loopStart,this.loopEnd=eu.loopEnd,this.offset=eu.offset,this.duration=eu.duration,this.playbackRate=eu.playbackRate,this.hasPlaybackControl=eu.hasPlaybackControl,this.sourceType=eu.sourceType,this.filters=eu.filters.slice(),this)}clone(eu){return new this.constructor(this.listener).copy(this,eu)}}const _position=new Vector3,_quaternion=new Quaternion,_scale=new Vector3,_orientation=new Vector3;class PositionalAudio extends Audio{constructor(eu){super(eu),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(eu){return this.panner.refDistance=eu,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(eu){return this.panner.rolloffFactor=eu,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(eu){return this.panner.distanceModel=eu,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(eu){return this.panner.maxDistance=eu,this}setDirectionalCone(eu,tu,su){return this.panner.coneInnerAngle=eu,this.panner.coneOuterAngle=tu,this.panner.coneOuterGain=su,this}updateMatrixWorld(eu){if(super.updateMatrixWorld(eu),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(_position,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion);const tu=this.panner;if(tu.positionX){const su=this.context.currentTime+this.listener.timeDelta;tu.positionX.linearRampToValueAtTime(_position.x,su),tu.positionY.linearRampToValueAtTime(_position.y,su),tu.positionZ.linearRampToValueAtTime(_position.z,su),tu.orientationX.linearRampToValueAtTime(_orientation.x,su),tu.orientationY.linearRampToValueAtTime(_orientation.y,su),tu.orientationZ.linearRampToValueAtTime(_orientation.z,su)}else tu.setPosition(_position.x,_position.y,_position.z),tu.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(eu,tu=2048){this.analyser=eu.context.createAnalyser(),this.analyser.fftSize=tu,this.data=new Uint8Array(this.analyser.frequencyBinCount),eu.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let eu=0;const tu=this.getFrequencyData();for(let su=0;su<tu.length;su++)eu+=tu[su];return eu/tu.length}}class PropertyMixer{constructor(eu,tu,su){this.binding=eu,this.valueSize=su;let au,uu,du;switch(tu){case"quaternion":au=this._slerp,uu=this._slerpAdditive,du=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(su*6),this._workIndex=5;break;case"string":case"bool":au=this._select,uu=this._select,du=this._setAdditiveIdentityOther,this.buffer=new Array(su*5);break;default:au=this._lerp,uu=this._lerpAdditive,du=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(su*5)}this._mixBufferRegion=au,this._mixBufferRegionAdditive=uu,this._setIdentity=du,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(eu,tu){const su=this.buffer,au=this.valueSize,uu=eu*au+au;let du=this.cumulativeWeight;if(du===0){for(let fu=0;fu!==au;++fu)su[uu+fu]=su[fu];du=tu}else{du+=tu;const fu=tu/du;this._mixBufferRegion(su,uu,0,fu,au)}this.cumulativeWeight=du}accumulateAdditive(eu){const tu=this.buffer,su=this.valueSize,au=su*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(tu,au,0,eu,su),this.cumulativeWeightAdditive+=eu}apply(eu){const tu=this.valueSize,su=this.buffer,au=eu*tu+tu,uu=this.cumulativeWeight,du=this.cumulativeWeightAdditive,fu=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,uu<1){const gu=tu*this._origIndex;this._mixBufferRegion(su,au,gu,1-uu,tu)}du>0&&this._mixBufferRegionAdditive(su,au,this._addIndex*tu,1,tu);for(let gu=tu,yu=tu+tu;gu!==yu;++gu)if(su[gu]!==su[gu+tu]){fu.setValue(su,au);break}}saveOriginalState(){const eu=this.binding,tu=this.buffer,su=this.valueSize,au=su*this._origIndex;eu.getValue(tu,au);for(let uu=su,du=au;uu!==du;++uu)tu[uu]=tu[au+uu%su];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const eu=this.valueSize*3;this.binding.setValue(this.buffer,eu)}_setAdditiveIdentityNumeric(){const eu=this._addIndex*this.valueSize,tu=eu+this.valueSize;for(let su=eu;su<tu;su++)this.buffer[su]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const eu=this._origIndex*this.valueSize,tu=this._addIndex*this.valueSize;for(let su=0;su<this.valueSize;su++)this.buffer[tu+su]=this.buffer[eu+su]}_select(eu,tu,su,au,uu){if(au>=.5)for(let du=0;du!==uu;++du)eu[tu+du]=eu[su+du]}_slerp(eu,tu,su,au){Quaternion.slerpFlat(eu,tu,eu,tu,eu,su,au)}_slerpAdditive(eu,tu,su,au,uu){const du=this._workIndex*uu;Quaternion.multiplyQuaternionsFlat(eu,du,eu,tu,eu,su),Quaternion.slerpFlat(eu,tu,eu,tu,eu,du,au)}_lerp(eu,tu,su,au,uu){const du=1-au;for(let fu=0;fu!==uu;++fu){const gu=tu+fu;eu[gu]=eu[gu]*du+eu[su+fu]*au}}_lerpAdditive(eu,tu,su,au,uu){for(let du=0;du!==uu;++du){const fu=tu+du;eu[fu]=eu[fu]+eu[su+du]*au}}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(eu,tu,su){const au=su||PropertyBinding.parseTrackName(tu);this._targetGroup=eu,this._bindings=eu.subscribe_(tu,au)}getValue(eu,tu){this.bind();const su=this._targetGroup.nCachedObjects_,au=this._bindings[su];au!==void 0&&au.getValue(eu,tu)}setValue(eu,tu){const su=this._bindings;for(let au=this._targetGroup.nCachedObjects_,uu=su.length;au!==uu;++au)su[au].setValue(eu,tu)}bind(){const eu=this._bindings;for(let tu=this._targetGroup.nCachedObjects_,su=eu.length;tu!==su;++tu)eu[tu].bind()}unbind(){const eu=this._bindings;for(let tu=this._targetGroup.nCachedObjects_,su=eu.length;tu!==su;++tu)eu[tu].unbind()}}class PropertyBinding{constructor(eu,tu,su){this.path=tu,this.parsedPath=su||PropertyBinding.parseTrackName(tu),this.node=PropertyBinding.findNode(eu,this.parsedPath.nodeName),this.rootNode=eu,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(eu,tu,su){return eu&&eu.isAnimationObjectGroup?new PropertyBinding.Composite(eu,tu,su):new PropertyBinding(eu,tu,su)}static sanitizeNodeName(eu){return eu.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(eu){const tu=_trackRe.exec(eu);if(tu===null)throw new Error("PropertyBinding: Cannot parse trackName: "+eu);const su={nodeName:tu[2],objectName:tu[3],objectIndex:tu[4],propertyName:tu[5],propertyIndex:tu[6]},au=su.nodeName&&su.nodeName.lastIndexOf(".");if(au!==void 0&&au!==-1){const uu=su.nodeName.substring(au+1);_supportedObjectNames.indexOf(uu)!==-1&&(su.nodeName=su.nodeName.substring(0,au),su.objectName=uu)}if(su.propertyName===null||su.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+eu);return su}static findNode(eu,tu){if(tu===void 0||tu===""||tu==="."||tu===-1||tu===eu.name||tu===eu.uuid)return eu;if(eu.skeleton){const su=eu.skeleton.getBoneByName(tu);if(su!==void 0)return su}if(eu.children){const su=function(uu){for(let du=0;du<uu.length;du++){const fu=uu[du];if(fu.name===tu||fu.uuid===tu)return fu;const gu=su(fu.children);if(gu)return gu}return null},au=su(eu.children);if(au)return au}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(eu,tu){eu[tu]=this.targetObject[this.propertyName]}_getValue_array(eu,tu){const su=this.resolvedProperty;for(let au=0,uu=su.length;au!==uu;++au)eu[tu++]=su[au]}_getValue_arrayElement(eu,tu){eu[tu]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(eu,tu){this.resolvedProperty.toArray(eu,tu)}_setValue_direct(eu,tu){this.targetObject[this.propertyName]=eu[tu]}_setValue_direct_setNeedsUpdate(eu,tu){this.targetObject[this.propertyName]=eu[tu],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(eu,tu){this.targetObject[this.propertyName]=eu[tu],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(eu,tu){const su=this.resolvedProperty;for(let au=0,uu=su.length;au!==uu;++au)su[au]=eu[tu++]}_setValue_array_setNeedsUpdate(eu,tu){const su=this.resolvedProperty;for(let au=0,uu=su.length;au!==uu;++au)su[au]=eu[tu++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(eu,tu){const su=this.resolvedProperty;for(let au=0,uu=su.length;au!==uu;++au)su[au]=eu[tu++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(eu,tu){this.resolvedProperty[this.propertyIndex]=eu[tu]}_setValue_arrayElement_setNeedsUpdate(eu,tu){this.resolvedProperty[this.propertyIndex]=eu[tu],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(eu,tu){this.resolvedProperty[this.propertyIndex]=eu[tu],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(eu,tu){this.resolvedProperty.fromArray(eu,tu)}_setValue_fromArray_setNeedsUpdate(eu,tu){this.resolvedProperty.fromArray(eu,tu),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(eu,tu){this.resolvedProperty.fromArray(eu,tu),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(eu,tu){this.bind(),this.getValue(eu,tu)}_setValue_unbound(eu,tu){this.bind(),this.setValue(eu,tu)}bind(){let eu=this.node;const tu=this.parsedPath,su=tu.objectName,au=tu.propertyName;let uu=tu.propertyIndex;if(eu||(eu=PropertyBinding.findNode(this.rootNode,tu.nodeName),this.node=eu),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!eu){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(su){let yu=tu.objectIndex;switch(su){case"materials":if(!eu.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!eu.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}eu=eu.material.materials;break;case"bones":if(!eu.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}eu=eu.skeleton.bones;for(let xu=0;xu<eu.length;xu++)if(eu[xu].name===yu){yu=xu;break}break;case"map":if("map"in eu){eu=eu.map;break}if(!eu.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!eu.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}eu=eu.material.map;break;default:if(eu[su]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}eu=eu[su]}if(yu!==void 0){if(eu[yu]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,eu);return}eu=eu[yu]}}const du=eu[au];if(du===void 0){const yu=tu.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+yu+"."+au+" but it wasn't found.",eu);return}let fu=this.Versioning.None;this.targetObject=eu,eu.isMaterial===!0?fu=this.Versioning.NeedsUpdate:eu.isObject3D===!0&&(fu=this.Versioning.MatrixWorldNeedsUpdate);let gu=this.BindingType.Direct;if(uu!==void 0){if(au==="morphTargetInfluences"){if(!eu.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!eu.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}eu.morphTargetDictionary[uu]!==void 0&&(uu=eu.morphTargetDictionary[uu])}gu=this.BindingType.ArrayElement,this.resolvedProperty=du,this.propertyIndex=uu}else du.fromArray!==void 0&&du.toArray!==void 0?(gu=this.BindingType.HasFromToArray,this.resolvedProperty=du):Array.isArray(du)?(gu=this.BindingType.EntireArray,this.resolvedProperty=du):this.propertyName=au;this.getValue=this.GetterByBindingType[gu],this.setValue=this.SetterByBindingTypeAndVersioning[gu][fu]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const eu={};this._indicesByUUID=eu;for(let su=0,au=arguments.length;su!==au;++su)eu[arguments[su].uuid]=su;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const tu=this;this.stats={objects:{get total(){return tu._objects.length},get inUse(){return this.total-tu.nCachedObjects_}},get bindingsPerObject(){return tu._bindings.length}}}add(){const eu=this._objects,tu=this._indicesByUUID,su=this._paths,au=this._parsedPaths,uu=this._bindings,du=uu.length;let fu,gu=eu.length,yu=this.nCachedObjects_;for(let xu=0,vu=arguments.length;xu!==vu;++xu){const Su=arguments[xu],Iu=Su.uuid;let Mu=tu[Iu];if(Mu===void 0){Mu=gu++,tu[Iu]=Mu,eu.push(Su);for(let ku=0,Bu=du;ku!==Bu;++ku)uu[ku].push(new PropertyBinding(Su,su[ku],au[ku]))}else if(Mu<yu){fu=eu[Mu];const ku=--yu,Bu=eu[ku];tu[Bu.uuid]=Mu,eu[Mu]=Bu,tu[Iu]=ku,eu[ku]=Su;for(let _u=0,Lu=du;_u!==Lu;++_u){const Du=uu[_u],Ou=Du[ku];let Wu=Du[Mu];Du[Mu]=Ou,Wu===void 0&&(Wu=new PropertyBinding(Su,su[_u],au[_u])),Du[ku]=Wu}}else eu[Mu]!==fu&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=yu}remove(){const eu=this._objects,tu=this._indicesByUUID,su=this._bindings,au=su.length;let uu=this.nCachedObjects_;for(let du=0,fu=arguments.length;du!==fu;++du){const gu=arguments[du],yu=gu.uuid,xu=tu[yu];if(xu!==void 0&&xu>=uu){const vu=uu++,Su=eu[vu];tu[Su.uuid]=xu,eu[xu]=Su,tu[yu]=vu,eu[vu]=gu;for(let Iu=0,Mu=au;Iu!==Mu;++Iu){const ku=su[Iu],Bu=ku[vu],_u=ku[xu];ku[xu]=Bu,ku[vu]=_u}}}this.nCachedObjects_=uu}uncache(){const eu=this._objects,tu=this._indicesByUUID,su=this._bindings,au=su.length;let uu=this.nCachedObjects_,du=eu.length;for(let fu=0,gu=arguments.length;fu!==gu;++fu){const yu=arguments[fu],xu=yu.uuid,vu=tu[xu];if(vu!==void 0)if(delete tu[xu],vu<uu){const Su=--uu,Iu=eu[Su],Mu=--du,ku=eu[Mu];tu[Iu.uuid]=vu,eu[vu]=Iu,tu[ku.uuid]=Su,eu[Su]=ku,eu.pop();for(let Bu=0,_u=au;Bu!==_u;++Bu){const Lu=su[Bu],Du=Lu[Su],Ou=Lu[Mu];Lu[vu]=Du,Lu[Su]=Ou,Lu.pop()}}else{const Su=--du,Iu=eu[Su];Su>0&&(tu[Iu.uuid]=vu),eu[vu]=Iu,eu.pop();for(let Mu=0,ku=au;Mu!==ku;++Mu){const Bu=su[Mu];Bu[vu]=Bu[Su],Bu.pop()}}}this.nCachedObjects_=uu}subscribe_(eu,tu){const su=this._bindingsIndicesByPath;let au=su[eu];const uu=this._bindings;if(au!==void 0)return uu[au];const du=this._paths,fu=this._parsedPaths,gu=this._objects,yu=gu.length,xu=this.nCachedObjects_,vu=new Array(yu);au=uu.length,su[eu]=au,du.push(eu),fu.push(tu),uu.push(vu);for(let Su=xu,Iu=gu.length;Su!==Iu;++Su){const Mu=gu[Su];vu[Su]=new PropertyBinding(Mu,eu,tu)}return vu}unsubscribe_(eu){const tu=this._bindingsIndicesByPath,su=tu[eu];if(su!==void 0){const au=this._paths,uu=this._parsedPaths,du=this._bindings,fu=du.length-1,gu=du[fu],yu=eu[fu];tu[yu]=su,du[su]=gu,du.pop(),uu[su]=uu[fu],uu.pop(),au[su]=au[fu],au.pop()}}}class AnimationAction{constructor(eu,tu,su=null,au=tu.blendMode){this._mixer=eu,this._clip=tu,this._localRoot=su,this.blendMode=au;const uu=tu.tracks,du=uu.length,fu=new Array(du),gu={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let yu=0;yu!==du;++yu){const xu=uu[yu].createInterpolant(null);fu[yu]=xu,xu.settings=gu}this._interpolantSettings=gu,this._interpolants=fu,this._propertyBindings=new Array(du),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=LoopRepeat,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(eu){return this._startTime=eu,this}setLoop(eu,tu){return this.loop=eu,this.repetitions=tu,this}setEffectiveWeight(eu){return this.weight=eu,this._effectiveWeight=this.enabled?eu:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(eu){return this._scheduleFading(eu,0,1)}fadeOut(eu){return this._scheduleFading(eu,1,0)}crossFadeFrom(eu,tu,su){if(eu.fadeOut(tu),this.fadeIn(tu),su){const au=this._clip.duration,uu=eu._clip.duration,du=uu/au,fu=au/uu;eu.warp(1,du,tu),this.warp(fu,1,tu)}return this}crossFadeTo(eu,tu,su){return eu.crossFadeFrom(this,tu,su)}stopFading(){const eu=this._weightInterpolant;return eu!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(eu)),this}setEffectiveTimeScale(eu){return this.timeScale=eu,this._effectiveTimeScale=this.paused?0:eu,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(eu){return this.timeScale=this._clip.duration/eu,this.stopWarping()}syncWith(eu){return this.time=eu.time,this.timeScale=eu.timeScale,this.stopWarping()}halt(eu){return this.warp(this._effectiveTimeScale,0,eu)}warp(eu,tu,su){const au=this._mixer,uu=au.time,du=this.timeScale;let fu=this._timeScaleInterpolant;fu===null&&(fu=au._lendControlInterpolant(),this._timeScaleInterpolant=fu);const gu=fu.parameterPositions,yu=fu.sampleValues;return gu[0]=uu,gu[1]=uu+su,yu[0]=eu/du,yu[1]=tu/du,this}stopWarping(){const eu=this._timeScaleInterpolant;return eu!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(eu)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(eu,tu,su,au){if(!this.enabled){this._updateWeight(eu);return}const uu=this._startTime;if(uu!==null){const gu=(eu-uu)*su;gu<0||su===0?tu=0:(this._startTime=null,tu=su*gu)}tu*=this._updateTimeScale(eu);const du=this._updateTime(tu),fu=this._updateWeight(eu);if(fu>0){const gu=this._interpolants,yu=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let xu=0,vu=gu.length;xu!==vu;++xu)gu[xu].evaluate(du),yu[xu].accumulateAdditive(fu);break;case NormalAnimationBlendMode:default:for(let xu=0,vu=gu.length;xu!==vu;++xu)gu[xu].evaluate(du),yu[xu].accumulate(au,fu)}}}_updateWeight(eu){let tu=0;if(this.enabled){tu=this.weight;const su=this._weightInterpolant;if(su!==null){const au=su.evaluate(eu)[0];tu*=au,eu>su.parameterPositions[1]&&(this.stopFading(),au===0&&(this.enabled=!1))}}return this._effectiveWeight=tu,tu}_updateTimeScale(eu){let tu=0;if(!this.paused){tu=this.timeScale;const su=this._timeScaleInterpolant;if(su!==null){const au=su.evaluate(eu)[0];tu*=au,eu>su.parameterPositions[1]&&(this.stopWarping(),tu===0?this.paused=!0:this.timeScale=tu)}}return this._effectiveTimeScale=tu,tu}_updateTime(eu){const tu=this._clip.duration,su=this.loop;let au=this.time+eu,uu=this._loopCount;const du=su===LoopPingPong;if(eu===0)return uu===-1?au:du&&(uu&1)===1?tu-au:au;if(su===LoopOnce){uu===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(au>=tu)au=tu;else if(au<0)au=0;else{this.time=au;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=au,this._mixer.dispatchEvent({type:"finished",action:this,direction:eu<0?-1:1})}}else{if(uu===-1&&(eu>=0?(uu=0,this._setEndings(!0,this.repetitions===0,du)):this._setEndings(this.repetitions===0,!0,du)),au>=tu||au<0){const fu=Math.floor(au/tu);au-=tu*fu,uu+=Math.abs(fu);const gu=this.repetitions-uu;if(gu<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,au=eu>0?tu:0,this.time=au,this._mixer.dispatchEvent({type:"finished",action:this,direction:eu>0?1:-1});else{if(gu===1){const yu=eu<0;this._setEndings(yu,!yu,du)}else this._setEndings(!1,!1,du);this._loopCount=uu,this.time=au,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:fu})}}else this.time=au;if(du&&(uu&1)===1)return tu-au}return au}_setEndings(eu,tu,su){const au=this._interpolantSettings;su?(au.endingStart=ZeroSlopeEnding,au.endingEnd=ZeroSlopeEnding):(eu?au.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding:au.endingStart=WrapAroundEnding,tu?au.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding:au.endingEnd=WrapAroundEnding)}_scheduleFading(eu,tu,su){const au=this._mixer,uu=au.time;let du=this._weightInterpolant;du===null&&(du=au._lendControlInterpolant(),this._weightInterpolant=du);const fu=du.parameterPositions,gu=du.sampleValues;return fu[0]=uu,gu[0]=tu,fu[1]=uu+eu,gu[1]=su,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(eu){super(),this._root=eu,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(eu,tu){const su=eu._localRoot||this._root,au=eu._clip.tracks,uu=au.length,du=eu._propertyBindings,fu=eu._interpolants,gu=su.uuid,yu=this._bindingsByRootAndName;let xu=yu[gu];xu===void 0&&(xu={},yu[gu]=xu);for(let vu=0;vu!==uu;++vu){const Su=au[vu],Iu=Su.name;let Mu=xu[Iu];if(Mu!==void 0)++Mu.referenceCount,du[vu]=Mu;else{if(Mu=du[vu],Mu!==void 0){Mu._cacheIndex===null&&(++Mu.referenceCount,this._addInactiveBinding(Mu,gu,Iu));continue}const ku=tu&&tu._propertyBindings[vu].binding.parsedPath;Mu=new PropertyMixer(PropertyBinding.create(su,Iu,ku),Su.ValueTypeName,Su.getValueSize()),++Mu.referenceCount,this._addInactiveBinding(Mu,gu,Iu),du[vu]=Mu}fu[vu].resultBuffer=Mu.buffer}}_activateAction(eu){if(!this._isActiveAction(eu)){if(eu._cacheIndex===null){const su=(eu._localRoot||this._root).uuid,au=eu._clip.uuid,uu=this._actionsByClip[au];this._bindAction(eu,uu&&uu.knownActions[0]),this._addInactiveAction(eu,au,su)}const tu=eu._propertyBindings;for(let su=0,au=tu.length;su!==au;++su){const uu=tu[su];uu.useCount++===0&&(this._lendBinding(uu),uu.saveOriginalState())}this._lendAction(eu)}}_deactivateAction(eu){if(this._isActiveAction(eu)){const tu=eu._propertyBindings;for(let su=0,au=tu.length;su!==au;++su){const uu=tu[su];--uu.useCount===0&&(uu.restoreOriginalState(),this._takeBackBinding(uu))}this._takeBackAction(eu)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const eu=this;this.stats={actions:{get total(){return eu._actions.length},get inUse(){return eu._nActiveActions}},bindings:{get total(){return eu._bindings.length},get inUse(){return eu._nActiveBindings}},controlInterpolants:{get total(){return eu._controlInterpolants.length},get inUse(){return eu._nActiveControlInterpolants}}}}_isActiveAction(eu){const tu=eu._cacheIndex;return tu!==null&&tu<this._nActiveActions}_addInactiveAction(eu,tu,su){const au=this._actions,uu=this._actionsByClip;let du=uu[tu];if(du===void 0)du={knownActions:[eu],actionByRoot:{}},eu._byClipCacheIndex=0,uu[tu]=du;else{const fu=du.knownActions;eu._byClipCacheIndex=fu.length,fu.push(eu)}eu._cacheIndex=au.length,au.push(eu),du.actionByRoot[su]=eu}_removeInactiveAction(eu){const tu=this._actions,su=tu[tu.length-1],au=eu._cacheIndex;su._cacheIndex=au,tu[au]=su,tu.pop(),eu._cacheIndex=null;const uu=eu._clip.uuid,du=this._actionsByClip,fu=du[uu],gu=fu.knownActions,yu=gu[gu.length-1],xu=eu._byClipCacheIndex;yu._byClipCacheIndex=xu,gu[xu]=yu,gu.pop(),eu._byClipCacheIndex=null;const vu=fu.actionByRoot,Su=(eu._localRoot||this._root).uuid;delete vu[Su],gu.length===0&&delete du[uu],this._removeInactiveBindingsForAction(eu)}_removeInactiveBindingsForAction(eu){const tu=eu._propertyBindings;for(let su=0,au=tu.length;su!==au;++su){const uu=tu[su];--uu.referenceCount===0&&this._removeInactiveBinding(uu)}}_lendAction(eu){const tu=this._actions,su=eu._cacheIndex,au=this._nActiveActions++,uu=tu[au];eu._cacheIndex=au,tu[au]=eu,uu._cacheIndex=su,tu[su]=uu}_takeBackAction(eu){const tu=this._actions,su=eu._cacheIndex,au=--this._nActiveActions,uu=tu[au];eu._cacheIndex=au,tu[au]=eu,uu._cacheIndex=su,tu[su]=uu}_addInactiveBinding(eu,tu,su){const au=this._bindingsByRootAndName,uu=this._bindings;let du=au[tu];du===void 0&&(du={},au[tu]=du),du[su]=eu,eu._cacheIndex=uu.length,uu.push(eu)}_removeInactiveBinding(eu){const tu=this._bindings,su=eu.binding,au=su.rootNode.uuid,uu=su.path,du=this._bindingsByRootAndName,fu=du[au],gu=tu[tu.length-1],yu=eu._cacheIndex;gu._cacheIndex=yu,tu[yu]=gu,tu.pop(),delete fu[uu],Object.keys(fu).length===0&&delete du[au]}_lendBinding(eu){const tu=this._bindings,su=eu._cacheIndex,au=this._nActiveBindings++,uu=tu[au];eu._cacheIndex=au,tu[au]=eu,uu._cacheIndex=su,tu[su]=uu}_takeBackBinding(eu){const tu=this._bindings,su=eu._cacheIndex,au=--this._nActiveBindings,uu=tu[au];eu._cacheIndex=au,tu[au]=eu,uu._cacheIndex=su,tu[su]=uu}_lendControlInterpolant(){const eu=this._controlInterpolants,tu=this._nActiveControlInterpolants++;let su=eu[tu];return su===void 0&&(su=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),su.__cacheIndex=tu,eu[tu]=su),su}_takeBackControlInterpolant(eu){const tu=this._controlInterpolants,su=eu.__cacheIndex,au=--this._nActiveControlInterpolants,uu=tu[au];eu.__cacheIndex=au,tu[au]=eu,uu.__cacheIndex=su,tu[su]=uu}clipAction(eu,tu,su){const au=tu||this._root,uu=au.uuid;let du=typeof eu=="string"?AnimationClip.findByName(au,eu):eu;const fu=du!==null?du.uuid:eu,gu=this._actionsByClip[fu];let yu=null;if(su===void 0&&(du!==null?su=du.blendMode:su=NormalAnimationBlendMode),gu!==void 0){const vu=gu.actionByRoot[uu];if(vu!==void 0&&vu.blendMode===su)return vu;yu=gu.knownActions[0],du===null&&(du=yu._clip)}if(du===null)return null;const xu=new AnimationAction(this,du,tu,su);return this._bindAction(xu,yu),this._addInactiveAction(xu,fu,uu),xu}existingAction(eu,tu){const su=tu||this._root,au=su.uuid,uu=typeof eu=="string"?AnimationClip.findByName(su,eu):eu,du=uu?uu.uuid:eu,fu=this._actionsByClip[du];return fu!==void 0&&fu.actionByRoot[au]||null}stopAllAction(){const eu=this._actions,tu=this._nActiveActions;for(let su=tu-1;su>=0;--su)eu[su].stop();return this}update(eu){eu*=this.timeScale;const tu=this._actions,su=this._nActiveActions,au=this.time+=eu,uu=Math.sign(eu),du=this._accuIndex^=1;for(let yu=0;yu!==su;++yu)tu[yu]._update(au,eu,uu,du);const fu=this._bindings,gu=this._nActiveBindings;for(let yu=0;yu!==gu;++yu)fu[yu].apply(du);return this}setTime(eu){this.time=0;for(let tu=0;tu<this._actions.length;tu++)this._actions[tu].time=0;return this.update(eu)}getRoot(){return this._root}uncacheClip(eu){const tu=this._actions,su=eu.uuid,au=this._actionsByClip,uu=au[su];if(uu!==void 0){const du=uu.knownActions;for(let fu=0,gu=du.length;fu!==gu;++fu){const yu=du[fu];this._deactivateAction(yu);const xu=yu._cacheIndex,vu=tu[tu.length-1];yu._cacheIndex=null,yu._byClipCacheIndex=null,vu._cacheIndex=xu,tu[xu]=vu,tu.pop(),this._removeInactiveBindingsForAction(yu)}delete au[su]}}uncacheRoot(eu){const tu=eu.uuid,su=this._actionsByClip;for(const du in su){const fu=su[du].actionByRoot,gu=fu[tu];gu!==void 0&&(this._deactivateAction(gu),this._removeInactiveAction(gu))}const au=this._bindingsByRootAndName,uu=au[tu];if(uu!==void 0)for(const du in uu){const fu=uu[du];fu.restoreOriginalState(),this._removeInactiveBinding(fu)}}uncacheAction(eu,tu){const su=this.existingAction(eu,tu);su!==null&&(this._deactivateAction(su),this._removeInactiveAction(su))}}class RenderTarget3D extends RenderTarget{constructor(eu=1,tu=1,su=1,au={}){super(eu,tu,au),this.isRenderTarget3D=!0,this.depth=su,this.texture=new Data3DTexture(null,eu,tu,su),this.texture.isRenderTargetTexture=!0}}class RenderTargetArray extends RenderTarget{constructor(eu=1,tu=1,su=1,au={}){super(eu,tu,au),this.isRenderTargetArray=!0,this.depth=su,this.texture=new DataArrayTexture(null,eu,tu,su),this.texture.isRenderTargetTexture=!0}}class Uniform{constructor(eu){this.value=eu}clone(){return new Uniform(this.value.clone===void 0?this.value:this.value.clone())}}let _id$3=0;class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:_id$3++}),this.name="",this.usage=StaticDrawUsage,this.uniforms=[]}add(eu){return this.uniforms.push(eu),this}remove(eu){const tu=this.uniforms.indexOf(eu);return tu!==-1&&this.uniforms.splice(tu,1),this}setName(eu){return this.name=eu,this}setUsage(eu){return this.usage=eu,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(eu){this.name=eu.name,this.usage=eu.usage;const tu=eu.uniforms;this.uniforms.length=0;for(let su=0,au=tu.length;su<au;su++){const uu=Array.isArray(tu[su])?tu[su]:[tu[su]];for(let du=0;du<uu.length;du++)this.uniforms.push(uu[du].clone())}return this}clone(){return new this.constructor().copy(this)}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(eu,tu,su=1){super(eu,tu),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=su}copy(eu){return super.copy(eu),this.meshPerAttribute=eu.meshPerAttribute,this}clone(eu){const tu=super.clone(eu);return tu.meshPerAttribute=this.meshPerAttribute,tu}toJSON(eu){const tu=super.toJSON(eu);return tu.isInstancedInterleavedBuffer=!0,tu.meshPerAttribute=this.meshPerAttribute,tu}}class GLBufferAttribute{constructor(eu,tu,su,au,uu){this.isGLBufferAttribute=!0,this.name="",this.buffer=eu,this.type=tu,this.itemSize=su,this.elementSize=au,this.count=uu,this.version=0}set needsUpdate(eu){eu===!0&&this.version++}setBuffer(eu){return this.buffer=eu,this}setType(eu,tu){return this.type=eu,this.elementSize=tu,this}setItemSize(eu){return this.itemSize=eu,this}setCount(eu){return this.count=eu,this}}const _matrix=new Matrix4;class Raycaster{constructor(eu,tu,su=0,au=1/0){this.ray=new Ray(eu,tu),this.near=su,this.far=au,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(eu,tu){this.ray.set(eu,tu)}setFromCamera(eu,tu){tu.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(tu.matrixWorld),this.ray.direction.set(eu.x,eu.y,.5).unproject(tu).sub(this.ray.origin).normalize(),this.camera=tu):tu.isOrthographicCamera?(this.ray.origin.set(eu.x,eu.y,(tu.near+tu.far)/(tu.near-tu.far)).unproject(tu),this.ray.direction.set(0,0,-1).transformDirection(tu.matrixWorld),this.camera=tu):console.error("THREE.Raycaster: Unsupported camera type: "+tu.type)}setFromXRController(eu){return _matrix.identity().extractRotation(eu.matrixWorld),this.ray.origin.setFromMatrixPosition(eu.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_matrix),this}intersectObject(eu,tu=!0,su=[]){return intersect(eu,this,su,tu),su.sort(ascSort),su}intersectObjects(eu,tu=!0,su=[]){for(let au=0,uu=eu.length;au<uu;au++)intersect(eu[au],this,su,tu);return su.sort(ascSort),su}}function ascSort(iu,eu){return iu.distance-eu.distance}function intersect(iu,eu,tu,su){let au=!0;if(iu.layers.test(eu.layers)&&iu.raycast(eu,tu)===!1&&(au=!1),au===!0&&su===!0){const uu=iu.children;for(let du=0,fu=uu.length;du<fu;du++)intersect(uu[du],eu,tu,!0)}}class Spherical{constructor(eu=1,tu=0,su=0){return this.radius=eu,this.phi=tu,this.theta=su,this}set(eu,tu,su){return this.radius=eu,this.phi=tu,this.theta=su,this}copy(eu){return this.radius=eu.radius,this.phi=eu.phi,this.theta=eu.theta,this}makeSafe(){return this.phi=clamp(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(eu){return this.setFromCartesianCoords(eu.x,eu.y,eu.z)}setFromCartesianCoords(eu,tu,su){return this.radius=Math.sqrt(eu*eu+tu*tu+su*su),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(eu,su),this.phi=Math.acos(clamp(tu/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Cylindrical{constructor(eu=1,tu=0,su=0){return this.radius=eu,this.theta=tu,this.y=su,this}set(eu,tu,su){return this.radius=eu,this.theta=tu,this.y=su,this}copy(eu){return this.radius=eu.radius,this.theta=eu.theta,this.y=eu.y,this}setFromVector3(eu){return this.setFromCartesianCoords(eu.x,eu.y,eu.z)}setFromCartesianCoords(eu,tu,su){return this.radius=Math.sqrt(eu*eu+su*su),this.theta=Math.atan2(eu,su),this.y=tu,this}clone(){return new this.constructor().copy(this)}}class Matrix2{constructor(eu,tu,su,au){Matrix2.prototype.isMatrix2=!0,this.elements=[1,0,0,1],eu!==void 0&&this.set(eu,tu,su,au)}identity(){return this.set(1,0,0,1),this}fromArray(eu,tu=0){for(let su=0;su<4;su++)this.elements[su]=eu[su+tu];return this}set(eu,tu,su,au){const uu=this.elements;return uu[0]=eu,uu[2]=tu,uu[1]=su,uu[3]=au,this}}const _vector$4=new Vector2;class Box2{constructor(eu=new Vector2(1/0,1/0),tu=new Vector2(-1/0,-1/0)){this.isBox2=!0,this.min=eu,this.max=tu}set(eu,tu){return this.min.copy(eu),this.max.copy(tu),this}setFromPoints(eu){this.makeEmpty();for(let tu=0,su=eu.length;tu<su;tu++)this.expandByPoint(eu[tu]);return this}setFromCenterAndSize(eu,tu){const su=_vector$4.copy(tu).multiplyScalar(.5);return this.min.copy(eu).sub(su),this.max.copy(eu).add(su),this}clone(){return new this.constructor().copy(this)}copy(eu){return this.min.copy(eu.min),this.max.copy(eu.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(eu){return this.isEmpty()?eu.set(0,0):eu.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(eu){return this.isEmpty()?eu.set(0,0):eu.subVectors(this.max,this.min)}expandByPoint(eu){return this.min.min(eu),this.max.max(eu),this}expandByVector(eu){return this.min.sub(eu),this.max.add(eu),this}expandByScalar(eu){return this.min.addScalar(-eu),this.max.addScalar(eu),this}containsPoint(eu){return eu.x>=this.min.x&&eu.x<=this.max.x&&eu.y>=this.min.y&&eu.y<=this.max.y}containsBox(eu){return this.min.x<=eu.min.x&&eu.max.x<=this.max.x&&this.min.y<=eu.min.y&&eu.max.y<=this.max.y}getParameter(eu,tu){return tu.set((eu.x-this.min.x)/(this.max.x-this.min.x),(eu.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(eu){return eu.max.x>=this.min.x&&eu.min.x<=this.max.x&&eu.max.y>=this.min.y&&eu.min.y<=this.max.y}clampPoint(eu,tu){return tu.copy(eu).clamp(this.min,this.max)}distanceToPoint(eu){return this.clampPoint(eu,_vector$4).distanceTo(eu)}intersect(eu){return this.min.max(eu.min),this.max.min(eu.max),this.isEmpty()&&this.makeEmpty(),this}union(eu){return this.min.min(eu.min),this.max.max(eu.max),this}translate(eu){return this.min.add(eu),this.max.add(eu),this}equals(eu){return eu.min.equals(this.min)&&eu.max.equals(this.max)}}const _startP=new Vector3,_startEnd=new Vector3;class Line3{constructor(eu=new Vector3,tu=new Vector3){this.start=eu,this.end=tu}set(eu,tu){return this.start.copy(eu),this.end.copy(tu),this}copy(eu){return this.start.copy(eu.start),this.end.copy(eu.end),this}getCenter(eu){return eu.addVectors(this.start,this.end).multiplyScalar(.5)}delta(eu){return eu.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(eu,tu){return this.delta(tu).multiplyScalar(eu).add(this.start)}closestPointToPointParameter(eu,tu){_startP.subVectors(eu,this.start),_startEnd.subVectors(this.end,this.start);const su=_startEnd.dot(_startEnd);let uu=_startEnd.dot(_startP)/su;return tu&&(uu=clamp(uu,0,1)),uu}closestPointToPoint(eu,tu,su){const au=this.closestPointToPointParameter(eu,tu);return this.delta(su).multiplyScalar(au).add(this.start)}applyMatrix4(eu){return this.start.applyMatrix4(eu),this.end.applyMatrix4(eu),this}equals(eu){return eu.start.equals(this.start)&&eu.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const _vector$3=new Vector3;class SpotLightHelper extends Object3D{constructor(eu,tu){super(),this.light=eu,this.matrixAutoUpdate=!1,this.color=tu,this.type="SpotLightHelper";const su=new BufferGeometry,au=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let du=0,fu=1,gu=32;du<gu;du++,fu++){const yu=du/gu*Math.PI*2,xu=fu/gu*Math.PI*2;au.push(Math.cos(yu),Math.sin(yu),1,Math.cos(xu),Math.sin(xu),1)}su.setAttribute("position",new Float32BufferAttribute(au,3));const uu=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(su,uu),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const eu=this.light.distance?this.light.distance:1e3,tu=eu*Math.tan(this.light.angle);this.cone.scale.set(tu,tu,eu),_vector$3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(_vector$3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _vector$2=new Vector3,_boneMatrix=new Matrix4,_matrixWorldInv=new Matrix4;class SkeletonHelper extends LineSegments{constructor(eu){const tu=getBoneList(eu),su=new BufferGeometry,au=[],uu=[],du=new Color(0,0,1),fu=new Color(0,1,0);for(let yu=0;yu<tu.length;yu++){const xu=tu[yu];xu.parent&&xu.parent.isBone&&(au.push(0,0,0),au.push(0,0,0),uu.push(du.r,du.g,du.b),uu.push(fu.r,fu.g,fu.b))}su.setAttribute("position",new Float32BufferAttribute(au,3)),su.setAttribute("color",new Float32BufferAttribute(uu,3));const gu=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(su,gu),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=eu,this.bones=tu,this.matrix=eu.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(eu){const tu=this.bones,su=this.geometry,au=su.getAttribute("position");_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let uu=0,du=0;uu<tu.length;uu++){const fu=tu[uu];fu.parent&&fu.parent.isBone&&(_boneMatrix.multiplyMatrices(_matrixWorldInv,fu.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),au.setXYZ(du,_vector$2.x,_vector$2.y,_vector$2.z),_boneMatrix.multiplyMatrices(_matrixWorldInv,fu.parent.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),au.setXYZ(du+1,_vector$2.x,_vector$2.y,_vector$2.z),du+=2)}su.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(eu)}dispose(){this.geometry.dispose(),this.material.dispose()}}function getBoneList(iu){const eu=[];iu.isBone===!0&&eu.push(iu);for(let tu=0;tu<iu.children.length;tu++)eu.push.apply(eu,getBoneList(iu.children[tu]));return eu}class PointLightHelper extends Mesh{constructor(eu,tu,su){const au=new SphereGeometry(tu,4,2),uu=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(au,uu),this.light=eu,this.color=su,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _vector$1=new Vector3,_color1=new Color,_color2=new Color;class HemisphereLightHelper extends Object3D{constructor(eu,tu,su){super(),this.light=eu,this.matrix=eu.matrixWorld,this.matrixAutoUpdate=!1,this.color=su,this.type="HemisphereLightHelper";const au=new OctahedronGeometry(tu);au.rotateY(Math.PI*.5),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const uu=au.getAttribute("position"),du=new Float32Array(uu.count*3);au.setAttribute("color",new BufferAttribute(du,3)),this.add(new Mesh(au,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const eu=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const tu=eu.geometry.getAttribute("color");_color1.copy(this.light.color),_color2.copy(this.light.groundColor);for(let su=0,au=tu.count;su<au;su++){const uu=su<au/2?_color1:_color2;tu.setXYZ(su,uu.r,uu.g,uu.b)}tu.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),eu.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(eu=10,tu=10,su=4473924,au=8947848){su=new Color(su),au=new Color(au);const uu=tu/2,du=eu/tu,fu=eu/2,gu=[],yu=[];for(let Su=0,Iu=0,Mu=-fu;Su<=tu;Su++,Mu+=du){gu.push(-fu,0,Mu,fu,0,Mu),gu.push(Mu,0,-fu,Mu,0,fu);const ku=Su===uu?su:au;ku.toArray(yu,Iu),Iu+=3,ku.toArray(yu,Iu),Iu+=3,ku.toArray(yu,Iu),Iu+=3,ku.toArray(yu,Iu),Iu+=3}const xu=new BufferGeometry;xu.setAttribute("position",new Float32BufferAttribute(gu,3)),xu.setAttribute("color",new Float32BufferAttribute(yu,3));const vu=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(xu,vu),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class PolarGridHelper extends LineSegments{constructor(eu=10,tu=16,su=8,au=64,uu=4473924,du=8947848){uu=new Color(uu),du=new Color(du);const fu=[],gu=[];if(tu>1)for(let vu=0;vu<tu;vu++){const Su=vu/tu*(Math.PI*2),Iu=Math.sin(Su)*eu,Mu=Math.cos(Su)*eu;fu.push(0,0,0),fu.push(Iu,0,Mu);const ku=vu&1?uu:du;gu.push(ku.r,ku.g,ku.b),gu.push(ku.r,ku.g,ku.b)}for(let vu=0;vu<su;vu++){const Su=vu&1?uu:du,Iu=eu-eu/su*vu;for(let Mu=0;Mu<au;Mu++){let ku=Mu/au*(Math.PI*2),Bu=Math.sin(ku)*Iu,_u=Math.cos(ku)*Iu;fu.push(Bu,0,_u),gu.push(Su.r,Su.g,Su.b),ku=(Mu+1)/au*(Math.PI*2),Bu=Math.sin(ku)*Iu,_u=Math.cos(ku)*Iu,fu.push(Bu,0,_u),gu.push(Su.r,Su.g,Su.b)}}const yu=new BufferGeometry;yu.setAttribute("position",new Float32BufferAttribute(fu,3)),yu.setAttribute("color",new Float32BufferAttribute(gu,3));const xu=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(yu,xu),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const _v1=new Vector3,_v2=new Vector3,_v3=new Vector3;class DirectionalLightHelper extends Object3D{constructor(eu,tu,su){super(),this.light=eu,this.matrix=eu.matrixWorld,this.matrixAutoUpdate=!1,this.color=su,this.type="DirectionalLightHelper",tu===void 0&&(tu=1);let au=new BufferGeometry;au.setAttribute("position",new Float32BufferAttribute([-tu,tu,0,tu,tu,0,tu,-tu,0,-tu,-tu,0,-tu,tu,0],3));const uu=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(au,uu),this.add(this.lightPlane),au=new BufferGeometry,au.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(au,uu),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),_v1.setFromMatrixPosition(this.light.matrixWorld),_v2.setFromMatrixPosition(this.light.target.matrixWorld),_v3.subVectors(_v2,_v1),this.lightPlane.lookAt(_v2),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(_v2),this.targetLine.scale.z=_v3.length()}}const _vector=new Vector3,_camera=new Camera;class CameraHelper extends LineSegments{constructor(eu){const tu=new BufferGeometry,su=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),au=[],uu=[],du={};fu("n1","n2"),fu("n2","n4"),fu("n4","n3"),fu("n3","n1"),fu("f1","f2"),fu("f2","f4"),fu("f4","f3"),fu("f3","f1"),fu("n1","f1"),fu("n2","f2"),fu("n3","f3"),fu("n4","f4"),fu("p","n1"),fu("p","n2"),fu("p","n3"),fu("p","n4"),fu("u1","u2"),fu("u2","u3"),fu("u3","u1"),fu("c","t"),fu("p","c"),fu("cn1","cn2"),fu("cn3","cn4"),fu("cf1","cf2"),fu("cf3","cf4");function fu(Mu,ku){gu(Mu),gu(ku)}function gu(Mu){au.push(0,0,0),uu.push(0,0,0),du[Mu]===void 0&&(du[Mu]=[]),du[Mu].push(au.length/3-1)}tu.setAttribute("position",new Float32BufferAttribute(au,3)),tu.setAttribute("color",new Float32BufferAttribute(uu,3)),super(tu,su),this.type="CameraHelper",this.camera=eu,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=eu.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=du,this.update();const yu=new Color(16755200),xu=new Color(16711680),vu=new Color(43775),Su=new Color(16777215),Iu=new Color(3355443);this.setColors(yu,xu,vu,Su,Iu)}setColors(eu,tu,su,au,uu){const fu=this.geometry.getAttribute("color");fu.setXYZ(0,eu.r,eu.g,eu.b),fu.setXYZ(1,eu.r,eu.g,eu.b),fu.setXYZ(2,eu.r,eu.g,eu.b),fu.setXYZ(3,eu.r,eu.g,eu.b),fu.setXYZ(4,eu.r,eu.g,eu.b),fu.setXYZ(5,eu.r,eu.g,eu.b),fu.setXYZ(6,eu.r,eu.g,eu.b),fu.setXYZ(7,eu.r,eu.g,eu.b),fu.setXYZ(8,eu.r,eu.g,eu.b),fu.setXYZ(9,eu.r,eu.g,eu.b),fu.setXYZ(10,eu.r,eu.g,eu.b),fu.setXYZ(11,eu.r,eu.g,eu.b),fu.setXYZ(12,eu.r,eu.g,eu.b),fu.setXYZ(13,eu.r,eu.g,eu.b),fu.setXYZ(14,eu.r,eu.g,eu.b),fu.setXYZ(15,eu.r,eu.g,eu.b),fu.setXYZ(16,eu.r,eu.g,eu.b),fu.setXYZ(17,eu.r,eu.g,eu.b),fu.setXYZ(18,eu.r,eu.g,eu.b),fu.setXYZ(19,eu.r,eu.g,eu.b),fu.setXYZ(20,eu.r,eu.g,eu.b),fu.setXYZ(21,eu.r,eu.g,eu.b),fu.setXYZ(22,eu.r,eu.g,eu.b),fu.setXYZ(23,eu.r,eu.g,eu.b),fu.setXYZ(24,tu.r,tu.g,tu.b),fu.setXYZ(25,tu.r,tu.g,tu.b),fu.setXYZ(26,tu.r,tu.g,tu.b),fu.setXYZ(27,tu.r,tu.g,tu.b),fu.setXYZ(28,tu.r,tu.g,tu.b),fu.setXYZ(29,tu.r,tu.g,tu.b),fu.setXYZ(30,tu.r,tu.g,tu.b),fu.setXYZ(31,tu.r,tu.g,tu.b),fu.setXYZ(32,su.r,su.g,su.b),fu.setXYZ(33,su.r,su.g,su.b),fu.setXYZ(34,su.r,su.g,su.b),fu.setXYZ(35,su.r,su.g,su.b),fu.setXYZ(36,su.r,su.g,su.b),fu.setXYZ(37,su.r,su.g,su.b),fu.setXYZ(38,au.r,au.g,au.b),fu.setXYZ(39,au.r,au.g,au.b),fu.setXYZ(40,uu.r,uu.g,uu.b),fu.setXYZ(41,uu.r,uu.g,uu.b),fu.setXYZ(42,uu.r,uu.g,uu.b),fu.setXYZ(43,uu.r,uu.g,uu.b),fu.setXYZ(44,uu.r,uu.g,uu.b),fu.setXYZ(45,uu.r,uu.g,uu.b),fu.setXYZ(46,uu.r,uu.g,uu.b),fu.setXYZ(47,uu.r,uu.g,uu.b),fu.setXYZ(48,uu.r,uu.g,uu.b),fu.setXYZ(49,uu.r,uu.g,uu.b),fu.needsUpdate=!0}update(){const eu=this.geometry,tu=this.pointMap,su=1,au=1;_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const uu=this.camera.coordinateSystem===WebGLCoordinateSystem?-1:0;setPoint("c",tu,eu,_camera,0,0,uu),setPoint("t",tu,eu,_camera,0,0,1),setPoint("n1",tu,eu,_camera,-1,-1,uu),setPoint("n2",tu,eu,_camera,su,-1,uu),setPoint("n3",tu,eu,_camera,-1,au,uu),setPoint("n4",tu,eu,_camera,su,au,uu),setPoint("f1",tu,eu,_camera,-1,-1,1),setPoint("f2",tu,eu,_camera,su,-1,1),setPoint("f3",tu,eu,_camera,-1,au,1),setPoint("f4",tu,eu,_camera,su,au,1),setPoint("u1",tu,eu,_camera,su*.7,au*1.1,uu),setPoint("u2",tu,eu,_camera,-1*.7,au*1.1,uu),setPoint("u3",tu,eu,_camera,0,au*2,uu),setPoint("cf1",tu,eu,_camera,-1,0,1),setPoint("cf2",tu,eu,_camera,su,0,1),setPoint("cf3",tu,eu,_camera,0,-1,1),setPoint("cf4",tu,eu,_camera,0,au,1),setPoint("cn1",tu,eu,_camera,-1,0,uu),setPoint("cn2",tu,eu,_camera,su,0,uu),setPoint("cn3",tu,eu,_camera,0,-1,uu),setPoint("cn4",tu,eu,_camera,0,au,uu),eu.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function setPoint(iu,eu,tu,su,au,uu,du){_vector.set(au,uu,du).unproject(su);const fu=eu[iu];if(fu!==void 0){const gu=tu.getAttribute("position");for(let yu=0,xu=fu.length;yu<xu;yu++)gu.setXYZ(fu[yu],_vector.x,_vector.y,_vector.z)}}const _box=new Box3;class BoxHelper extends LineSegments{constructor(eu,tu=16776960){const su=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),au=new Float32Array(8*3),uu=new BufferGeometry;uu.setIndex(new BufferAttribute(su,1)),uu.setAttribute("position",new BufferAttribute(au,3)),super(uu,new LineBasicMaterial({color:tu,toneMapped:!1})),this.object=eu,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(eu){if(eu!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_box.setFromObject(this.object),_box.isEmpty())return;const tu=_box.min,su=_box.max,au=this.geometry.attributes.position,uu=au.array;uu[0]=su.x,uu[1]=su.y,uu[2]=su.z,uu[3]=tu.x,uu[4]=su.y,uu[5]=su.z,uu[6]=tu.x,uu[7]=tu.y,uu[8]=su.z,uu[9]=su.x,uu[10]=tu.y,uu[11]=su.z,uu[12]=su.x,uu[13]=su.y,uu[14]=tu.z,uu[15]=tu.x,uu[16]=su.y,uu[17]=tu.z,uu[18]=tu.x,uu[19]=tu.y,uu[20]=tu.z,uu[21]=su.x,uu[22]=tu.y,uu[23]=tu.z,au.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(eu){return this.object=eu,this.update(),this}copy(eu,tu){return super.copy(eu,tu),this.object=eu.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Box3Helper extends LineSegments{constructor(eu,tu=16776960){const su=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),au=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],uu=new BufferGeometry;uu.setIndex(new BufferAttribute(su,1)),uu.setAttribute("position",new Float32BufferAttribute(au,3)),super(uu,new LineBasicMaterial({color:tu,toneMapped:!1})),this.box=eu,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(eu){const tu=this.box;tu.isEmpty()||(tu.getCenter(this.position),tu.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(eu))}dispose(){this.geometry.dispose(),this.material.dispose()}}class PlaneHelper extends Line{constructor(eu,tu=1,su=16776960){const au=su,uu=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],du=new BufferGeometry;du.setAttribute("position",new Float32BufferAttribute(uu,3)),du.computeBoundingSphere(),super(du,new LineBasicMaterial({color:au,toneMapped:!1})),this.type="PlaneHelper",this.plane=eu,this.size=tu;const fu=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],gu=new BufferGeometry;gu.setAttribute("position",new Float32BufferAttribute(fu,3)),gu.computeBoundingSphere(),this.add(new Mesh(gu,new MeshBasicMaterial({color:au,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(eu){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(eu)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const _axis=new Vector3;let _lineGeometry,_coneGeometry;class ArrowHelper extends Object3D{constructor(eu=new Vector3(0,0,1),tu=new Vector3(0,0,0),su=1,au=16776960,uu=su*.2,du=uu*.2){super(),this.type="ArrowHelper",_lineGeometry===void 0&&(_lineGeometry=new BufferGeometry,_lineGeometry.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),_coneGeometry=new CylinderGeometry(0,.5,1,5,1),_coneGeometry.translate(0,-.5,0)),this.position.copy(tu),this.line=new Line(_lineGeometry,new LineBasicMaterial({color:au,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color:au,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(eu),this.setLength(su,uu,du)}setDirection(eu){if(eu.y>.99999)this.quaternion.set(0,0,0,1);else if(eu.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(eu.z,0,-eu.x).normalize();const tu=Math.acos(eu.y);this.quaternion.setFromAxisAngle(_axis,tu)}}setLength(eu,tu=eu*.2,su=tu*.2){this.line.scale.set(1,Math.max(1e-4,eu-tu),1),this.line.updateMatrix(),this.cone.scale.set(su,tu,su),this.cone.position.y=eu,this.cone.updateMatrix()}setColor(eu){this.line.material.color.set(eu),this.cone.material.color.set(eu)}copy(eu){return super.copy(eu,!1),this.line.copy(eu.line),this.cone.copy(eu.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class AxesHelper extends LineSegments{constructor(eu=1){const tu=[0,0,0,eu,0,0,0,0,0,0,eu,0,0,0,0,0,0,eu],su=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],au=new BufferGeometry;au.setAttribute("position",new Float32BufferAttribute(tu,3)),au.setAttribute("color",new Float32BufferAttribute(su,3));const uu=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(au,uu),this.type="AxesHelper"}setColors(eu,tu,su){const au=new Color,uu=this.geometry.attributes.color.array;return au.set(eu),au.toArray(uu,0),au.toArray(uu,3),au.set(tu),au.toArray(uu,6),au.toArray(uu,9),au.set(su),au.toArray(uu,12),au.toArray(uu,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath",this.color=new Color,this.subPaths=[],this.currentPath=null}moveTo(eu,tu){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(eu,tu),this}lineTo(eu,tu){return this.currentPath.lineTo(eu,tu),this}quadraticCurveTo(eu,tu,su,au){return this.currentPath.quadraticCurveTo(eu,tu,su,au),this}bezierCurveTo(eu,tu,su,au,uu,du){return this.currentPath.bezierCurveTo(eu,tu,su,au,uu,du),this}splineThru(eu){return this.currentPath.splineThru(eu),this}toShapes(eu){function tu(_u){const Lu=[];for(let Du=0,Ou=_u.length;Du<Ou;Du++){const Wu=_u[Du],Zu=new Shape;Zu.curves=Wu.curves,Lu.push(Zu)}return Lu}function su(_u,Lu){const Du=Lu.length;let Ou=!1;for(let Wu=Du-1,Zu=0;Zu<Du;Wu=Zu++){let Hu=Lu[Wu],Yu=Lu[Zu],Ku=Yu.x-Hu.x,ju=Yu.y-Hu.y;if(Math.abs(ju)>Number.EPSILON){if(ju<0&&(Hu=Lu[Zu],Ku=-Ku,Yu=Lu[Wu],ju=-ju),_u.y<Hu.y||_u.y>Yu.y)continue;if(_u.y===Hu.y){if(_u.x===Hu.x)return!0}else{const tp=ju*(_u.x-Hu.x)-Ku*(_u.y-Hu.y);if(tp===0)return!0;if(tp<0)continue;Ou=!Ou}}else{if(_u.y!==Hu.y)continue;if(Yu.x<=_u.x&&_u.x<=Hu.x||Hu.x<=_u.x&&_u.x<=Yu.x)return!0}}return Ou}const au=ShapeUtils.isClockWise,uu=this.subPaths;if(uu.length===0)return[];let du,fu,gu;const yu=[];if(uu.length===1)return fu=uu[0],gu=new Shape,gu.curves=fu.curves,yu.push(gu),yu;let xu=!au(uu[0].getPoints());xu=eu?!xu:xu;const vu=[],Su=[];let Iu=[],Mu=0,ku;Su[Mu]=void 0,Iu[Mu]=[];for(let _u=0,Lu=uu.length;_u<Lu;_u++)fu=uu[_u],ku=fu.getPoints(),du=au(ku),du=eu?!du:du,du?(!xu&&Su[Mu]&&Mu++,Su[Mu]={s:new Shape,p:ku},Su[Mu].s.curves=fu.curves,xu&&Mu++,Iu[Mu]=[]):Iu[Mu].push({h:fu,p:ku[0]});if(!Su[0])return tu(uu);if(Su.length>1){let _u=!1,Lu=0;for(let Du=0,Ou=Su.length;Du<Ou;Du++)vu[Du]=[];for(let Du=0,Ou=Su.length;Du<Ou;Du++){const Wu=Iu[Du];for(let Zu=0;Zu<Wu.length;Zu++){const Hu=Wu[Zu];let Yu=!0;for(let Ku=0;Ku<Su.length;Ku++)su(Hu.p,Su[Ku].p)&&(Du!==Ku&&Lu++,Yu?(Yu=!1,vu[Ku].push(Hu)):_u=!0);Yu&&vu[Du].push(Hu)}}Lu>0&&_u===!1&&(Iu=vu)}let Bu;for(let _u=0,Lu=Su.length;_u<Lu;_u++){gu=Su[_u].s,yu.push(gu),Bu=Iu[_u];for(let Du=0,Ou=Bu.length;Du<Ou;Du++)gu.holes.push(Bu[Du].h)}return yu}}class Controls extends EventDispatcher{constructor(eu,tu=null){super(),this.object=eu,this.domElement=tu,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}function contain(iu,eu){const tu=iu.image&&iu.image.width?iu.image.width/iu.image.height:1;return tu>eu?(iu.repeat.x=1,iu.repeat.y=tu/eu,iu.offset.x=0,iu.offset.y=(1-iu.repeat.y)/2):(iu.repeat.x=eu/tu,iu.repeat.y=1,iu.offset.x=(1-iu.repeat.x)/2,iu.offset.y=0),iu}function cover(iu,eu){const tu=iu.image&&iu.image.width?iu.image.width/iu.image.height:1;return tu>eu?(iu.repeat.x=eu/tu,iu.repeat.y=1,iu.offset.x=(1-iu.repeat.x)/2,iu.offset.y=0):(iu.repeat.x=1,iu.repeat.y=tu/eu,iu.offset.x=0,iu.offset.y=(1-iu.repeat.y)/2),iu}function fill(iu){return iu.repeat.x=1,iu.repeat.y=1,iu.offset.x=0,iu.offset.y=0,iu}function getByteLength(iu,eu,tu,su){const au=getTextureTypeByteLength(su);switch(tu){case AlphaFormat:return iu*eu;case LuminanceFormat:return iu*eu;case LuminanceAlphaFormat:return iu*eu*2;case RedFormat:return iu*eu/au.components*au.byteLength;case RedIntegerFormat:return iu*eu/au.components*au.byteLength;case RGFormat:return iu*eu*2/au.components*au.byteLength;case RGIntegerFormat:return iu*eu*2/au.components*au.byteLength;case RGBFormat:return iu*eu*3/au.components*au.byteLength;case RGBAFormat:return iu*eu*4/au.components*au.byteLength;case RGBAIntegerFormat:return iu*eu*4/au.components*au.byteLength;case RGB_S3TC_DXT1_Format:case RGBA_S3TC_DXT1_Format:return Math.floor((iu+3)/4)*Math.floor((eu+3)/4)*8;case RGBA_S3TC_DXT3_Format:case RGBA_S3TC_DXT5_Format:return Math.floor((iu+3)/4)*Math.floor((eu+3)/4)*16;case RGB_PVRTC_2BPPV1_Format:case RGBA_PVRTC_2BPPV1_Format:return Math.max(iu,16)*Math.max(eu,8)/4;case RGB_PVRTC_4BPPV1_Format:case RGBA_PVRTC_4BPPV1_Format:return Math.max(iu,8)*Math.max(eu,8)/2;case RGB_ETC1_Format:case RGB_ETC2_Format:return Math.floor((iu+3)/4)*Math.floor((eu+3)/4)*8;case RGBA_ETC2_EAC_Format:return Math.floor((iu+3)/4)*Math.floor((eu+3)/4)*16;case RGBA_ASTC_4x4_Format:return Math.floor((iu+3)/4)*Math.floor((eu+3)/4)*16;case RGBA_ASTC_5x4_Format:return Math.floor((iu+4)/5)*Math.floor((eu+3)/4)*16;case RGBA_ASTC_5x5_Format:return Math.floor((iu+4)/5)*Math.floor((eu+4)/5)*16;case RGBA_ASTC_6x5_Format:return Math.floor((iu+5)/6)*Math.floor((eu+4)/5)*16;case RGBA_ASTC_6x6_Format:return Math.floor((iu+5)/6)*Math.floor((eu+5)/6)*16;case RGBA_ASTC_8x5_Format:return Math.floor((iu+7)/8)*Math.floor((eu+4)/5)*16;case RGBA_ASTC_8x6_Format:return Math.floor((iu+7)/8)*Math.floor((eu+5)/6)*16;case RGBA_ASTC_8x8_Format:return Math.floor((iu+7)/8)*Math.floor((eu+7)/8)*16;case RGBA_ASTC_10x5_Format:return Math.floor((iu+9)/10)*Math.floor((eu+4)/5)*16;case RGBA_ASTC_10x6_Format:return Math.floor((iu+9)/10)*Math.floor((eu+5)/6)*16;case RGBA_ASTC_10x8_Format:return Math.floor((iu+9)/10)*Math.floor((eu+7)/8)*16;case RGBA_ASTC_10x10_Format:return Math.floor((iu+9)/10)*Math.floor((eu+9)/10)*16;case RGBA_ASTC_12x10_Format:return Math.floor((iu+11)/12)*Math.floor((eu+9)/10)*16;case RGBA_ASTC_12x12_Format:return Math.floor((iu+11)/12)*Math.floor((eu+11)/12)*16;case RGBA_BPTC_Format:case RGB_BPTC_SIGNED_Format:case RGB_BPTC_UNSIGNED_Format:return Math.ceil(iu/4)*Math.ceil(eu/4)*16;case RED_RGTC1_Format:case SIGNED_RED_RGTC1_Format:return Math.ceil(iu/4)*Math.ceil(eu/4)*8;case RED_GREEN_RGTC2_Format:case SIGNED_RED_GREEN_RGTC2_Format:return Math.ceil(iu/4)*Math.ceil(eu/4)*16}throw new Error(`Unable to determine texture byte length for ${tu} format.`)}function getTextureTypeByteLength(iu){switch(iu){case UnsignedByteType:case ByteType:return{byteLength:1,components:1};case UnsignedShortType:case ShortType:case HalfFloatType:return{byteLength:2,components:1};case UnsignedShort4444Type:case UnsignedShort5551Type:return{byteLength:2,components:4};case UnsignedIntType:case IntType:case FloatType:return{byteLength:4,components:1};case UnsignedInt5999Type:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${iu}.`)}const TextureUtils={contain,cover,fill,getByteLength};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function WebGLAnimation(){let iu=null,eu=!1,tu=null,su=null;function au(uu,du){tu(uu,du),su=iu.requestAnimationFrame(au)}return{start:function(){eu!==!0&&tu!==null&&(su=iu.requestAnimationFrame(au),eu=!0)},stop:function(){iu.cancelAnimationFrame(su),eu=!1},setAnimationLoop:function(uu){tu=uu},setContext:function(uu){iu=uu}}}function WebGLAttributes(iu){const eu=new WeakMap;function tu(fu,gu){const yu=fu.array,xu=fu.usage,vu=yu.byteLength,Su=iu.createBuffer();iu.bindBuffer(gu,Su),iu.bufferData(gu,yu,xu),fu.onUploadCallback();let Iu;if(yu instanceof Float32Array)Iu=iu.FLOAT;else if(yu instanceof Uint16Array)fu.isFloat16BufferAttribute?Iu=iu.HALF_FLOAT:Iu=iu.UNSIGNED_SHORT;else if(yu instanceof Int16Array)Iu=iu.SHORT;else if(yu instanceof Uint32Array)Iu=iu.UNSIGNED_INT;else if(yu instanceof Int32Array)Iu=iu.INT;else if(yu instanceof Int8Array)Iu=iu.BYTE;else if(yu instanceof Uint8Array)Iu=iu.UNSIGNED_BYTE;else if(yu instanceof Uint8ClampedArray)Iu=iu.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+yu);return{buffer:Su,type:Iu,bytesPerElement:yu.BYTES_PER_ELEMENT,version:fu.version,size:vu}}function su(fu,gu,yu){const xu=gu.array,vu=gu.updateRanges;if(iu.bindBuffer(yu,fu),vu.length===0)iu.bufferSubData(yu,0,xu);else{vu.sort((Iu,Mu)=>Iu.start-Mu.start);let Su=0;for(let Iu=1;Iu<vu.length;Iu++){const Mu=vu[Su],ku=vu[Iu];ku.start<=Mu.start+Mu.count+1?Mu.count=Math.max(Mu.count,ku.start+ku.count-Mu.start):(++Su,vu[Su]=ku)}vu.length=Su+1;for(let Iu=0,Mu=vu.length;Iu<Mu;Iu++){const ku=vu[Iu];iu.bufferSubData(yu,ku.start*xu.BYTES_PER_ELEMENT,xu,ku.start,ku.count)}gu.clearUpdateRanges()}gu.onUploadCallback()}function au(fu){return fu.isInterleavedBufferAttribute&&(fu=fu.data),eu.get(fu)}function uu(fu){fu.isInterleavedBufferAttribute&&(fu=fu.data);const gu=eu.get(fu);gu&&(iu.deleteBuffer(gu.buffer),eu.delete(fu))}function du(fu,gu){if(fu.isInterleavedBufferAttribute&&(fu=fu.data),fu.isGLBufferAttribute){const xu=eu.get(fu);(!xu||xu.version<fu.version)&&eu.set(fu,{buffer:fu.buffer,type:fu.type,bytesPerElement:fu.elementSize,version:fu.version});return}const yu=eu.get(fu);if(yu===void 0)eu.set(fu,tu(fu,gu));else if(yu.version<fu.version){if(yu.size!==fu.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");su(yu.buffer,fu,gu),yu.version=fu.version}}return{get:au,remove:uu,update:du}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,batching_pars_vertex=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,batching_vertex=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphinstance_vertex=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,batching_pars_vertex,batching_vertex,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphinstance_vertex,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},envMapRotation:{value:new Matrix3},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Matrix3}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0},_e1$1=new Euler,_m1$1=new Matrix4;function WebGLBackground(iu,eu,tu,su,au,uu,du){const fu=new Color(0);let gu=uu===!0?0:1,yu,xu,vu=null,Su=0,Iu=null;function Mu(Du){let Ou=Du.isScene===!0?Du.background:null;return Ou&&Ou.isTexture&&(Ou=(Du.backgroundBlurriness>0?tu:eu).get(Ou)),Ou}function ku(Du){let Ou=!1;const Wu=Mu(Du);Wu===null?_u(fu,gu):Wu&&Wu.isColor&&(_u(Wu,1),Ou=!0);const Zu=iu.xr.getEnvironmentBlendMode();Zu==="additive"?su.buffers.color.setClear(0,0,0,1,du):Zu==="alpha-blend"&&su.buffers.color.setClear(0,0,0,0,du),(iu.autoClear||Ou)&&(su.buffers.depth.setTest(!0),su.buffers.depth.setMask(!0),su.buffers.color.setMask(!0),iu.clear(iu.autoClearColor,iu.autoClearDepth,iu.autoClearStencil))}function Bu(Du,Ou){const Wu=Mu(Ou);Wu&&(Wu.isCubeTexture||Wu.mapping===CubeUVReflectionMapping)?(xu===void 0&&(xu=new Mesh(new BoxGeometry(1e4,1e4,1e4),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1})),xu.geometry.deleteAttribute("normal"),xu.geometry.deleteAttribute("uv"),xu.onBeforeRender=function(Zu,Hu,Yu){this.matrixWorld.copyPosition(Yu.matrixWorld)},Object.defineProperty(xu.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),au.update(xu)),_e1$1.copy(Ou.backgroundRotation),_e1$1.x*=-1,_e1$1.y*=-1,_e1$1.z*=-1,Wu.isCubeTexture&&Wu.isRenderTargetTexture===!1&&(_e1$1.y*=-1,_e1$1.z*=-1),xu.material.uniforms.envMap.value=Wu,xu.material.uniforms.flipEnvMap.value=Wu.isCubeTexture&&Wu.isRenderTargetTexture===!1?-1:1,xu.material.uniforms.backgroundBlurriness.value=Ou.backgroundBlurriness,xu.material.uniforms.backgroundIntensity.value=Ou.backgroundIntensity,xu.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),xu.material.toneMapped=ColorManagement.getTransfer(Wu.colorSpace)!==SRGBTransfer,(vu!==Wu||Su!==Wu.version||Iu!==iu.toneMapping)&&(xu.material.needsUpdate=!0,vu=Wu,Su=Wu.version,Iu=iu.toneMapping),xu.layers.enableAll(),Du.unshift(xu,xu.geometry,xu.material,0,0,null)):Wu&&Wu.isTexture&&(yu===void 0&&(yu=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1})),yu.geometry.deleteAttribute("normal"),Object.defineProperty(yu.material,"map",{get:function(){return this.uniforms.t2D.value}}),au.update(yu)),yu.material.uniforms.t2D.value=Wu,yu.material.uniforms.backgroundIntensity.value=Ou.backgroundIntensity,yu.material.toneMapped=ColorManagement.getTransfer(Wu.colorSpace)!==SRGBTransfer,Wu.matrixAutoUpdate===!0&&Wu.updateMatrix(),yu.material.uniforms.uvTransform.value.copy(Wu.matrix),(vu!==Wu||Su!==Wu.version||Iu!==iu.toneMapping)&&(yu.material.needsUpdate=!0,vu=Wu,Su=Wu.version,Iu=iu.toneMapping),yu.layers.enableAll(),Du.unshift(yu,yu.geometry,yu.material,0,0,null))}function _u(Du,Ou){Du.getRGB(_rgb,getUnlitUniformColorSpace(iu)),su.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,Ou,du)}function Lu(){xu!==void 0&&(xu.geometry.dispose(),xu.material.dispose(),xu=void 0),yu!==void 0&&(yu.geometry.dispose(),yu.material.dispose(),yu=void 0)}return{getClearColor:function(){return fu},setClearColor:function(Du,Ou=1){fu.set(Du),gu=Ou,_u(fu,gu)},getClearAlpha:function(){return gu},setClearAlpha:function(Du){gu=Du,_u(fu,gu)},render:ku,addToRenderList:Bu,dispose:Lu}}function WebGLBindingStates(iu,eu){const tu=iu.getParameter(iu.MAX_VERTEX_ATTRIBS),su={},au=Su(null);let uu=au,du=!1;function fu(ju,tp,gp,yp,Cp){let Hp=!1;const wp=vu(yp,gp,tp);uu!==wp&&(uu=wp,yu(uu.object)),Hp=Iu(ju,yp,gp,Cp),Hp&&Mu(ju,yp,gp,Cp),Cp!==null&&eu.update(Cp,iu.ELEMENT_ARRAY_BUFFER),(Hp||du)&&(du=!1,Ou(ju,tp,gp,yp),Cp!==null&&iu.bindBuffer(iu.ELEMENT_ARRAY_BUFFER,eu.get(Cp).buffer))}function gu(){return iu.createVertexArray()}function yu(ju){return iu.bindVertexArray(ju)}function xu(ju){return iu.deleteVertexArray(ju)}function vu(ju,tp,gp){const yp=gp.wireframe===!0;let Cp=su[ju.id];Cp===void 0&&(Cp={},su[ju.id]=Cp);let Hp=Cp[tp.id];Hp===void 0&&(Hp={},Cp[tp.id]=Hp);let wp=Hp[yp];return wp===void 0&&(wp=Su(gu()),Hp[yp]=wp),wp}function Su(ju){const tp=[],gp=[],yp=[];for(let Cp=0;Cp<tu;Cp++)tp[Cp]=0,gp[Cp]=0,yp[Cp]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:tp,enabledAttributes:gp,attributeDivisors:yp,object:ju,attributes:{},index:null}}function Iu(ju,tp,gp,yp){const Cp=uu.attributes,Hp=tp.attributes;let wp=0;const Dp=gp.getAttributes();for(const dp in Dp)if(Dp[dp].location>=0){const xp=Cp[dp];let cm=Hp[dp];if(cm===void 0&&(dp==="instanceMatrix"&&ju.instanceMatrix&&(cm=ju.instanceMatrix),dp==="instanceColor"&&ju.instanceColor&&(cm=ju.instanceColor)),xp===void 0||xp.attribute!==cm||cm&&xp.data!==cm.data)return!0;wp++}return uu.attributesNum!==wp||uu.index!==yp}function Mu(ju,tp,gp,yp){const Cp={},Hp=tp.attributes;let wp=0;const Dp=gp.getAttributes();for(const dp in Dp)if(Dp[dp].location>=0){let xp=Hp[dp];xp===void 0&&(dp==="instanceMatrix"&&ju.instanceMatrix&&(xp=ju.instanceMatrix),dp==="instanceColor"&&ju.instanceColor&&(xp=ju.instanceColor));const cm={};cm.attribute=xp,xp&&xp.data&&(cm.data=xp.data),Cp[dp]=cm,wp++}uu.attributes=Cp,uu.attributesNum=wp,uu.index=yp}function ku(){const ju=uu.newAttributes;for(let tp=0,gp=ju.length;tp<gp;tp++)ju[tp]=0}function Bu(ju){_u(ju,0)}function _u(ju,tp){const gp=uu.newAttributes,yp=uu.enabledAttributes,Cp=uu.attributeDivisors;gp[ju]=1,yp[ju]===0&&(iu.enableVertexAttribArray(ju),yp[ju]=1),Cp[ju]!==tp&&(iu.vertexAttribDivisor(ju,tp),Cp[ju]=tp)}function Lu(){const ju=uu.newAttributes,tp=uu.enabledAttributes;for(let gp=0,yp=tp.length;gp<yp;gp++)tp[gp]!==ju[gp]&&(iu.disableVertexAttribArray(gp),tp[gp]=0)}function Du(ju,tp,gp,yp,Cp,Hp,wp){wp===!0?iu.vertexAttribIPointer(ju,tp,gp,Cp,Hp):iu.vertexAttribPointer(ju,tp,gp,yp,Cp,Hp)}function Ou(ju,tp,gp,yp){ku();const Cp=yp.attributes,Hp=gp.getAttributes(),wp=tp.defaultAttributeValues;for(const Dp in Hp){const dp=Hp[Dp];if(dp.location>=0){let Rp=Cp[Dp];if(Rp===void 0&&(Dp==="instanceMatrix"&&ju.instanceMatrix&&(Rp=ju.instanceMatrix),Dp==="instanceColor"&&ju.instanceColor&&(Rp=ju.instanceColor)),Rp!==void 0){const xp=Rp.normalized,cm=Rp.itemSize,lm=eu.get(Rp);if(lm===void 0)continue;const vp=lm.buffer,bp=lm.type,kp=lm.bytesPerElement,dm=bp===iu.INT||bp===iu.UNSIGNED_INT||Rp.gpuType===IntType;if(Rp.isInterleavedBufferAttribute){const nm=Rp.data,Bp=nm.stride,Qp=Rp.offset;if(nm.isInstancedInterleavedBuffer){for(let Xp=0;Xp<dp.locationSize;Xp++)_u(dp.location+Xp,nm.meshPerAttribute);ju.isInstancedMesh!==!0&&yp._maxInstanceCount===void 0&&(yp._maxInstanceCount=nm.meshPerAttribute*nm.count)}else for(let Xp=0;Xp<dp.locationSize;Xp++)Bu(dp.location+Xp);iu.bindBuffer(iu.ARRAY_BUFFER,vp);for(let Xp=0;Xp<dp.locationSize;Xp++)Du(dp.location+Xp,cm/dp.locationSize,bp,xp,Bp*kp,(Qp+cm/dp.locationSize*Xp)*kp,dm)}else{if(Rp.isInstancedBufferAttribute){for(let nm=0;nm<dp.locationSize;nm++)_u(dp.location+nm,Rp.meshPerAttribute);ju.isInstancedMesh!==!0&&yp._maxInstanceCount===void 0&&(yp._maxInstanceCount=Rp.meshPerAttribute*Rp.count)}else for(let nm=0;nm<dp.locationSize;nm++)Bu(dp.location+nm);iu.bindBuffer(iu.ARRAY_BUFFER,vp);for(let nm=0;nm<dp.locationSize;nm++)Du(dp.location+nm,cm/dp.locationSize,bp,xp,cm*kp,cm/dp.locationSize*nm*kp,dm)}}else if(wp!==void 0){const xp=wp[Dp];if(xp!==void 0)switch(xp.length){case 2:iu.vertexAttrib2fv(dp.location,xp);break;case 3:iu.vertexAttrib3fv(dp.location,xp);break;case 4:iu.vertexAttrib4fv(dp.location,xp);break;default:iu.vertexAttrib1fv(dp.location,xp)}}}}Lu()}function Wu(){Yu();for(const ju in su){const tp=su[ju];for(const gp in tp){const yp=tp[gp];for(const Cp in yp)xu(yp[Cp].object),delete yp[Cp];delete tp[gp]}delete su[ju]}}function Zu(ju){if(su[ju.id]===void 0)return;const tp=su[ju.id];for(const gp in tp){const yp=tp[gp];for(const Cp in yp)xu(yp[Cp].object),delete yp[Cp];delete tp[gp]}delete su[ju.id]}function Hu(ju){for(const tp in su){const gp=su[tp];if(gp[ju.id]===void 0)continue;const yp=gp[ju.id];for(const Cp in yp)xu(yp[Cp].object),delete yp[Cp];delete gp[ju.id]}}function Yu(){Ku(),du=!0,uu!==au&&(uu=au,yu(uu.object))}function Ku(){au.geometry=null,au.program=null,au.wireframe=!1}return{setup:fu,reset:Yu,resetDefaultState:Ku,dispose:Wu,releaseStatesOfGeometry:Zu,releaseStatesOfProgram:Hu,initAttributes:ku,enableAttribute:Bu,disableUnusedAttributes:Lu}}function WebGLBufferRenderer(iu,eu,tu){let su;function au(yu){su=yu}function uu(yu,xu){iu.drawArrays(su,yu,xu),tu.update(xu,su,1)}function du(yu,xu,vu){vu!==0&&(iu.drawArraysInstanced(su,yu,xu,vu),tu.update(xu,su,vu))}function fu(yu,xu,vu){if(vu===0)return;eu.get("WEBGL_multi_draw").multiDrawArraysWEBGL(su,yu,0,xu,0,vu);let Iu=0;for(let Mu=0;Mu<vu;Mu++)Iu+=xu[Mu];tu.update(Iu,su,1)}function gu(yu,xu,vu,Su){if(vu===0)return;const Iu=eu.get("WEBGL_multi_draw");if(Iu===null)for(let Mu=0;Mu<yu.length;Mu++)du(yu[Mu],xu[Mu],Su[Mu]);else{Iu.multiDrawArraysInstancedWEBGL(su,yu,0,xu,0,Su,0,vu);let Mu=0;for(let ku=0;ku<vu;ku++)Mu+=xu[ku]*Su[ku];tu.update(Mu,su,1)}}this.setMode=au,this.render=uu,this.renderInstances=du,this.renderMultiDraw=fu,this.renderMultiDrawInstances=gu}function WebGLCapabilities(iu,eu,tu,su){let au;function uu(){if(au!==void 0)return au;if(eu.has("EXT_texture_filter_anisotropic")===!0){const Hu=eu.get("EXT_texture_filter_anisotropic");au=iu.getParameter(Hu.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else au=0;return au}function du(Hu){return!(Hu!==RGBAFormat&&su.convert(Hu)!==iu.getParameter(iu.IMPLEMENTATION_COLOR_READ_FORMAT))}function fu(Hu){const Yu=Hu===HalfFloatType&&(eu.has("EXT_color_buffer_half_float")||eu.has("EXT_color_buffer_float"));return!(Hu!==UnsignedByteType&&su.convert(Hu)!==iu.getParameter(iu.IMPLEMENTATION_COLOR_READ_TYPE)&&Hu!==FloatType&&!Yu)}function gu(Hu){if(Hu==="highp"){if(iu.getShaderPrecisionFormat(iu.VERTEX_SHADER,iu.HIGH_FLOAT).precision>0&&iu.getShaderPrecisionFormat(iu.FRAGMENT_SHADER,iu.HIGH_FLOAT).precision>0)return"highp";Hu="mediump"}return Hu==="mediump"&&iu.getShaderPrecisionFormat(iu.VERTEX_SHADER,iu.MEDIUM_FLOAT).precision>0&&iu.getShaderPrecisionFormat(iu.FRAGMENT_SHADER,iu.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let yu=tu.precision!==void 0?tu.precision:"highp";const xu=gu(yu);xu!==yu&&(console.warn("THREE.WebGLRenderer:",yu,"not supported, using",xu,"instead."),yu=xu);const vu=tu.logarithmicDepthBuffer===!0,Su=tu.reverseDepthBuffer===!0&&eu.has("EXT_clip_control"),Iu=iu.getParameter(iu.MAX_TEXTURE_IMAGE_UNITS),Mu=iu.getParameter(iu.MAX_VERTEX_TEXTURE_IMAGE_UNITS),ku=iu.getParameter(iu.MAX_TEXTURE_SIZE),Bu=iu.getParameter(iu.MAX_CUBE_MAP_TEXTURE_SIZE),_u=iu.getParameter(iu.MAX_VERTEX_ATTRIBS),Lu=iu.getParameter(iu.MAX_VERTEX_UNIFORM_VECTORS),Du=iu.getParameter(iu.MAX_VARYING_VECTORS),Ou=iu.getParameter(iu.MAX_FRAGMENT_UNIFORM_VECTORS),Wu=Mu>0,Zu=iu.getParameter(iu.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:uu,getMaxPrecision:gu,textureFormatReadable:du,textureTypeReadable:fu,precision:yu,logarithmicDepthBuffer:vu,reverseDepthBuffer:Su,maxTextures:Iu,maxVertexTextures:Mu,maxTextureSize:ku,maxCubemapSize:Bu,maxAttributes:_u,maxVertexUniforms:Lu,maxVaryings:Du,maxFragmentUniforms:Ou,vertexTextures:Wu,maxSamples:Zu}}function WebGLClipping(iu){const eu=this;let tu=null,su=0,au=!1,uu=!1;const du=new Plane,fu=new Matrix3,gu={value:null,needsUpdate:!1};this.uniform=gu,this.numPlanes=0,this.numIntersection=0,this.init=function(vu,Su){const Iu=vu.length!==0||Su||su!==0||au;return au=Su,su=vu.length,Iu},this.beginShadows=function(){uu=!0,xu(null)},this.endShadows=function(){uu=!1},this.setGlobalState=function(vu,Su){tu=xu(vu,Su,0)},this.setState=function(vu,Su,Iu){const Mu=vu.clippingPlanes,ku=vu.clipIntersection,Bu=vu.clipShadows,_u=iu.get(vu);if(!au||Mu===null||Mu.length===0||uu&&!Bu)uu?xu(null):yu();else{const Lu=uu?0:su,Du=Lu*4;let Ou=_u.clippingState||null;gu.value=Ou,Ou=xu(Mu,Su,Du,Iu);for(let Wu=0;Wu!==Du;++Wu)Ou[Wu]=tu[Wu];_u.clippingState=Ou,this.numIntersection=ku?this.numPlanes:0,this.numPlanes+=Lu}};function yu(){gu.value!==tu&&(gu.value=tu,gu.needsUpdate=su>0),eu.numPlanes=su,eu.numIntersection=0}function xu(vu,Su,Iu,Mu){const ku=vu!==null?vu.length:0;let Bu=null;if(ku!==0){if(Bu=gu.value,Mu!==!0||Bu===null){const _u=Iu+ku*4,Lu=Su.matrixWorldInverse;fu.getNormalMatrix(Lu),(Bu===null||Bu.length<_u)&&(Bu=new Float32Array(_u));for(let Du=0,Ou=Iu;Du!==ku;++Du,Ou+=4)du.copy(vu[Du]).applyMatrix4(Lu,fu),du.normal.toArray(Bu,Ou),Bu[Ou+3]=du.constant}gu.value=Bu,gu.needsUpdate=!0}return eu.numPlanes=ku,eu.numIntersection=0,Bu}}function WebGLCubeMaps(iu){let eu=new WeakMap;function tu(du,fu){return fu===EquirectangularReflectionMapping?du.mapping=CubeReflectionMapping:fu===EquirectangularRefractionMapping&&(du.mapping=CubeRefractionMapping),du}function su(du){if(du&&du.isTexture){const fu=du.mapping;if(fu===EquirectangularReflectionMapping||fu===EquirectangularRefractionMapping)if(eu.has(du)){const gu=eu.get(du).texture;return tu(gu,du.mapping)}else{const gu=du.image;if(gu&&gu.height>0){const yu=new WebGLCubeRenderTarget(gu.height);return yu.fromEquirectangularTexture(iu,du),eu.set(du,yu),du.addEventListener("dispose",au),tu(yu.texture,du.mapping)}else return null}}return du}function au(du){const fu=du.target;fu.removeEventListener("dispose",au);const gu=eu.get(fu);gu!==void 0&&(eu.delete(fu),gu.dispose())}function uu(){eu=new WeakMap}return{get:su,dispose:uu}}const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera,_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0,_oldXrEnabled=!1;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(-PHI,INV_PHI,0),new Vector3(PHI,INV_PHI,0),new Vector3(-INV_PHI,0,PHI),new Vector3(INV_PHI,0,PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(0,PHI,INV_PHI),new Vector3(-1,1,-1),new Vector3(1,1,-1),new Vector3(-1,1,1),new Vector3(1,1,1)];class PMREMGenerator{constructor(eu){this._renderer=eu,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(eu,tu=0,su=.1,au=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const uu=this._allocateTargets();return uu.depthBuffer=!0,this._sceneToCubeUV(eu,su,au,uu),tu>0&&this._blur(uu,0,0,tu),this._applyPMREM(uu),this._cleanup(uu),uu}fromEquirectangular(eu,tu=null){return this._fromTexture(eu,tu)}fromCubemap(eu,tu=null){return this._fromTexture(eu,tu)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(eu){this._lodMax=Math.floor(Math.log2(eu)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let eu=0;eu<this._lodPlanes.length;eu++)this._lodPlanes[eu].dispose()}_cleanup(eu){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),this._renderer.xr.enabled=_oldXrEnabled,eu.scissorTest=!1,_setViewport(eu,0,0,eu.width,eu.height)}_fromTexture(eu,tu){eu.mapping===CubeReflectionMapping||eu.mapping===CubeRefractionMapping?this._setSize(eu.image.length===0?16:eu.image[0].width||eu.image[0].image.width):this._setSize(eu.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const su=tu||this._allocateTargets();return this._textureToCubeUV(eu,su),this._applyPMREM(su),this._cleanup(su),su}_allocateTargets(){const eu=3*Math.max(this._cubeSize,112),tu=4*this._cubeSize,su={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!1},au=_createRenderTarget(eu,tu,su);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==eu||this._pingPongRenderTarget.height!==tu){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(eu,tu,su);const{_lodMax:uu}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes(uu)),this._blurMaterial=_getBlurShader(uu,eu,tu)}return au}_compileMaterial(eu){const tu=new Mesh(this._lodPlanes[0],eu);this._renderer.compile(tu,_flatCamera)}_sceneToCubeUV(eu,tu,su,au){const fu=new PerspectiveCamera(90,1,tu,su),gu=[1,-1,1,1,1,1],yu=[1,1,1,-1,-1,-1],xu=this._renderer,vu=xu.autoClear,Su=xu.toneMapping;xu.getClearColor(_clearColor),xu.toneMapping=NoToneMapping,xu.autoClear=!1;const Iu=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1}),Mu=new Mesh(new BoxGeometry,Iu);let ku=!1;const Bu=eu.background;Bu?Bu.isColor&&(Iu.color.copy(Bu),eu.background=null,ku=!0):(Iu.color.copy(_clearColor),ku=!0);for(let _u=0;_u<6;_u++){const Lu=_u%3;Lu===0?(fu.up.set(0,gu[_u],0),fu.lookAt(yu[_u],0,0)):Lu===1?(fu.up.set(0,0,gu[_u]),fu.lookAt(0,yu[_u],0)):(fu.up.set(0,gu[_u],0),fu.lookAt(0,0,yu[_u]));const Du=this._cubeSize;_setViewport(au,Lu*Du,_u>2?Du:0,Du,Du),xu.setRenderTarget(au),ku&&xu.render(Mu,fu),xu.render(eu,fu)}Mu.geometry.dispose(),Mu.material.dispose(),xu.toneMapping=Su,xu.autoClear=vu,eu.background=Bu}_textureToCubeUV(eu,tu){const su=this._renderer,au=eu.mapping===CubeReflectionMapping||eu.mapping===CubeRefractionMapping;au?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=eu.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const uu=au?this._cubemapMaterial:this._equirectMaterial,du=new Mesh(this._lodPlanes[0],uu),fu=uu.uniforms;fu.envMap.value=eu;const gu=this._cubeSize;_setViewport(tu,0,0,3*gu,2*gu),su.setRenderTarget(tu),su.render(du,_flatCamera)}_applyPMREM(eu){const tu=this._renderer,su=tu.autoClear;tu.autoClear=!1;const au=this._lodPlanes.length;for(let uu=1;uu<au;uu++){const du=Math.sqrt(this._sigmas[uu]*this._sigmas[uu]-this._sigmas[uu-1]*this._sigmas[uu-1]),fu=_axisDirections[(au-uu-1)%_axisDirections.length];this._blur(eu,uu-1,uu,du,fu)}tu.autoClear=su}_blur(eu,tu,su,au,uu){const du=this._pingPongRenderTarget;this._halfBlur(eu,du,tu,su,au,"latitudinal",uu),this._halfBlur(du,eu,su,su,au,"longitudinal",uu)}_halfBlur(eu,tu,su,au,uu,du,fu){const gu=this._renderer,yu=this._blurMaterial;du!=="latitudinal"&&du!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const xu=3,vu=new Mesh(this._lodPlanes[au],yu),Su=yu.uniforms,Iu=this._sizeLods[su]-1,Mu=isFinite(uu)?Math.PI/(2*Iu):2*Math.PI/(2*MAX_SAMPLES-1),ku=uu/Mu,Bu=isFinite(uu)?1+Math.floor(xu*ku):MAX_SAMPLES;Bu>MAX_SAMPLES&&console.warn(`sigmaRadians, ${uu}, is too large and will clip, as it requested ${Bu} samples when the maximum is set to ${MAX_SAMPLES}`);const _u=[];let Lu=0;for(let Hu=0;Hu<MAX_SAMPLES;++Hu){const Yu=Hu/ku,Ku=Math.exp(-Yu*Yu/2);_u.push(Ku),Hu===0?Lu+=Ku:Hu<Bu&&(Lu+=2*Ku)}for(let Hu=0;Hu<_u.length;Hu++)_u[Hu]=_u[Hu]/Lu;Su.envMap.value=eu.texture,Su.samples.value=Bu,Su.weights.value=_u,Su.latitudinal.value=du==="latitudinal",fu&&(Su.poleAxis.value=fu);const{_lodMax:Du}=this;Su.dTheta.value=Mu,Su.mipInt.value=Du-su;const Ou=this._sizeLods[au],Wu=3*Ou*(au>Du-LOD_MIN?au-Du+LOD_MIN:0),Zu=4*(this._cubeSize-Ou);_setViewport(tu,Wu,Zu,3*Ou,2*Ou),gu.setRenderTarget(tu),gu.render(vu,_flatCamera)}}function _createPlanes(iu){const eu=[],tu=[],su=[];let au=iu;const uu=iu-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let du=0;du<uu;du++){const fu=Math.pow(2,au);tu.push(fu);let gu=1/fu;du>iu-LOD_MIN?gu=EXTRA_LOD_SIGMA[du-iu+LOD_MIN-1]:du===0&&(gu=0),su.push(gu);const yu=1/(fu-2),xu=-yu,vu=1+yu,Su=[xu,xu,vu,xu,vu,vu,xu,xu,vu,vu,xu,vu],Iu=6,Mu=6,ku=3,Bu=2,_u=1,Lu=new Float32Array(ku*Mu*Iu),Du=new Float32Array(Bu*Mu*Iu),Ou=new Float32Array(_u*Mu*Iu);for(let Zu=0;Zu<Iu;Zu++){const Hu=Zu%3*2/3-1,Yu=Zu>2?0:-1,Ku=[Hu,Yu,0,Hu+2/3,Yu,0,Hu+2/3,Yu+1,0,Hu,Yu,0,Hu+2/3,Yu+1,0,Hu,Yu+1,0];Lu.set(Ku,ku*Mu*Zu),Du.set(Su,Bu*Mu*Zu);const ju=[Zu,Zu,Zu,Zu,Zu,Zu];Ou.set(ju,_u*Mu*Zu)}const Wu=new BufferGeometry;Wu.setAttribute("position",new BufferAttribute(Lu,ku)),Wu.setAttribute("uv",new BufferAttribute(Du,Bu)),Wu.setAttribute("faceIndex",new BufferAttribute(Ou,_u)),eu.push(Wu),au>LOD_MIN&&au--}return{lodPlanes:eu,sizeLods:tu,sigmas:su}}function _createRenderTarget(iu,eu,tu){const su=new WebGLRenderTarget(iu,eu,tu);return su.texture.mapping=CubeUVReflectionMapping,su.texture.name="PMREM.cubeUv",su.scissorTest=!0,su}function _setViewport(iu,eu,tu,su,au){iu.viewport.set(eu,tu,su,au),iu.scissor.set(eu,tu,su,au)}function _getBlurShader(iu,eu,tu){const su=new Float32Array(MAX_SAMPLES),au=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/eu,CUBEUV_TEXEL_HEIGHT:1/tu,CUBEUV_MAX_MIP:`${iu}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:su},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:au}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(iu){let eu=new WeakMap,tu=null;function su(fu){if(fu&&fu.isTexture){const gu=fu.mapping,yu=gu===EquirectangularReflectionMapping||gu===EquirectangularRefractionMapping,xu=gu===CubeReflectionMapping||gu===CubeRefractionMapping;if(yu||xu){let vu=eu.get(fu);const Su=vu!==void 0?vu.texture.pmremVersion:0;if(fu.isRenderTargetTexture&&fu.pmremVersion!==Su)return tu===null&&(tu=new PMREMGenerator(iu)),vu=yu?tu.fromEquirectangular(fu,vu):tu.fromCubemap(fu,vu),vu.texture.pmremVersion=fu.pmremVersion,eu.set(fu,vu),vu.texture;if(vu!==void 0)return vu.texture;{const Iu=fu.image;return yu&&Iu&&Iu.height>0||xu&&Iu&&au(Iu)?(tu===null&&(tu=new PMREMGenerator(iu)),vu=yu?tu.fromEquirectangular(fu):tu.fromCubemap(fu),vu.texture.pmremVersion=fu.pmremVersion,eu.set(fu,vu),fu.addEventListener("dispose",uu),vu.texture):null}}}return fu}function au(fu){let gu=0;const yu=6;for(let xu=0;xu<yu;xu++)fu[xu]!==void 0&&gu++;return gu===yu}function uu(fu){const gu=fu.target;gu.removeEventListener("dispose",uu);const yu=eu.get(gu);yu!==void 0&&(eu.delete(gu),yu.dispose())}function du(){eu=new WeakMap,tu!==null&&(tu.dispose(),tu=null)}return{get:su,dispose:du}}function WebGLExtensions(iu){const eu={};function tu(su){if(eu[su]!==void 0)return eu[su];let au;switch(su){case"WEBGL_depth_texture":au=iu.getExtension("WEBGL_depth_texture")||iu.getExtension("MOZ_WEBGL_depth_texture")||iu.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":au=iu.getExtension("EXT_texture_filter_anisotropic")||iu.getExtension("MOZ_EXT_texture_filter_anisotropic")||iu.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":au=iu.getExtension("WEBGL_compressed_texture_s3tc")||iu.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||iu.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":au=iu.getExtension("WEBGL_compressed_texture_pvrtc")||iu.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:au=iu.getExtension(su)}return eu[su]=au,au}return{has:function(su){return tu(su)!==null},init:function(){tu("EXT_color_buffer_float"),tu("WEBGL_clip_cull_distance"),tu("OES_texture_float_linear"),tu("EXT_color_buffer_half_float"),tu("WEBGL_multisampled_render_to_texture"),tu("WEBGL_render_shared_exponent")},get:function(su){const au=tu(su);return au===null&&warnOnce("THREE.WebGLRenderer: "+su+" extension not supported."),au}}}function WebGLGeometries(iu,eu,tu,su){const au={},uu=new WeakMap;function du(vu){const Su=vu.target;Su.index!==null&&eu.remove(Su.index);for(const Mu in Su.attributes)eu.remove(Su.attributes[Mu]);Su.removeEventListener("dispose",du),delete au[Su.id];const Iu=uu.get(Su);Iu&&(eu.remove(Iu),uu.delete(Su)),su.releaseStatesOfGeometry(Su),Su.isInstancedBufferGeometry===!0&&delete Su._maxInstanceCount,tu.memory.geometries--}function fu(vu,Su){return au[Su.id]===!0||(Su.addEventListener("dispose",du),au[Su.id]=!0,tu.memory.geometries++),Su}function gu(vu){const Su=vu.attributes;for(const Iu in Su)eu.update(Su[Iu],iu.ARRAY_BUFFER)}function yu(vu){const Su=[],Iu=vu.index,Mu=vu.attributes.position;let ku=0;if(Iu!==null){const Lu=Iu.array;ku=Iu.version;for(let Du=0,Ou=Lu.length;Du<Ou;Du+=3){const Wu=Lu[Du+0],Zu=Lu[Du+1],Hu=Lu[Du+2];Su.push(Wu,Zu,Zu,Hu,Hu,Wu)}}else if(Mu!==void 0){const Lu=Mu.array;ku=Mu.version;for(let Du=0,Ou=Lu.length/3-1;Du<Ou;Du+=3){const Wu=Du+0,Zu=Du+1,Hu=Du+2;Su.push(Wu,Zu,Zu,Hu,Hu,Wu)}}else return;const Bu=new(arrayNeedsUint32(Su)?Uint32BufferAttribute:Uint16BufferAttribute)(Su,1);Bu.version=ku;const _u=uu.get(vu);_u&&eu.remove(_u),uu.set(vu,Bu)}function xu(vu){const Su=uu.get(vu);if(Su){const Iu=vu.index;Iu!==null&&Su.version<Iu.version&&yu(vu)}else yu(vu);return uu.get(vu)}return{get:fu,update:gu,getWireframeAttribute:xu}}function WebGLIndexedBufferRenderer(iu,eu,tu){let su;function au(Su){su=Su}let uu,du;function fu(Su){uu=Su.type,du=Su.bytesPerElement}function gu(Su,Iu){iu.drawElements(su,Iu,uu,Su*du),tu.update(Iu,su,1)}function yu(Su,Iu,Mu){Mu!==0&&(iu.drawElementsInstanced(su,Iu,uu,Su*du,Mu),tu.update(Iu,su,Mu))}function xu(Su,Iu,Mu){if(Mu===0)return;eu.get("WEBGL_multi_draw").multiDrawElementsWEBGL(su,Iu,0,uu,Su,0,Mu);let Bu=0;for(let _u=0;_u<Mu;_u++)Bu+=Iu[_u];tu.update(Bu,su,1)}function vu(Su,Iu,Mu,ku){if(Mu===0)return;const Bu=eu.get("WEBGL_multi_draw");if(Bu===null)for(let _u=0;_u<Su.length;_u++)yu(Su[_u]/du,Iu[_u],ku[_u]);else{Bu.multiDrawElementsInstancedWEBGL(su,Iu,0,uu,Su,0,ku,0,Mu);let _u=0;for(let Lu=0;Lu<Mu;Lu++)_u+=Iu[Lu]*ku[Lu];tu.update(_u,su,1)}}this.setMode=au,this.setIndex=fu,this.render=gu,this.renderInstances=yu,this.renderMultiDraw=xu,this.renderMultiDrawInstances=vu}function WebGLInfo(iu){const eu={geometries:0,textures:0},tu={frame:0,calls:0,triangles:0,points:0,lines:0};function su(uu,du,fu){switch(tu.calls++,du){case iu.TRIANGLES:tu.triangles+=fu*(uu/3);break;case iu.LINES:tu.lines+=fu*(uu/2);break;case iu.LINE_STRIP:tu.lines+=fu*(uu-1);break;case iu.LINE_LOOP:tu.lines+=fu*uu;break;case iu.POINTS:tu.points+=fu*uu;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",du);break}}function au(){tu.calls=0,tu.triangles=0,tu.points=0,tu.lines=0}return{memory:eu,render:tu,programs:null,autoReset:!0,reset:au,update:su}}function WebGLMorphtargets(iu,eu,tu){const su=new WeakMap,au=new Vector4;function uu(du,fu,gu){const yu=du.morphTargetInfluences,xu=fu.morphAttributes.position||fu.morphAttributes.normal||fu.morphAttributes.color,vu=xu!==void 0?xu.length:0;let Su=su.get(fu);if(Su===void 0||Su.count!==vu){let ju=function(){Yu.dispose(),su.delete(fu),fu.removeEventListener("dispose",ju)};var Iu=ju;Su!==void 0&&Su.texture.dispose();const Mu=fu.morphAttributes.position!==void 0,ku=fu.morphAttributes.normal!==void 0,Bu=fu.morphAttributes.color!==void 0,_u=fu.morphAttributes.position||[],Lu=fu.morphAttributes.normal||[],Du=fu.morphAttributes.color||[];let Ou=0;Mu===!0&&(Ou=1),ku===!0&&(Ou=2),Bu===!0&&(Ou=3);let Wu=fu.attributes.position.count*Ou,Zu=1;Wu>eu.maxTextureSize&&(Zu=Math.ceil(Wu/eu.maxTextureSize),Wu=eu.maxTextureSize);const Hu=new Float32Array(Wu*Zu*4*vu),Yu=new DataArrayTexture(Hu,Wu,Zu,vu);Yu.type=FloatType,Yu.needsUpdate=!0;const Ku=Ou*4;for(let tp=0;tp<vu;tp++){const gp=_u[tp],yp=Lu[tp],Cp=Du[tp],Hp=Wu*Zu*4*tp;for(let wp=0;wp<gp.count;wp++){const Dp=wp*Ku;Mu===!0&&(au.fromBufferAttribute(gp,wp),Hu[Hp+Dp+0]=au.x,Hu[Hp+Dp+1]=au.y,Hu[Hp+Dp+2]=au.z,Hu[Hp+Dp+3]=0),ku===!0&&(au.fromBufferAttribute(yp,wp),Hu[Hp+Dp+4]=au.x,Hu[Hp+Dp+5]=au.y,Hu[Hp+Dp+6]=au.z,Hu[Hp+Dp+7]=0),Bu===!0&&(au.fromBufferAttribute(Cp,wp),Hu[Hp+Dp+8]=au.x,Hu[Hp+Dp+9]=au.y,Hu[Hp+Dp+10]=au.z,Hu[Hp+Dp+11]=Cp.itemSize===4?au.w:1)}}Su={count:vu,texture:Yu,size:new Vector2(Wu,Zu)},su.set(fu,Su),fu.addEventListener("dispose",ju)}if(du.isInstancedMesh===!0&&du.morphTexture!==null)gu.getUniforms().setValue(iu,"morphTexture",du.morphTexture,tu);else{let Mu=0;for(let Bu=0;Bu<yu.length;Bu++)Mu+=yu[Bu];const ku=fu.morphTargetsRelative?1:1-Mu;gu.getUniforms().setValue(iu,"morphTargetBaseInfluence",ku),gu.getUniforms().setValue(iu,"morphTargetInfluences",yu)}gu.getUniforms().setValue(iu,"morphTargetsTexture",Su.texture,tu),gu.getUniforms().setValue(iu,"morphTargetsTextureSize",Su.size)}return{update:uu}}class WebGLMultiview{constructor(eu,tu,su){if(this.renderer=eu,this.DEFAULT_NUMVIEWS=2,this.maxNumViews=0,this.gl=su,this.extensions=tu,this.available=this.extensions.has("OCULUS_multiview"),this.available){const uu=this.extensions.get("OCULUS_multiview");this.maxNumViews=this.gl.getParameter(uu.MAX_VIEWS_OVR),this.mat4=[],this.mat3=[],this.cameraArray=[];for(var au=0;au<this.maxNumViews;au++)this.mat4[au]=new Matrix4,this.mat3[au]=new Matrix3}}getCameraArray(eu){return eu.isArrayCamera?eu.cameras:(this.cameraArray[0]=eu,this.cameraArray)}updateCameraProjectionMatricesUniform(eu,tu){for(var su=this.getCameraArray(eu),au=0;au<su.length;au++)this.mat4[au].copy(su[au].projectionMatrix);tu.setValue(this.gl,"projectionMatrices",this.mat4)}updateCameraViewMatricesUniform(eu,tu){for(var su=this.getCameraArray(eu),au=0;au<su.length;au++)this.mat4[au].copy(su[au].matrixWorldInverse);tu.setValue(this.gl,"viewMatrices",this.mat4)}updateObjectMatricesUniforms(eu,tu,su){for(var au=this.getCameraArray(tu),uu=0;uu<au.length;uu++)this.mat4[uu].multiplyMatrices(au[uu].matrixWorldInverse,eu.matrixWorld),this.mat3[uu].getNormalMatrix(this.mat4[uu]);su.setValue(this.gl,"modelViewMatrices",this.mat4),su.setValue(this.gl,"normalMatrices",this.mat3)}}function WebGLObjects(iu,eu,tu,su){let au=new WeakMap;function uu(gu){const yu=su.render.frame,xu=gu.geometry,vu=eu.get(gu,xu);if(au.get(vu)!==yu&&(eu.update(vu),au.set(vu,yu)),gu.isInstancedMesh&&(gu.hasEventListener("dispose",fu)===!1&&gu.addEventListener("dispose",fu),au.get(gu)!==yu&&(tu.update(gu.instanceMatrix,iu.ARRAY_BUFFER),gu.instanceColor!==null&&tu.update(gu.instanceColor,iu.ARRAY_BUFFER),au.set(gu,yu))),gu.isSkinnedMesh){const Su=gu.skeleton;au.get(Su)!==yu&&(Su.update(),au.set(Su,yu))}return vu}function du(){au=new WeakMap}function fu(gu){const yu=gu.target;yu.removeEventListener("dispose",fu),tu.remove(yu.instanceMatrix),yu.instanceColor!==null&&tu.remove(yu.instanceColor)}return{update:uu,dispose:du}}const emptyTexture=new Texture,emptyShadowTexture=new DepthTexture(1,1),emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten(iu,eu,tu){const su=iu[0];if(su<=0||su>0)return iu;const au=eu*tu;let uu=arrayCacheF32[au];if(uu===void 0&&(uu=new Float32Array(au),arrayCacheF32[au]=uu),eu!==0){su.toArray(uu,0);for(let du=1,fu=0;du!==eu;++du)fu+=tu,iu[du].toArray(uu,fu)}return uu}function arraysEqual(iu,eu){if(iu.length!==eu.length)return!1;for(let tu=0,su=iu.length;tu<su;tu++)if(iu[tu]!==eu[tu])return!1;return!0}function copyArray(iu,eu){for(let tu=0,su=eu.length;tu<su;tu++)iu[tu]=eu[tu]}function allocTexUnits(iu,eu){let tu=arrayCacheI32[eu];tu===void 0&&(tu=new Int32Array(eu),arrayCacheI32[eu]=tu);for(let su=0;su!==eu;++su)tu[su]=iu.allocateTextureUnit();return tu}function setValueV1f(iu,eu){const tu=this.cache;tu[0]!==eu&&(iu.uniform1f(this.addr,eu),tu[0]=eu)}function setValueV2f(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y)&&(iu.uniform2f(this.addr,eu.x,eu.y),tu[0]=eu.x,tu[1]=eu.y);else{if(arraysEqual(tu,eu))return;iu.uniform2fv(this.addr,eu),copyArray(tu,eu)}}function setValueV3f(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y||tu[2]!==eu.z)&&(iu.uniform3f(this.addr,eu.x,eu.y,eu.z),tu[0]=eu.x,tu[1]=eu.y,tu[2]=eu.z);else if(eu.r!==void 0)(tu[0]!==eu.r||tu[1]!==eu.g||tu[2]!==eu.b)&&(iu.uniform3f(this.addr,eu.r,eu.g,eu.b),tu[0]=eu.r,tu[1]=eu.g,tu[2]=eu.b);else{if(arraysEqual(tu,eu))return;iu.uniform3fv(this.addr,eu),copyArray(tu,eu)}}function setValueV4f(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y||tu[2]!==eu.z||tu[3]!==eu.w)&&(iu.uniform4f(this.addr,eu.x,eu.y,eu.z,eu.w),tu[0]=eu.x,tu[1]=eu.y,tu[2]=eu.z,tu[3]=eu.w);else{if(arraysEqual(tu,eu))return;iu.uniform4fv(this.addr,eu),copyArray(tu,eu)}}function setValueM2(iu,eu){const tu=this.cache,su=eu.elements;if(su===void 0){if(arraysEqual(tu,eu))return;iu.uniformMatrix2fv(this.addr,!1,eu),copyArray(tu,eu)}else{if(arraysEqual(tu,su))return;mat2array.set(su),iu.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(tu,su)}}function setValueM3(iu,eu){const tu=this.cache,su=eu.elements;if(su===void 0){if(arraysEqual(tu,eu))return;iu.uniformMatrix3fv(this.addr,!1,eu),copyArray(tu,eu)}else{if(arraysEqual(tu,su))return;mat3array.set(su),iu.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(tu,su)}}function setValueM4(iu,eu){const tu=this.cache,su=eu.elements;if(su===void 0){if(arraysEqual(tu,eu))return;iu.uniformMatrix4fv(this.addr,!1,eu),copyArray(tu,eu)}else{if(arraysEqual(tu,su))return;mat4array.set(su),iu.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(tu,su)}}function setValueV1i(iu,eu){const tu=this.cache;tu[0]!==eu&&(iu.uniform1i(this.addr,eu),tu[0]=eu)}function setValueV2i(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y)&&(iu.uniform2i(this.addr,eu.x,eu.y),tu[0]=eu.x,tu[1]=eu.y);else{if(arraysEqual(tu,eu))return;iu.uniform2iv(this.addr,eu),copyArray(tu,eu)}}function setValueV3i(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y||tu[2]!==eu.z)&&(iu.uniform3i(this.addr,eu.x,eu.y,eu.z),tu[0]=eu.x,tu[1]=eu.y,tu[2]=eu.z);else{if(arraysEqual(tu,eu))return;iu.uniform3iv(this.addr,eu),copyArray(tu,eu)}}function setValueV4i(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y||tu[2]!==eu.z||tu[3]!==eu.w)&&(iu.uniform4i(this.addr,eu.x,eu.y,eu.z,eu.w),tu[0]=eu.x,tu[1]=eu.y,tu[2]=eu.z,tu[3]=eu.w);else{if(arraysEqual(tu,eu))return;iu.uniform4iv(this.addr,eu),copyArray(tu,eu)}}function setValueV1ui(iu,eu){const tu=this.cache;tu[0]!==eu&&(iu.uniform1ui(this.addr,eu),tu[0]=eu)}function setValueV2ui(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y)&&(iu.uniform2ui(this.addr,eu.x,eu.y),tu[0]=eu.x,tu[1]=eu.y);else{if(arraysEqual(tu,eu))return;iu.uniform2uiv(this.addr,eu),copyArray(tu,eu)}}function setValueV3ui(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y||tu[2]!==eu.z)&&(iu.uniform3ui(this.addr,eu.x,eu.y,eu.z),tu[0]=eu.x,tu[1]=eu.y,tu[2]=eu.z);else{if(arraysEqual(tu,eu))return;iu.uniform3uiv(this.addr,eu),copyArray(tu,eu)}}function setValueV4ui(iu,eu){const tu=this.cache;if(eu.x!==void 0)(tu[0]!==eu.x||tu[1]!==eu.y||tu[2]!==eu.z||tu[3]!==eu.w)&&(iu.uniform4ui(this.addr,eu.x,eu.y,eu.z,eu.w),tu[0]=eu.x,tu[1]=eu.y,tu[2]=eu.z,tu[3]=eu.w);else{if(arraysEqual(tu,eu))return;iu.uniform4uiv(this.addr,eu),copyArray(tu,eu)}}function setValueT1(iu,eu,tu){const su=this.cache,au=tu.allocateTextureUnit();su[0]!==au&&(iu.uniform1i(this.addr,au),su[0]=au);let uu;this.type===iu.SAMPLER_2D_SHADOW?(emptyShadowTexture.compareFunction=LessEqualCompare,uu=emptyShadowTexture):uu=emptyTexture,tu.setTexture2D(eu||uu,au)}function setValueT3D1(iu,eu,tu){const su=this.cache,au=tu.allocateTextureUnit();su[0]!==au&&(iu.uniform1i(this.addr,au),su[0]=au),tu.setTexture3D(eu||empty3dTexture,au)}function setValueT6(iu,eu,tu){const su=this.cache,au=tu.allocateTextureUnit();su[0]!==au&&(iu.uniform1i(this.addr,au),su[0]=au),tu.setTextureCube(eu||emptyCubeTexture,au)}function setValueT2DArray1(iu,eu,tu){const su=this.cache,au=tu.allocateTextureUnit();su[0]!==au&&(iu.uniform1i(this.addr,au),su[0]=au),tu.setTexture2DArray(eu||emptyArrayTexture,au)}function getSingularSetter(iu){switch(iu){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(iu,eu){iu.uniform1fv(this.addr,eu)}function setValueV2fArray(iu,eu){const tu=flatten(eu,this.size,2);iu.uniform2fv(this.addr,tu)}function setValueV3fArray(iu,eu){const tu=flatten(eu,this.size,3);iu.uniform3fv(this.addr,tu)}function setValueV4fArray(iu,eu){const tu=flatten(eu,this.size,4);iu.uniform4fv(this.addr,tu)}function setValueM2Array(iu,eu){const tu=flatten(eu,this.size,4);iu.uniformMatrix2fv(this.addr,!1,tu)}function setValueM3Array(iu,eu){const tu=flatten(eu,this.size,9);iu.uniformMatrix3fv(this.addr,!1,tu)}function setValueM4Array(iu,eu){const tu=flatten(eu,this.size,16);iu.uniformMatrix4fv(this.addr,!1,tu)}function setValueV1iArray(iu,eu){iu.uniform1iv(this.addr,eu)}function setValueV2iArray(iu,eu){iu.uniform2iv(this.addr,eu)}function setValueV3iArray(iu,eu){iu.uniform3iv(this.addr,eu)}function setValueV4iArray(iu,eu){iu.uniform4iv(this.addr,eu)}function setValueV1uiArray(iu,eu){iu.uniform1uiv(this.addr,eu)}function setValueV2uiArray(iu,eu){iu.uniform2uiv(this.addr,eu)}function setValueV3uiArray(iu,eu){iu.uniform3uiv(this.addr,eu)}function setValueV4uiArray(iu,eu){iu.uniform4uiv(this.addr,eu)}function setValueT1Array(iu,eu,tu){const su=this.cache,au=eu.length,uu=allocTexUnits(tu,au);arraysEqual(su,uu)||(iu.uniform1iv(this.addr,uu),copyArray(su,uu));for(let du=0;du!==au;++du)tu.setTexture2D(eu[du]||emptyTexture,uu[du])}function setValueT3DArray(iu,eu,tu){const su=this.cache,au=eu.length,uu=allocTexUnits(tu,au);arraysEqual(su,uu)||(iu.uniform1iv(this.addr,uu),copyArray(su,uu));for(let du=0;du!==au;++du)tu.setTexture3D(eu[du]||empty3dTexture,uu[du])}function setValueT6Array(iu,eu,tu){const su=this.cache,au=eu.length,uu=allocTexUnits(tu,au);arraysEqual(su,uu)||(iu.uniform1iv(this.addr,uu),copyArray(su,uu));for(let du=0;du!==au;++du)tu.setTextureCube(eu[du]||emptyCubeTexture,uu[du])}function setValueT2DArrayArray(iu,eu,tu){const su=this.cache,au=eu.length,uu=allocTexUnits(tu,au);arraysEqual(su,uu)||(iu.uniform1iv(this.addr,uu),copyArray(su,uu));for(let du=0;du!==au;++du)tu.setTexture2DArray(eu[du]||emptyArrayTexture,uu[du])}function getPureArraySetter(iu){switch(iu){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(eu,tu,su){this.id=eu,this.addr=su,this.cache=[],this.type=tu.type,this.setValue=getSingularSetter(tu.type)}}class PureArrayUniform{constructor(eu,tu,su){this.id=eu,this.addr=su,this.cache=[],this.type=tu.type,this.size=tu.size,this.setValue=getPureArraySetter(tu.type)}}class StructuredUniform{constructor(eu){this.id=eu,this.seq=[],this.map={}}setValue(eu,tu,su){const au=this.seq;for(let uu=0,du=au.length;uu!==du;++uu){const fu=au[uu];fu.setValue(eu,tu[fu.id],su)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(iu,eu){iu.seq.push(eu),iu.map[eu.id]=eu}function parseUniform(iu,eu,tu){const su=iu.name,au=su.length;for(RePathPart.lastIndex=0;;){const uu=RePathPart.exec(su),du=RePathPart.lastIndex;let fu=uu[1];const gu=uu[2]==="]",yu=uu[3];if(gu&&(fu=fu|0),yu===void 0||yu==="["&&du+2===au){addUniform(tu,yu===void 0?new SingleUniform(fu,iu,eu):new PureArrayUniform(fu,iu,eu));break}else{let vu=tu.map[fu];vu===void 0&&(vu=new StructuredUniform(fu),addUniform(tu,vu)),tu=vu}}}class WebGLUniforms{constructor(eu,tu){this.seq=[],this.map={};const su=eu.getProgramParameter(tu,eu.ACTIVE_UNIFORMS);for(let au=0;au<su;++au){const uu=eu.getActiveUniform(tu,au),du=eu.getUniformLocation(tu,uu.name);parseUniform(uu,du,this)}}setValue(eu,tu,su,au){const uu=this.map[tu];uu!==void 0&&uu.setValue(eu,su,au)}setOptional(eu,tu,su){const au=tu[su];au!==void 0&&this.setValue(eu,su,au)}static upload(eu,tu,su,au){for(let uu=0,du=tu.length;uu!==du;++uu){const fu=tu[uu],gu=su[fu.id];gu.needsUpdate!==!1&&fu.setValue(eu,gu.value,au)}}static seqWithValue(eu,tu){const su=[];for(let au=0,uu=eu.length;au!==uu;++au){const du=eu[au];du.id in tu&&su.push(du)}return su}}function WebGLShader(iu,eu,tu){const su=iu.createShader(eu);return iu.shaderSource(su,tu),iu.compileShader(su),su}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(iu,eu){const tu=iu.split(`
`),su=[],au=Math.max(eu-6,0),uu=Math.min(eu+6,tu.length);for(let du=au;du<uu;du++){const fu=du+1;su.push(`${fu===eu?">":" "} ${fu}: ${tu[du]}`)}return su.join(`
`)}const _m0=new Matrix3;function getEncodingComponents(iu){ColorManagement._getMatrix(_m0,ColorManagement.workingColorSpace,iu);const eu=`mat3( ${_m0.elements.map(tu=>tu.toFixed(4))} )`;switch(ColorManagement.getTransfer(iu)){case LinearTransfer:return[eu,"LinearTransferOETF"];case SRGBTransfer:return[eu,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",iu),[eu,"LinearTransferOETF"]}}function getShaderErrors(iu,eu,tu){const su=iu.getShaderParameter(eu,iu.COMPILE_STATUS),au=iu.getShaderInfoLog(eu).trim();if(su&&au==="")return"";const uu=/ERROR: 0:(\d+)/.exec(au);if(uu){const du=parseInt(uu[1]);return tu.toUpperCase()+`

`+au+`

`+handleSource(iu.getShaderSource(eu),du)}else return au}function getTexelEncodingFunction(iu,eu){const tu=getEncodingComponents(eu);return[`vec4 ${iu}( vec4 value ) {`,`	return ${tu[1]}( vec4( value.rgb * ${tu[0]}, value.a ) );`,"}"].join(`
`)}function getToneMappingFunction(iu,eu){let tu;switch(eu){case LinearToneMapping:tu="Linear";break;case ReinhardToneMapping:tu="Reinhard";break;case CineonToneMapping:tu="Cineon";break;case ACESFilmicToneMapping:tu="ACESFilmic";break;case AgXToneMapping:tu="AgX";break;case NeutralToneMapping:tu="Neutral";break;case CustomToneMapping:tu="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",eu),tu="Linear"}return"vec3 "+iu+"( vec3 color ) { return "+tu+"ToneMapping( color ); }"}const _v0=new Vector3;function getLuminanceFunction(){ColorManagement.getLuminanceCoefficients(_v0);const iu=_v0.x.toFixed(4),eu=_v0.y.toFixed(4),tu=_v0.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${iu}, ${eu}, ${tu} );`,"	return dot( weights, rgb );","}"].join(`
`)}function generateVertexExtensions(iu){return[iu.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",iu.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(filterEmptyLine).join(`
`)}function generateDefines(iu){const eu=[];for(const tu in iu){const su=iu[tu];su!==!1&&eu.push("#define "+tu+" "+su)}return eu.join(`
`)}function fetchAttributeLocations(iu,eu){const tu={},su=iu.getProgramParameter(eu,iu.ACTIVE_ATTRIBUTES);for(let au=0;au<su;au++){const uu=iu.getActiveAttrib(eu,au),du=uu.name;let fu=1;uu.type===iu.FLOAT_MAT2&&(fu=2),uu.type===iu.FLOAT_MAT3&&(fu=3),uu.type===iu.FLOAT_MAT4&&(fu=4),tu[du]={type:uu.type,location:iu.getAttribLocation(eu,du),locationSize:fu}}return tu}function filterEmptyLine(iu){return iu!==""}function replaceLightNums(iu,eu){const tu=eu.numSpotLightShadows+eu.numSpotLightMaps-eu.numSpotLightShadowsWithMaps;return iu.replace(/NUM_DIR_LIGHTS/g,eu.numDirLights).replace(/NUM_SPOT_LIGHTS/g,eu.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,eu.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,tu).replace(/NUM_RECT_AREA_LIGHTS/g,eu.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,eu.numPointLights).replace(/NUM_HEMI_LIGHTS/g,eu.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,eu.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,eu.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,eu.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,eu.numPointLightShadows)}function replaceClippingPlaneNums(iu,eu){return iu.replace(/NUM_CLIPPING_PLANES/g,eu.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,eu.numClippingPlanes-eu.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(iu){return iu.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map;function includeReplacer(iu,eu){let tu=ShaderChunk[eu];if(tu===void 0){const su=shaderChunkMap.get(eu);if(su!==void 0)tu=ShaderChunk[su],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',eu,su);else throw new Error("Can not resolve #include <"+eu+">")}return resolveIncludes(tu)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(iu){return iu.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(iu,eu,tu,su){let au="";for(let uu=parseInt(eu);uu<parseInt(tu);uu++)au+=su.replace(/\[\s*i\s*\]/g,"[ "+uu+" ]").replace(/UNROLLED_LOOP_INDEX/g,uu);return au}function generatePrecision(iu){let eu=`precision ${iu.precision} float;
	precision ${iu.precision} int;
	precision ${iu.precision} sampler2D;
	precision ${iu.precision} samplerCube;
	precision ${iu.precision} sampler3D;
	precision ${iu.precision} sampler2DArray;
	precision ${iu.precision} sampler2DShadow;
	precision ${iu.precision} samplerCubeShadow;
	precision ${iu.precision} sampler2DArrayShadow;
	precision ${iu.precision} isampler2D;
	precision ${iu.precision} isampler3D;
	precision ${iu.precision} isamplerCube;
	precision ${iu.precision} isampler2DArray;
	precision ${iu.precision} usampler2D;
	precision ${iu.precision} usampler3D;
	precision ${iu.precision} usamplerCube;
	precision ${iu.precision} usampler2DArray;
	`;return iu.precision==="highp"?eu+=`
#define HIGH_PRECISION`:iu.precision==="mediump"?eu+=`
#define MEDIUM_PRECISION`:iu.precision==="lowp"&&(eu+=`
#define LOW_PRECISION`),eu}function generateShadowMapTypeDefine(iu){let eu="SHADOWMAP_TYPE_BASIC";return iu.shadowMapType===PCFShadowMap?eu="SHADOWMAP_TYPE_PCF":iu.shadowMapType===PCFSoftShadowMap?eu="SHADOWMAP_TYPE_PCF_SOFT":iu.shadowMapType===VSMShadowMap&&(eu="SHADOWMAP_TYPE_VSM"),eu}function generateEnvMapTypeDefine(iu){let eu="ENVMAP_TYPE_CUBE";if(iu.envMap)switch(iu.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:eu="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:eu="ENVMAP_TYPE_CUBE_UV";break}return eu}function generateEnvMapModeDefine(iu){let eu="ENVMAP_MODE_REFLECTION";if(iu.envMap)switch(iu.envMapMode){case CubeRefractionMapping:eu="ENVMAP_MODE_REFRACTION";break}return eu}function generateEnvMapBlendingDefine(iu){let eu="ENVMAP_BLENDING_NONE";if(iu.envMap)switch(iu.combine){case MultiplyOperation:eu="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:eu="ENVMAP_BLENDING_MIX";break;case AddOperation:eu="ENVMAP_BLENDING_ADD";break}return eu}function generateCubeUVSize(iu){const eu=iu.envMapCubeUVHeight;if(eu===null)return null;const tu=Math.log2(eu)-2,su=1/eu;return{texelWidth:1/(3*Math.max(Math.pow(2,tu),7*16)),texelHeight:su,maxMip:tu}}function WebGLProgram(iu,eu,tu,su){const au=iu.getContext(),uu=tu.defines;let du=tu.vertexShader,fu=tu.fragmentShader;const gu=generateShadowMapTypeDefine(tu),yu=generateEnvMapTypeDefine(tu),xu=generateEnvMapModeDefine(tu),vu=generateEnvMapBlendingDefine(tu),Su=generateCubeUVSize(tu),Iu=generateVertexExtensions(tu),Mu=generateDefines(uu),ku=au.createProgram();let Bu,_u,Lu=tu.glslVersion?"#version "+tu.glslVersion+`
`:"";const Du=tu.numMultiviewViews;tu.isRawShaderMaterial?(Bu=["#define SHADER_TYPE "+tu.shaderType,"#define SHADER_NAME "+tu.shaderName,Mu].filter(filterEmptyLine).join(`
`),Bu.length>0&&(Bu+=`
`),_u=["#define SHADER_TYPE "+tu.shaderType,"#define SHADER_NAME "+tu.shaderName,Mu].filter(filterEmptyLine).join(`
`),_u.length>0&&(_u+=`
`)):(Bu=[generatePrecision(tu),"#define SHADER_TYPE "+tu.shaderType,"#define SHADER_NAME "+tu.shaderName,Mu,tu.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",tu.batching?"#define USE_BATCHING":"",tu.batchingColor?"#define USE_BATCHING_COLOR":"",tu.instancing?"#define USE_INSTANCING":"",tu.instancingColor?"#define USE_INSTANCING_COLOR":"",tu.instancingMorph?"#define USE_INSTANCING_MORPH":"",tu.useFog&&tu.fog?"#define USE_FOG":"",tu.useFog&&tu.fogExp2?"#define FOG_EXP2":"",tu.map?"#define USE_MAP":"",tu.envMap?"#define USE_ENVMAP":"",tu.envMap?"#define "+xu:"",tu.lightMap?"#define USE_LIGHTMAP":"",tu.aoMap?"#define USE_AOMAP":"",tu.bumpMap?"#define USE_BUMPMAP":"",tu.normalMap?"#define USE_NORMALMAP":"",tu.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",tu.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",tu.displacementMap?"#define USE_DISPLACEMENTMAP":"",tu.emissiveMap?"#define USE_EMISSIVEMAP":"",tu.anisotropy?"#define USE_ANISOTROPY":"",tu.anisotropyMap?"#define USE_ANISOTROPYMAP":"",tu.clearcoatMap?"#define USE_CLEARCOATMAP":"",tu.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",tu.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",tu.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",tu.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",tu.specularMap?"#define USE_SPECULARMAP":"",tu.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",tu.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",tu.roughnessMap?"#define USE_ROUGHNESSMAP":"",tu.metalnessMap?"#define USE_METALNESSMAP":"",tu.alphaMap?"#define USE_ALPHAMAP":"",tu.alphaHash?"#define USE_ALPHAHASH":"",tu.transmission?"#define USE_TRANSMISSION":"",tu.transmissionMap?"#define USE_TRANSMISSIONMAP":"",tu.thicknessMap?"#define USE_THICKNESSMAP":"",tu.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",tu.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",tu.mapUv?"#define MAP_UV "+tu.mapUv:"",tu.alphaMapUv?"#define ALPHAMAP_UV "+tu.alphaMapUv:"",tu.lightMapUv?"#define LIGHTMAP_UV "+tu.lightMapUv:"",tu.aoMapUv?"#define AOMAP_UV "+tu.aoMapUv:"",tu.emissiveMapUv?"#define EMISSIVEMAP_UV "+tu.emissiveMapUv:"",tu.bumpMapUv?"#define BUMPMAP_UV "+tu.bumpMapUv:"",tu.normalMapUv?"#define NORMALMAP_UV "+tu.normalMapUv:"",tu.displacementMapUv?"#define DISPLACEMENTMAP_UV "+tu.displacementMapUv:"",tu.metalnessMapUv?"#define METALNESSMAP_UV "+tu.metalnessMapUv:"",tu.roughnessMapUv?"#define ROUGHNESSMAP_UV "+tu.roughnessMapUv:"",tu.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+tu.anisotropyMapUv:"",tu.clearcoatMapUv?"#define CLEARCOATMAP_UV "+tu.clearcoatMapUv:"",tu.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+tu.clearcoatNormalMapUv:"",tu.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+tu.clearcoatRoughnessMapUv:"",tu.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+tu.iridescenceMapUv:"",tu.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+tu.iridescenceThicknessMapUv:"",tu.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+tu.sheenColorMapUv:"",tu.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+tu.sheenRoughnessMapUv:"",tu.specularMapUv?"#define SPECULARMAP_UV "+tu.specularMapUv:"",tu.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+tu.specularColorMapUv:"",tu.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+tu.specularIntensityMapUv:"",tu.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+tu.transmissionMapUv:"",tu.thicknessMapUv?"#define THICKNESSMAP_UV "+tu.thicknessMapUv:"",tu.vertexTangents&&tu.flatShading===!1?"#define USE_TANGENT":"",tu.vertexColors?"#define USE_COLOR":"",tu.vertexAlphas?"#define USE_COLOR_ALPHA":"",tu.vertexUv1s?"#define USE_UV1":"",tu.vertexUv2s?"#define USE_UV2":"",tu.vertexUv3s?"#define USE_UV3":"",tu.pointsUvs?"#define USE_POINTS_UV":"",tu.flatShading?"#define FLAT_SHADED":"",tu.skinning?"#define USE_SKINNING":"",tu.morphTargets?"#define USE_MORPHTARGETS":"",tu.morphNormals&&tu.flatShading===!1?"#define USE_MORPHNORMALS":"",tu.morphColors?"#define USE_MORPHCOLORS":"",tu.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+tu.morphTextureStride:"",tu.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+tu.morphTargetsCount:"",tu.doubleSided?"#define DOUBLE_SIDED":"",tu.flipSided?"#define FLIP_SIDED":"",tu.shadowMapEnabled?"#define USE_SHADOWMAP":"",tu.shadowMapEnabled?"#define "+gu:"",tu.sizeAttenuation?"#define USE_SIZEATTENUATION":"",tu.numLightProbes>0?"#define USE_LIGHT_PROBES":"",tu.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",tu.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),_u=[generatePrecision(tu),"#define SHADER_TYPE "+tu.shaderType,"#define SHADER_NAME "+tu.shaderName,Mu,tu.useFog&&tu.fog?"#define USE_FOG":"",tu.useFog&&tu.fogExp2?"#define FOG_EXP2":"",tu.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",tu.map?"#define USE_MAP":"",tu.matcap?"#define USE_MATCAP":"",tu.envMap?"#define USE_ENVMAP":"",tu.envMap?"#define "+yu:"",tu.envMap?"#define "+xu:"",tu.envMap?"#define "+vu:"",Su?"#define CUBEUV_TEXEL_WIDTH "+Su.texelWidth:"",Su?"#define CUBEUV_TEXEL_HEIGHT "+Su.texelHeight:"",Su?"#define CUBEUV_MAX_MIP "+Su.maxMip+".0":"",tu.lightMap?"#define USE_LIGHTMAP":"",tu.aoMap?"#define USE_AOMAP":"",tu.bumpMap?"#define USE_BUMPMAP":"",tu.normalMap?"#define USE_NORMALMAP":"",tu.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",tu.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",tu.emissiveMap?"#define USE_EMISSIVEMAP":"",tu.anisotropy?"#define USE_ANISOTROPY":"",tu.anisotropyMap?"#define USE_ANISOTROPYMAP":"",tu.clearcoat?"#define USE_CLEARCOAT":"",tu.clearcoatMap?"#define USE_CLEARCOATMAP":"",tu.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",tu.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",tu.dispersion?"#define USE_DISPERSION":"",tu.iridescence?"#define USE_IRIDESCENCE":"",tu.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",tu.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",tu.specularMap?"#define USE_SPECULARMAP":"",tu.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",tu.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",tu.roughnessMap?"#define USE_ROUGHNESSMAP":"",tu.metalnessMap?"#define USE_METALNESSMAP":"",tu.alphaMap?"#define USE_ALPHAMAP":"",tu.alphaTest?"#define USE_ALPHATEST":"",tu.alphaHash?"#define USE_ALPHAHASH":"",tu.sheen?"#define USE_SHEEN":"",tu.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",tu.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",tu.transmission?"#define USE_TRANSMISSION":"",tu.transmissionMap?"#define USE_TRANSMISSIONMAP":"",tu.thicknessMap?"#define USE_THICKNESSMAP":"",tu.vertexTangents&&tu.flatShading===!1?"#define USE_TANGENT":"",tu.vertexColors||tu.instancingColor||tu.batchingColor?"#define USE_COLOR":"",tu.vertexAlphas?"#define USE_COLOR_ALPHA":"",tu.vertexUv1s?"#define USE_UV1":"",tu.vertexUv2s?"#define USE_UV2":"",tu.vertexUv3s?"#define USE_UV3":"",tu.pointsUvs?"#define USE_POINTS_UV":"",tu.gradientMap?"#define USE_GRADIENTMAP":"",tu.flatShading?"#define FLAT_SHADED":"",tu.doubleSided?"#define DOUBLE_SIDED":"",tu.flipSided?"#define FLIP_SIDED":"",tu.shadowMapEnabled?"#define USE_SHADOWMAP":"",tu.shadowMapEnabled?"#define "+gu:"",tu.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",tu.numLightProbes>0?"#define USE_LIGHT_PROBES":"",tu.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",tu.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",tu.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",tu.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",tu.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",tu.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",tu.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",tu.toneMapping):"",tu.dithering?"#define DITHERING":"",tu.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",tu.outputColorSpace),getLuminanceFunction(),tu.useDepthPacking?"#define DEPTH_PACKING "+tu.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),du=resolveIncludes(du),du=replaceLightNums(du,tu),du=replaceClippingPlaneNums(du,tu),fu=resolveIncludes(fu),fu=replaceLightNums(fu,tu),fu=replaceClippingPlaneNums(fu,tu),du=unrollLoops(du),fu=unrollLoops(fu),tu.isRawShaderMaterial!==!0&&(Lu=`#version 300 es
`,Bu=[Iu,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+Bu,_u=["#define varying in",tu.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",tu.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_u,Du>0&&(Bu=["#extension GL_OVR_multiview : require","layout(num_views = "+Du+") in;","#define VIEW_ID gl_ViewID_OVR"].join(`
`)+`
`+Bu,Bu=Bu.replace(["uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;"].join(`
`),["uniform mat4 modelViewMatrices["+Du+"];","uniform mat4 projectionMatrices["+Du+"];","uniform mat4 viewMatrices["+Du+"];","uniform mat3 normalMatrices["+Du+"];","#define modelViewMatrix modelViewMatrices[VIEW_ID]","#define projectionMatrix projectionMatrices[VIEW_ID]","#define viewMatrix viewMatrices[VIEW_ID]","#define normalMatrix normalMatrices[VIEW_ID]"].join(`
`)),_u=["#extension GL_OVR_multiview : require","#define VIEW_ID gl_ViewID_OVR"].join(`
`)+`
`+_u,_u=_u.replace("uniform mat4 viewMatrix;",["uniform mat4 viewMatrices["+Du+"];","#define viewMatrix viewMatrices[VIEW_ID]"].join(`
`))));const Ou=Lu+Bu+du,Wu=Lu+_u+fu,Zu=WebGLShader(au,au.VERTEX_SHADER,Ou),Hu=WebGLShader(au,au.FRAGMENT_SHADER,Wu);au.attachShader(ku,Zu),au.attachShader(ku,Hu),tu.index0AttributeName!==void 0?au.bindAttribLocation(ku,0,tu.index0AttributeName):tu.morphTargets===!0&&au.bindAttribLocation(ku,0,"position"),au.linkProgram(ku);function Yu(gp){if(iu.debug.checkShaderErrors){const yp=au.getProgramInfoLog(ku).trim(),Cp=au.getShaderInfoLog(Zu).trim(),Hp=au.getShaderInfoLog(Hu).trim();let wp=!0,Dp=!0;if(au.getProgramParameter(ku,au.LINK_STATUS)===!1)if(wp=!1,typeof iu.debug.onShaderError=="function")iu.debug.onShaderError(au,ku,Zu,Hu);else{const dp=getShaderErrors(au,Zu,"vertex"),Rp=getShaderErrors(au,Hu,"fragment");console.error("THREE.WebGLProgram: Shader Error "+au.getError()+" - VALIDATE_STATUS "+au.getProgramParameter(ku,au.VALIDATE_STATUS)+`

Material Name: `+gp.name+`
Material Type: `+gp.type+`

Program Info Log: `+yp+`
`+dp+`
`+Rp)}else yp!==""?console.warn("THREE.WebGLProgram: Program Info Log:",yp):(Cp===""||Hp==="")&&(Dp=!1);Dp&&(gp.diagnostics={runnable:wp,programLog:yp,vertexShader:{log:Cp,prefix:Bu},fragmentShader:{log:Hp,prefix:_u}})}au.deleteShader(Zu),au.deleteShader(Hu),Ku=new WebGLUniforms(au,ku),ju=fetchAttributeLocations(au,ku)}let Ku;this.getUniforms=function(){return Ku===void 0&&Yu(this),Ku};let ju;this.getAttributes=function(){return ju===void 0&&Yu(this),ju};let tp=tu.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return tp===!1&&(tp=au.getProgramParameter(ku,COMPLETION_STATUS_KHR)),tp},this.destroy=function(){su.releaseStatesOfProgram(this),au.deleteProgram(ku),this.program=void 0},this.type=tu.shaderType,this.name=tu.shaderName,this.id=programIdCount++,this.cacheKey=eu,this.usedTimes=1,this.program=ku,this.vertexShader=Zu,this.fragmentShader=Hu,this.numMultiviewViews=Du,this}let _id=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(eu){const tu=eu.vertexShader,su=eu.fragmentShader,au=this._getShaderStage(tu),uu=this._getShaderStage(su),du=this._getShaderCacheForMaterial(eu);return du.has(au)===!1&&(du.add(au),au.usedTimes++),du.has(uu)===!1&&(du.add(uu),uu.usedTimes++),this}remove(eu){const tu=this.materialCache.get(eu);for(const su of tu)su.usedTimes--,su.usedTimes===0&&this.shaderCache.delete(su.code);return this.materialCache.delete(eu),this}getVertexShaderID(eu){return this._getShaderStage(eu.vertexShader).id}getFragmentShaderID(eu){return this._getShaderStage(eu.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(eu){const tu=this.materialCache;let su=tu.get(eu);return su===void 0&&(su=new Set,tu.set(eu,su)),su}_getShaderStage(eu){const tu=this.shaderCache;let su=tu.get(eu);return su===void 0&&(su=new WebGLShaderStage(eu),tu.set(eu,su)),su}}class WebGLShaderStage{constructor(eu){this.id=_id++,this.code=eu,this.usedTimes=0}}function WebGLPrograms(iu,eu,tu,su,au,uu,du){const fu=new Layers,gu=new WebGLShaderCache,yu=new Set,xu=[],vu=au.logarithmicDepthBuffer,Su=au.vertexTextures;let Iu=au.precision;const Mu={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function ku(Ku){return yu.add(Ku),Ku===0?"uv":`uv${Ku}`}function Bu(Ku,ju,tp,gp,yp){const Cp=gp.fog,Hp=yp.geometry,wp=Ku.isMeshStandardMaterial?gp.environment:null,Dp=(Ku.isMeshStandardMaterial?tu:eu).get(Ku.envMap||wp),dp=Dp&&Dp.mapping===CubeUVReflectionMapping?Dp.image.height:null,Rp=Mu[Ku.type];Ku.precision!==null&&(Iu=au.getMaxPrecision(Ku.precision),Iu!==Ku.precision&&console.warn("THREE.WebGLProgram.getParameters:",Ku.precision,"not supported, using",Iu,"instead."));const xp=Hp.morphAttributes.position||Hp.morphAttributes.normal||Hp.morphAttributes.color,cm=xp!==void 0?xp.length:0;let lm=0;Hp.morphAttributes.position!==void 0&&(lm=1),Hp.morphAttributes.normal!==void 0&&(lm=2),Hp.morphAttributes.color!==void 0&&(lm=3);let vp,bp,kp,dm;if(Rp){const i0=ShaderLib[Rp];vp=i0.vertexShader,bp=i0.fragmentShader}else vp=Ku.vertexShader,bp=Ku.fragmentShader,gu.update(Ku),kp=gu.getVertexShaderID(Ku),dm=gu.getFragmentShaderID(Ku);const nm=iu.getRenderTarget(),Bp=iu.state.buffers.depth.getReversed(),Qp=nm&&nm.isWebGLMultiviewRenderTarget?nm.numViews:0,Xp=yp.isInstancedMesh===!0,sm=yp.isBatchedMesh===!0,$p=!!Ku.map,_f=!!Ku.matcap,rm=!!Dp,lp=!!Ku.aoMap,cp=!!Ku.lightMap,mm=!!Ku.bumpMap,$u=!!Ku.normalMap,Vu=!!Ku.displacementMap,_h=!!Ku.emissiveMap,ap=!!Ku.metalnessMap,mp=!!Ku.roughnessMap,Lp=Ku.anisotropy>0,Kp=Ku.clearcoat>0,vm=Ku.dispersion>0,sp=Ku.iridescence>0,_d=Ku.sheen>0,Sp=Ku.transmission>0,tm=Lp&&!!Ku.anisotropyMap,qu=Kp&&!!Ku.clearcoatMap,Uu=Kp&&!!Ku.clearcoatNormalMap,zu=Kp&&!!Ku.clearcoatRoughnessMap,ep=sp&&!!Ku.iridescenceMap,up=sp&&!!Ku.iridescenceThicknessMap,Mp=_d&&!!Ku.sheenColorMap,Ip=_d&&!!Ku.sheenRoughnessMap,fm=!!Ku.specularMap,Gm=!!Ku.specularColorMap,pp=!!Ku.specularIntensityMap,Zp=Sp&&!!Ku.transmissionMap,om=Sp&&!!Ku.thicknessMap,Mm=!!Ku.gradientMap,Tm=!!Ku.alphaMap,Lm=Ku.alphaTest>0,Ym=!!Ku.alphaHash,Rm=!!Ku.extensions;let Sm=NoToneMapping;Ku.toneMapped&&(nm===null||nm.isXRRenderTarget===!0)&&(Sm=iu.toneMapping);const Fm={shaderID:Rp,shaderType:Ku.type,shaderName:Ku.name,vertexShader:vp,fragmentShader:bp,defines:Ku.defines,customVertexShaderID:kp,customFragmentShaderID:dm,isRawShaderMaterial:Ku.isRawShaderMaterial===!0,glslVersion:Ku.glslVersion,precision:Iu,batching:sm,batchingColor:sm&&yp._colorsTexture!==null,instancing:Xp,instancingColor:Xp&&yp.instanceColor!==null,instancingMorph:Xp&&yp.morphTexture!==null,supportsVertexTextures:Su,numMultiviewViews:Qp,outputColorSpace:nm===null?iu.outputColorSpace:nm.isXRRenderTarget===!0?nm.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!Ku.alphaToCoverage,map:$p,matcap:_f,envMap:rm,envMapMode:rm&&Dp.mapping,envMapCubeUVHeight:dp,aoMap:lp,lightMap:cp,bumpMap:mm,normalMap:$u,displacementMap:Su&&Vu,emissiveMap:_h,normalMapObjectSpace:$u&&Ku.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:$u&&Ku.normalMapType===TangentSpaceNormalMap,metalnessMap:ap,roughnessMap:mp,anisotropy:Lp,anisotropyMap:tm,clearcoat:Kp,clearcoatMap:qu,clearcoatNormalMap:Uu,clearcoatRoughnessMap:zu,dispersion:vm,iridescence:sp,iridescenceMap:ep,iridescenceThicknessMap:up,sheen:_d,sheenColorMap:Mp,sheenRoughnessMap:Ip,specularMap:fm,specularColorMap:Gm,specularIntensityMap:pp,transmission:Sp,transmissionMap:Zp,thicknessMap:om,gradientMap:Mm,opaque:Ku.transparent===!1&&Ku.blending===NormalBlending&&Ku.alphaToCoverage===!1,alphaMap:Tm,alphaTest:Lm,alphaHash:Ym,combine:Ku.combine,mapUv:$p&&ku(Ku.map.channel),aoMapUv:lp&&ku(Ku.aoMap.channel),lightMapUv:cp&&ku(Ku.lightMap.channel),bumpMapUv:mm&&ku(Ku.bumpMap.channel),normalMapUv:$u&&ku(Ku.normalMap.channel),displacementMapUv:Vu&&ku(Ku.displacementMap.channel),emissiveMapUv:_h&&ku(Ku.emissiveMap.channel),metalnessMapUv:ap&&ku(Ku.metalnessMap.channel),roughnessMapUv:mp&&ku(Ku.roughnessMap.channel),anisotropyMapUv:tm&&ku(Ku.anisotropyMap.channel),clearcoatMapUv:qu&&ku(Ku.clearcoatMap.channel),clearcoatNormalMapUv:Uu&&ku(Ku.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:zu&&ku(Ku.clearcoatRoughnessMap.channel),iridescenceMapUv:ep&&ku(Ku.iridescenceMap.channel),iridescenceThicknessMapUv:up&&ku(Ku.iridescenceThicknessMap.channel),sheenColorMapUv:Mp&&ku(Ku.sheenColorMap.channel),sheenRoughnessMapUv:Ip&&ku(Ku.sheenRoughnessMap.channel),specularMapUv:fm&&ku(Ku.specularMap.channel),specularColorMapUv:Gm&&ku(Ku.specularColorMap.channel),specularIntensityMapUv:pp&&ku(Ku.specularIntensityMap.channel),transmissionMapUv:Zp&&ku(Ku.transmissionMap.channel),thicknessMapUv:om&&ku(Ku.thicknessMap.channel),alphaMapUv:Tm&&ku(Ku.alphaMap.channel),vertexTangents:!!Hp.attributes.tangent&&($u||Lp),vertexColors:Ku.vertexColors,vertexAlphas:Ku.vertexColors===!0&&!!Hp.attributes.color&&Hp.attributes.color.itemSize===4,pointsUvs:yp.isPoints===!0&&!!Hp.attributes.uv&&($p||Tm),fog:!!Cp,useFog:Ku.fog===!0,fogExp2:!!Cp&&Cp.isFogExp2,flatShading:Ku.flatShading===!0,sizeAttenuation:Ku.sizeAttenuation===!0,logarithmicDepthBuffer:vu,reverseDepthBuffer:Bp,skinning:yp.isSkinnedMesh===!0,morphTargets:Hp.morphAttributes.position!==void 0,morphNormals:Hp.morphAttributes.normal!==void 0,morphColors:Hp.morphAttributes.color!==void 0,morphTargetsCount:cm,morphTextureStride:lm,numDirLights:ju.directional.length,numPointLights:ju.point.length,numSpotLights:ju.spot.length,numSpotLightMaps:ju.spotLightMap.length,numRectAreaLights:ju.rectArea.length,numHemiLights:ju.hemi.length,numDirLightShadows:ju.directionalShadowMap.length,numPointLightShadows:ju.pointShadowMap.length,numSpotLightShadows:ju.spotShadowMap.length,numSpotLightShadowsWithMaps:ju.numSpotLightShadowsWithMaps,numLightProbes:ju.numLightProbes,numClippingPlanes:du.numPlanes,numClipIntersection:du.numIntersection,dithering:Ku.dithering,shadowMapEnabled:iu.shadowMap.enabled&&tp.length>0,shadowMapType:iu.shadowMap.type,toneMapping:Sm,decodeVideoTexture:$p&&Ku.map.isVideoTexture===!0&&ColorManagement.getTransfer(Ku.map.colorSpace)===SRGBTransfer,decodeVideoTextureEmissive:_h&&Ku.emissiveMap.isVideoTexture===!0&&ColorManagement.getTransfer(Ku.emissiveMap.colorSpace)===SRGBTransfer,premultipliedAlpha:Ku.premultipliedAlpha,doubleSided:Ku.side===DoubleSide,flipSided:Ku.side===BackSide,useDepthPacking:Ku.depthPacking>=0,depthPacking:Ku.depthPacking||0,index0AttributeName:Ku.index0AttributeName,extensionClipCullDistance:Rm&&Ku.extensions.clipCullDistance===!0&&su.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Rm&&Ku.extensions.multiDraw===!0||sm)&&su.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:su.has("KHR_parallel_shader_compile"),customProgramCacheKey:Ku.customProgramCacheKey()};return Fm.vertexUv1s=yu.has(1),Fm.vertexUv2s=yu.has(2),Fm.vertexUv3s=yu.has(3),yu.clear(),Fm}function _u(Ku){const ju=[];if(Ku.shaderID?ju.push(Ku.shaderID):(ju.push(Ku.customVertexShaderID),ju.push(Ku.customFragmentShaderID)),Ku.defines!==void 0)for(const tp in Ku.defines)ju.push(tp),ju.push(Ku.defines[tp]);return Ku.isRawShaderMaterial===!1&&(Lu(ju,Ku),Du(ju,Ku),ju.push(iu.outputColorSpace)),ju.push(Ku.customProgramCacheKey),ju.join()}function Lu(Ku,ju){Ku.push(ju.precision),Ku.push(ju.outputColorSpace),Ku.push(ju.envMapMode),Ku.push(ju.envMapCubeUVHeight),Ku.push(ju.mapUv),Ku.push(ju.alphaMapUv),Ku.push(ju.lightMapUv),Ku.push(ju.aoMapUv),Ku.push(ju.bumpMapUv),Ku.push(ju.normalMapUv),Ku.push(ju.displacementMapUv),Ku.push(ju.emissiveMapUv),Ku.push(ju.metalnessMapUv),Ku.push(ju.roughnessMapUv),Ku.push(ju.anisotropyMapUv),Ku.push(ju.clearcoatMapUv),Ku.push(ju.clearcoatNormalMapUv),Ku.push(ju.clearcoatRoughnessMapUv),Ku.push(ju.iridescenceMapUv),Ku.push(ju.iridescenceThicknessMapUv),Ku.push(ju.sheenColorMapUv),Ku.push(ju.sheenRoughnessMapUv),Ku.push(ju.specularMapUv),Ku.push(ju.specularColorMapUv),Ku.push(ju.specularIntensityMapUv),Ku.push(ju.transmissionMapUv),Ku.push(ju.thicknessMapUv),Ku.push(ju.combine),Ku.push(ju.fogExp2),Ku.push(ju.sizeAttenuation),Ku.push(ju.morphTargetsCount),Ku.push(ju.morphAttributeCount),Ku.push(ju.numDirLights),Ku.push(ju.numPointLights),Ku.push(ju.numSpotLights),Ku.push(ju.numSpotLightMaps),Ku.push(ju.numHemiLights),Ku.push(ju.numRectAreaLights),Ku.push(ju.numDirLightShadows),Ku.push(ju.numPointLightShadows),Ku.push(ju.numSpotLightShadows),Ku.push(ju.numSpotLightShadowsWithMaps),Ku.push(ju.numLightProbes),Ku.push(ju.shadowMapType),Ku.push(ju.toneMapping),Ku.push(ju.numClippingPlanes),Ku.push(ju.numClipIntersection),Ku.push(ju.depthPacking)}function Du(Ku,ju){fu.disableAll(),ju.supportsVertexTextures&&fu.enable(0),ju.instancing&&fu.enable(1),ju.instancingColor&&fu.enable(2),ju.instancingMorph&&fu.enable(3),ju.matcap&&fu.enable(4),ju.envMap&&fu.enable(5),ju.normalMapObjectSpace&&fu.enable(6),ju.normalMapTangentSpace&&fu.enable(7),ju.clearcoat&&fu.enable(8),ju.iridescence&&fu.enable(9),ju.alphaTest&&fu.enable(10),ju.vertexColors&&fu.enable(11),ju.vertexAlphas&&fu.enable(12),ju.vertexUv1s&&fu.enable(13),ju.vertexUv2s&&fu.enable(14),ju.vertexUv3s&&fu.enable(15),ju.vertexTangents&&fu.enable(16),ju.anisotropy&&fu.enable(17),ju.alphaHash&&fu.enable(18),ju.batching&&fu.enable(19),ju.dispersion&&fu.enable(20),ju.batchingColor&&fu.enable(21),Ku.push(fu.mask),fu.disableAll(),ju.fog&&fu.enable(0),ju.useFog&&fu.enable(1),ju.flatShading&&fu.enable(2),ju.logarithmicDepthBuffer&&fu.enable(3),ju.reverseDepthBuffer&&fu.enable(4),ju.skinning&&fu.enable(5),ju.morphTargets&&fu.enable(6),ju.morphNormals&&fu.enable(7),ju.morphColors&&fu.enable(8),ju.premultipliedAlpha&&fu.enable(9),ju.shadowMapEnabled&&fu.enable(10),ju.doubleSided&&fu.enable(11),ju.flipSided&&fu.enable(12),ju.useDepthPacking&&fu.enable(13),ju.dithering&&fu.enable(14),ju.transmission&&fu.enable(15),ju.sheen&&fu.enable(16),ju.opaque&&fu.enable(17),ju.pointsUvs&&fu.enable(18),ju.decodeVideoTexture&&fu.enable(19),ju.decodeVideoTextureEmissive&&fu.enable(20),ju.alphaToCoverage&&fu.enable(21),ju.numMultiviewViews&&fu.enable(21),Ku.push(fu.mask)}function Ou(Ku){const ju=Mu[Ku.type];let tp;if(ju){const gp=ShaderLib[ju];tp=UniformsUtils.clone(gp.uniforms)}else tp=Ku.uniforms;return tp}function Wu(Ku,ju){let tp;for(let gp=0,yp=xu.length;gp<yp;gp++){const Cp=xu[gp];if(Cp.cacheKey===ju){tp=Cp,++tp.usedTimes;break}}return tp===void 0&&(tp=new WebGLProgram(iu,ju,Ku,uu),xu.push(tp)),tp}function Zu(Ku){if(--Ku.usedTimes===0){const ju=xu.indexOf(Ku);xu[ju]=xu[xu.length-1],xu.pop(),Ku.destroy()}}function Hu(Ku){gu.remove(Ku)}function Yu(){gu.dispose()}return{getParameters:Bu,getProgramCacheKey:_u,getUniforms:Ou,acquireProgram:Wu,releaseProgram:Zu,releaseShaderCache:Hu,programs:xu,dispose:Yu}}function WebGLProperties(){let iu=new WeakMap;function eu(du){return iu.has(du)}function tu(du){let fu=iu.get(du);return fu===void 0&&(fu={},iu.set(du,fu)),fu}function su(du){iu.delete(du)}function au(du,fu,gu){iu.get(du)[fu]=gu}function uu(){iu=new WeakMap}return{has:eu,get:tu,remove:su,update:au,dispose:uu}}function painterSortStable(iu,eu){return iu.groupOrder!==eu.groupOrder?iu.groupOrder-eu.groupOrder:iu.renderOrder!==eu.renderOrder?iu.renderOrder-eu.renderOrder:iu.material.id!==eu.material.id?iu.material.id-eu.material.id:iu.z!==eu.z?iu.z-eu.z:iu.id-eu.id}function reversePainterSortStable(iu,eu){return iu.groupOrder!==eu.groupOrder?iu.groupOrder-eu.groupOrder:iu.renderOrder!==eu.renderOrder?iu.renderOrder-eu.renderOrder:iu.z!==eu.z?eu.z-iu.z:iu.id-eu.id}function WebGLRenderList(){const iu=[];let eu=0;const tu=[],su=[],au=[];function uu(){eu=0,tu.length=0,su.length=0,au.length=0}function du(vu,Su,Iu,Mu,ku,Bu){let _u=iu[eu];return _u===void 0?(_u={id:vu.id,object:vu,geometry:Su,material:Iu,groupOrder:Mu,renderOrder:vu.renderOrder,z:ku,group:Bu},iu[eu]=_u):(_u.id=vu.id,_u.object=vu,_u.geometry=Su,_u.material=Iu,_u.groupOrder=Mu,_u.renderOrder=vu.renderOrder,_u.z=ku,_u.group=Bu),eu++,_u}function fu(vu,Su,Iu,Mu,ku,Bu){const _u=du(vu,Su,Iu,Mu,ku,Bu);Iu.transmission>0?su.push(_u):Iu.transparent===!0?au.push(_u):tu.push(_u)}function gu(vu,Su,Iu,Mu,ku,Bu){const _u=du(vu,Su,Iu,Mu,ku,Bu);Iu.transmission>0?su.unshift(_u):Iu.transparent===!0?au.unshift(_u):tu.unshift(_u)}function yu(vu,Su){tu.length>1&&tu.sort(vu||painterSortStable),su.length>1&&su.sort(Su||reversePainterSortStable),au.length>1&&au.sort(Su||reversePainterSortStable)}function xu(){for(let vu=eu,Su=iu.length;vu<Su;vu++){const Iu=iu[vu];if(Iu.id===null)break;Iu.id=null,Iu.object=null,Iu.geometry=null,Iu.material=null,Iu.group=null}}return{opaque:tu,transmissive:su,transparent:au,init:uu,push:fu,unshift:gu,finish:xu,sort:yu}}function WebGLRenderLists(){let iu=new WeakMap;function eu(su,au){const uu=iu.get(su);let du;return uu===void 0?(du=new WebGLRenderList,iu.set(su,[du])):au>=uu.length?(du=new WebGLRenderList,uu.push(du)):du=uu[au],du}function tu(){iu=new WeakMap}return{get:eu,dispose:tu}}function UniformsCache(){const iu={};return{get:function(eu){if(iu[eu.id]!==void 0)return iu[eu.id];let tu;switch(eu.type){case"DirectionalLight":tu={direction:new Vector3,color:new Color};break;case"SpotLight":tu={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":tu={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":tu={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":tu={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return iu[eu.id]=tu,tu}}}function ShadowUniformsCache(){const iu={};return{get:function(eu){if(iu[eu.id]!==void 0)return iu[eu.id];let tu;switch(eu.type){case"DirectionalLight":tu={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":tu={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":tu={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return iu[eu.id]=tu,tu}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(iu,eu){return(eu.castShadow?2:0)-(iu.castShadow?2:0)+(eu.map?1:0)-(iu.map?1:0)}function WebGLLights(iu){const eu=new UniformsCache,tu=ShadowUniformsCache(),su={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let yu=0;yu<9;yu++)su.probe.push(new Vector3);const au=new Vector3,uu=new Matrix4,du=new Matrix4;function fu(yu){let xu=0,vu=0,Su=0;for(let Ku=0;Ku<9;Ku++)su.probe[Ku].set(0,0,0);let Iu=0,Mu=0,ku=0,Bu=0,_u=0,Lu=0,Du=0,Ou=0,Wu=0,Zu=0,Hu=0;yu.sort(shadowCastingAndTexturingLightsFirst);for(let Ku=0,ju=yu.length;Ku<ju;Ku++){const tp=yu[Ku],gp=tp.color,yp=tp.intensity,Cp=tp.distance,Hp=tp.shadow&&tp.shadow.map?tp.shadow.map.texture:null;if(tp.isAmbientLight)xu+=gp.r*yp,vu+=gp.g*yp,Su+=gp.b*yp;else if(tp.isLightProbe){for(let wp=0;wp<9;wp++)su.probe[wp].addScaledVector(tp.sh.coefficients[wp],yp);Hu++}else if(tp.isDirectionalLight){const wp=eu.get(tp);if(wp.color.copy(tp.color).multiplyScalar(tp.intensity),tp.castShadow){const Dp=tp.shadow,dp=tu.get(tp);dp.shadowIntensity=Dp.intensity,dp.shadowBias=Dp.bias,dp.shadowNormalBias=Dp.normalBias,dp.shadowRadius=Dp.radius,dp.shadowMapSize=Dp.mapSize,su.directionalShadow[Iu]=dp,su.directionalShadowMap[Iu]=Hp,su.directionalShadowMatrix[Iu]=tp.shadow.matrix,Lu++}su.directional[Iu]=wp,Iu++}else if(tp.isSpotLight){const wp=eu.get(tp);wp.position.setFromMatrixPosition(tp.matrixWorld),wp.color.copy(gp).multiplyScalar(yp),wp.distance=Cp,wp.coneCos=Math.cos(tp.angle),wp.penumbraCos=Math.cos(tp.angle*(1-tp.penumbra)),wp.decay=tp.decay,su.spot[ku]=wp;const Dp=tp.shadow;if(tp.map&&(su.spotLightMap[Wu]=tp.map,Wu++,Dp.updateMatrices(tp),tp.castShadow&&Zu++),su.spotLightMatrix[ku]=Dp.matrix,tp.castShadow){const dp=tu.get(tp);dp.shadowIntensity=Dp.intensity,dp.shadowBias=Dp.bias,dp.shadowNormalBias=Dp.normalBias,dp.shadowRadius=Dp.radius,dp.shadowMapSize=Dp.mapSize,su.spotShadow[ku]=dp,su.spotShadowMap[ku]=Hp,Ou++}ku++}else if(tp.isRectAreaLight){const wp=eu.get(tp);wp.color.copy(gp).multiplyScalar(yp),wp.halfWidth.set(tp.width*.5,0,0),wp.halfHeight.set(0,tp.height*.5,0),su.rectArea[Bu]=wp,Bu++}else if(tp.isPointLight){const wp=eu.get(tp);if(wp.color.copy(tp.color).multiplyScalar(tp.intensity),wp.distance=tp.distance,wp.decay=tp.decay,tp.castShadow){const Dp=tp.shadow,dp=tu.get(tp);dp.shadowIntensity=Dp.intensity,dp.shadowBias=Dp.bias,dp.shadowNormalBias=Dp.normalBias,dp.shadowRadius=Dp.radius,dp.shadowMapSize=Dp.mapSize,dp.shadowCameraNear=Dp.camera.near,dp.shadowCameraFar=Dp.camera.far,su.pointShadow[Mu]=dp,su.pointShadowMap[Mu]=Hp,su.pointShadowMatrix[Mu]=tp.shadow.matrix,Du++}su.point[Mu]=wp,Mu++}else if(tp.isHemisphereLight){const wp=eu.get(tp);wp.skyColor.copy(tp.color).multiplyScalar(yp),wp.groundColor.copy(tp.groundColor).multiplyScalar(yp),su.hemi[_u]=wp,_u++}}Bu>0&&(iu.has("OES_texture_float_linear")===!0?(su.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,su.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(su.rectAreaLTC1=UniformsLib.LTC_HALF_1,su.rectAreaLTC2=UniformsLib.LTC_HALF_2)),su.ambient[0]=xu,su.ambient[1]=vu,su.ambient[2]=Su;const Yu=su.hash;(Yu.directionalLength!==Iu||Yu.pointLength!==Mu||Yu.spotLength!==ku||Yu.rectAreaLength!==Bu||Yu.hemiLength!==_u||Yu.numDirectionalShadows!==Lu||Yu.numPointShadows!==Du||Yu.numSpotShadows!==Ou||Yu.numSpotMaps!==Wu||Yu.numLightProbes!==Hu)&&(su.directional.length=Iu,su.spot.length=ku,su.rectArea.length=Bu,su.point.length=Mu,su.hemi.length=_u,su.directionalShadow.length=Lu,su.directionalShadowMap.length=Lu,su.pointShadow.length=Du,su.pointShadowMap.length=Du,su.spotShadow.length=Ou,su.spotShadowMap.length=Ou,su.directionalShadowMatrix.length=Lu,su.pointShadowMatrix.length=Du,su.spotLightMatrix.length=Ou+Wu-Zu,su.spotLightMap.length=Wu,su.numSpotLightShadowsWithMaps=Zu,su.numLightProbes=Hu,Yu.directionalLength=Iu,Yu.pointLength=Mu,Yu.spotLength=ku,Yu.rectAreaLength=Bu,Yu.hemiLength=_u,Yu.numDirectionalShadows=Lu,Yu.numPointShadows=Du,Yu.numSpotShadows=Ou,Yu.numSpotMaps=Wu,Yu.numLightProbes=Hu,su.version=nextVersion++)}function gu(yu,xu){let vu=0,Su=0,Iu=0,Mu=0,ku=0;const Bu=xu.matrixWorldInverse;for(let _u=0,Lu=yu.length;_u<Lu;_u++){const Du=yu[_u];if(Du.isDirectionalLight){const Ou=su.directional[vu];Ou.direction.setFromMatrixPosition(Du.matrixWorld),au.setFromMatrixPosition(Du.target.matrixWorld),Ou.direction.sub(au),Ou.direction.transformDirection(Bu),vu++}else if(Du.isSpotLight){const Ou=su.spot[Iu];Ou.position.setFromMatrixPosition(Du.matrixWorld),Ou.position.applyMatrix4(Bu),Ou.direction.setFromMatrixPosition(Du.matrixWorld),au.setFromMatrixPosition(Du.target.matrixWorld),Ou.direction.sub(au),Ou.direction.transformDirection(Bu),Iu++}else if(Du.isRectAreaLight){const Ou=su.rectArea[Mu];Ou.position.setFromMatrixPosition(Du.matrixWorld),Ou.position.applyMatrix4(Bu),du.identity(),uu.copy(Du.matrixWorld),uu.premultiply(Bu),du.extractRotation(uu),Ou.halfWidth.set(Du.width*.5,0,0),Ou.halfHeight.set(0,Du.height*.5,0),Ou.halfWidth.applyMatrix4(du),Ou.halfHeight.applyMatrix4(du),Mu++}else if(Du.isPointLight){const Ou=su.point[Su];Ou.position.setFromMatrixPosition(Du.matrixWorld),Ou.position.applyMatrix4(Bu),Su++}else if(Du.isHemisphereLight){const Ou=su.hemi[ku];Ou.direction.setFromMatrixPosition(Du.matrixWorld),Ou.direction.transformDirection(Bu),ku++}}}return{setup:fu,setupView:gu,state:su}}function WebGLRenderState(iu){const eu=new WebGLLights(iu),tu=[],su=[];function au(xu){yu.camera=xu,tu.length=0,su.length=0}function uu(xu){tu.push(xu)}function du(xu){su.push(xu)}function fu(){eu.setup(tu)}function gu(xu){eu.setupView(tu,xu)}const yu={lightsArray:tu,shadowsArray:su,camera:null,lights:eu,transmissionRenderTarget:{}};return{init:au,state:yu,setupLights:fu,setupLightsView:gu,pushLight:uu,pushShadow:du}}function WebGLRenderStates(iu){let eu=new WeakMap;function tu(au,uu=0){const du=eu.get(au);let fu;return du===void 0?(fu=new WebGLRenderState(iu),eu.set(au,[fu])):uu>=du.length?(fu=new WebGLRenderState(iu),du.push(fu)):fu=du[uu],fu}function su(){eu=new WeakMap}return{get:tu,dispose:su}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(iu,eu,tu){let su=new Frustum;const au=new Vector2,uu=new Vector2,du=new Vector4,fu=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),gu=new MeshDistanceMaterial,yu={},xu=tu.maxTextureSize,vu={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},Su=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),Iu=Su.clone();Iu.defines.HORIZONTAL_PASS=1;const Mu=new BufferGeometry;Mu.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const ku=new Mesh(Mu,Su),Bu=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let _u=this.type;this.render=function(Zu,Hu,Yu){if(Bu.enabled===!1||Bu.autoUpdate===!1&&Bu.needsUpdate===!1||Zu.length===0)return;const Ku=iu.getRenderTarget(),ju=iu.getActiveCubeFace(),tp=iu.getActiveMipmapLevel(),gp=iu.state;gp.setBlending(NoBlending),gp.buffers.color.setClear(1,1,1,1),gp.buffers.depth.setTest(!0),gp.setScissorTest(!1);const yp=_u!==VSMShadowMap&&this.type===VSMShadowMap,Cp=_u===VSMShadowMap&&this.type!==VSMShadowMap;for(let Hp=0,wp=Zu.length;Hp<wp;Hp++){const Dp=Zu[Hp],dp=Dp.shadow;if(dp===void 0){console.warn("THREE.WebGLShadowMap:",Dp,"has no shadow.");continue}if(dp.autoUpdate===!1&&dp.needsUpdate===!1)continue;au.copy(dp.mapSize);const Rp=dp.getFrameExtents();if(au.multiply(Rp),uu.copy(dp.mapSize),(au.x>xu||au.y>xu)&&(au.x>xu&&(uu.x=Math.floor(xu/Rp.x),au.x=uu.x*Rp.x,dp.mapSize.x=uu.x),au.y>xu&&(uu.y=Math.floor(xu/Rp.y),au.y=uu.y*Rp.y,dp.mapSize.y=uu.y)),dp.map===null||yp===!0||Cp===!0){const cm=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};dp.map!==null&&dp.map.dispose(),dp.map=new WebGLRenderTarget(au.x,au.y,cm),dp.map.texture.name=Dp.name+".shadowMap",dp.camera.updateProjectionMatrix()}iu.setRenderTarget(dp.map),iu.clear();const xp=dp.getViewportCount();for(let cm=0;cm<xp;cm++){const lm=dp.getViewport(cm);du.set(uu.x*lm.x,uu.y*lm.y,uu.x*lm.z,uu.y*lm.w),gp.viewport(du),dp.updateMatrices(Dp,cm),su=dp.getFrustum(),Ou(Hu,Yu,dp.camera,Dp,this.type)}dp.isPointLightShadow!==!0&&this.type===VSMShadowMap&&Lu(dp,Yu),dp.needsUpdate=!1}_u=this.type,Bu.needsUpdate=!1,iu.setRenderTarget(Ku,ju,tp)};function Lu(Zu,Hu){const Yu=eu.update(ku);Su.defines.VSM_SAMPLES!==Zu.blurSamples&&(Su.defines.VSM_SAMPLES=Zu.blurSamples,Iu.defines.VSM_SAMPLES=Zu.blurSamples,Su.needsUpdate=!0,Iu.needsUpdate=!0),Zu.mapPass===null&&(Zu.mapPass=new WebGLRenderTarget(au.x,au.y)),Su.uniforms.shadow_pass.value=Zu.map.texture,Su.uniforms.resolution.value=Zu.mapSize,Su.uniforms.radius.value=Zu.radius,iu.setRenderTarget(Zu.mapPass),iu.clear(),iu.renderBufferDirect(Hu,null,Yu,Su,ku,null),Iu.uniforms.shadow_pass.value=Zu.mapPass.texture,Iu.uniforms.resolution.value=Zu.mapSize,Iu.uniforms.radius.value=Zu.radius,iu.setRenderTarget(Zu.map),iu.clear(),iu.renderBufferDirect(Hu,null,Yu,Iu,ku,null)}function Du(Zu,Hu,Yu,Ku){let ju=null;const tp=Yu.isPointLight===!0?Zu.customDistanceMaterial:Zu.customDepthMaterial;if(tp!==void 0)ju=tp;else if(ju=Yu.isPointLight===!0?gu:fu,iu.localClippingEnabled&&Hu.clipShadows===!0&&Array.isArray(Hu.clippingPlanes)&&Hu.clippingPlanes.length!==0||Hu.displacementMap&&Hu.displacementScale!==0||Hu.alphaMap&&Hu.alphaTest>0||Hu.map&&Hu.alphaTest>0){const gp=ju.uuid,yp=Hu.uuid;let Cp=yu[gp];Cp===void 0&&(Cp={},yu[gp]=Cp);let Hp=Cp[yp];Hp===void 0&&(Hp=ju.clone(),Cp[yp]=Hp,Hu.addEventListener("dispose",Wu)),ju=Hp}if(ju.visible=Hu.visible,ju.wireframe=Hu.wireframe,Ku===VSMShadowMap?ju.side=Hu.shadowSide!==null?Hu.shadowSide:Hu.side:ju.side=Hu.shadowSide!==null?Hu.shadowSide:vu[Hu.side],ju.alphaMap=Hu.alphaMap,ju.alphaTest=Hu.alphaTest,ju.map=Hu.map,ju.clipShadows=Hu.clipShadows,ju.clippingPlanes=Hu.clippingPlanes,ju.clipIntersection=Hu.clipIntersection,ju.displacementMap=Hu.displacementMap,ju.displacementScale=Hu.displacementScale,ju.displacementBias=Hu.displacementBias,ju.wireframeLinewidth=Hu.wireframeLinewidth,ju.linewidth=Hu.linewidth,Yu.isPointLight===!0&&ju.isMeshDistanceMaterial===!0){const gp=iu.properties.get(ju);gp.light=Yu}return ju}function Ou(Zu,Hu,Yu,Ku,ju){if(Zu.visible===!1)return;if(Zu.layers.test(Hu.layers)&&(Zu.isMesh||Zu.isLine||Zu.isPoints)&&(Zu.castShadow||Zu.receiveShadow&&ju===VSMShadowMap)&&(!Zu.frustumCulled||su.intersectsObject(Zu))){Zu.modelViewMatrix.multiplyMatrices(Yu.matrixWorldInverse,Zu.matrixWorld);const yp=eu.update(Zu),Cp=Zu.material;if(Array.isArray(Cp)){const Hp=yp.groups;for(let wp=0,Dp=Hp.length;wp<Dp;wp++){const dp=Hp[wp],Rp=Cp[dp.materialIndex];if(Rp&&Rp.visible){const xp=Du(Zu,Rp,Ku,ju);Zu.onBeforeShadow(iu,Zu,Hu,Yu,yp,xp,dp),iu.renderBufferDirect(Yu,null,yp,xp,Zu,dp),Zu.onAfterShadow(iu,Zu,Hu,Yu,yp,xp,dp)}}}else if(Cp.visible){const Hp=Du(Zu,Cp,Ku,ju);Zu.onBeforeShadow(iu,Zu,Hu,Yu,yp,Hp,null),iu.renderBufferDirect(Yu,null,yp,Hp,Zu,null),Zu.onAfterShadow(iu,Zu,Hu,Yu,yp,Hp,null)}}const gp=Zu.children;for(let yp=0,Cp=gp.length;yp<Cp;yp++)Ou(gp[yp],Hu,Yu,Ku,ju)}function Wu(Zu){Zu.target.removeEventListener("dispose",Wu);for(const Yu in yu){const Ku=yu[Yu],ju=Zu.target.uuid;ju in Ku&&(Ku[ju].dispose(),delete Ku[ju])}}}const reversedFuncs={[NeverDepth]:AlwaysDepth,[LessDepth]:GreaterDepth,[EqualDepth]:NotEqualDepth,[LessEqualDepth]:GreaterEqualDepth,[AlwaysDepth]:NeverDepth,[GreaterDepth]:LessDepth,[NotEqualDepth]:EqualDepth,[GreaterEqualDepth]:LessEqualDepth};function WebGLState(iu,eu){function tu(){let pp=!1;const Zp=new Vector4;let om=null;const Mm=new Vector4(0,0,0,0);return{setMask:function(Tm){om!==Tm&&!pp&&(iu.colorMask(Tm,Tm,Tm,Tm),om=Tm)},setLocked:function(Tm){pp=Tm},setClear:function(Tm,Lm,Ym,Rm,Sm){Sm===!0&&(Tm*=Rm,Lm*=Rm,Ym*=Rm),Zp.set(Tm,Lm,Ym,Rm),Mm.equals(Zp)===!1&&(iu.clearColor(Tm,Lm,Ym,Rm),Mm.copy(Zp))},reset:function(){pp=!1,om=null,Mm.set(-1,0,0,0)}}}function su(){let pp=!1,Zp=!1,om=null,Mm=null,Tm=null;return{setReversed:function(Lm){if(Zp!==Lm){const Ym=eu.get("EXT_clip_control");Zp?Ym.clipControlEXT(Ym.LOWER_LEFT_EXT,Ym.ZERO_TO_ONE_EXT):Ym.clipControlEXT(Ym.LOWER_LEFT_EXT,Ym.NEGATIVE_ONE_TO_ONE_EXT);const Rm=Tm;Tm=null,this.setClear(Rm)}Zp=Lm},getReversed:function(){return Zp},setTest:function(Lm){Lm?nm(iu.DEPTH_TEST):Bp(iu.DEPTH_TEST)},setMask:function(Lm){om!==Lm&&!pp&&(iu.depthMask(Lm),om=Lm)},setFunc:function(Lm){if(Zp&&(Lm=reversedFuncs[Lm]),Mm!==Lm){switch(Lm){case NeverDepth:iu.depthFunc(iu.NEVER);break;case AlwaysDepth:iu.depthFunc(iu.ALWAYS);break;case LessDepth:iu.depthFunc(iu.LESS);break;case LessEqualDepth:iu.depthFunc(iu.LEQUAL);break;case EqualDepth:iu.depthFunc(iu.EQUAL);break;case GreaterEqualDepth:iu.depthFunc(iu.GEQUAL);break;case GreaterDepth:iu.depthFunc(iu.GREATER);break;case NotEqualDepth:iu.depthFunc(iu.NOTEQUAL);break;default:iu.depthFunc(iu.LEQUAL)}Mm=Lm}},setLocked:function(Lm){pp=Lm},setClear:function(Lm){Tm!==Lm&&(Zp&&(Lm=1-Lm),iu.clearDepth(Lm),Tm=Lm)},reset:function(){pp=!1,om=null,Mm=null,Tm=null,Zp=!1}}}function au(){let pp=!1,Zp=null,om=null,Mm=null,Tm=null,Lm=null,Ym=null,Rm=null,Sm=null;return{setTest:function(Fm){pp||(Fm?nm(iu.STENCIL_TEST):Bp(iu.STENCIL_TEST))},setMask:function(Fm){Zp!==Fm&&!pp&&(iu.stencilMask(Fm),Zp=Fm)},setFunc:function(Fm,i0,$0){(om!==Fm||Mm!==i0||Tm!==$0)&&(iu.stencilFunc(Fm,i0,$0),om=Fm,Mm=i0,Tm=$0)},setOp:function(Fm,i0,$0){(Lm!==Fm||Ym!==i0||Rm!==$0)&&(iu.stencilOp(Fm,i0,$0),Lm=Fm,Ym=i0,Rm=$0)},setLocked:function(Fm){pp=Fm},setClear:function(Fm){Sm!==Fm&&(iu.clearStencil(Fm),Sm=Fm)},reset:function(){pp=!1,Zp=null,om=null,Mm=null,Tm=null,Lm=null,Ym=null,Rm=null,Sm=null}}}const uu=new tu,du=new su,fu=new au,gu=new WeakMap,yu=new WeakMap;let xu={},vu={},Su=new WeakMap,Iu=[],Mu=null,ku=!1,Bu=null,_u=null,Lu=null,Du=null,Ou=null,Wu=null,Zu=null,Hu=new Color(0,0,0),Yu=0,Ku=!1,ju=null,tp=null,gp=null,yp=null,Cp=null;const Hp=iu.getParameter(iu.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let wp=!1,Dp=0;const dp=iu.getParameter(iu.VERSION);dp.indexOf("WebGL")!==-1?(Dp=parseFloat(/^WebGL (\d)/.exec(dp)[1]),wp=Dp>=1):dp.indexOf("OpenGL ES")!==-1&&(Dp=parseFloat(/^OpenGL ES (\d)/.exec(dp)[1]),wp=Dp>=2);let Rp=null,xp={};const cm=iu.getParameter(iu.SCISSOR_BOX),lm=iu.getParameter(iu.VIEWPORT),vp=new Vector4().fromArray(cm),bp=new Vector4().fromArray(lm);function kp(pp,Zp,om,Mm){const Tm=new Uint8Array(4),Lm=iu.createTexture();iu.bindTexture(pp,Lm),iu.texParameteri(pp,iu.TEXTURE_MIN_FILTER,iu.NEAREST),iu.texParameteri(pp,iu.TEXTURE_MAG_FILTER,iu.NEAREST);for(let Ym=0;Ym<om;Ym++)pp===iu.TEXTURE_3D||pp===iu.TEXTURE_2D_ARRAY?iu.texImage3D(Zp,0,iu.RGBA,1,1,Mm,0,iu.RGBA,iu.UNSIGNED_BYTE,Tm):iu.texImage2D(Zp+Ym,0,iu.RGBA,1,1,0,iu.RGBA,iu.UNSIGNED_BYTE,Tm);return Lm}const dm={};dm[iu.TEXTURE_2D]=kp(iu.TEXTURE_2D,iu.TEXTURE_2D,1),dm[iu.TEXTURE_CUBE_MAP]=kp(iu.TEXTURE_CUBE_MAP,iu.TEXTURE_CUBE_MAP_POSITIVE_X,6),dm[iu.TEXTURE_2D_ARRAY]=kp(iu.TEXTURE_2D_ARRAY,iu.TEXTURE_2D_ARRAY,1,1),dm[iu.TEXTURE_3D]=kp(iu.TEXTURE_3D,iu.TEXTURE_3D,1,1),uu.setClear(0,0,0,1),du.setClear(1),fu.setClear(0),nm(iu.DEPTH_TEST),du.setFunc(LessEqualDepth),cp(!1),mm(CullFaceBack),nm(iu.CULL_FACE),rm(NoBlending);function nm(pp){xu[pp]!==!0&&(iu.enable(pp),xu[pp]=!0)}function Bp(pp){xu[pp]!==!1&&(iu.disable(pp),xu[pp]=!1)}function Qp(pp,Zp){return vu[pp]!==Zp?(iu.bindFramebuffer(pp,Zp),vu[pp]=Zp,pp===iu.DRAW_FRAMEBUFFER&&(vu[iu.FRAMEBUFFER]=Zp),pp===iu.FRAMEBUFFER&&(vu[iu.DRAW_FRAMEBUFFER]=Zp),!0):!1}function Xp(pp,Zp){let om=Iu,Mm=!1;if(pp){om=Su.get(Zp),om===void 0&&(om=[],Su.set(Zp,om));const Tm=pp.textures;if(om.length!==Tm.length||om[0]!==iu.COLOR_ATTACHMENT0){for(let Lm=0,Ym=Tm.length;Lm<Ym;Lm++)om[Lm]=iu.COLOR_ATTACHMENT0+Lm;om.length=Tm.length,Mm=!0}}else om[0]!==iu.BACK&&(om[0]=iu.BACK,Mm=!0);Mm&&iu.drawBuffers(om)}function sm(pp){return Mu!==pp?(iu.useProgram(pp),Mu=pp,!0):!1}const $p={[AddEquation]:iu.FUNC_ADD,[SubtractEquation]:iu.FUNC_SUBTRACT,[ReverseSubtractEquation]:iu.FUNC_REVERSE_SUBTRACT};$p[MinEquation]=iu.MIN,$p[MaxEquation]=iu.MAX;const _f={[ZeroFactor]:iu.ZERO,[OneFactor]:iu.ONE,[SrcColorFactor]:iu.SRC_COLOR,[SrcAlphaFactor]:iu.SRC_ALPHA,[SrcAlphaSaturateFactor]:iu.SRC_ALPHA_SATURATE,[DstColorFactor]:iu.DST_COLOR,[DstAlphaFactor]:iu.DST_ALPHA,[OneMinusSrcColorFactor]:iu.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:iu.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:iu.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:iu.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:iu.CONSTANT_COLOR,[OneMinusConstantColorFactor]:iu.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:iu.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:iu.ONE_MINUS_CONSTANT_ALPHA};function rm(pp,Zp,om,Mm,Tm,Lm,Ym,Rm,Sm,Fm){if(pp===NoBlending){ku===!0&&(Bp(iu.BLEND),ku=!1);return}if(ku===!1&&(nm(iu.BLEND),ku=!0),pp!==CustomBlending){if(pp!==Bu||Fm!==Ku){if((_u!==AddEquation||Ou!==AddEquation)&&(iu.blendEquation(iu.FUNC_ADD),_u=AddEquation,Ou=AddEquation),Fm)switch(pp){case NormalBlending:iu.blendFuncSeparate(iu.ONE,iu.ONE_MINUS_SRC_ALPHA,iu.ONE,iu.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:iu.blendFunc(iu.ONE,iu.ONE);break;case SubtractiveBlending:iu.blendFuncSeparate(iu.ZERO,iu.ONE_MINUS_SRC_COLOR,iu.ZERO,iu.ONE);break;case MultiplyBlending:iu.blendFuncSeparate(iu.ZERO,iu.SRC_COLOR,iu.ZERO,iu.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",pp);break}else switch(pp){case NormalBlending:iu.blendFuncSeparate(iu.SRC_ALPHA,iu.ONE_MINUS_SRC_ALPHA,iu.ONE,iu.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:iu.blendFunc(iu.SRC_ALPHA,iu.ONE);break;case SubtractiveBlending:iu.blendFuncSeparate(iu.ZERO,iu.ONE_MINUS_SRC_COLOR,iu.ZERO,iu.ONE);break;case MultiplyBlending:iu.blendFunc(iu.ZERO,iu.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",pp);break}Lu=null,Du=null,Wu=null,Zu=null,Hu.set(0,0,0),Yu=0,Bu=pp,Ku=Fm}return}Tm=Tm||Zp,Lm=Lm||om,Ym=Ym||Mm,(Zp!==_u||Tm!==Ou)&&(iu.blendEquationSeparate($p[Zp],$p[Tm]),_u=Zp,Ou=Tm),(om!==Lu||Mm!==Du||Lm!==Wu||Ym!==Zu)&&(iu.blendFuncSeparate(_f[om],_f[Mm],_f[Lm],_f[Ym]),Lu=om,Du=Mm,Wu=Lm,Zu=Ym),(Rm.equals(Hu)===!1||Sm!==Yu)&&(iu.blendColor(Rm.r,Rm.g,Rm.b,Sm),Hu.copy(Rm),Yu=Sm),Bu=pp,Ku=!1}function lp(pp,Zp){pp.side===DoubleSide?Bp(iu.CULL_FACE):nm(iu.CULL_FACE);let om=pp.side===BackSide;Zp&&(om=!om),cp(om),pp.blending===NormalBlending&&pp.transparent===!1?rm(NoBlending):rm(pp.blending,pp.blendEquation,pp.blendSrc,pp.blendDst,pp.blendEquationAlpha,pp.blendSrcAlpha,pp.blendDstAlpha,pp.blendColor,pp.blendAlpha,pp.premultipliedAlpha),du.setFunc(pp.depthFunc),du.setTest(pp.depthTest),du.setMask(pp.depthWrite),uu.setMask(pp.colorWrite);const Mm=pp.stencilWrite;fu.setTest(Mm),Mm&&(fu.setMask(pp.stencilWriteMask),fu.setFunc(pp.stencilFunc,pp.stencilRef,pp.stencilFuncMask),fu.setOp(pp.stencilFail,pp.stencilZFail,pp.stencilZPass)),Vu(pp.polygonOffset,pp.polygonOffsetFactor,pp.polygonOffsetUnits),pp.alphaToCoverage===!0?nm(iu.SAMPLE_ALPHA_TO_COVERAGE):Bp(iu.SAMPLE_ALPHA_TO_COVERAGE)}function cp(pp){ju!==pp&&(pp?iu.frontFace(iu.CW):iu.frontFace(iu.CCW),ju=pp)}function mm(pp){pp!==CullFaceNone?(nm(iu.CULL_FACE),pp!==tp&&(pp===CullFaceBack?iu.cullFace(iu.BACK):pp===CullFaceFront?iu.cullFace(iu.FRONT):iu.cullFace(iu.FRONT_AND_BACK))):Bp(iu.CULL_FACE),tp=pp}function $u(pp){pp!==gp&&(wp&&iu.lineWidth(pp),gp=pp)}function Vu(pp,Zp,om){pp?(nm(iu.POLYGON_OFFSET_FILL),(yp!==Zp||Cp!==om)&&(iu.polygonOffset(Zp,om),yp=Zp,Cp=om)):Bp(iu.POLYGON_OFFSET_FILL)}function _h(pp){pp?nm(iu.SCISSOR_TEST):Bp(iu.SCISSOR_TEST)}function ap(pp){pp===void 0&&(pp=iu.TEXTURE0+Hp-1),Rp!==pp&&(iu.activeTexture(pp),Rp=pp)}function mp(pp,Zp,om){om===void 0&&(Rp===null?om=iu.TEXTURE0+Hp-1:om=Rp);let Mm=xp[om];Mm===void 0&&(Mm={type:void 0,texture:void 0},xp[om]=Mm),(Mm.type!==pp||Mm.texture!==Zp)&&(Rp!==om&&(iu.activeTexture(om),Rp=om),iu.bindTexture(pp,Zp||dm[pp]),Mm.type=pp,Mm.texture=Zp)}function Lp(){const pp=xp[Rp];pp!==void 0&&pp.type!==void 0&&(iu.bindTexture(pp.type,null),pp.type=void 0,pp.texture=void 0)}function Kp(){try{iu.compressedTexImage2D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function vm(){try{iu.compressedTexImage3D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function sp(){try{iu.texSubImage2D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function _d(){try{iu.texSubImage3D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function Sp(){try{iu.compressedTexSubImage2D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function tm(){try{iu.compressedTexSubImage3D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function qu(){try{iu.texStorage2D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function Uu(){try{iu.texStorage3D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function zu(){try{iu.texImage2D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function ep(){try{iu.texImage3D.apply(iu,arguments)}catch(pp){console.error("THREE.WebGLState:",pp)}}function up(pp){vp.equals(pp)===!1&&(iu.scissor(pp.x,pp.y,pp.z,pp.w),vp.copy(pp))}function Mp(pp){bp.equals(pp)===!1&&(iu.viewport(pp.x,pp.y,pp.z,pp.w),bp.copy(pp))}function Ip(pp,Zp){let om=yu.get(Zp);om===void 0&&(om=new WeakMap,yu.set(Zp,om));let Mm=om.get(pp);Mm===void 0&&(Mm=iu.getUniformBlockIndex(Zp,pp.name),om.set(pp,Mm))}function fm(pp,Zp){const Mm=yu.get(Zp).get(pp);gu.get(Zp)!==Mm&&(iu.uniformBlockBinding(Zp,Mm,pp.__bindingPointIndex),gu.set(Zp,Mm))}function Gm(){iu.disable(iu.BLEND),iu.disable(iu.CULL_FACE),iu.disable(iu.DEPTH_TEST),iu.disable(iu.POLYGON_OFFSET_FILL),iu.disable(iu.SCISSOR_TEST),iu.disable(iu.STENCIL_TEST),iu.disable(iu.SAMPLE_ALPHA_TO_COVERAGE),iu.blendEquation(iu.FUNC_ADD),iu.blendFunc(iu.ONE,iu.ZERO),iu.blendFuncSeparate(iu.ONE,iu.ZERO,iu.ONE,iu.ZERO),iu.blendColor(0,0,0,0),iu.colorMask(!0,!0,!0,!0),iu.clearColor(0,0,0,0),iu.depthMask(!0),iu.depthFunc(iu.LESS),du.setReversed(!1),iu.clearDepth(1),iu.stencilMask(4294967295),iu.stencilFunc(iu.ALWAYS,0,4294967295),iu.stencilOp(iu.KEEP,iu.KEEP,iu.KEEP),iu.clearStencil(0),iu.cullFace(iu.BACK),iu.frontFace(iu.CCW),iu.polygonOffset(0,0),iu.activeTexture(iu.TEXTURE0),iu.bindFramebuffer(iu.FRAMEBUFFER,null),iu.bindFramebuffer(iu.DRAW_FRAMEBUFFER,null),iu.bindFramebuffer(iu.READ_FRAMEBUFFER,null),iu.useProgram(null),iu.lineWidth(1),iu.scissor(0,0,iu.canvas.width,iu.canvas.height),iu.viewport(0,0,iu.canvas.width,iu.canvas.height),xu={},Rp=null,xp={},vu={},Su=new WeakMap,Iu=[],Mu=null,ku=!1,Bu=null,_u=null,Lu=null,Du=null,Ou=null,Wu=null,Zu=null,Hu=new Color(0,0,0),Yu=0,Ku=!1,ju=null,tp=null,gp=null,yp=null,Cp=null,vp.set(0,0,iu.canvas.width,iu.canvas.height),bp.set(0,0,iu.canvas.width,iu.canvas.height),uu.reset(),du.reset(),fu.reset()}return{buffers:{color:uu,depth:du,stencil:fu},enable:nm,disable:Bp,bindFramebuffer:Qp,drawBuffers:Xp,useProgram:sm,setBlending:rm,setMaterial:lp,setFlipSided:cp,setCullFace:mm,setLineWidth:$u,setPolygonOffset:Vu,setScissorTest:_h,activeTexture:ap,bindTexture:mp,unbindTexture:Lp,compressedTexImage2D:Kp,compressedTexImage3D:vm,texImage2D:zu,texImage3D:ep,updateUBOMapping:Ip,uniformBlockBinding:fm,texStorage2D:qu,texStorage3D:Uu,texSubImage2D:sp,texSubImage3D:_d,compressedTexSubImage2D:Sp,compressedTexSubImage3D:tm,scissor:up,viewport:Mp,reset:Gm}}function WebGLTextures(iu,eu,tu,su,au,uu,du){const fu=eu.has("WEBGL_multisampled_render_to_texture")?eu.get("WEBGL_multisampled_render_to_texture"):null,gu=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),yu=eu.has("OCULUS_multiview")?eu.get("OCULUS_multiview"):null,xu=new Vector2,vu=new WeakMap;let Su;const Iu=new WeakMap;let Mu=[],ku=!1,Bu=!1;try{Bu=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function _u(sp,_d){return Bu?new OffscreenCanvas(sp,_d):createElementNS("canvas")}function Lu(sp,_d,Sp){let tm=1;const qu=vm(sp);if((qu.width>Sp||qu.height>Sp)&&(tm=Sp/Math.max(qu.width,qu.height)),tm<1)if(typeof HTMLImageElement<"u"&&sp instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&sp instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&sp instanceof ImageBitmap||typeof VideoFrame<"u"&&sp instanceof VideoFrame){const Uu=Math.floor(tm*qu.width),zu=Math.floor(tm*qu.height);Su===void 0&&(Su=_u(Uu,zu));const ep=_d?_u(Uu,zu):Su;return ep.width=Uu,ep.height=zu,ep.getContext("2d").drawImage(sp,0,0,Uu,zu),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+qu.width+"x"+qu.height+") to ("+Uu+"x"+zu+")."),ep}else return"data"in sp&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+qu.width+"x"+qu.height+")."),sp;return sp}function Du(sp){return sp.generateMipmaps}function Ou(sp){iu.generateMipmap(sp)}function Wu(sp){return sp.isWebGLCubeRenderTarget?iu.TEXTURE_CUBE_MAP:sp.isWebGL3DRenderTarget?iu.TEXTURE_3D:sp.isWebGLArrayRenderTarget||sp.isCompressedArrayTexture?iu.TEXTURE_2D_ARRAY:iu.TEXTURE_2D}function Zu(sp,_d,Sp,tm,qu=!1){if(sp!==null){if(iu[sp]!==void 0)return iu[sp];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+sp+"'")}let Uu=_d;if(_d===iu.RED&&(Sp===iu.FLOAT&&(Uu=iu.R32F),Sp===iu.HALF_FLOAT&&(Uu=iu.R16F),Sp===iu.UNSIGNED_BYTE&&(Uu=iu.R8)),_d===iu.RED_INTEGER&&(Sp===iu.UNSIGNED_BYTE&&(Uu=iu.R8UI),Sp===iu.UNSIGNED_SHORT&&(Uu=iu.R16UI),Sp===iu.UNSIGNED_INT&&(Uu=iu.R32UI),Sp===iu.BYTE&&(Uu=iu.R8I),Sp===iu.SHORT&&(Uu=iu.R16I),Sp===iu.INT&&(Uu=iu.R32I)),_d===iu.RG&&(Sp===iu.FLOAT&&(Uu=iu.RG32F),Sp===iu.HALF_FLOAT&&(Uu=iu.RG16F),Sp===iu.UNSIGNED_BYTE&&(Uu=iu.RG8)),_d===iu.RG_INTEGER&&(Sp===iu.UNSIGNED_BYTE&&(Uu=iu.RG8UI),Sp===iu.UNSIGNED_SHORT&&(Uu=iu.RG16UI),Sp===iu.UNSIGNED_INT&&(Uu=iu.RG32UI),Sp===iu.BYTE&&(Uu=iu.RG8I),Sp===iu.SHORT&&(Uu=iu.RG16I),Sp===iu.INT&&(Uu=iu.RG32I)),_d===iu.RGB_INTEGER&&(Sp===iu.UNSIGNED_BYTE&&(Uu=iu.RGB8UI),Sp===iu.UNSIGNED_SHORT&&(Uu=iu.RGB16UI),Sp===iu.UNSIGNED_INT&&(Uu=iu.RGB32UI),Sp===iu.BYTE&&(Uu=iu.RGB8I),Sp===iu.SHORT&&(Uu=iu.RGB16I),Sp===iu.INT&&(Uu=iu.RGB32I)),_d===iu.RGBA_INTEGER&&(Sp===iu.UNSIGNED_BYTE&&(Uu=iu.RGBA8UI),Sp===iu.UNSIGNED_SHORT&&(Uu=iu.RGBA16UI),Sp===iu.UNSIGNED_INT&&(Uu=iu.RGBA32UI),Sp===iu.BYTE&&(Uu=iu.RGBA8I),Sp===iu.SHORT&&(Uu=iu.RGBA16I),Sp===iu.INT&&(Uu=iu.RGBA32I)),_d===iu.RGB&&Sp===iu.UNSIGNED_INT_5_9_9_9_REV&&(Uu=iu.RGB9_E5),_d===iu.RGBA){const zu=qu?LinearTransfer:ColorManagement.getTransfer(tm);Sp===iu.FLOAT&&(Uu=iu.RGBA32F),Sp===iu.HALF_FLOAT&&(Uu=iu.RGBA16F),Sp===iu.UNSIGNED_BYTE&&(Uu=zu===SRGBTransfer?iu.SRGB8_ALPHA8:iu.RGBA8),Sp===iu.UNSIGNED_SHORT_4_4_4_4&&(Uu=iu.RGBA4),Sp===iu.UNSIGNED_SHORT_5_5_5_1&&(Uu=iu.RGB5_A1)}return(Uu===iu.R16F||Uu===iu.R32F||Uu===iu.RG16F||Uu===iu.RG32F||Uu===iu.RGBA16F||Uu===iu.RGBA32F)&&eu.get("EXT_color_buffer_float"),Uu}function Hu(sp,_d){let Sp;return sp?_d===null||_d===UnsignedIntType||_d===UnsignedInt248Type?Sp=iu.DEPTH24_STENCIL8:_d===FloatType?Sp=iu.DEPTH32F_STENCIL8:_d===UnsignedShortType&&(Sp=iu.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):_d===null||_d===UnsignedIntType||_d===UnsignedInt248Type?Sp=iu.DEPTH_COMPONENT24:_d===FloatType?Sp=iu.DEPTH_COMPONENT32F:_d===UnsignedShortType&&(Sp=iu.DEPTH_COMPONENT16),Sp}function Yu(sp,_d){return Du(sp)===!0||sp.isFramebufferTexture&&sp.minFilter!==NearestFilter&&sp.minFilter!==LinearFilter?Math.log2(Math.max(_d.width,_d.height))+1:sp.mipmaps!==void 0&&sp.mipmaps.length>0?sp.mipmaps.length:sp.isCompressedTexture&&Array.isArray(sp.image)?_d.mipmaps.length:1}function Ku(sp){const _d=sp.target;_d.removeEventListener("dispose",Ku),tp(_d),_d.isVideoTexture&&vu.delete(_d)}function ju(sp){const _d=sp.target;_d.removeEventListener("dispose",ju),yp(_d)}function tp(sp){const _d=su.get(sp);if(_d.__webglInit===void 0)return;const Sp=sp.source,tm=Iu.get(Sp);if(tm){const qu=tm[_d.__cacheKey];qu.usedTimes--,qu.usedTimes===0&&gp(sp),Object.keys(tm).length===0&&Iu.delete(Sp)}su.remove(sp)}function gp(sp){const _d=su.get(sp);iu.deleteTexture(_d.__webglTexture);const Sp=sp.source,tm=Iu.get(Sp);delete tm[_d.__cacheKey],du.memory.textures--}function yp(sp){const _d=su.get(sp);if(sp.depthTexture&&(sp.depthTexture.dispose(),su.remove(sp.depthTexture)),sp.isWebGLCubeRenderTarget)for(let tm=0;tm<6;tm++){if(Array.isArray(_d.__webglFramebuffer[tm]))for(let qu=0;qu<_d.__webglFramebuffer[tm].length;qu++)iu.deleteFramebuffer(_d.__webglFramebuffer[tm][qu]);else iu.deleteFramebuffer(_d.__webglFramebuffer[tm]);_d.__webglDepthbuffer&&iu.deleteRenderbuffer(_d.__webglDepthbuffer[tm])}else{if(Array.isArray(_d.__webglFramebuffer))for(let tm=0;tm<_d.__webglFramebuffer.length;tm++)iu.deleteFramebuffer(_d.__webglFramebuffer[tm]);else iu.deleteFramebuffer(_d.__webglFramebuffer);if(_d.__webglDepthbuffer&&iu.deleteRenderbuffer(_d.__webglDepthbuffer),_d.__webglMultisampledFramebuffer&&iu.deleteFramebuffer(_d.__webglMultisampledFramebuffer),_d.__webglColorRenderbuffer)for(let tm=0;tm<_d.__webglColorRenderbuffer.length;tm++)_d.__webglColorRenderbuffer[tm]&&iu.deleteRenderbuffer(_d.__webglColorRenderbuffer[tm]);_d.__webglDepthRenderbuffer&&iu.deleteRenderbuffer(_d.__webglDepthRenderbuffer)}const Sp=sp.textures;for(let tm=0,qu=Sp.length;tm<qu;tm++){const Uu=su.get(Sp[tm]);Uu.__webglTexture&&(iu.deleteTexture(Uu.__webglTexture),du.memory.textures--),su.remove(Sp[tm])}su.remove(sp)}let Cp=0;function Hp(){Cp=0}function wp(){const sp=Cp;return sp>=au.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+sp+" texture units while this GPU supports only "+au.maxTextures),Cp+=1,sp}function Dp(sp){const _d=[];return _d.push(sp.wrapS),_d.push(sp.wrapT),_d.push(sp.wrapR||0),_d.push(sp.magFilter),_d.push(sp.minFilter),_d.push(sp.anisotropy),_d.push(sp.internalFormat),_d.push(sp.format),_d.push(sp.type),_d.push(sp.generateMipmaps),_d.push(sp.premultiplyAlpha),_d.push(sp.flipY),_d.push(sp.unpackAlignment),_d.push(sp.colorSpace),_d.join()}function dp(sp,_d){const Sp=su.get(sp);if(sp.isVideoTexture&&Lp(sp),sp.isRenderTargetTexture===!1&&sp.version>0&&Sp.__version!==sp.version){const tm=sp.image;if(tm===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(tm.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else if(Qp(Sp,sp,_d))return}tu.bindTexture(iu.TEXTURE_2D,Sp.__webglTexture,iu.TEXTURE0+_d)}function Rp(sp,_d){const Sp=su.get(sp);if(sp.version>0&&Sp.__version!==sp.version){Qp(Sp,sp,_d);return}tu.bindTexture(iu.TEXTURE_2D_ARRAY,Sp.__webglTexture,iu.TEXTURE0+_d)}function xp(sp,_d){const Sp=su.get(sp);if(sp.version>0&&Sp.__version!==sp.version){Qp(Sp,sp,_d);return}tu.bindTexture(iu.TEXTURE_3D,Sp.__webglTexture,iu.TEXTURE0+_d)}function cm(sp,_d){const Sp=su.get(sp);if(sp.version>0&&Sp.__version!==sp.version){Xp(Sp,sp,_d);return}tu.bindTexture(iu.TEXTURE_CUBE_MAP,Sp.__webglTexture,iu.TEXTURE0+_d)}const lm={[RepeatWrapping]:iu.REPEAT,[ClampToEdgeWrapping]:iu.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:iu.MIRRORED_REPEAT},vp={[NearestFilter]:iu.NEAREST,[NearestMipmapNearestFilter]:iu.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:iu.NEAREST_MIPMAP_LINEAR,[LinearFilter]:iu.LINEAR,[LinearMipmapNearestFilter]:iu.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:iu.LINEAR_MIPMAP_LINEAR},bp={[NeverCompare]:iu.NEVER,[AlwaysCompare]:iu.ALWAYS,[LessCompare]:iu.LESS,[LessEqualCompare]:iu.LEQUAL,[EqualCompare]:iu.EQUAL,[GreaterEqualCompare]:iu.GEQUAL,[GreaterCompare]:iu.GREATER,[NotEqualCompare]:iu.NOTEQUAL};function kp(sp,_d){if(_d.type===FloatType&&eu.has("OES_texture_float_linear")===!1&&(_d.magFilter===LinearFilter||_d.magFilter===LinearMipmapNearestFilter||_d.magFilter===NearestMipmapLinearFilter||_d.magFilter===LinearMipmapLinearFilter||_d.minFilter===LinearFilter||_d.minFilter===LinearMipmapNearestFilter||_d.minFilter===NearestMipmapLinearFilter||_d.minFilter===LinearMipmapLinearFilter)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),iu.texParameteri(sp,iu.TEXTURE_WRAP_S,lm[_d.wrapS]),iu.texParameteri(sp,iu.TEXTURE_WRAP_T,lm[_d.wrapT]),(sp===iu.TEXTURE_3D||sp===iu.TEXTURE_2D_ARRAY)&&iu.texParameteri(sp,iu.TEXTURE_WRAP_R,lm[_d.wrapR]),iu.texParameteri(sp,iu.TEXTURE_MAG_FILTER,vp[_d.magFilter]),iu.texParameteri(sp,iu.TEXTURE_MIN_FILTER,vp[_d.minFilter]),_d.compareFunction&&(iu.texParameteri(sp,iu.TEXTURE_COMPARE_MODE,iu.COMPARE_REF_TO_TEXTURE),iu.texParameteri(sp,iu.TEXTURE_COMPARE_FUNC,bp[_d.compareFunction])),eu.has("EXT_texture_filter_anisotropic")===!0){if(_d.magFilter===NearestFilter||_d.minFilter!==NearestMipmapLinearFilter&&_d.minFilter!==LinearMipmapLinearFilter||_d.type===FloatType&&eu.has("OES_texture_float_linear")===!1)return;if(_d.anisotropy>1||su.get(_d).__currentAnisotropy){const Sp=eu.get("EXT_texture_filter_anisotropic");iu.texParameterf(sp,Sp.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(_d.anisotropy,au.getMaxAnisotropy())),su.get(_d).__currentAnisotropy=_d.anisotropy}}}function dm(sp,_d){let Sp=!1;sp.__webglInit===void 0&&(sp.__webglInit=!0,_d.addEventListener("dispose",Ku));const tm=_d.source;let qu=Iu.get(tm);qu===void 0&&(qu={},Iu.set(tm,qu));const Uu=Dp(_d);if(Uu!==sp.__cacheKey){qu[Uu]===void 0&&(qu[Uu]={texture:iu.createTexture(),usedTimes:0},du.memory.textures++,Sp=!0),qu[Uu].usedTimes++;const zu=qu[sp.__cacheKey];zu!==void 0&&(qu[sp.__cacheKey].usedTimes--,zu.usedTimes===0&&gp(_d)),sp.__cacheKey=Uu,sp.__webglTexture=qu[Uu].texture}return Sp}function nm(sp){ku=sp}function Bp(){const sp=ku;ku=!1;for(const _d of Mu)Qp(_d.textureProperties,_d.texture,_d.slot),_d.texture.isPendingDeferredUpload=!1;Mu=[],ku=sp}function Qp(sp,_d,Sp){if(ku)return _d.isPendingDeferredUpload||(_d.isPendingDeferredUpload=!0,Mu.push({textureProperties:sp,texture:_d,slot:Sp})),!1;let tm=iu.TEXTURE_2D;(_d.isDataArrayTexture||_d.isCompressedArrayTexture)&&(tm=iu.TEXTURE_2D_ARRAY),_d.isData3DTexture&&(tm=iu.TEXTURE_3D);const qu=dm(sp,_d),Uu=_d.source;tu.bindTexture(tm,sp.__webglTexture,iu.TEXTURE0+Sp);const zu=su.get(Uu);if(Uu.version!==zu.__version||qu===!0){tu.activeTexture(iu.TEXTURE0+Sp);const ep=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),up=_d.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(_d.colorSpace),Mp=_d.colorSpace===NoColorSpace||ep===up?iu.NONE:iu.BROWSER_DEFAULT_WEBGL;iu.pixelStorei(iu.UNPACK_FLIP_Y_WEBGL,_d.flipY),iu.pixelStorei(iu.UNPACK_PREMULTIPLY_ALPHA_WEBGL,_d.premultiplyAlpha),iu.pixelStorei(iu.UNPACK_ALIGNMENT,_d.unpackAlignment),iu.pixelStorei(iu.UNPACK_COLORSPACE_CONVERSION_WEBGL,Mp);let Ip=Lu(_d.image,!1,au.maxTextureSize);Ip=Kp(_d,Ip);const fm=uu.convert(_d.format,_d.colorSpace),Gm=uu.convert(_d.type);let pp=Zu(_d.internalFormat,fm,Gm,_d.colorSpace,_d.isVideoTexture);kp(tm,_d);let Zp;const om=_d.mipmaps,Mm=_d.isVideoTexture!==!0,Tm=zu.__version===void 0||qu===!0,Lm=Uu.dataReady,Ym=Yu(_d,Ip);if(_d.isDepthTexture)pp=Hu(_d.format===DepthStencilFormat,_d.type),Tm&&(Mm?tu.texStorage2D(iu.TEXTURE_2D,1,pp,Ip.width,Ip.height):tu.texImage2D(iu.TEXTURE_2D,0,pp,Ip.width,Ip.height,0,fm,Gm,null));else if(_d.isDataTexture)if(om.length>0){Mm&&Tm&&tu.texStorage2D(iu.TEXTURE_2D,Ym,pp,om[0].width,om[0].height);for(let Rm=0,Sm=om.length;Rm<Sm;Rm++)Zp=om[Rm],Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_2D,Rm,0,0,Zp.width,Zp.height,fm,Gm,Zp.data):tu.texImage2D(iu.TEXTURE_2D,Rm,pp,Zp.width,Zp.height,0,fm,Gm,Zp.data);_d.generateMipmaps=!1}else Mm?(Tm&&tu.texStorage2D(iu.TEXTURE_2D,Ym,pp,Ip.width,Ip.height),Lm&&tu.texSubImage2D(iu.TEXTURE_2D,0,0,0,Ip.width,Ip.height,fm,Gm,Ip.data)):tu.texImage2D(iu.TEXTURE_2D,0,pp,Ip.width,Ip.height,0,fm,Gm,Ip.data);else if(_d.isCompressedTexture)if(_d.isCompressedArrayTexture){Mm&&Tm&&tu.texStorage3D(iu.TEXTURE_2D_ARRAY,Ym,pp,om[0].width,om[0].height,Ip.depth);for(let Rm=0,Sm=om.length;Rm<Sm;Rm++)if(Zp=om[Rm],_d.format!==RGBAFormat)if(fm!==null)if(Mm){if(Lm)if(_d.layerUpdates.size>0){const Fm=getByteLength(Zp.width,Zp.height,_d.format,_d.type);for(const i0 of _d.layerUpdates){const $0=Zp.data.subarray(i0*Fm/Zp.data.BYTES_PER_ELEMENT,(i0+1)*Fm/Zp.data.BYTES_PER_ELEMENT);tu.compressedTexSubImage3D(iu.TEXTURE_2D_ARRAY,Rm,0,0,i0,Zp.width,Zp.height,1,fm,$0)}_d.clearLayerUpdates()}else tu.compressedTexSubImage3D(iu.TEXTURE_2D_ARRAY,Rm,0,0,0,Zp.width,Zp.height,Ip.depth,fm,Zp.data)}else tu.compressedTexImage3D(iu.TEXTURE_2D_ARRAY,Rm,pp,Zp.width,Zp.height,Ip.depth,0,Zp.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Mm?Lm&&tu.texSubImage3D(iu.TEXTURE_2D_ARRAY,Rm,0,0,0,Zp.width,Zp.height,Ip.depth,fm,Gm,Zp.data):tu.texImage3D(iu.TEXTURE_2D_ARRAY,Rm,pp,Zp.width,Zp.height,Ip.depth,0,fm,Gm,Zp.data)}else{Mm&&Tm&&tu.texStorage2D(iu.TEXTURE_2D,Ym,pp,om[0].width,om[0].height);for(let Rm=0,Sm=om.length;Rm<Sm;Rm++)Zp=om[Rm],_d.format!==RGBAFormat?fm!==null?Mm?Lm&&tu.compressedTexSubImage2D(iu.TEXTURE_2D,Rm,0,0,Zp.width,Zp.height,fm,Zp.data):tu.compressedTexImage2D(iu.TEXTURE_2D,Rm,pp,Zp.width,Zp.height,0,Zp.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_2D,Rm,0,0,Zp.width,Zp.height,fm,Gm,Zp.data):tu.texImage2D(iu.TEXTURE_2D,Rm,pp,Zp.width,Zp.height,0,fm,Gm,Zp.data)}else if(_d.isDataArrayTexture)if(Mm){if(Tm&&tu.texStorage3D(iu.TEXTURE_2D_ARRAY,Ym,pp,Ip.width,Ip.height,Ip.depth),Lm)if(_d.layerUpdates.size>0){const Rm=getByteLength(Ip.width,Ip.height,_d.format,_d.type);for(const Sm of _d.layerUpdates){const Fm=Ip.data.subarray(Sm*Rm/Ip.data.BYTES_PER_ELEMENT,(Sm+1)*Rm/Ip.data.BYTES_PER_ELEMENT);tu.texSubImage3D(iu.TEXTURE_2D_ARRAY,0,0,0,Sm,Ip.width,Ip.height,1,fm,Gm,Fm)}_d.clearLayerUpdates()}else tu.texSubImage3D(iu.TEXTURE_2D_ARRAY,0,0,0,0,Ip.width,Ip.height,Ip.depth,fm,Gm,Ip.data)}else tu.texImage3D(iu.TEXTURE_2D_ARRAY,0,pp,Ip.width,Ip.height,Ip.depth,0,fm,Gm,Ip.data);else if(_d.isData3DTexture)Mm?(Tm&&tu.texStorage3D(iu.TEXTURE_3D,Ym,pp,Ip.width,Ip.height,Ip.depth),Lm&&tu.texSubImage3D(iu.TEXTURE_3D,0,0,0,0,Ip.width,Ip.height,Ip.depth,fm,Gm,Ip.data)):tu.texImage3D(iu.TEXTURE_3D,0,pp,Ip.width,Ip.height,Ip.depth,0,fm,Gm,Ip.data);else if(_d.isFramebufferTexture){if(Tm)if(Mm)tu.texStorage2D(iu.TEXTURE_2D,Ym,pp,Ip.width,Ip.height);else{let Rm=Ip.width,Sm=Ip.height;for(let Fm=0;Fm<Ym;Fm++)tu.texImage2D(iu.TEXTURE_2D,Fm,pp,Rm,Sm,0,fm,Gm,null),Rm>>=1,Sm>>=1}}else if(om.length>0){if(Mm&&Tm){const Rm=vm(om[0]);tu.texStorage2D(iu.TEXTURE_2D,Ym,pp,Rm.width,Rm.height)}for(let Rm=0,Sm=om.length;Rm<Sm;Rm++)Zp=om[Rm],Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_2D,Rm,0,0,fm,Gm,Zp):tu.texImage2D(iu.TEXTURE_2D,Rm,pp,fm,Gm,Zp);_d.generateMipmaps=!1}else if(Mm){if(Tm){const Rm=vm(Ip);tu.texStorage2D(iu.TEXTURE_2D,Ym,pp,Rm.width,Rm.height)}Lm&&tu.texSubImage2D(iu.TEXTURE_2D,0,0,0,fm,Gm,Ip)}else tu.texImage2D(iu.TEXTURE_2D,0,pp,fm,Gm,Ip);Du(_d)&&Ou(tm),zu.__version=Uu.version,_d.onUpdate&&_d.onUpdate(_d)}return sp.__version=_d.version,!0}function Xp(sp,_d,Sp){if(_d.image.length!==6)return;const tm=dm(sp,_d),qu=_d.source;tu.bindTexture(iu.TEXTURE_CUBE_MAP,sp.__webglTexture,iu.TEXTURE0+Sp);const Uu=su.get(qu);if(qu.version!==Uu.__version||tm===!0){tu.activeTexture(iu.TEXTURE0+Sp);const zu=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),ep=_d.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(_d.colorSpace),up=_d.colorSpace===NoColorSpace||zu===ep?iu.NONE:iu.BROWSER_DEFAULT_WEBGL;iu.pixelStorei(iu.UNPACK_FLIP_Y_WEBGL,_d.flipY),iu.pixelStorei(iu.UNPACK_PREMULTIPLY_ALPHA_WEBGL,_d.premultiplyAlpha),iu.pixelStorei(iu.UNPACK_ALIGNMENT,_d.unpackAlignment),iu.pixelStorei(iu.UNPACK_COLORSPACE_CONVERSION_WEBGL,up);const Mp=_d.isCompressedTexture||_d.image[0].isCompressedTexture,Ip=_d.image[0]&&_d.image[0].isDataTexture,fm=[];for(let Sm=0;Sm<6;Sm++)!Mp&&!Ip?fm[Sm]=Lu(_d.image[Sm],!0,au.maxCubemapSize):fm[Sm]=Ip?_d.image[Sm].image:_d.image[Sm],fm[Sm]=Kp(_d,fm[Sm]);const Gm=fm[0],pp=uu.convert(_d.format,_d.colorSpace),Zp=uu.convert(_d.type),om=Zu(_d.internalFormat,pp,Zp,_d.colorSpace),Mm=_d.isVideoTexture!==!0,Tm=Uu.__version===void 0||tm===!0,Lm=qu.dataReady;let Ym=Yu(_d,Gm);kp(iu.TEXTURE_CUBE_MAP,_d);let Rm;if(Mp){Mm&&Tm&&tu.texStorage2D(iu.TEXTURE_CUBE_MAP,Ym,om,Gm.width,Gm.height);for(let Sm=0;Sm<6;Sm++){Rm=fm[Sm].mipmaps;for(let Fm=0;Fm<Rm.length;Fm++){const i0=Rm[Fm];_d.format!==RGBAFormat?pp!==null?Mm?Lm&&tu.compressedTexSubImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm,0,0,i0.width,i0.height,pp,i0.data):tu.compressedTexImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm,om,i0.width,i0.height,0,i0.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm,0,0,i0.width,i0.height,pp,Zp,i0.data):tu.texImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm,om,i0.width,i0.height,0,pp,Zp,i0.data)}}}else{if(Rm=_d.mipmaps,Mm&&Tm){Rm.length>0&&Ym++;const Sm=vm(fm[0]);tu.texStorage2D(iu.TEXTURE_CUBE_MAP,Ym,om,Sm.width,Sm.height)}for(let Sm=0;Sm<6;Sm++)if(Ip){Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,0,0,0,fm[Sm].width,fm[Sm].height,pp,Zp,fm[Sm].data):tu.texImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,0,om,fm[Sm].width,fm[Sm].height,0,pp,Zp,fm[Sm].data);for(let Fm=0;Fm<Rm.length;Fm++){const $0=Rm[Fm].image[Sm].image;Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm+1,0,0,$0.width,$0.height,pp,Zp,$0.data):tu.texImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm+1,om,$0.width,$0.height,0,pp,Zp,$0.data)}}else{Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,0,0,0,pp,Zp,fm[Sm]):tu.texImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,0,om,pp,Zp,fm[Sm]);for(let Fm=0;Fm<Rm.length;Fm++){const i0=Rm[Fm];Mm?Lm&&tu.texSubImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm+1,0,0,pp,Zp,i0.image[Sm]):tu.texImage2D(iu.TEXTURE_CUBE_MAP_POSITIVE_X+Sm,Fm+1,om,pp,Zp,i0.image[Sm])}}}Du(_d)&&Ou(iu.TEXTURE_CUBE_MAP),Uu.__version=qu.version,_d.onUpdate&&_d.onUpdate(_d)}sp.__version=_d.version}function sm(sp,_d,Sp,tm,qu,Uu){const zu=uu.convert(Sp.format,Sp.colorSpace),ep=uu.convert(Sp.type),up=Zu(Sp.internalFormat,zu,ep,Sp.colorSpace),Mp=su.get(_d),Ip=su.get(Sp);if(Ip.__renderTarget=_d,!Mp.__hasExternalTextures){const Gm=Math.max(1,_d.width>>Uu),pp=Math.max(1,_d.height>>Uu);_d.isWebGLMultiviewRenderTarget===!0?tu.texStorage3D(iu.TEXTURE_2D_ARRAY,0,up,_d.width,_d.height,_d.numViews):qu===iu.TEXTURE_3D||qu===iu.TEXTURE_2D_ARRAY?tu.texImage3D(qu,Uu,up,Gm,pp,_d.depth,0,zu,ep,null):tu.texImage2D(qu,Uu,up,Gm,pp,0,zu,ep,null)}tu.bindFramebuffer(iu.FRAMEBUFFER,sp);const fm=mp(_d);_d.isWebGLMultiviewRenderTarget===!0?fm?yu.framebufferTextureMultisampleMultiviewOVR(iu.FRAMEBUFFER,iu.COLOR_ATTACHMENT0,Ip.__webglTexture,0,ap(_d),0,_d.numViews):yu.framebufferTextureMultiviewOVR(iu.FRAMEBUFFER,iu.COLOR_ATTACHMENT0,Ip.__webglTexture,0,0,_d.numViews):(qu===iu.TEXTURE_2D||qu>=iu.TEXTURE_CUBE_MAP_POSITIVE_X&&qu<=iu.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&(fm?fu.framebufferTexture2DMultisampleEXT(iu.FRAMEBUFFER,tm,qu,Ip.__webglTexture,0,ap(_d)):iu.framebufferTexture2D(iu.FRAMEBUFFER,tm,qu,Ip.__webglTexture,Uu)),tu.bindFramebuffer(iu.FRAMEBUFFER,null)}function $p(sp,_d,Sp){if(iu.bindRenderbuffer(iu.RENDERBUFFER,sp),_d.isWebGLMultiviewRenderTarget===!0){const tm=mp(_d),qu=_d.numViews,Uu=_d.depthTexture;let zu=iu.DEPTH_COMPONENT24,ep=iu.DEPTH_ATTACHMENT;Uu&&Uu.isDepthTexture&&(Uu.type===FloatType?zu=iu.DEPTH_COMPONENT32F:Uu.type===UnsignedInt248Type&&(zu=iu.DEPTH24_STENCIL8,ep=iu.DEPTH_STENCIL_ATTACHMENT));let up=su.get(_d.depthTexture).__webglTexture;up===void 0&&(up=iu.createTexture(),iu.bindTexture(iu.TEXTURE_2D_ARRAY,up),iu.texStorage3D(iu.TEXTURE_2D_ARRAY,1,zu,_d.width,_d.height,qu)),tm?yu.framebufferTextureMultisampleMultiviewOVR(iu.FRAMEBUFFER,ep,up,0,ap(_d),0,qu):yu.framebufferTextureMultiviewOVR(iu.FRAMEBUFFER,ep,up,0,0,qu)}else if(_d.depthBuffer){const tm=_d.depthTexture,qu=tm&&tm.isDepthTexture?tm.type:null,Uu=Hu(_d.stencilBuffer,qu),zu=_d.stencilBuffer?iu.DEPTH_STENCIL_ATTACHMENT:iu.DEPTH_ATTACHMENT,ep=ap(_d);mp(_d)?fu.renderbufferStorageMultisampleEXT(iu.RENDERBUFFER,ep,Uu,_d.width,_d.height):Sp?iu.renderbufferStorageMultisample(iu.RENDERBUFFER,ep,Uu,_d.width,_d.height):iu.renderbufferStorage(iu.RENDERBUFFER,Uu,_d.width,_d.height),iu.framebufferRenderbuffer(iu.FRAMEBUFFER,zu,iu.RENDERBUFFER,sp)}else{const tm=_d.textures;for(let qu=0;qu<tm.length;qu++){const Uu=tm[qu],zu=uu.convert(Uu.format,Uu.colorSpace),ep=uu.convert(Uu.type),up=Zu(Uu.internalFormat,zu,ep,Uu.colorSpace),Mp=ap(_d);Sp&&mp(_d)===!1?iu.renderbufferStorageMultisample(iu.RENDERBUFFER,Mp,up,_d.width,_d.height):mp(_d)?fu.renderbufferStorageMultisampleEXT(iu.RENDERBUFFER,Mp,up,_d.width,_d.height):iu.renderbufferStorage(iu.RENDERBUFFER,up,_d.width,_d.height)}}iu.bindRenderbuffer(iu.RENDERBUFFER,null)}function _f(sp,_d){if(_d&&_d.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(tu.bindFramebuffer(iu.FRAMEBUFFER,sp),!(_d.depthTexture&&_d.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const tm=su.get(_d.depthTexture);tm.__renderTarget=_d,(!tm.__webglTexture||_d.depthTexture.image.width!==_d.width||_d.depthTexture.image.height!==_d.height)&&(_d.depthTexture.image.width=_d.width,_d.depthTexture.image.height=_d.height,_d.depthTexture.needsUpdate=!0),_d.depthTexture.image.depth!=1?Rp(_d.depthTexture,0):dp(_d.depthTexture,0);const qu=tm.__webglTexture,Uu=ap(_d);if(_d.isWebGLMultiviewRenderTarget===!0){const zu=mp(_d),ep=_d.numViews;if(_d.depthTexture.format===DepthFormat)zu?yu.framebufferTextureMultisampleMultiviewOVR(iu.FRAMEBUFFER,iu.DEPTH_ATTACHMENT,qu,0,Uu,0,ep):yu.framebufferTextureMultiviewOVR(iu.FRAMEBUFFER,iu.DEPTH_ATTACHMENT,qu,0,0,ep);else if(_d.depthTexture.format===DepthStencilFormat)zu?yu.framebufferTextureMultisampleMultiviewOVR(iu.FRAMEBUFFER,iu.DEPTH_STENCIL_ATTACHMENT,qu,0,Uu,0,ep):yu.framebufferTextureMultiviewOVR(iu.FRAMEBUFFER,iu.DEPTH_STENCIL_ATTACHMENT,qu,0,0,ep);else throw new Error("Unknown depthTexture format")}else if(_d.depthTexture.format===DepthFormat)mp(_d)?fu.framebufferTexture2DMultisampleEXT(iu.FRAMEBUFFER,iu.DEPTH_ATTACHMENT,iu.TEXTURE_2D,qu,0,Uu):iu.framebufferTexture2D(iu.FRAMEBUFFER,iu.DEPTH_ATTACHMENT,iu.TEXTURE_2D,qu,0);else if(_d.depthTexture.format===DepthStencilFormat)mp(_d)?fu.framebufferTexture2DMultisampleEXT(iu.FRAMEBUFFER,iu.DEPTH_STENCIL_ATTACHMENT,iu.TEXTURE_2D,qu,0,Uu):iu.framebufferTexture2D(iu.FRAMEBUFFER,iu.DEPTH_STENCIL_ATTACHMENT,iu.TEXTURE_2D,qu,0);else throw new Error("Unknown depthTexture format")}function rm(sp){const _d=su.get(sp),Sp=sp.isWebGLCubeRenderTarget===!0;if(_d.__boundDepthTexture!==sp.depthTexture){const tm=sp.depthTexture;if(_d.__depthDisposeCallback&&_d.__depthDisposeCallback(),tm){const qu=()=>{delete _d.__boundDepthTexture,delete _d.__depthDisposeCallback,tm.removeEventListener("dispose",qu)};tm.addEventListener("dispose",qu),_d.__depthDisposeCallback=qu}_d.__boundDepthTexture=tm}if(sp.depthTexture&&!_d.__autoAllocateDepthBuffer){if(Sp)throw new Error("target.depthTexture not supported in Cube render targets");_f(_d.__webglFramebuffer,sp)}else if(Sp){_d.__webglDepthbuffer=[];for(let tm=0;tm<6;tm++)if(tu.bindFramebuffer(iu.FRAMEBUFFER,_d.__webglFramebuffer[tm]),_d.__webglDepthbuffer[tm]===void 0)_d.__webglDepthbuffer[tm]=iu.createRenderbuffer(),$p(_d.__webglDepthbuffer[tm],sp,!1);else{const qu=sp.stencilBuffer?iu.DEPTH_STENCIL_ATTACHMENT:iu.DEPTH_ATTACHMENT,Uu=_d.__webglDepthbuffer[tm];iu.bindRenderbuffer(iu.RENDERBUFFER,Uu),iu.framebufferRenderbuffer(iu.FRAMEBUFFER,qu,iu.RENDERBUFFER,Uu)}}else if(tu.bindFramebuffer(iu.FRAMEBUFFER,_d.__webglFramebuffer),_d.__webglDepthbuffer===void 0)_d.__webglDepthbuffer=iu.createRenderbuffer(),$p(_d.__webglDepthbuffer,sp,!1);else{const tm=sp.stencilBuffer?iu.DEPTH_STENCIL_ATTACHMENT:iu.DEPTH_ATTACHMENT,qu=_d.__webglDepthbuffer;iu.bindRenderbuffer(iu.RENDERBUFFER,qu),iu.framebufferRenderbuffer(iu.FRAMEBUFFER,tm,iu.RENDERBUFFER,qu)}tu.bindFramebuffer(iu.FRAMEBUFFER,null)}function lp(sp,_d,Sp){const tm=su.get(sp);_d!==void 0&&sm(tm.__webglFramebuffer,sp,sp.texture,iu.COLOR_ATTACHMENT0,iu.TEXTURE_2D,0),Sp!==void 0&&rm(sp)}function cp(sp){const _d=sp.texture,Sp=su.get(sp),tm=su.get(_d);sp.addEventListener("dispose",ju);const qu=sp.textures,Uu=sp.isWebGLCubeRenderTarget===!0,zu=qu.length>1;if(zu||(tm.__webglTexture===void 0&&(tm.__webglTexture=iu.createTexture()),tm.__version=_d.version,du.memory.textures++),Uu){Sp.__webglFramebuffer=[];for(let ep=0;ep<6;ep++)if(_d.mipmaps&&_d.mipmaps.length>0){Sp.__webglFramebuffer[ep]=[];for(let up=0;up<_d.mipmaps.length;up++)Sp.__webglFramebuffer[ep][up]=iu.createFramebuffer()}else Sp.__webglFramebuffer[ep]=iu.createFramebuffer()}else{if(_d.mipmaps&&_d.mipmaps.length>0){Sp.__webglFramebuffer=[];for(let ep=0;ep<_d.mipmaps.length;ep++)Sp.__webglFramebuffer[ep]=iu.createFramebuffer()}else Sp.__webglFramebuffer=iu.createFramebuffer();if(zu)for(let ep=0,up=qu.length;ep<up;ep++){const Mp=su.get(qu[ep]);Mp.__webglTexture===void 0&&(Mp.__webglTexture=iu.createTexture(),du.memory.textures++)}if(sp.samples>0&&mp(sp)===!1){Sp.__webglMultisampledFramebuffer=iu.createFramebuffer(),Sp.__webglColorRenderbuffer=[],tu.bindFramebuffer(iu.FRAMEBUFFER,Sp.__webglMultisampledFramebuffer);for(let ep=0;ep<qu.length;ep++){const up=qu[ep];Sp.__webglColorRenderbuffer[ep]=iu.createRenderbuffer(),iu.bindRenderbuffer(iu.RENDERBUFFER,Sp.__webglColorRenderbuffer[ep]);const Mp=uu.convert(up.format,up.colorSpace),Ip=uu.convert(up.type),fm=Zu(up.internalFormat,Mp,Ip,up.colorSpace,sp.isXRRenderTarget===!0),Gm=ap(sp);iu.renderbufferStorageMultisample(iu.RENDERBUFFER,Gm,fm,sp.width,sp.height),iu.framebufferRenderbuffer(iu.FRAMEBUFFER,iu.COLOR_ATTACHMENT0+ep,iu.RENDERBUFFER,Sp.__webglColorRenderbuffer[ep])}iu.bindRenderbuffer(iu.RENDERBUFFER,null),sp.depthBuffer&&(Sp.__webglDepthRenderbuffer=iu.createRenderbuffer(),$p(Sp.__webglDepthRenderbuffer,sp,!0)),tu.bindFramebuffer(iu.FRAMEBUFFER,null)}}if(Uu){tu.bindTexture(iu.TEXTURE_CUBE_MAP,tm.__webglTexture),kp(iu.TEXTURE_CUBE_MAP,_d);for(let ep=0;ep<6;ep++)if(_d.mipmaps&&_d.mipmaps.length>0)for(let up=0;up<_d.mipmaps.length;up++)sm(Sp.__webglFramebuffer[ep][up],sp,_d,iu.COLOR_ATTACHMENT0,iu.TEXTURE_CUBE_MAP_POSITIVE_X+ep,up);else sm(Sp.__webglFramebuffer[ep],sp,_d,iu.COLOR_ATTACHMENT0,iu.TEXTURE_CUBE_MAP_POSITIVE_X+ep,0);Du(_d)&&Ou(iu.TEXTURE_CUBE_MAP),tu.unbindTexture()}else if(zu){for(let ep=0,up=qu.length;ep<up;ep++){const Mp=qu[ep],Ip=su.get(Mp);tu.bindTexture(iu.TEXTURE_2D,Ip.__webglTexture),kp(iu.TEXTURE_2D,Mp),sm(Sp.__webglFramebuffer,sp,Mp,iu.COLOR_ATTACHMENT0+ep,iu.TEXTURE_2D,0),Du(Mp)&&Ou(iu.TEXTURE_2D)}tu.unbindTexture()}else{let ep=iu.TEXTURE_2D;if((sp.isWebGL3DRenderTarget||sp.isWebGLArrayRenderTarget)&&(ep=sp.isWebGL3DRenderTarget?iu.TEXTURE_3D:iu.TEXTURE_2D_ARRAY),sp.isWebGLMultiviewRenderTarget===!0&&(ep=iu.TEXTURE_2D_ARRAY),tu.bindTexture(ep,tm.__webglTexture),kp(ep,_d),_d.mipmaps&&_d.mipmaps.length>0)for(let up=0;up<_d.mipmaps.length;up++)sm(Sp.__webglFramebuffer[up],sp,_d,iu.COLOR_ATTACHMENT0,ep,up);else sm(Sp.__webglFramebuffer,sp,_d,iu.COLOR_ATTACHMENT0,ep,0);Du(_d)&&Ou(ep),tu.unbindTexture()}(sp.depthBuffer||sp.isWebGLMultiviewRenderTarget===!0)&&this.setupDepthRenderbuffer(sp)}function mm(sp){const _d=sp.textures;for(let Sp=0,tm=_d.length;Sp<tm;Sp++){const qu=_d[Sp];if(Du(qu)){const Uu=Wu(sp),zu=su.get(qu).__webglTexture;tu.bindTexture(Uu,zu),Ou(Uu),tu.unbindTexture()}}}const $u=[],Vu=[];function _h(sp){if(sp.samples>0){if(mp(sp)===!1){const _d=sp.textures,Sp=sp.width,tm=sp.height;let qu=iu.COLOR_BUFFER_BIT;const Uu=sp.stencilBuffer?iu.DEPTH_STENCIL_ATTACHMENT:iu.DEPTH_ATTACHMENT,zu=su.get(sp),ep=_d.length>1;if(ep)for(let up=0;up<_d.length;up++)tu.bindFramebuffer(iu.FRAMEBUFFER,zu.__webglMultisampledFramebuffer),iu.framebufferRenderbuffer(iu.FRAMEBUFFER,iu.COLOR_ATTACHMENT0+up,iu.RENDERBUFFER,null),tu.bindFramebuffer(iu.FRAMEBUFFER,zu.__webglFramebuffer),iu.framebufferTexture2D(iu.DRAW_FRAMEBUFFER,iu.COLOR_ATTACHMENT0+up,iu.TEXTURE_2D,null,0);tu.bindFramebuffer(iu.READ_FRAMEBUFFER,zu.__webglMultisampledFramebuffer),tu.bindFramebuffer(iu.DRAW_FRAMEBUFFER,zu.__webglFramebuffer);for(let up=0;up<_d.length;up++){if(sp.resolveDepthBuffer&&(sp.depthBuffer&&(qu|=iu.DEPTH_BUFFER_BIT),sp.stencilBuffer&&sp.resolveStencilBuffer&&(qu|=iu.STENCIL_BUFFER_BIT)),ep){iu.framebufferRenderbuffer(iu.READ_FRAMEBUFFER,iu.COLOR_ATTACHMENT0,iu.RENDERBUFFER,zu.__webglColorRenderbuffer[up]);const Mp=su.get(_d[up]).__webglTexture;iu.framebufferTexture2D(iu.DRAW_FRAMEBUFFER,iu.COLOR_ATTACHMENT0,iu.TEXTURE_2D,Mp,0)}iu.blitFramebuffer(0,0,Sp,tm,0,0,Sp,tm,qu,iu.NEAREST),gu===!0&&($u.length=0,Vu.length=0,$u.push(iu.COLOR_ATTACHMENT0+up),sp.depthBuffer&&sp.resolveDepthBuffer===!1&&($u.push(Uu),Vu.push(Uu),iu.invalidateFramebuffer(iu.DRAW_FRAMEBUFFER,Vu)),iu.invalidateFramebuffer(iu.READ_FRAMEBUFFER,$u))}if(tu.bindFramebuffer(iu.READ_FRAMEBUFFER,null),tu.bindFramebuffer(iu.DRAW_FRAMEBUFFER,null),ep)for(let up=0;up<_d.length;up++){tu.bindFramebuffer(iu.FRAMEBUFFER,zu.__webglMultisampledFramebuffer),iu.framebufferRenderbuffer(iu.FRAMEBUFFER,iu.COLOR_ATTACHMENT0+up,iu.RENDERBUFFER,zu.__webglColorRenderbuffer[up]);const Mp=su.get(_d[up]).__webglTexture;tu.bindFramebuffer(iu.FRAMEBUFFER,zu.__webglFramebuffer),iu.framebufferTexture2D(iu.DRAW_FRAMEBUFFER,iu.COLOR_ATTACHMENT0+up,iu.TEXTURE_2D,Mp,0)}tu.bindFramebuffer(iu.DRAW_FRAMEBUFFER,zu.__webglMultisampledFramebuffer)}else if(sp.depthBuffer&&sp.resolveDepthBuffer===!1&&gu){const _d=sp.stencilBuffer?iu.DEPTH_STENCIL_ATTACHMENT:iu.DEPTH_ATTACHMENT;iu.invalidateFramebuffer(iu.DRAW_FRAMEBUFFER,[_d])}}}function ap(sp){return Math.min(au.maxSamples,sp.samples)}function mp(sp){const _d=su.get(sp);return sp.samples>0&&eu.has("WEBGL_multisampled_render_to_texture")===!0&&_d.__useRenderToTexture!==!1}function Lp(sp){const _d=du.render.frame;vu.get(sp)!==_d&&(vu.set(sp,_d),sp.update())}function Kp(sp,_d){const Sp=sp.colorSpace,tm=sp.format,qu=sp.type;return sp.isCompressedTexture===!0||sp.isVideoTexture===!0||Sp!==LinearSRGBColorSpace&&Sp!==NoColorSpace&&(ColorManagement.getTransfer(Sp)===SRGBTransfer?(tm!==RGBAFormat||qu!==UnsignedByteType)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Sp)),_d}function vm(sp){return typeof HTMLImageElement<"u"&&sp instanceof HTMLImageElement?(xu.width=sp.naturalWidth||sp.width,xu.height=sp.naturalHeight||sp.height):typeof VideoFrame<"u"&&sp instanceof VideoFrame?(xu.width=sp.displayWidth,xu.height=sp.displayHeight):(xu.width=sp.width,xu.height=sp.height),xu}this.allocateTextureUnit=wp,this.resetTextureUnits=Hp,this.setTexture2D=dp,this.setTexture2DArray=Rp,this.setTexture3D=xp,this.setTextureCube=cm,this.rebindTextures=lp,this.uploadTexture=Qp,this.setupRenderTarget=cp,this.updateRenderTargetMipmap=mm,this.updateMultisampleRenderTarget=_h,this.setupDepthTexture=_f,this.setupDepthRenderbuffer=rm,this.setupFrameBufferTexture=sm,this.useMultisampledRTT=mp,this.runDeferredUploads=Bp,this.setDeferTextureUploads=nm}function WebGLUtils(iu,eu){function tu(su,au=NoColorSpace){let uu;const du=ColorManagement.getTransfer(au);if(su===UnsignedByteType)return iu.UNSIGNED_BYTE;if(su===UnsignedShort4444Type)return iu.UNSIGNED_SHORT_4_4_4_4;if(su===UnsignedShort5551Type)return iu.UNSIGNED_SHORT_5_5_5_1;if(su===UnsignedInt5999Type)return iu.UNSIGNED_INT_5_9_9_9_REV;if(su===ByteType)return iu.BYTE;if(su===ShortType)return iu.SHORT;if(su===UnsignedShortType)return iu.UNSIGNED_SHORT;if(su===IntType)return iu.INT;if(su===UnsignedIntType)return iu.UNSIGNED_INT;if(su===FloatType)return iu.FLOAT;if(su===HalfFloatType)return iu.HALF_FLOAT;if(su===AlphaFormat)return iu.ALPHA;if(su===RGBFormat)return iu.RGB;if(su===RGBAFormat)return iu.RGBA;if(su===LuminanceFormat)return iu.LUMINANCE;if(su===LuminanceAlphaFormat)return iu.LUMINANCE_ALPHA;if(su===DepthFormat)return iu.DEPTH_COMPONENT;if(su===DepthStencilFormat)return iu.DEPTH_STENCIL;if(su===RedFormat)return iu.RED;if(su===RedIntegerFormat)return iu.RED_INTEGER;if(su===RGFormat)return iu.RG;if(su===RGIntegerFormat)return iu.RG_INTEGER;if(su===RGBAIntegerFormat)return iu.RGBA_INTEGER;if(su===RGB_S3TC_DXT1_Format||su===RGBA_S3TC_DXT1_Format||su===RGBA_S3TC_DXT3_Format||su===RGBA_S3TC_DXT5_Format)if(du===SRGBTransfer)if(uu=eu.get("WEBGL_compressed_texture_s3tc_srgb"),uu!==null){if(su===RGB_S3TC_DXT1_Format)return uu.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(su===RGBA_S3TC_DXT1_Format)return uu.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(su===RGBA_S3TC_DXT3_Format)return uu.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(su===RGBA_S3TC_DXT5_Format)return uu.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(uu=eu.get("WEBGL_compressed_texture_s3tc"),uu!==null){if(su===RGB_S3TC_DXT1_Format)return uu.COMPRESSED_RGB_S3TC_DXT1_EXT;if(su===RGBA_S3TC_DXT1_Format)return uu.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(su===RGBA_S3TC_DXT3_Format)return uu.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(su===RGBA_S3TC_DXT5_Format)return uu.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(su===RGB_PVRTC_4BPPV1_Format||su===RGB_PVRTC_2BPPV1_Format||su===RGBA_PVRTC_4BPPV1_Format||su===RGBA_PVRTC_2BPPV1_Format)if(uu=eu.get("WEBGL_compressed_texture_pvrtc"),uu!==null){if(su===RGB_PVRTC_4BPPV1_Format)return uu.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(su===RGB_PVRTC_2BPPV1_Format)return uu.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(su===RGBA_PVRTC_4BPPV1_Format)return uu.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(su===RGBA_PVRTC_2BPPV1_Format)return uu.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(su===RGB_ETC1_Format||su===RGB_ETC2_Format||su===RGBA_ETC2_EAC_Format)if(uu=eu.get("WEBGL_compressed_texture_etc"),uu!==null){if(su===RGB_ETC1_Format||su===RGB_ETC2_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ETC2:uu.COMPRESSED_RGB8_ETC2;if(su===RGBA_ETC2_EAC_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:uu.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(su===RGBA_ASTC_4x4_Format||su===RGBA_ASTC_5x4_Format||su===RGBA_ASTC_5x5_Format||su===RGBA_ASTC_6x5_Format||su===RGBA_ASTC_6x6_Format||su===RGBA_ASTC_8x5_Format||su===RGBA_ASTC_8x6_Format||su===RGBA_ASTC_8x8_Format||su===RGBA_ASTC_10x5_Format||su===RGBA_ASTC_10x6_Format||su===RGBA_ASTC_10x8_Format||su===RGBA_ASTC_10x10_Format||su===RGBA_ASTC_12x10_Format||su===RGBA_ASTC_12x12_Format)if(uu=eu.get("WEBGL_compressed_texture_astc"),uu!==null){if(su===RGBA_ASTC_4x4_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:uu.COMPRESSED_RGBA_ASTC_4x4_KHR;if(su===RGBA_ASTC_5x4_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:uu.COMPRESSED_RGBA_ASTC_5x4_KHR;if(su===RGBA_ASTC_5x5_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:uu.COMPRESSED_RGBA_ASTC_5x5_KHR;if(su===RGBA_ASTC_6x5_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:uu.COMPRESSED_RGBA_ASTC_6x5_KHR;if(su===RGBA_ASTC_6x6_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:uu.COMPRESSED_RGBA_ASTC_6x6_KHR;if(su===RGBA_ASTC_8x5_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:uu.COMPRESSED_RGBA_ASTC_8x5_KHR;if(su===RGBA_ASTC_8x6_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:uu.COMPRESSED_RGBA_ASTC_8x6_KHR;if(su===RGBA_ASTC_8x8_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:uu.COMPRESSED_RGBA_ASTC_8x8_KHR;if(su===RGBA_ASTC_10x5_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:uu.COMPRESSED_RGBA_ASTC_10x5_KHR;if(su===RGBA_ASTC_10x6_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:uu.COMPRESSED_RGBA_ASTC_10x6_KHR;if(su===RGBA_ASTC_10x8_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:uu.COMPRESSED_RGBA_ASTC_10x8_KHR;if(su===RGBA_ASTC_10x10_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:uu.COMPRESSED_RGBA_ASTC_10x10_KHR;if(su===RGBA_ASTC_12x10_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:uu.COMPRESSED_RGBA_ASTC_12x10_KHR;if(su===RGBA_ASTC_12x12_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:uu.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(su===RGBA_BPTC_Format||su===RGB_BPTC_SIGNED_Format||su===RGB_BPTC_UNSIGNED_Format)if(uu=eu.get("EXT_texture_compression_bptc"),uu!==null){if(su===RGBA_BPTC_Format)return du===SRGBTransfer?uu.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:uu.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(su===RGB_BPTC_SIGNED_Format)return uu.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(su===RGB_BPTC_UNSIGNED_Format)return uu.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(su===RED_RGTC1_Format||su===SIGNED_RED_RGTC1_Format||su===RED_GREEN_RGTC2_Format||su===SIGNED_RED_GREEN_RGTC2_Format)if(uu=eu.get("EXT_texture_compression_rgtc"),uu!==null){if(su===RGBA_BPTC_Format)return uu.COMPRESSED_RED_RGTC1_EXT;if(su===SIGNED_RED_RGTC1_Format)return uu.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(su===RED_GREEN_RGTC2_Format)return uu.COMPRESSED_RED_GREEN_RGTC2_EXT;if(su===SIGNED_RED_GREEN_RGTC2_Format)return uu.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return su===UnsignedInt248Type?iu.UNSIGNED_INT_24_8:iu[su]!==void 0?iu[su]:null}return{convert:tu}}class WebGLMultiviewRenderTarget extends WebGLRenderTarget{constructor(eu,tu,su,au={}){super(eu,tu,au),this.depthBuffer=!1,this.stencilBuffer=!1,this.numViews=su}copy(eu){return super.copy(eu),this.numViews=eu.numViews,this}}WebGLMultiviewRenderTarget.prototype.isWebGLMultiviewRenderTarget=!0;const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(eu,tu,su){if(this.texture===null){const au=new Texture,uu=eu.properties.get(au);uu.__webglTexture=tu.texture,(tu.depthNear!==su.depthNear||tu.depthFar!==su.depthFar)&&(this.depthNear=tu.depthNear,this.depthFar=tu.depthFar),this.texture=au}}getMesh(eu){if(this.texture!==null&&this.mesh===null){const tu=eu.cameras[0].viewport,su=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:tu.z},depthHeight:{value:tu.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),su)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class WebXRManager extends EventDispatcher{constructor(eu,tu,su,au){super();const uu=this;let du=null,fu=1;var gu=null;let yu=null,xu="local-floor",vu=1,Su=null,Iu=null;var Mu=[];let ku=null,Bu=null,_u=null,Lu=null;const Du=new WebXRDepthSensing,Ou=tu.getContextAttributes();let Wu=null,Zu=null;const Hu=[],Yu=[],Ku=new Vector2;let ju=null;const tp=new PerspectiveCamera;tp.viewport=new Vector4;const gp=new PerspectiveCamera;gp.viewport=new Vector4;const yp=[tp,gp],Cp=new ArrayCamera;let Hp=null,wp=null;this.cameraAutoUpdate=!0,this.layersEnabled=!1,this.enabled=!1,this.isPresenting=!1,this.isMultiview=!1,this.getCameraPose=function(){return Iu},this.getController=function(Bp){let Qp=Hu[Bp];return Qp===void 0&&(Qp=new WebXRController,Hu[Bp]=Qp),Qp.getTargetRaySpace()},this.getControllerGrip=function(Bp){let Qp=Hu[Bp];return Qp===void 0&&(Qp=new WebXRController,Hu[Bp]=Qp),Qp.getGripSpace()},this.getHand=function(Bp){let Qp=Hu[Bp];return Qp===void 0&&(Qp=new WebXRController,Hu[Bp]=Qp),Qp.getHandSpace()};function Dp(Bp){const Qp=Yu.indexOf(Bp.inputSource);if(Qp===-1)return;const Xp=Hu[Qp];Xp!==void 0&&(Xp.update(Bp.inputSource,Bp.frame,Su||yu),Xp.dispatchEvent({type:Bp.type,data:Bp.inputSource}))}function dp(){du.removeEventListener("select",Dp),du.removeEventListener("selectstart",Dp),du.removeEventListener("selectend",Dp),du.removeEventListener("squeeze",Dp),du.removeEventListener("squeezestart",Dp),du.removeEventListener("squeezeend",Dp),du.removeEventListener("end",dp),du.removeEventListener("inputsourceschange",Rp);for(let Bp=0;Bp<Hu.length;Bp++){const Qp=Yu[Bp];Qp!==null&&(Yu[Bp]=null,Hu[Bp].disconnect(Qp))}Hp=null,wp=null,Du.reset(),uu.isPresenting=!1,eu.setRenderTarget(Wu),_u=null,Bu=null,ku=null,du=null,Zu=null,nm.stop(),eu.setPixelRatio(ju),eu.setSize(Ku.width,Ku.height,!1),uu.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(Bp){fu=Bp,uu.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Bp){xu=Bp,uu.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return Su||yu},this.setReferenceSpace=function(Bp){Su=Bp},this.getBaseLayer=function(){return Bu!==null?Bu:_u},this.getBinding=function(){return ku},this.getRenderTarget=function(){return Zu},this.getFrame=function(){return Lu},this.getSession=function(){return du},this.setSession=async function(Bp){if(du=Bp,du!==null){if(Wu=eu.getRenderTarget(),du.addEventListener("select",Dp),du.addEventListener("selectstart",Dp),du.addEventListener("selectend",Dp),du.addEventListener("squeeze",Dp),du.addEventListener("squeezestart",Dp),du.addEventListener("squeezeend",Dp),du.addEventListener("end",dp),du.addEventListener("inputsourceschange",Rp),Ou.xrCompatible!==!0&&await tu.makeXRCompatible(),ju=eu.getPixelRatio(),eu.getSize(Ku),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let Xp=null,sm=null,$p=null;Ou.depth&&($p=Ou.stencil?tu.DEPTH24_STENCIL8:tu.DEPTH_COMPONENT24,Xp=Ou.stencil?DepthStencilFormat:DepthFormat,sm=Ou.stencil?UnsignedInt248Type:UnsignedIntType),uu.isMultiview=au&&su.has("OCULUS_multiview");const _f={colorFormat:tu.RGBA8,depthFormat:$p,scaleFactor:fu};uu.isMultiview&&(_f.textureType="texture-array"),ku=new XRWebGLBinding(du,tu),Bu=ku.createProjectionLayer(_f),du.updateRenderState({layers:[Bu]}),eu.setPixelRatio(1),eu.setSize(Bu.textureWidth,Bu.textureHeight,!1);const rm={format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(Bu.textureWidth,Bu.textureHeight,sm,void 0,void 0,void 0,void 0,void 0,void 0,Xp),stencilBuffer:Ou.stencil,colorSpace:eu.outputColorSpace,samples:Ou.antialias?4:0,resolveDepthBuffer:Bu.ignoreDepthValues===!1};if(uu.isMultiview){const lp=su.get("OCULUS_multiview");this.maxNumViews=tu.getParameter(lp.MAX_VIEWS_OVR),Zu=new WebGLMultiviewRenderTarget(Bu.textureWidth,Bu.textureHeight,2,rm)}else Zu=new WebGLRenderTarget(Bu.textureWidth,Bu.textureHeight,rm)}else{const Xp={antialias:Ou.antialias,alpha:!0,depth:Ou.depth,stencil:Ou.stencil,framebufferScaleFactor:fu};_u=new XRWebGLLayer(du,tu,Xp),du.updateRenderState({baseLayer:_u}),eu.setPixelRatio(1),eu.setSize(_u.framebufferWidth,_u.framebufferHeight,!1),Zu=new WebGLRenderTarget(_u.framebufferWidth,_u.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:eu.outputColorSpace,stencilBuffer:Ou.stencil})}Zu.isXRRenderTarget=!0,this.setFoveation(vu),Su=null,yu=await du.requestReferenceSpace(xu),nm.setContext(du),nm.start(),uu.isPresenting=!0,uu.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(du!==null)return du.environmentBlendMode},this.addLayer=function(Bp){!window.XRWebGLBinding||!this.layersEnabled||!du||(Mu.push(Bp),this.updateLayers())},this.removeLayer=function(Bp){Mu.splice(Mu.indexOf(Bp),1),!(!window.XRWebGLBinding||!this.layersEnabled||!du)&&this.updateLayers()},this.updateLayers=function(){var Bp=Mu.map(function(Qp){return Qp});Bp.unshift(du.renderState.layers[0]),du.updateRenderState({layers:Bp})},this.getDepthTexture=function(){return Du.getDepthTexture()};function Rp(Bp){for(let Qp=0;Qp<Bp.removed.length;Qp++){const Xp=Bp.removed[Qp],sm=Yu.indexOf(Xp);sm>=0&&(Yu[sm]=null,Hu[sm].disconnect(Xp))}for(let Qp=0;Qp<Bp.added.length;Qp++){const Xp=Bp.added[Qp];let sm=Yu.indexOf(Xp);if(sm===-1){for(let _f=0;_f<Hu.length;_f++)if(_f>=Yu.length){Yu.push(Xp),sm=_f;break}else if(Yu[_f]===null){Yu[_f]=Xp,sm=_f;break}if(sm===-1)break}const $p=Hu[sm];$p&&$p.connect(Xp)}}const xp=new Vector3,cm=new Vector3;function lm(Bp,Qp,Xp){xp.setFromMatrixPosition(Qp.matrixWorld),cm.setFromMatrixPosition(Xp.matrixWorld);const sm=xp.distanceTo(cm),$p=Qp.projectionMatrix.elements,_f=Xp.projectionMatrix.elements,rm=$p[14]/($p[10]-1),lp=$p[14]/($p[10]+1),cp=($p[9]+1)/$p[5],mm=($p[9]-1)/$p[5],$u=($p[8]-1)/$p[0],Vu=(_f[8]+1)/_f[0],_h=rm*$u,ap=rm*Vu,mp=sm/(-$u+Vu),Lp=mp*-$u;if(Qp.matrixWorld.decompose(Bp.position,Bp.quaternion,Bp.scale),Bp.translateX(Lp),Bp.translateZ(mp),Bp.matrixWorld.compose(Bp.position,Bp.quaternion,Bp.scale),Bp.matrixWorldInverse.copy(Bp.matrixWorld).invert(),$p[10]===-1)Bp.projectionMatrix.copy(Qp.projectionMatrix),Bp.projectionMatrixInverse.copy(Qp.projectionMatrixInverse);else{const Kp=rm+mp,vm=lp+mp,sp=_h-Lp,_d=ap+(sm-Lp),Sp=cp*lp/vm*Kp,tm=mm*lp/vm*Kp;Bp.projectionMatrix.makePerspective(sp,_d,Sp,tm,Kp,vm),Bp.projectionMatrixInverse.copy(Bp.projectionMatrix).invert()}}function vp(Bp,Qp){Qp===null?Bp.matrixWorld.copy(Bp.matrix):Bp.matrixWorld.multiplyMatrices(Qp.matrixWorld,Bp.matrix),Bp.matrixWorldInverse.copy(Bp.matrixWorld).invert()}this.setPoseTarget=function(Bp){Bp!==void 0&&(gu=Bp)},this.updateCamera=function(Bp){if(du===null)return;let Qp=Bp.near,Xp=Bp.far;Du.texture!==null&&(Du.depthNear>0&&(Qp=Du.depthNear),Du.depthFar>0&&(Xp=Du.depthFar)),Cp.near=gp.near=tp.near=Qp,Cp.far=gp.far=tp.far=Xp,(Hp!==Cp.near||wp!==Cp.far)&&(du.updateRenderState({depthNear:Cp.near,depthFar:Cp.far}),Hp=Cp.near,wp=Cp.far),tp.layers.mask=Bp.layers.mask|2,gp.layers.mask=Bp.layers.mask|4,Cp.layers.mask=tp.layers.mask|gp.layers.mask;const sm=Cp.cameras;var $p=gu||Bp;const _f=$p.parent;vp(Cp,_f);for(let rm=0;rm<sm.length;rm++)vp(sm[rm],_f);sm.length===2?lm(Cp,tp,gp):Cp.projectionMatrix.copy(tp.projectionMatrix),bp(Bp,Cp,$p)};function bp(Bp,Qp,Xp){Qp.matrixWorld.decompose(Qp.position,Qp.quaternion,Qp.scale),Xp.parent===null?Xp.matrix.copy(Qp.matrixWorld):(Xp.matrix.copy(Xp.parent.matrixWorld),Xp.matrix.invert(),Xp.matrix.multiply(Qp.matrixWorld)),Xp.matrix.decompose(Xp.position,Xp.quaternion,Xp.scale),Xp.updateMatrixWorld(!0),Bp.projectionMatrix.copy(Qp.projectionMatrix),Bp.projectionMatrixInverse.copy(Qp.projectionMatrixInverse),Bp.isPerspectiveCamera&&(Bp.fov=RAD2DEG*2*Math.atan(1/Bp.projectionMatrix.elements[5]),Bp.zoom=1)}this.getCamera=function(){return Cp},this.getFoveation=function(){if(!(Bu===null&&_u===null))return vu},this.setFoveation=function(Bp){vu=Bp,Bu!==null&&(Bu.fixedFoveation=Bp),_u!==null&&_u.fixedFoveation!==void 0&&(_u.fixedFoveation=Bp)},this.hasDepthSensing=function(){return Du.texture!==null},this.getDepthSensingMesh=function(){return Du.getMesh(Cp)};let kp=null;function dm(Bp,Qp){if(Iu=Qp.getViewerPose(Su||yu),Lu=Qp,Iu!==null){const Xp=Iu.views;_u!==null&&(eu.setRenderTargetFramebuffer(Zu,_u.framebuffer),eu.setRenderTarget(Zu));let sm=!1;Xp.length!==Cp.cameras.length&&(Cp.cameras.length=0,sm=!0);for(let rm=0;rm<Xp.length;rm++){const lp=Xp[rm];let cp=null;if(_u!==null)cp=_u.getViewport(lp);else{const $u=ku.getViewSubImage(Bu,lp);cp=$u.viewport,rm===0&&(eu.setRenderTargetTextures(Zu,$u.colorTexture,Bu.ignoreDepthValues?void 0:$u.depthStencilTexture),eu.setRenderTarget(Zu))}let mm=yp[rm];mm===void 0&&(mm=new PerspectiveCamera,mm.layers.enable(rm),mm.viewport=new Vector4,yp[rm]=mm),mm.matrix.fromArray(lp.transform.matrix),mm.matrix.decompose(mm.position,mm.quaternion,mm.scale),mm.projectionMatrix.fromArray(lp.projectionMatrix),mm.projectionMatrixInverse.copy(mm.projectionMatrix).invert(),mm.viewport.set(cp.x,cp.y,cp.width,cp.height),rm===0&&(Cp.matrix.copy(mm.matrix),Cp.matrix.decompose(Cp.position,Cp.quaternion,Cp.scale)),sm===!0&&Cp.cameras.push(mm)}const $p=du.enabledFeatures;if($p&&$p.includes("depth-sensing")&&du.depthUsage=="gpu-optimized"&&ku){const rm=ku.getDepthInformation(Xp[0]);rm&&rm.isValid&&rm.texture&&Du.init(eu,rm,du.renderState)}}for(let Xp=0;Xp<Hu.length;Xp++){const sm=Yu[Xp],$p=Hu[Xp];sm!==null&&$p!==void 0&&$p.update(sm,Qp,Su||yu)}kp&&kp(Bp,Qp),Qp.detectedPlanes&&uu.dispatchEvent({type:"planesdetected",data:Qp}),Lu=null}const nm=new WebGLAnimation;nm.setAnimationLoop(dm),this.setAnimationLoop=function(Bp){kp=Bp},this.dispose=function(){}}}const _e1=new Euler,_m1=new Matrix4;function WebGLMaterials(iu,eu){function tu(Bu,_u){Bu.matrixAutoUpdate===!0&&Bu.updateMatrix(),_u.value.copy(Bu.matrix)}function su(Bu,_u){_u.color.getRGB(Bu.fogColor.value,getUnlitUniformColorSpace(iu)),_u.isFog?(Bu.fogNear.value=_u.near,Bu.fogFar.value=_u.far):_u.isFogExp2&&(Bu.fogDensity.value=_u.density)}function au(Bu,_u,Lu,Du,Ou){_u.isMeshBasicMaterial||_u.isMeshLambertMaterial?uu(Bu,_u):_u.isMeshToonMaterial?(uu(Bu,_u),vu(Bu,_u)):_u.isMeshPhongMaterial?(uu(Bu,_u),xu(Bu,_u)):_u.isMeshStandardMaterial?(uu(Bu,_u),Su(Bu,_u),_u.isMeshPhysicalMaterial&&Iu(Bu,_u,Ou)):_u.isMeshMatcapMaterial?(uu(Bu,_u),Mu(Bu,_u)):_u.isMeshDepthMaterial?uu(Bu,_u):_u.isMeshDistanceMaterial?(uu(Bu,_u),ku(Bu,_u)):_u.isMeshNormalMaterial?uu(Bu,_u):_u.isLineBasicMaterial?(du(Bu,_u),_u.isLineDashedMaterial&&fu(Bu,_u)):_u.isPointsMaterial?gu(Bu,_u,Lu,Du):_u.isSpriteMaterial?yu(Bu,_u):_u.isShadowMaterial?(Bu.color.value.copy(_u.color),Bu.opacity.value=_u.opacity):_u.isShaderMaterial&&(_u.uniformsNeedUpdate=!1)}function uu(Bu,_u){Bu.opacity.value=_u.opacity,_u.color&&Bu.diffuse.value.copy(_u.color),_u.emissive&&Bu.emissive.value.copy(_u.emissive).multiplyScalar(_u.emissiveIntensity),_u.map&&(Bu.map.value=_u.map,tu(_u.map,Bu.mapTransform)),_u.alphaMap&&(Bu.alphaMap.value=_u.alphaMap,tu(_u.alphaMap,Bu.alphaMapTransform)),_u.bumpMap&&(Bu.bumpMap.value=_u.bumpMap,tu(_u.bumpMap,Bu.bumpMapTransform),Bu.bumpScale.value=_u.bumpScale,_u.side===BackSide&&(Bu.bumpScale.value*=-1)),_u.normalMap&&(Bu.normalMap.value=_u.normalMap,tu(_u.normalMap,Bu.normalMapTransform),Bu.normalScale.value.copy(_u.normalScale),_u.side===BackSide&&Bu.normalScale.value.negate()),_u.displacementMap&&(Bu.displacementMap.value=_u.displacementMap,tu(_u.displacementMap,Bu.displacementMapTransform),Bu.displacementScale.value=_u.displacementScale,Bu.displacementBias.value=_u.displacementBias),_u.emissiveMap&&(Bu.emissiveMap.value=_u.emissiveMap,tu(_u.emissiveMap,Bu.emissiveMapTransform)),_u.specularMap&&(Bu.specularMap.value=_u.specularMap,tu(_u.specularMap,Bu.specularMapTransform)),_u.alphaTest>0&&(Bu.alphaTest.value=_u.alphaTest);const Lu=eu.get(_u),Du=Lu.envMap,Ou=Lu.envMapRotation;Du&&(Bu.envMap.value=Du,_e1.copy(Ou),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,Du.isCubeTexture&&Du.isRenderTargetTexture===!1&&(_e1.y*=-1,_e1.z*=-1),Bu.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),Bu.flipEnvMap.value=Du.isCubeTexture&&Du.isRenderTargetTexture===!1?-1:1,Bu.reflectivity.value=_u.reflectivity,Bu.ior.value=_u.ior,Bu.refractionRatio.value=_u.refractionRatio),_u.lightMap&&(Bu.lightMap.value=_u.lightMap,Bu.lightMapIntensity.value=_u.lightMapIntensity,tu(_u.lightMap,Bu.lightMapTransform)),_u.aoMap&&(Bu.aoMap.value=_u.aoMap,Bu.aoMapIntensity.value=_u.aoMapIntensity,tu(_u.aoMap,Bu.aoMapTransform))}function du(Bu,_u){Bu.diffuse.value.copy(_u.color),Bu.opacity.value=_u.opacity,_u.map&&(Bu.map.value=_u.map,tu(_u.map,Bu.mapTransform))}function fu(Bu,_u){Bu.dashSize.value=_u.dashSize,Bu.totalSize.value=_u.dashSize+_u.gapSize,Bu.scale.value=_u.scale}function gu(Bu,_u,Lu,Du){Bu.diffuse.value.copy(_u.color),Bu.opacity.value=_u.opacity,Bu.size.value=_u.size*Lu,Bu.scale.value=Du*.5,_u.map&&(Bu.map.value=_u.map,tu(_u.map,Bu.uvTransform)),_u.alphaMap&&(Bu.alphaMap.value=_u.alphaMap,tu(_u.alphaMap,Bu.alphaMapTransform)),_u.alphaTest>0&&(Bu.alphaTest.value=_u.alphaTest)}function yu(Bu,_u){Bu.diffuse.value.copy(_u.color),Bu.opacity.value=_u.opacity,Bu.rotation.value=_u.rotation,_u.map&&(Bu.map.value=_u.map,tu(_u.map,Bu.mapTransform)),_u.alphaMap&&(Bu.alphaMap.value=_u.alphaMap,tu(_u.alphaMap,Bu.alphaMapTransform)),_u.alphaTest>0&&(Bu.alphaTest.value=_u.alphaTest)}function xu(Bu,_u){Bu.specular.value.copy(_u.specular),Bu.shininess.value=Math.max(_u.shininess,1e-4)}function vu(Bu,_u){_u.gradientMap&&(Bu.gradientMap.value=_u.gradientMap)}function Su(Bu,_u){Bu.metalness.value=_u.metalness,_u.metalnessMap&&(Bu.metalnessMap.value=_u.metalnessMap,tu(_u.metalnessMap,Bu.metalnessMapTransform)),Bu.roughness.value=_u.roughness,_u.roughnessMap&&(Bu.roughnessMap.value=_u.roughnessMap,tu(_u.roughnessMap,Bu.roughnessMapTransform)),_u.envMap&&(Bu.envMapIntensity.value=_u.envMapIntensity)}function Iu(Bu,_u,Lu){Bu.ior.value=_u.ior,_u.sheen>0&&(Bu.sheenColor.value.copy(_u.sheenColor).multiplyScalar(_u.sheen),Bu.sheenRoughness.value=_u.sheenRoughness,_u.sheenColorMap&&(Bu.sheenColorMap.value=_u.sheenColorMap,tu(_u.sheenColorMap,Bu.sheenColorMapTransform)),_u.sheenRoughnessMap&&(Bu.sheenRoughnessMap.value=_u.sheenRoughnessMap,tu(_u.sheenRoughnessMap,Bu.sheenRoughnessMapTransform))),_u.clearcoat>0&&(Bu.clearcoat.value=_u.clearcoat,Bu.clearcoatRoughness.value=_u.clearcoatRoughness,_u.clearcoatMap&&(Bu.clearcoatMap.value=_u.clearcoatMap,tu(_u.clearcoatMap,Bu.clearcoatMapTransform)),_u.clearcoatRoughnessMap&&(Bu.clearcoatRoughnessMap.value=_u.clearcoatRoughnessMap,tu(_u.clearcoatRoughnessMap,Bu.clearcoatRoughnessMapTransform)),_u.clearcoatNormalMap&&(Bu.clearcoatNormalMap.value=_u.clearcoatNormalMap,tu(_u.clearcoatNormalMap,Bu.clearcoatNormalMapTransform),Bu.clearcoatNormalScale.value.copy(_u.clearcoatNormalScale),_u.side===BackSide&&Bu.clearcoatNormalScale.value.negate())),_u.dispersion>0&&(Bu.dispersion.value=_u.dispersion),_u.iridescence>0&&(Bu.iridescence.value=_u.iridescence,Bu.iridescenceIOR.value=_u.iridescenceIOR,Bu.iridescenceThicknessMinimum.value=_u.iridescenceThicknessRange[0],Bu.iridescenceThicknessMaximum.value=_u.iridescenceThicknessRange[1],_u.iridescenceMap&&(Bu.iridescenceMap.value=_u.iridescenceMap,tu(_u.iridescenceMap,Bu.iridescenceMapTransform)),_u.iridescenceThicknessMap&&(Bu.iridescenceThicknessMap.value=_u.iridescenceThicknessMap,tu(_u.iridescenceThicknessMap,Bu.iridescenceThicknessMapTransform))),_u.transmission>0&&(Bu.transmission.value=_u.transmission,Bu.transmissionSamplerMap.value=Lu.texture,Bu.transmissionSamplerSize.value.set(Lu.width,Lu.height),_u.transmissionMap&&(Bu.transmissionMap.value=_u.transmissionMap,tu(_u.transmissionMap,Bu.transmissionMapTransform)),Bu.thickness.value=_u.thickness,_u.thicknessMap&&(Bu.thicknessMap.value=_u.thicknessMap,tu(_u.thicknessMap,Bu.thicknessMapTransform)),Bu.attenuationDistance.value=_u.attenuationDistance,Bu.attenuationColor.value.copy(_u.attenuationColor)),_u.anisotropy>0&&(Bu.anisotropyVector.value.set(_u.anisotropy*Math.cos(_u.anisotropyRotation),_u.anisotropy*Math.sin(_u.anisotropyRotation)),_u.anisotropyMap&&(Bu.anisotropyMap.value=_u.anisotropyMap,tu(_u.anisotropyMap,Bu.anisotropyMapTransform))),Bu.specularIntensity.value=_u.specularIntensity,Bu.specularColor.value.copy(_u.specularColor),_u.specularColorMap&&(Bu.specularColorMap.value=_u.specularColorMap,tu(_u.specularColorMap,Bu.specularColorMapTransform)),_u.specularIntensityMap&&(Bu.specularIntensityMap.value=_u.specularIntensityMap,tu(_u.specularIntensityMap,Bu.specularIntensityMapTransform))}function Mu(Bu,_u){_u.matcap&&(Bu.matcap.value=_u.matcap)}function ku(Bu,_u){const Lu=eu.get(_u).light;Bu.referencePosition.value.setFromMatrixPosition(Lu.matrixWorld),Bu.nearDistance.value=Lu.shadow.camera.near,Bu.farDistance.value=Lu.shadow.camera.far}return{refreshFogUniforms:su,refreshMaterialUniforms:au}}function WebGLUniformsGroups(iu,eu,tu,su){let au={},uu={},du=[];const fu=iu.getParameter(iu.MAX_UNIFORM_BUFFER_BINDINGS);function gu(Lu,Du){const Ou=Du.program;su.uniformBlockBinding(Lu,Ou)}function yu(Lu,Du){let Ou=au[Lu.id];Ou===void 0&&(Mu(Lu),Ou=xu(Lu),au[Lu.id]=Ou,Lu.addEventListener("dispose",Bu));const Wu=Du.program;su.updateUBOMapping(Lu,Wu);const Zu=eu.render.frame;uu[Lu.id]!==Zu&&(Su(Lu),uu[Lu.id]=Zu)}function xu(Lu){const Du=vu();Lu.__bindingPointIndex=Du;const Ou=iu.createBuffer(),Wu=Lu.__size,Zu=Lu.usage;return iu.bindBuffer(iu.UNIFORM_BUFFER,Ou),iu.bufferData(iu.UNIFORM_BUFFER,Wu,Zu),iu.bindBuffer(iu.UNIFORM_BUFFER,null),iu.bindBufferBase(iu.UNIFORM_BUFFER,Du,Ou),Ou}function vu(){for(let Lu=0;Lu<fu;Lu++)if(du.indexOf(Lu)===-1)return du.push(Lu),Lu;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function Su(Lu){const Du=au[Lu.id],Ou=Lu.uniforms,Wu=Lu.__cache;iu.bindBuffer(iu.UNIFORM_BUFFER,Du);for(let Zu=0,Hu=Ou.length;Zu<Hu;Zu++){const Yu=Array.isArray(Ou[Zu])?Ou[Zu]:[Ou[Zu]];for(let Ku=0,ju=Yu.length;Ku<ju;Ku++){const tp=Yu[Ku];if(Iu(tp,Zu,Ku,Wu)===!0){const gp=tp.__offset,yp=Array.isArray(tp.value)?tp.value:[tp.value];let Cp=0;for(let Hp=0;Hp<yp.length;Hp++){const wp=yp[Hp],Dp=ku(wp);typeof wp=="number"||typeof wp=="boolean"?(tp.__data[0]=wp,iu.bufferSubData(iu.UNIFORM_BUFFER,gp+Cp,tp.__data)):wp.isMatrix3?(tp.__data[0]=wp.elements[0],tp.__data[1]=wp.elements[1],tp.__data[2]=wp.elements[2],tp.__data[3]=0,tp.__data[4]=wp.elements[3],tp.__data[5]=wp.elements[4],tp.__data[6]=wp.elements[5],tp.__data[7]=0,tp.__data[8]=wp.elements[6],tp.__data[9]=wp.elements[7],tp.__data[10]=wp.elements[8],tp.__data[11]=0):(wp.toArray(tp.__data,Cp),Cp+=Dp.storage/Float32Array.BYTES_PER_ELEMENT)}iu.bufferSubData(iu.UNIFORM_BUFFER,gp,tp.__data)}}}iu.bindBuffer(iu.UNIFORM_BUFFER,null)}function Iu(Lu,Du,Ou,Wu){const Zu=Lu.value,Hu=Du+"_"+Ou;if(Wu[Hu]===void 0)return typeof Zu=="number"||typeof Zu=="boolean"?Wu[Hu]=Zu:Wu[Hu]=Zu.clone(),!0;{const Yu=Wu[Hu];if(typeof Zu=="number"||typeof Zu=="boolean"){if(Yu!==Zu)return Wu[Hu]=Zu,!0}else if(Yu.equals(Zu)===!1)return Yu.copy(Zu),!0}return!1}function Mu(Lu){const Du=Lu.uniforms;let Ou=0;const Wu=16;for(let Hu=0,Yu=Du.length;Hu<Yu;Hu++){const Ku=Array.isArray(Du[Hu])?Du[Hu]:[Du[Hu]];for(let ju=0,tp=Ku.length;ju<tp;ju++){const gp=Ku[ju],yp=Array.isArray(gp.value)?gp.value:[gp.value];for(let Cp=0,Hp=yp.length;Cp<Hp;Cp++){const wp=yp[Cp],Dp=ku(wp),dp=Ou%Wu,Rp=dp%Dp.boundary,xp=dp+Rp;Ou+=Rp,xp!==0&&Wu-xp<Dp.storage&&(Ou+=Wu-xp),gp.__data=new Float32Array(Dp.storage/Float32Array.BYTES_PER_ELEMENT),gp.__offset=Ou,Ou+=Dp.storage}}}const Zu=Ou%Wu;return Zu>0&&(Ou+=Wu-Zu),Lu.__size=Ou,Lu.__cache={},this}function ku(Lu){const Du={boundary:0,storage:0};return typeof Lu=="number"||typeof Lu=="boolean"?(Du.boundary=4,Du.storage=4):Lu.isVector2?(Du.boundary=8,Du.storage=8):Lu.isVector3||Lu.isColor?(Du.boundary=16,Du.storage=12):Lu.isVector4?(Du.boundary=16,Du.storage=16):Lu.isMatrix3?(Du.boundary=48,Du.storage=48):Lu.isMatrix4?(Du.boundary=64,Du.storage=64):Lu.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",Lu),Du}function Bu(Lu){const Du=Lu.target;Du.removeEventListener("dispose",Bu);const Ou=du.indexOf(Du.__bindingPointIndex);du.splice(Ou,1),iu.deleteBuffer(au[Du.id]),delete au[Du.id],delete uu[Du.id]}function _u(){for(const Lu in au)iu.deleteBuffer(au[Lu]);du=[],au={},uu={}}return{bind:gu,update:yu,dispose:_u}}class WebGLRenderer{constructor(eu={}){const{canvas:tu=createCanvasElement(),context:su=null,depth:au=!0,stencil:uu=!1,alpha:du=!1,antialias:fu=!1,premultipliedAlpha:gu=!0,preserveDrawingBuffer:yu=!1,powerPreference:xu="default",failIfMajorPerformanceCaveat:vu=!1,reverseDepthBuffer:Su=!1,multiviewStereo:Iu=!1}=eu;this.isWebGLRenderer=!0;let Mu;if(su!==null){if(typeof WebGLRenderingContext<"u"&&su instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");Mu=su.getContextAttributes().alpha}else Mu=du;const ku=new Uint32Array(4),Bu=new Int32Array(4);let _u=null,Lu=null;const Du=[],Ou=[];this.domElement=tu,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=SRGBColorSpace,this.toneMapping=NoToneMapping,this.toneMappingExposure=1;const Wu=this;let Zu=!1,Hu=0,Yu=0,Ku=null,ju=-1,tp=null;const gp=new Vector4,yp=new Vector4;let Cp=null;const Hp=new Color(0);let wp=0,Dp=tu.width,dp=tu.height,Rp=1,xp=null,cm=null;const lm=new Vector4(0,0,Dp,dp),vp=new Vector4(0,0,Dp,dp);let bp=!1;const kp=new Frustum;let dm=!1,nm=!1;this.transmissionResolutionScale=1;const Bp=new Matrix4,Qp=new Matrix4,Xp=new Vector3,sm=new Vector4,$p={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let _f=!1;function rm(){return Ku===null?Rp:1}let lp=su;function cp(np,Np){return tu.getContext(np,Np)}try{const np={alpha:!0,depth:au,stencil:uu,antialias:fu,premultipliedAlpha:gu,preserveDrawingBuffer:yu,powerPreference:xu,failIfMajorPerformanceCaveat:vu};if("setAttribute"in tu&&tu.setAttribute("data-engine",`three.js r${REVISION}`),tu.addEventListener("webglcontextlost",Lm,!1),tu.addEventListener("webglcontextrestored",Ym,!1),tu.addEventListener("webglcontextcreationerror",Rm,!1),lp===null){const Np="webgl2";if(lp=cp(Np,np),lp===null)throw cp(Np)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(np){throw console.error("THREE.WebGLRenderer: "+np.message),np}let mm,$u,Vu,_h,ap,mp,Lp,Kp,vm,sp,_d,Sp,tm,qu,Uu,zu,ep,up,Mp,Ip,fm,Gm,pp,Zp,om;function Mm(){mm=new WebGLExtensions(lp),mm.init(),pp=new WebGLUtils(lp,mm),$u=new WebGLCapabilities(lp,mm,eu,pp),Vu=new WebGLState(lp,mm),$u.reverseDepthBuffer&&Su&&Vu.buffers.depth.setReversed(!0),_h=new WebGLInfo(lp),ap=new WebGLProperties,mp=new WebGLTextures(lp,mm,Vu,ap,$u,pp,_h),Lp=new WebGLCubeMaps(Wu),Kp=new WebGLCubeUVMaps(Wu),vm=new WebGLAttributes(lp),Zp=new WebGLBindingStates(lp,vm),sp=new WebGLGeometries(lp,vm,_h,Zp),_d=new WebGLObjects(lp,sp,vm,_h),Ip=new WebGLMorphtargets(lp,$u,mp),zu=new WebGLClipping(ap),Sp=new WebGLPrograms(Wu,Lp,Kp,mm,$u,Zp,zu),tm=new WebGLMaterials(Wu,ap),qu=new WebGLRenderLists,Uu=new WebGLRenderStates(mm),Mp=new WebGLBackground(Wu,Lp,Kp,Vu,_d,Mu,gu),up=new WebGLMultiview(Wu,mm,lp),ep=new WebGLShadowMap(Wu,_d,$u),om=new WebGLUniformsGroups(lp,_h,$u,Vu),fm=new WebGLBufferRenderer(lp,mm,_h),Gm=new WebGLIndexedBufferRenderer(lp,mm,_h),_h.programs=Sp.programs,Wu.capabilities=$u,Wu.extensions=mm,Wu.properties=ap,Wu.renderLists=qu,Wu.shadowMap=ep,Wu.state=Vu,Wu.info=_h}Mm();const Tm=new WebXRManager(Wu,lp);this.xr=Tm,this.getContext=function(){return lp},this.getContextAttributes=function(){return lp.getContextAttributes()},this.forceContextLoss=function(){const np=mm.get("WEBGL_lose_context");np&&np.loseContext()},this.forceContextRestore=function(){const np=mm.get("WEBGL_lose_context");np&&np.restoreContext()},this.getPixelRatio=function(){return Rp},this.setPixelRatio=function(np){np!==void 0&&(Rp=np,this.setSize(Dp,dp,!1))},this.getSize=function(np){return np.set(Dp,dp)},this.setSize=function(np,Np,Wp=!0){if(Tm.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}Dp=np,dp=Np,tu.width=Math.floor(np*Rp),tu.height=Math.floor(Np*Rp),Wp===!0&&(tu.style.width=np+"px",tu.style.height=Np+"px"),this.setViewport(0,0,np,Np)},this.getDrawingBufferSize=function(np){return np.set(Dp*Rp,dp*Rp).floor()},this.setDrawingBufferSize=function(np,Np,Wp){Dp=np,dp=Np,Rp=Wp,tu.width=Math.floor(np*Wp),tu.height=Math.floor(Np*Wp),this.setViewport(0,0,np,Np)},this.getCurrentViewport=function(np){return np.copy(gp)},this.getViewport=function(np){return np.copy(lm)},this.setViewport=function(np,Np,Wp,jp){np.isVector4?lm.set(np.x,np.y,np.z,np.w):lm.set(np,Np,Wp,jp),Vu.viewport(gp.copy(lm).multiplyScalar(Rp).round())},this.getScissor=function(np){return np.copy(vp)},this.setScissor=function(np,Np,Wp,jp){np.isVector4?vp.set(np.x,np.y,np.z,np.w):vp.set(np,Np,Wp,jp),Vu.scissor(yp.copy(vp).multiplyScalar(Rp).round())},this.getScissorTest=function(){return bp},this.setScissorTest=function(np){Vu.setScissorTest(bp=np)},this.setOpaqueSort=function(np){xp=np},this.setTransparentSort=function(np){cm=np},this.getClearColor=function(np){return np.copy(Mp.getClearColor())},this.setClearColor=function(){Mp.setClearColor.apply(Mp,arguments)},this.getClearAlpha=function(){return Mp.getClearAlpha()},this.setClearAlpha=function(){Mp.setClearAlpha.apply(Mp,arguments)},this.clear=function(np=!0,Np=!0,Wp=!0){let jp=0;if(np){let Gp=!1;if(Ku!==null){const gm=Ku.texture.format;Gp=gm===RGBAIntegerFormat||gm===RGIntegerFormat||gm===RedIntegerFormat}if(Gp){const gm=Ku.texture.type,_m=gm===UnsignedByteType||gm===UnsignedIntType||gm===UnsignedShortType||gm===UnsignedInt248Type||gm===UnsignedShort4444Type||gm===UnsignedShort5551Type,Nm=Mp.getClearColor(),Dm=Mp.getClearAlpha(),Km=Nm.r,Zm=Nm.g,Vm=Nm.b;_m?(ku[0]=Km,ku[1]=Zm,ku[2]=Vm,ku[3]=Dm,lp.clearBufferuiv(lp.COLOR,0,ku)):(Bu[0]=Km,Bu[1]=Zm,Bu[2]=Vm,Bu[3]=Dm,lp.clearBufferiv(lp.COLOR,0,Bu))}else jp|=lp.COLOR_BUFFER_BIT}Np&&(jp|=lp.DEPTH_BUFFER_BIT),Wp&&(jp|=lp.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),lp.clear(jp)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){tu.removeEventListener("webglcontextlost",Lm,!1),tu.removeEventListener("webglcontextrestored",Ym,!1),tu.removeEventListener("webglcontextcreationerror",Rm,!1),Mp.dispose(),qu.dispose(),Uu.dispose(),ap.dispose(),Lp.dispose(),Kp.dispose(),_d.dispose(),Zp.dispose(),om.dispose(),Sp.dispose(),Tm.dispose(),Tm.removeEventListener("sessionstart",zv),Tm.removeEventListener("sessionend",N1),tx.stop()};function Lm(np){np.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),Zu=!0}function Ym(){console.log("THREE.WebGLRenderer: Context Restored."),Zu=!1;const np=_h.autoReset,Np=ep.enabled,Wp=ep.autoUpdate,jp=ep.needsUpdate,Gp=ep.type;Mm(),_h.autoReset=np,ep.enabled=Np,ep.autoUpdate=Wp,ep.needsUpdate=jp,ep.type=Gp}function Rm(np){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",np.statusMessage)}function Sm(np){const Np=np.target;Np.removeEventListener("dispose",Sm),Fm(Np)}function Fm(np){i0(np),ap.remove(np)}function i0(np){const Np=ap.get(np).programs;Np!==void 0&&(Np.forEach(function(Wp){Sp.releaseProgram(Wp)}),np.isShaderMaterial&&Sp.releaseShaderCache(np))}this.renderBufferDirect=function(np,Np,Wp,jp,Gp,gm){Np===null&&(Np=$p);const _m=Gp.isMesh&&Gp.matrixWorld.determinant()<0,Nm=CC(np,Np,Wp,jp,Gp);Vu.setMaterial(jp,_m);let Dm=Wp.index,Km=1;if(jp.wireframe===!0){if(Dm=sp.getWireframeAttribute(Wp),Dm===void 0)return;Km=2}const Zm=Wp.drawRange,Vm=Wp.attributes.position;let r0=Zm.start*Km,h0=(Zm.start+Zm.count)*Km;gm!==null&&(r0=Math.max(r0,gm.start*Km),h0=Math.min(h0,(gm.start+gm.count)*Km)),Dm!==null?(r0=Math.max(r0,0),h0=Math.min(h0,Dm.count)):Vm!=null&&(r0=Math.max(r0,0),h0=Math.min(h0,Vm.count));const P0=h0-r0;if(P0<0||P0===1/0)return;Zp.setup(Gp,jp,Nm,Wp,Dm);let N0,s0=fm;if(Dm!==null&&(N0=vm.get(Dm),s0=Gm,s0.setIndex(N0)),Gp.isMesh)jp.wireframe===!0?(Vu.setLineWidth(jp.wireframeLinewidth*rm()),s0.setMode(lp.LINES)):s0.setMode(lp.TRIANGLES);else if(Gp.isLine){let z0=jp.linewidth;z0===void 0&&(z0=1),Vu.setLineWidth(z0*rm()),Gp.isLineSegments?s0.setMode(lp.LINES):Gp.isLineLoop?s0.setMode(lp.LINE_LOOP):s0.setMode(lp.LINE_STRIP)}else Gp.isPoints?s0.setMode(lp.POINTS):Gp.isSprite&&s0.setMode(lp.TRIANGLES);if(Gp.isBatchedMesh)if(Gp._multiDrawInstances!==null)s0.renderMultiDrawInstances(Gp._multiDrawStarts,Gp._multiDrawCounts,Gp._multiDrawCount,Gp._multiDrawInstances);else if(mm.get("WEBGL_multi_draw"))s0.renderMultiDraw(Gp._multiDrawStarts,Gp._multiDrawCounts,Gp._multiDrawCount);else{const z0=Gp._multiDrawStarts,Um=Gp._multiDrawCounts,Nx=Gp._multiDrawCount,d0=Dm?vm.get(Dm).bytesPerElement:1,cy=ap.get(jp).currentProgram.getUniforms();for(let yy=0;yy<Nx;yy++)cy.setValue(lp,"_gl_DrawID",yy),s0.render(z0[yy]/d0,Um[yy])}else if(Gp.isInstancedMesh)s0.renderInstances(r0,P0,Gp.count);else if(Wp.isInstancedBufferGeometry){const z0=Wp._maxInstanceCount!==void 0?Wp._maxInstanceCount:1/0,Um=Math.min(Wp.instanceCount,z0);s0.renderInstances(r0,P0,Um)}else s0.render(r0,P0)};function $0(np,Np,Wp){np.transparent===!0&&np.side===DoubleSide&&np.forceSinglePass===!1?(np.side=BackSide,np.needsUpdate=!0,gv(np,Np,Wp),np.side=FrontSide,np.needsUpdate=!0,gv(np,Np,Wp),np.side=DoubleSide):gv(np,Np,Wp)}this.compile=function(np,Np,Wp=null){Wp===null&&(Wp=np),Lu=Uu.get(Wp),Lu.init(Np),Ou.push(Lu),Wp.traverseVisible(function(Gp){Gp.isLight&&Gp.layers.test(Np.layers)&&(Lu.pushLight(Gp),Gp.castShadow&&Lu.pushShadow(Gp))}),np!==Wp&&np.traverseVisible(function(Gp){Gp.isLight&&Gp.layers.test(Np.layers)&&(Lu.pushLight(Gp),Gp.castShadow&&Lu.pushShadow(Gp))}),Lu.setupLights();const jp=new Set;return np.traverse(function(Gp){if(!(Gp.isMesh||Gp.isPoints||Gp.isLine||Gp.isSprite))return;const gm=Gp.material;if(gm)if(Array.isArray(gm))for(let _m=0;_m<gm.length;_m++){const Nm=gm[_m];$0(Nm,Wp,Gp),jp.add(Nm)}else $0(gm,Wp,Gp),jp.add(gm)}),Ou.pop(),Lu=null,jp},this.compileAsync=function(np,Np,Wp=null){const jp=this.compile(np,Np,Wp);return new Promise(Gp=>{function gm(){if(jp.forEach(function(_m){ap.get(_m).currentProgram.isReady()&&jp.delete(_m)}),jp.size===0){Gp(np);return}setTimeout(gm,10)}mm.get("KHR_parallel_shader_compile")!==null?gm():setTimeout(gm,10)})};let pv=null;function L1(np){pv&&pv(np)}function zv(){tx.stop()}function N1(){tx.start()}const tx=new WebGLAnimation;tx.setAnimationLoop(L1),typeof self<"u"&&tx.setContext(self),this.setAnimationLoop=function(np){pv=np,Tm.setAnimationLoop(np),np===null?tx.stop():tx.start()},Tm.addEventListener("sessionstart",zv),Tm.addEventListener("sessionend",N1),this.render=function(np,Np){if(Np!==void 0&&Np.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(Zu===!0)return;if(np.matrixWorldAutoUpdate===!0&&np.updateMatrixWorld(),Np.parent===null&&Np.matrixWorldAutoUpdate===!0&&Np.updateMatrixWorld(),Tm.enabled===!0&&Tm.isPresenting===!0&&(Tm.cameraAutoUpdate===!0&&Tm.updateCamera(Np),Np=Tm.getCamera()),np.isScene===!0&&np.onBeforeRender(Wu,np,Np,Ku),Lu=Uu.get(np,Ou.length),Lu.init(Np),Ou.push(Lu),Qp.multiplyMatrices(Np.projectionMatrix,Np.matrixWorldInverse),kp.setFromProjectionMatrix(Qp),nm=this.localClippingEnabled,dm=zu.init(this.clippingPlanes,nm),_u=qu.get(np,Du.length),_u.init(),Du.push(_u),Tm.enabled===!0&&Tm.isPresenting===!0){const gm=Wu.xr.getDepthSensingMesh();gm!==null&&fv(gm,Np,-1/0,Wu.sortObjects)}fv(np,Np,0,Wu.sortObjects),_u.finish(),Wu.sortObjects===!0&&_u.sort(xp,cm),_f=Tm.enabled===!1||Tm.isPresenting===!1||Tm.hasDepthSensing()===!1,_f&&Mp.addToRenderList(_u,np),this.info.render.frame++,dm===!0&&zu.beginShadows();const Wp=Lu.state.shadowsArray;ep.render(Wp,np,Np),dm===!0&&zu.endShadows(),this.info.autoReset===!0&&this.info.reset();const jp=_u.opaque,Gp=_u.transmissive;if(Lu.setupLights(),Np.isArrayCamera){const gm=Np.cameras;if(Gp.length>0)for(let _m=0,Nm=gm.length;_m<Nm;_m++){const Dm=gm[_m];D1(jp,Gp,np,Dm)}if(_f&&Mp.render(np),Tm.enabled&&Tm.isMultiview)mp.setDeferTextureUploads(!0),Wv(_u,np,Np,Np.cameras[0].viewport);else for(let _m=0,Nm=gm.length;_m<Nm;_m++){const Dm=gm[_m];Wv(_u,np,Dm,Dm.viewport)}}else Gp.length>0&&D1(jp,Gp,np,Np),_f&&Mp.render(np),Wv(_u,np,Np);Ku!==null&&Yu===0&&(mp.updateMultisampleRenderTarget(Ku),mp.updateRenderTargetMipmap(Ku)),np.isScene===!0&&np.onAfterRender(Wu,np,Np),Zp.resetDefaultState(),ju=-1,tp=null,Ou.pop(),Ou.length>0?(Lu=Ou[Ou.length-1],dm===!0&&zu.setGlobalState(Wu.clippingPlanes,Lu.state.camera)):Lu=null,Du.pop(),Du.length>0?_u=Du[Du.length-1]:_u=null};function fv(np,Np,Wp,jp){if(np.visible===!1)return;if(np.layers.test(Np.layers)){if(np.isGroup)Wp=np.renderOrder;else if(np.isLOD)np.autoUpdate===!0&&np.update(Np);else if(np.isLight)Lu.pushLight(np),np.castShadow&&Lu.pushShadow(np);else if(np.isSprite){if(!np.frustumCulled||kp.intersectsSprite(np)){jp&&sm.setFromMatrixPosition(np.matrixWorld).applyMatrix4(Qp);const _m=_d.update(np),Nm=np.material;Nm.visible&&_u.push(np,_m,Nm,Wp,sm.z,null)}}else if((np.isMesh||np.isLine||np.isPoints)&&(!np.frustumCulled||kp.intersectsObject(np))){const _m=_d.update(np),Nm=np.material;if(jp&&(np.boundingSphere!==void 0?(np.boundingSphere===null&&np.computeBoundingSphere(),sm.copy(np.boundingSphere.center)):(_m.boundingSphere===null&&_m.computeBoundingSphere(),sm.copy(_m.boundingSphere.center)),sm.applyMatrix4(np.matrixWorld).applyMatrix4(Qp)),Array.isArray(Nm)){const Dm=_m.groups;for(let Km=0,Zm=Dm.length;Km<Zm;Km++){const Vm=Dm[Km],r0=Nm[Vm.materialIndex];r0&&r0.visible&&_u.push(np,_m,r0,Wp,sm.z,Vm)}}else Nm.visible&&_u.push(np,_m,Nm,Wp,sm.z,null)}}const gm=np.children;for(let _m=0,Nm=gm.length;_m<Nm;_m++)fv(gm[_m],Np,Wp,jp)}function Wv(np,Np,Wp,jp){const Gp=np.opaque,gm=np.transmissive,_m=np.transparent;Lu.setupLightsView(Wp),dm===!0&&zu.setGlobalState(Wu.clippingPlanes,Wp),jp&&Vu.viewport(gp.copy(jp)),Gp.length>0&&Lx(Gp,Np,Wp),gm.length>0&&Lx(gm,Np,Wp),_m.length>0&&Lx(_m,Np,Wp),Vu.buffers.depth.setTest(!0),Vu.buffers.depth.setMask(!0),Vu.buffers.color.setMask(!0),Vu.setPolygonOffset(!1)}function D1(np,Np,Wp,jp){if((Wp.isScene===!0?Wp.overrideMaterial:null)!==null)return;Lu.state.transmissionRenderTarget[jp.id]===void 0&&(Lu.state.transmissionRenderTarget[jp.id]=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:mm.has("EXT_color_buffer_half_float")||mm.has("EXT_color_buffer_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:4,stencilBuffer:uu,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ColorManagement.workingColorSpace}));const gm=Lu.state.transmissionRenderTarget[jp.id],_m=jp.viewport||gp;gm.setSize(_m.z*Wu.transmissionResolutionScale,_m.w*Wu.transmissionResolutionScale);const Nm=Wu.getRenderTarget();Wu.setRenderTarget(gm),Wu.getClearColor(Hp),wp=Wu.getClearAlpha(),wp<1&&Wu.setClearColor(16777215,.5),Wu.clear(),_f&&Mp.render(Wp);const Dm=Wu.toneMapping;Wu.toneMapping=NoToneMapping;const Km=jp.viewport;if(jp.viewport!==void 0&&(jp.viewport=void 0),Lu.setupLightsView(jp),dm===!0&&zu.setGlobalState(Wu.clippingPlanes,jp),Lx(np,Wp,jp),mp.updateMultisampleRenderTarget(gm),mp.updateRenderTargetMipmap(gm),mm.has("WEBGL_multisampled_render_to_texture")===!1){let Zm=!1;for(let Vm=0,r0=Np.length;Vm<r0;Vm++){const h0=Np[Vm],P0=h0.object,N0=h0.geometry,s0=h0.material,z0=h0.group;if(s0.side===DoubleSide&&P0.layers.test(jp.layers)){const Um=s0.side;s0.side=BackSide,s0.needsUpdate=!0,mv(P0,Wp,jp,N0,s0,z0),s0.side=Um,s0.needsUpdate=!0,Zm=!0}}Zm===!0&&(mp.updateMultisampleRenderTarget(gm),mp.updateRenderTargetMipmap(gm))}Wu.setRenderTarget(Nm),Wu.setClearColor(Hp,wp),Km!==void 0&&(jp.viewport=Km),Wu.toneMapping=Dm}function Lx(np,Np,Wp){const jp=Np.isScene===!0?Np.overrideMaterial:null;for(let Gp=0,gm=np.length;Gp<gm;Gp++){const _m=np[Gp],Nm=_m.object,Dm=_m.geometry,Km=jp===null?_m.material:jp,Zm=_m.group;Nm.layers.test(Wp.layers)&&mv(Nm,Np,Wp,Dm,Km,Zm)}}function mv(np,Np,Wp,jp,Gp,gm){np.onBeforeRender(Wu,Np,Wp,jp,Gp,gm),np.modelViewMatrix.multiplyMatrices(Wp.matrixWorldInverse,np.matrixWorld),np.normalMatrix.getNormalMatrix(np.modelViewMatrix),Gp.onBeforeRender(Wu,Np,Wp,jp,np,gm),Gp.transparent===!0&&Gp.side===DoubleSide&&Gp.forceSinglePass===!1?(Gp.side=BackSide,Gp.needsUpdate=!0,Wu.renderBufferDirect(Wp,Np,jp,Gp,np,gm),Gp.side=FrontSide,Gp.needsUpdate=!0,Wu.renderBufferDirect(Wp,Np,jp,Gp,np,gm),Gp.side=DoubleSide):Wu.renderBufferDirect(Wp,Np,jp,Gp,np,gm),np.onAfterRender(Wu,Np,Wp,jp,Gp,gm)}function gv(np,Np,Wp){Np.isScene!==!0&&(Np=$p);const jp=ap.get(np),Gp=Lu.state.lights,gm=Lu.state.shadowsArray,_m=Gp.state.version,Nm=Sp.getParameters(np,Gp.state,gm,Np,Wp),Dm=Sp.getProgramCacheKey(Nm);let Km=jp.programs;jp.environment=np.isMeshStandardMaterial?Np.environment:null,jp.fog=Np.fog,jp.envMap=(np.isMeshStandardMaterial?Kp:Lp).get(np.envMap||jp.environment),jp.envMapRotation=jp.environment!==null&&np.envMap===null?Np.environmentRotation:np.envMapRotation,Km===void 0&&(np.addEventListener("dispose",Sm),Km=new Map,jp.programs=Km);let Zm=Km.get(Dm);if(Zm!==void 0){if(jp.currentProgram===Zm&&jp.lightsStateVersion===_m)return F1(np,Nm),Zm}else Nm.uniforms=Sp.getUniforms(np),np.onBeforeCompile(Nm,Wu),Zm=Sp.acquireProgram(Nm,Dm),Km.set(Dm,Zm),jp.uniforms=Nm.uniforms;const Vm=jp.uniforms;return(!np.isShaderMaterial&&!np.isRawShaderMaterial||np.clipping===!0)&&(Vm.clippingPlanes=zu.uniform),F1(np,Nm),jp.needsLights=P1(np),jp.lightsStateVersion=_m,jp.needsLights&&(Vm.ambientLightColor.value=Gp.state.ambient,Vm.lightProbe.value=Gp.state.probe,Vm.directionalLights.value=Gp.state.directional,Vm.directionalLightShadows.value=Gp.state.directionalShadow,Vm.spotLights.value=Gp.state.spot,Vm.spotLightShadows.value=Gp.state.spotShadow,Vm.rectAreaLights.value=Gp.state.rectArea,Vm.ltc_1.value=Gp.state.rectAreaLTC1,Vm.ltc_2.value=Gp.state.rectAreaLTC2,Vm.pointLights.value=Gp.state.point,Vm.pointLightShadows.value=Gp.state.pointShadow,Vm.hemisphereLights.value=Gp.state.hemi,Vm.directionalShadowMap.value=Gp.state.directionalShadowMap,Vm.directionalShadowMatrix.value=Gp.state.directionalShadowMatrix,Vm.spotShadowMap.value=Gp.state.spotShadowMap,Vm.spotLightMatrix.value=Gp.state.spotLightMatrix,Vm.spotLightMap.value=Gp.state.spotLightMap,Vm.pointShadowMap.value=Gp.state.pointShadowMap,Vm.pointShadowMatrix.value=Gp.state.pointShadowMatrix),jp.currentProgram=Zm,jp.uniformsList=null,Zm}function Hv(np){if(np.uniformsList===null){const Np=np.currentProgram.getUniforms();np.uniformsList=WebGLUniforms.seqWithValue(Np.seq,np.uniforms)}return np.uniformsList}function F1(np,Np){const Wp=ap.get(np);Wp.outputColorSpace=Np.outputColorSpace,Wp.batching=Np.batching,Wp.batchingColor=Np.batchingColor,Wp.instancing=Np.instancing,Wp.instancingColor=Np.instancingColor,Wp.instancingMorph=Np.instancingMorph,Wp.skinning=Np.skinning,Wp.morphTargets=Np.morphTargets,Wp.morphNormals=Np.morphNormals,Wp.morphColors=Np.morphColors,Wp.morphTargetsCount=Np.morphTargetsCount,Wp.numClippingPlanes=Np.numClippingPlanes,Wp.numIntersection=Np.numClipIntersection,Wp.vertexAlphas=Np.vertexAlphas,Wp.vertexTangents=Np.vertexTangents,Wp.toneMapping=Np.toneMapping,Wp.numMultiviewViews=Np.numMultiviewViews}function CC(np,Np,Wp,jp,Gp){Np.isScene!==!0&&(Np=$p),mp.resetTextureUnits();const gm=Np.fog,_m=jp.isMeshStandardMaterial?Np.environment:null,Nm=Ku===null?Wu.outputColorSpace:Ku.isXRRenderTarget===!0?Ku.texture.colorSpace:LinearSRGBColorSpace,Dm=(jp.isMeshStandardMaterial?Kp:Lp).get(jp.envMap||_m),Km=jp.vertexColors===!0&&!!Wp.attributes.color&&Wp.attributes.color.itemSize===4,Zm=!!Wp.attributes.tangent&&(!!jp.normalMap||jp.anisotropy>0),Vm=!!Wp.morphAttributes.position,r0=!!Wp.morphAttributes.normal,h0=!!Wp.morphAttributes.color;let P0=NoToneMapping;jp.toneMapped&&(Ku===null||Ku.isXRRenderTarget===!0)&&(P0=Wu.toneMapping);const N0=Ku&&Ku.isWebGLMultiviewRenderTarget?Ku.numViews:0,s0=Wp.morphAttributes.position||Wp.morphAttributes.normal||Wp.morphAttributes.color,z0=s0!==void 0?s0.length:0,Um=ap.get(jp),Nx=Lu.state.lights;if(dm===!0&&(nm===!0||np!==tp)){const _0=np===tp&&jp.id===ju;zu.setState(jp,np,_0)}let d0=!1;jp.version===Um.__version?(Um.needsLights&&Um.lightsStateVersion!==Nx.state.version||Um.outputColorSpace!==Nm||Gp.isBatchedMesh&&Um.batching===!1||!Gp.isBatchedMesh&&Um.batching===!0||Gp.isBatchedMesh&&Um.batchingColor===!0&&Gp.colorTexture===null||Gp.isBatchedMesh&&Um.batchingColor===!1&&Gp.colorTexture!==null||Gp.isInstancedMesh&&Um.instancing===!1||!Gp.isInstancedMesh&&Um.instancing===!0||Gp.isSkinnedMesh&&Um.skinning===!1||!Gp.isSkinnedMesh&&Um.skinning===!0||Gp.isInstancedMesh&&Um.instancingColor===!0&&Gp.instanceColor===null||Gp.isInstancedMesh&&Um.instancingColor===!1&&Gp.instanceColor!==null||Gp.isInstancedMesh&&Um.instancingMorph===!0&&Gp.morphTexture===null||Gp.isInstancedMesh&&Um.instancingMorph===!1&&Gp.morphTexture!==null||Um.envMap!==Dm||jp.fog===!0&&Um.fog!==gm||Um.numClippingPlanes!==void 0&&(Um.numClippingPlanes!==zu.numPlanes||Um.numIntersection!==zu.numIntersection)||Um.vertexAlphas!==Km||Um.vertexTangents!==Zm||Um.morphTargets!==Vm||Um.morphNormals!==r0||Um.morphColors!==h0||Um.toneMapping!==P0||Um.morphTargetsCount!==z0||Um.numMultiviewViews!==N0)&&(d0=!0):(d0=!0,Um.__version=jp.version);let cy=Um.currentProgram;d0===!0&&(cy=gv(jp,Np,Gp));let yy=!1,Hy=!1,Dx=!1;const m0=cy.getUniforms(),V0=Um.uniforms;if(Vu.useProgram(cy.program)&&(yy=!0,Hy=!0,Dx=!0),jp.id!==ju&&(ju=jp.id,Hy=!0),yy||tp!==np){cy.numMultiviewViews>0?(up.updateCameraProjectionMatricesUniform(np,m0),up.updateCameraViewMatricesUniform(np,m0)):(Vu.buffers.depth.getReversed()?(Bp.copy(np.projectionMatrix),toNormalizedProjectionMatrix(Bp),toReversedProjectionMatrix(Bp),m0.setValue(lp,"projectionMatrix",Bp)):m0.setValue(lp,"projectionMatrix",np.projectionMatrix),m0.setValue(lp,"viewMatrix",np.matrixWorldInverse));const _0=m0.map.cameraPosition;_0!==void 0&&_0.setValue(lp,Xp.setFromMatrixPosition(np.matrixWorld)),$u.logarithmicDepthBuffer&&m0.setValue(lp,"logDepthBufFC",2/(Math.log(np.far+1)/Math.LN2)),(jp.isMeshPhongMaterial||jp.isMeshToonMaterial||jp.isMeshLambertMaterial||jp.isMeshBasicMaterial||jp.isMeshStandardMaterial||jp.isShaderMaterial)&&m0.setValue(lp,"isOrthographic",np.isOrthographicCamera===!0),tp!==np&&(tp=np,Hy=!0,Dx=!0)}if(Gp.isSkinnedMesh){m0.setOptional(lp,Gp,"bindMatrix"),m0.setOptional(lp,Gp,"bindMatrixInverse");const _0=Gp.skeleton;_0&&(_0.boneTexture===null&&_0.computeBoneTexture(),m0.setValue(lp,"boneTexture",_0.boneTexture,mp))}Gp.isBatchedMesh&&(m0.setOptional(lp,Gp,"batchingTexture"),m0.setValue(lp,"batchingTexture",Gp._matricesTexture,mp),m0.setOptional(lp,Gp,"batchingIdTexture"),m0.setValue(lp,"batchingIdTexture",Gp._indirectTexture,mp),m0.setOptional(lp,Gp,"batchingColorTexture"),Gp._colorsTexture!==null&&m0.setValue(lp,"batchingColorTexture",Gp._colorsTexture,mp));const Py=Wp.morphAttributes;if((Py.position!==void 0||Py.normal!==void 0||Py.color!==void 0)&&Ip.update(Gp,Wp,cy),(Hy||Um.receiveShadow!==Gp.receiveShadow)&&(Um.receiveShadow=Gp.receiveShadow,m0.setValue(lp,"receiveShadow",Gp.receiveShadow)),jp.isMeshGouraudMaterial&&jp.envMap!==null&&(V0.envMap.value=Dm,V0.flipEnvMap.value=Dm.isCubeTexture&&Dm.isRenderTargetTexture===!1?-1:1),jp.isMeshStandardMaterial&&jp.envMap===null&&Np.environment!==null&&(V0.envMapIntensity.value=Np.environmentIntensity),Hy&&(m0.setValue(lp,"toneMappingExposure",Wu.toneMappingExposure),Um.needsLights&&wC(V0,Dx),gm&&jp.fog===!0&&tm.refreshFogUniforms(V0,gm),tm.refreshMaterialUniforms(V0,jp,Rp,dp,Lu.state.transmissionRenderTarget[np.id]),WebGLUniforms.upload(lp,Hv(Um),V0,mp)),jp.isShaderMaterial&&jp.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(lp,Hv(Um),V0,mp),jp.uniformsNeedUpdate=!1),jp.isSpriteMaterial&&m0.setValue(lp,"center",Gp.center),cy.numMultiviewViews>0?up.updateObjectMatricesUniforms(Gp,np,m0):(m0.setValue(lp,"modelViewMatrix",Gp.modelViewMatrix),m0.setValue(lp,"normalMatrix",Gp.normalMatrix)),m0.setValue(lp,"modelMatrix",Gp.matrixWorld),jp.isShaderMaterial||jp.isRawShaderMaterial){const _0=jp.uniformsGroups;for(let Ax=0,yx=_0.length;Ax<yx;Ax++){const Xv=_0[Ax];om.update(Xv,cy),om.bind(Xv,cy)}}return cy}function wC(np,Np){np.ambientLightColor.needsUpdate=Np,np.lightProbe.needsUpdate=Np,np.directionalLights.needsUpdate=Np,np.directionalLightShadows.needsUpdate=Np,np.pointLights.needsUpdate=Np,np.pointLightShadows.needsUpdate=Np,np.spotLights.needsUpdate=Np,np.spotLightShadows.needsUpdate=Np,np.rectAreaLights.needsUpdate=Np,np.hemisphereLights.needsUpdate=Np}function P1(np){return np.isMeshLambertMaterial||np.isMeshToonMaterial||np.isMeshPhongMaterial||np.isMeshStandardMaterial||np.isShadowMaterial||np.isShaderMaterial&&np.lights===!0}this.setTexture2D=function(){var np=!1;return function(Wp,jp){Wp&&Wp.isWebGLRenderTarget&&(np||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),np=!0),Wp=Wp.texture),mp.setTexture2D(Wp,jp)}}(),this.getActiveCubeFace=function(){return Hu},this.getActiveMipmapLevel=function(){return Yu},this.getRenderTarget=function(){return Ku},this.setRenderTargetTextures=function(np,Np,Wp){ap.get(np.texture).__webglTexture=Np,ap.get(np.depthTexture).__webglTexture=Wp;const jp=ap.get(np);jp.__hasExternalTextures=!0,jp.__autoAllocateDepthBuffer=Wp===void 0,!jp.__autoAllocateDepthBuffer&&(!Ku||!Ku.isWebGLMultiviewRenderTarget)&&mm.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),jp.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(np,Np){const Wp=ap.get(np);Wp.__webglFramebuffer=Np,Wp.__useDefaultFramebuffer=Np===void 0};const EC=lp.createFramebuffer();this.setRenderTarget=function(np,Np=0,Wp=0){np===null&&this.xr.isPresenting&&(np=this.xr.getRenderTarget()),Ku=np,Hu=Np,Yu=Wp;let jp=!0,Gp=null,gm=!1,_m=!1;if(np){const Dm=ap.get(np);if(Dm.__useDefaultFramebuffer!==void 0)Vu.bindFramebuffer(lp.FRAMEBUFFER,null),jp=!1;else if(Dm.__webglFramebuffer===void 0)mp.setupRenderTarget(np);else if(Dm.__hasExternalTextures)mp.rebindTextures(np,ap.get(np.texture).__webglTexture,ap.get(np.depthTexture).__webglTexture);else if(np.depthBuffer){const Vm=np.depthTexture;if(Dm.__boundDepthTexture!==Vm){if(Vm!==null&&ap.has(Vm)&&(np.width!==Vm.image.width||np.height!==Vm.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");mp.setupDepthRenderbuffer(np)}}const Km=np.texture;(Km.isData3DTexture||Km.isDataArrayTexture||Km.isCompressedArrayTexture)&&(_m=!0);const Zm=ap.get(np).__webglFramebuffer;np.isWebGLCubeRenderTarget?(Array.isArray(Zm[Np])?Gp=Zm[Np][Wp]:Gp=Zm[Np],gm=!0):np.samples>0&&mp.useMultisampledRTT(np)===!1?Gp=ap.get(np).__webglMultisampledFramebuffer:Array.isArray(Zm)?Gp=Zm[Wp]:Gp=Zm,gp.copy(np.viewport),yp.copy(np.scissor),Cp=np.scissorTest}else gp.copy(lm).multiplyScalar(Rp).floor(),yp.copy(vp).multiplyScalar(Rp).floor(),Cp=bp;if(Wp!==0&&(Gp=EC),Vu.bindFramebuffer(lp.FRAMEBUFFER,Gp)&&jp&&Vu.drawBuffers(np,Gp),Vu.viewport(gp),Vu.scissor(yp),Vu.setScissorTest(Cp),gm){const Dm=ap.get(np.texture);lp.framebufferTexture2D(lp.FRAMEBUFFER,lp.COLOR_ATTACHMENT0,lp.TEXTURE_CUBE_MAP_POSITIVE_X+Np,Dm.__webglTexture,Wp)}else if(_m){const Dm=ap.get(np.texture),Km=Np;lp.framebufferTextureLayer(lp.FRAMEBUFFER,lp.COLOR_ATTACHMENT0,Dm.__webglTexture,Wp,Km)}else if(np!==null&&Wp!==0){const Dm=ap.get(np.texture);lp.framebufferTexture2D(lp.FRAMEBUFFER,lp.COLOR_ATTACHMENT0,lp.TEXTURE_2D,Dm.__webglTexture,Wp)}ju=-1},this.readRenderTargetPixels=function(np,Np,Wp,jp,Gp,gm,_m){if(!(np&&np.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Nm=ap.get(np).__webglFramebuffer;if(np.isWebGLCubeRenderTarget&&_m!==void 0&&(Nm=Nm[_m]),Nm){Vu.bindFramebuffer(lp.FRAMEBUFFER,Nm);try{const Dm=np.texture,Km=Dm.format,Zm=Dm.type;if(!$u.textureFormatReadable(Km)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!$u.textureTypeReadable(Zm)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Np>=0&&Np<=np.width-jp&&Wp>=0&&Wp<=np.height-Gp&&lp.readPixels(Np,Wp,jp,Gp,pp.convert(Km),pp.convert(Zm),gm)}finally{const Dm=Ku!==null?ap.get(Ku).__webglFramebuffer:null;Vu.bindFramebuffer(lp.FRAMEBUFFER,Dm)}}},this.readRenderTargetPixelsAsync=async function(np,Np,Wp,jp,Gp,gm,_m){if(!(np&&np.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let Nm=ap.get(np).__webglFramebuffer;if(np.isWebGLCubeRenderTarget&&_m!==void 0&&(Nm=Nm[_m]),Nm){const Dm=np.texture,Km=Dm.format,Zm=Dm.type;if(!$u.textureFormatReadable(Km))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!$u.textureTypeReadable(Zm))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(Np>=0&&Np<=np.width-jp&&Wp>=0&&Wp<=np.height-Gp){Vu.bindFramebuffer(lp.FRAMEBUFFER,Nm);const Vm=lp.createBuffer();lp.bindBuffer(lp.PIXEL_PACK_BUFFER,Vm),lp.bufferData(lp.PIXEL_PACK_BUFFER,gm.byteLength,lp.STREAM_READ),lp.readPixels(Np,Wp,jp,Gp,pp.convert(Km),pp.convert(Zm),0);const r0=Ku!==null?ap.get(Ku).__webglFramebuffer:null;Vu.bindFramebuffer(lp.FRAMEBUFFER,r0);const h0=lp.fenceSync(lp.SYNC_GPU_COMMANDS_COMPLETE,0);return lp.flush(),await probeAsync(lp,h0,4),lp.bindBuffer(lp.PIXEL_PACK_BUFFER,Vm),lp.getBufferSubData(lp.PIXEL_PACK_BUFFER,0,gm),lp.deleteBuffer(Vm),lp.deleteSync(h0),gm}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(np,Np=null,Wp=0){np.isTexture!==!0&&(warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed."),Np=arguments[0]||null,np=arguments[1]);const jp=Math.pow(2,-Wp),Gp=Math.floor(np.image.width*jp),gm=Math.floor(np.image.height*jp),_m=Np!==null?Np.x:0,Nm=Np!==null?Np.y:0;mp.setTexture2D(np,0),lp.copyTexSubImage2D(lp.TEXTURE_2D,Wp,0,0,_m,Nm,Gp,gm),Vu.unbindTexture()};const SC=lp.createFramebuffer(),jw=lp.createFramebuffer();this.copyTextureToTexture=function(np,Np,Wp=null,jp=null,Gp=0,gm=null){np.isTexture!==!0&&(warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed."),jp=arguments[0]||null,np=arguments[1],Np=arguments[2],gm=arguments[3]||0,Wp=null),gm===null&&(Gp!==0?(warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),gm=Gp,Gp=0):gm=0);let _m,Nm,Dm,Km,Zm,Vm,r0,h0,P0;const N0=np.isCompressedTexture?np.mipmaps[gm]:np.image;if(Wp!==null)_m=Wp.max.x-Wp.min.x,Nm=Wp.max.y-Wp.min.y,Dm=Wp.isBox3?Wp.max.z-Wp.min.z:1,Km=Wp.min.x,Zm=Wp.min.y,Vm=Wp.isBox3?Wp.min.z:0;else{const V0=Math.pow(2,-Gp);_m=Math.floor(N0.width*V0),Nm=Math.floor(N0.height*V0),np.isDataArrayTexture?Dm=N0.depth:np.isData3DTexture?Dm=Math.floor(N0.depth*V0):Dm=1,Km=0,Zm=0,Vm=0}jp!==null?(r0=jp.x,h0=jp.y,P0=jp.z):(r0=0,h0=0,P0=0);const s0=pp.convert(Np.format),z0=pp.convert(Np.type);let Um;Np.isData3DTexture?(mp.setTexture3D(Np,0),Um=lp.TEXTURE_3D):Np.isDataArrayTexture||Np.isCompressedArrayTexture?(mp.setTexture2DArray(Np,0),Um=lp.TEXTURE_2D_ARRAY):(mp.setTexture2D(Np,0),Um=lp.TEXTURE_2D),lp.pixelStorei(lp.UNPACK_FLIP_Y_WEBGL,Np.flipY),lp.pixelStorei(lp.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Np.premultiplyAlpha),lp.pixelStorei(lp.UNPACK_ALIGNMENT,Np.unpackAlignment);const Nx=lp.getParameter(lp.UNPACK_ROW_LENGTH),d0=lp.getParameter(lp.UNPACK_IMAGE_HEIGHT),cy=lp.getParameter(lp.UNPACK_SKIP_PIXELS),yy=lp.getParameter(lp.UNPACK_SKIP_ROWS),Hy=lp.getParameter(lp.UNPACK_SKIP_IMAGES);lp.pixelStorei(lp.UNPACK_ROW_LENGTH,N0.width),lp.pixelStorei(lp.UNPACK_IMAGE_HEIGHT,N0.height),lp.pixelStorei(lp.UNPACK_SKIP_PIXELS,Km),lp.pixelStorei(lp.UNPACK_SKIP_ROWS,Zm),lp.pixelStorei(lp.UNPACK_SKIP_IMAGES,Vm);const Dx=np.isDataArrayTexture||np.isData3DTexture,m0=Np.isDataArrayTexture||Np.isData3DTexture;if(np.isDepthTexture){const V0=ap.get(np),Py=ap.get(Np),_0=ap.get(V0.__renderTarget),Ax=ap.get(Py.__renderTarget);Vu.bindFramebuffer(lp.READ_FRAMEBUFFER,_0.__webglFramebuffer),Vu.bindFramebuffer(lp.DRAW_FRAMEBUFFER,Ax.__webglFramebuffer);for(let yx=0;yx<Dm;yx++)Dx&&(lp.framebufferTextureLayer(lp.READ_FRAMEBUFFER,lp.COLOR_ATTACHMENT0,ap.get(np).__webglTexture,Gp,Vm+yx),lp.framebufferTextureLayer(lp.DRAW_FRAMEBUFFER,lp.COLOR_ATTACHMENT0,ap.get(Np).__webglTexture,gm,P0+yx)),lp.blitFramebuffer(Km,Zm,_m,Nm,r0,h0,_m,Nm,lp.DEPTH_BUFFER_BIT,lp.NEAREST);Vu.bindFramebuffer(lp.READ_FRAMEBUFFER,null),Vu.bindFramebuffer(lp.DRAW_FRAMEBUFFER,null)}else if(Gp!==0||np.isRenderTargetTexture||ap.has(np)){const V0=ap.get(np),Py=ap.get(Np);Vu.bindFramebuffer(lp.READ_FRAMEBUFFER,SC),Vu.bindFramebuffer(lp.DRAW_FRAMEBUFFER,jw);for(let _0=0;_0<Dm;_0++)Dx?lp.framebufferTextureLayer(lp.READ_FRAMEBUFFER,lp.COLOR_ATTACHMENT0,V0.__webglTexture,Gp,Vm+_0):lp.framebufferTexture2D(lp.READ_FRAMEBUFFER,lp.COLOR_ATTACHMENT0,lp.TEXTURE_2D,V0.__webglTexture,Gp),m0?lp.framebufferTextureLayer(lp.DRAW_FRAMEBUFFER,lp.COLOR_ATTACHMENT0,Py.__webglTexture,gm,P0+_0):lp.framebufferTexture2D(lp.DRAW_FRAMEBUFFER,lp.COLOR_ATTACHMENT0,lp.TEXTURE_2D,Py.__webglTexture,gm),Gp!==0?lp.blitFramebuffer(Km,Zm,_m,Nm,r0,h0,_m,Nm,lp.COLOR_BUFFER_BIT,lp.NEAREST):m0?lp.copyTexSubImage3D(Um,gm,r0,h0,P0+_0,Km,Zm,_m,Nm):lp.copyTexSubImage2D(Um,gm,r0,h0,Km,Zm,_m,Nm);Vu.bindFramebuffer(lp.READ_FRAMEBUFFER,null),Vu.bindFramebuffer(lp.DRAW_FRAMEBUFFER,null)}else m0?np.isDataTexture||np.isData3DTexture?lp.texSubImage3D(Um,gm,r0,h0,P0,_m,Nm,Dm,s0,z0,N0.data):Np.isCompressedArrayTexture?lp.compressedTexSubImage3D(Um,gm,r0,h0,P0,_m,Nm,Dm,s0,N0.data):lp.texSubImage3D(Um,gm,r0,h0,P0,_m,Nm,Dm,s0,z0,N0):np.isDataTexture?lp.texSubImage2D(lp.TEXTURE_2D,gm,r0,h0,_m,Nm,s0,z0,N0.data):np.isCompressedTexture?lp.compressedTexSubImage2D(lp.TEXTURE_2D,gm,r0,h0,N0.width,N0.height,s0,N0.data):lp.texSubImage2D(lp.TEXTURE_2D,gm,r0,h0,_m,Nm,s0,z0,N0);lp.pixelStorei(lp.UNPACK_ROW_LENGTH,Nx),lp.pixelStorei(lp.UNPACK_IMAGE_HEIGHT,d0),lp.pixelStorei(lp.UNPACK_SKIP_PIXELS,cy),lp.pixelStorei(lp.UNPACK_SKIP_ROWS,yy),lp.pixelStorei(lp.UNPACK_SKIP_IMAGES,Hy),gm===0&&Np.generateMipmaps&&lp.generateMipmap(Um),Vu.unbindTexture()},this.copyTextureToTexture3D=function(np,Np,Wp=null,jp=null,Gp=0){return np.isTexture!==!0&&(warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed."),Wp=arguments[0]||null,jp=arguments[1]||null,np=arguments[2],Np=arguments[3],Gp=arguments[4]||0),warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(np,Np,Wp,jp,Gp)},this.initRenderTarget=function(np){ap.get(np).__webglFramebuffer===void 0&&mp.setupRenderTarget(np)},this.initTexture=function(np){np.isCubeTexture?mp.setTextureCube(np,0):np.isData3DTexture?mp.setTexture3D(np,0):np.isDataArrayTexture||np.isCompressedArrayTexture?mp.setTexture2DArray(np,0):mp.setTexture2D(np,0),Vu.unbindTexture()},this.resetState=function(){Hu=0,Yu=0,Ku=null,Vu.reset(),Zp.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(eu){this._outputColorSpace=eu;const tu=this.getContext();tu.drawingBufferColorspace=ColorManagement._getDrawingBufferColorSpace(eu),tu.unpackColorSpace=ColorManagement._getUnpackColorSpace()}}const e=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping,AddEquation,AddOperation,AdditiveAnimationBlendMode,AdditiveBlending,AgXToneMapping,AlphaFormat,AlwaysCompare,AlwaysDepth,AlwaysStencilFunc,AmbientLight,AnimationAction,AnimationClip,AnimationLoader,AnimationMixer,AnimationObjectGroup,AnimationUtils,ArcCurve,ArrayCamera,ArrowHelper,AttachedBindMode,Audio,AudioAnalyser,AudioContext,AudioListener,AudioLoader,AxesHelper,BackSide,BasicDepthPacking,BasicShadowMap,BatchedMesh,Bone,BooleanKeyframeTrack,Box2,Box3,Box3Helper,BoxGeometry,BoxHelper,BufferAttribute,BufferGeometry,BufferGeometryLoader,ByteType,Cache,Camera,CameraHelper,CanvasTexture,CapsuleGeometry,CatmullRomCurve3,CineonToneMapping,CircleGeometry,ClampToEdgeWrapping,Clock,Color,ColorKeyframeTrack,ColorManagement,CompressedArrayTexture,CompressedCubeTexture,CompressedTexture,CompressedTextureLoader,ConeGeometry,ConstantAlphaFactor,ConstantColorFactor,Controls,CubeCamera,CubeReflectionMapping,CubeRefractionMapping,CubeTexture,CubeTextureLoader,CubeUVReflectionMapping,CubicBezierCurve,CubicBezierCurve3,CubicInterpolant,CullFaceBack,CullFaceFront,CullFaceFrontBack,CullFaceNone,Curve,CurvePath,CustomBlending,CustomToneMapping,CylinderGeometry,Cylindrical,Data3DTexture,DataArrayTexture,DataTexture,DataTextureLoader,DataUtils,DecrementStencilOp,DecrementWrapStencilOp,DefaultLoadingManager,DepthFormat,DepthStencilFormat,DepthTexture,DetachedBindMode,DirectionalLight,DirectionalLightHelper,DiscreteInterpolant,DodecahedronGeometry,DoubleSide,DstAlphaFactor,DstColorFactor,DynamicCopyUsage,DynamicDrawUsage,DynamicReadUsage,EdgesGeometry,EllipseCurve,EqualCompare,EqualDepth,EqualStencilFunc,EquirectangularReflectionMapping,EquirectangularRefractionMapping,Euler,EventDispatcher,ExtrudeGeometry,FileLoader,Float16BufferAttribute,Float32BufferAttribute,FloatType,Fog,FogExp2,FramebufferTexture,FrontSide,Frustum,GLBufferAttribute,GLSL1,GLSL3,GreaterCompare,GreaterDepth,GreaterEqualCompare,GreaterEqualDepth,GreaterEqualStencilFunc,GreaterStencilFunc,GridHelper,Group,HalfFloatType,HemisphereLight,HemisphereLightHelper,IcosahedronGeometry,ImageBitmapLoader,ImageLoader,ImageUtils,IncrementStencilOp,IncrementWrapStencilOp,InstancedBufferAttribute,InstancedBufferGeometry,InstancedInterleavedBuffer,InstancedMesh,Int16BufferAttribute,Int32BufferAttribute,Int8BufferAttribute,IntType,InterleavedBuffer,InterleavedBufferAttribute,Interpolant,InterpolateDiscrete,InterpolateLinear,InterpolateSmooth,InvertStencilOp,KeepStencilOp,KeyframeTrack,LOD,LatheGeometry,Layers,LessCompare,LessDepth,LessEqualCompare,LessEqualDepth,LessEqualStencilFunc,LessStencilFunc,Light,LightProbe,Line,Line3,LineBasicMaterial,LineCurve,LineCurve3,LineDashedMaterial,LineLoop,LineSegments,LinearFilter,LinearInterpolant,LinearMipMapLinearFilter,LinearMipMapNearestFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,LinearSRGBColorSpace,LinearToneMapping,LinearTransfer,Loader:Loader$1,LoaderUtils,LoadingManager,LoopOnce,LoopPingPong,LoopRepeat,LuminanceAlphaFormat,LuminanceFormat,MOUSE,Material,MaterialLoader,MathUtils,Matrix2,Matrix3,Matrix4,MaxEquation,Mesh,MeshBasicMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshLambertMaterial,MeshMatcapMaterial,MeshNormalMaterial,MeshPhongMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshToonMaterial,MinEquation,MirroredRepeatWrapping,MixOperation,MultiplyBlending,MultiplyOperation,NearestFilter,NearestMipMapLinearFilter,NearestMipMapNearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,NeutralToneMapping,NeverCompare,NeverDepth,NeverStencilFunc,NoBlending,NoColorSpace,NoToneMapping,NormalAnimationBlendMode,NormalBlending,NotEqualCompare,NotEqualDepth,NotEqualStencilFunc,NumberKeyframeTrack,Object3D,ObjectLoader,ObjectSpaceNormalMap,OctahedronGeometry,OneFactor,OneMinusConstantAlphaFactor,OneMinusConstantColorFactor,OneMinusDstAlphaFactor,OneMinusDstColorFactor,OneMinusSrcAlphaFactor,OneMinusSrcColorFactor,OrthographicCamera,PCFShadowMap,PCFSoftShadowMap,PMREMGenerator,Path,PerspectiveCamera,Plane,PlaneGeometry,PlaneHelper,PointLight,PointLightHelper,Points,PointsMaterial,PolarGridHelper,PolyhedronGeometry,PositionalAudio,PropertyBinding,PropertyMixer,QuadraticBezierCurve,QuadraticBezierCurve3,Quaternion,QuaternionKeyframeTrack,QuaternionLinearInterpolant,RED_GREEN_RGTC2_Format,RED_RGTC1_Format,REVISION,RGBADepthPacking,RGBAFormat,RGBAIntegerFormat,RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format,RGBDepthPacking,RGBFormat,RGBIntegerFormat,RGB_BPTC_SIGNED_Format,RGB_BPTC_UNSIGNED_Format,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format,RGDepthPacking,RGFormat,RGIntegerFormat,RawShaderMaterial,Ray,Raycaster,RectAreaLight,RedFormat,RedIntegerFormat,ReinhardToneMapping,RenderTarget,RenderTarget3D,RenderTargetArray,RepeatWrapping,ReplaceStencilOp,ReverseSubtractEquation,RingGeometry,SIGNED_RED_GREEN_RGTC2_Format,SIGNED_RED_RGTC1_Format,SRGBColorSpace,SRGBTransfer,Scene,ShaderChunk,ShaderLib,ShaderMaterial,ShadowMaterial,Shape,ShapeGeometry,ShapePath,ShapeUtils,ShortType,Skeleton,SkeletonHelper,SkinnedMesh,Source,Sphere,SphereGeometry,Spherical,SphericalHarmonics3,SplineCurve,SpotLight,SpotLightHelper,Sprite,SpriteMaterial,SrcAlphaFactor,SrcAlphaSaturateFactor,SrcColorFactor,StaticCopyUsage,StaticDrawUsage,StaticReadUsage,StereoCamera,StreamCopyUsage,StreamDrawUsage,StreamReadUsage,StringKeyframeTrack,SubtractEquation,SubtractiveBlending,TOUCH,TangentSpaceNormalMap,TetrahedronGeometry,Texture,TextureLoader,TextureUtils,TimestampQuery,TorusGeometry,TorusKnotGeometry,Triangle,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,TubeGeometry,UVMapping,Uint16BufferAttribute,Uint32BufferAttribute,Uint8BufferAttribute,Uint8ClampedBufferAttribute,Uniform,UniformsGroup,UniformsLib,UniformsUtils,UnsignedByteType,UnsignedInt248Type,UnsignedInt5999Type,UnsignedIntType,UnsignedShort4444Type,UnsignedShort5551Type,UnsignedShortType,VSMShadowMap,Vector2,Vector3,Vector4,VectorKeyframeTrack,VideoFrameTexture,VideoTexture,WebGL3DRenderTarget,WebGLArrayRenderTarget,WebGLCoordinateSystem,WebGLCubeRenderTarget,WebGLRenderTarget,WebGLRenderer,WebGLUtils,WebGPUCoordinateSystem,WebXRController,WireframeGeometry,WrapAroundEnding,ZeroCurvatureEnding,ZeroFactor,ZeroSlopeEnding,ZeroStencilOp,createCanvasElement},Symbol.toStringTag,{value:"Module"}));var define_process_env_default$1={},t={8167:iu=>{var eu=Object.prototype.toString;iu.exports=function(tu){return tu.BYTES_PER_ELEMENT&&eu.call(tu.buffer)==="[object ArrayBuffer]"||Array.isArray(tu)}},5734:iu=>{iu.exports=function(eu,tu){return typeof eu=="number"?eu:typeof tu=="number"?tu:0}},7961:(iu,eu)=>{eu.byteLength=function(yu){var xu=fu(yu),vu=xu[0],Su=xu[1];return 3*(vu+Su)/4-Su},eu.toByteArray=function(yu){var xu,vu,Su=fu(yu),Iu=Su[0],Mu=Su[1],ku=new au(function(Lu,Du,Ou){return 3*(Du+Ou)/4-Ou}(0,Iu,Mu)),Bu=0,_u=Mu>0?Iu-4:Iu;for(vu=0;vu<_u;vu+=4)xu=su[yu.charCodeAt(vu)]<<18|su[yu.charCodeAt(vu+1)]<<12|su[yu.charCodeAt(vu+2)]<<6|su[yu.charCodeAt(vu+3)],ku[Bu++]=xu>>16&255,ku[Bu++]=xu>>8&255,ku[Bu++]=255&xu;return Mu===2&&(xu=su[yu.charCodeAt(vu)]<<2|su[yu.charCodeAt(vu+1)]>>4,ku[Bu++]=255&xu),Mu===1&&(xu=su[yu.charCodeAt(vu)]<<10|su[yu.charCodeAt(vu+1)]<<4|su[yu.charCodeAt(vu+2)]>>2,ku[Bu++]=xu>>8&255,ku[Bu++]=255&xu),ku},eu.fromByteArray=function(yu){for(var xu,vu=yu.length,Su=vu%3,Iu=[],Mu=16383,ku=0,Bu=vu-Su;ku<Bu;ku+=Mu)Iu.push(gu(yu,ku,ku+Mu>Bu?Bu:ku+Mu));return Su===1?(xu=yu[vu-1],Iu.push(tu[xu>>2]+tu[xu<<4&63]+"==")):Su===2&&(xu=(yu[vu-2]<<8)+yu[vu-1],Iu.push(tu[xu>>10]+tu[xu>>4&63]+tu[xu<<2&63]+"=")),Iu.join("")};for(var tu=[],su=[],au=typeof Uint8Array<"u"?Uint8Array:Array,uu="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",du=0;du<64;++du)tu[du]=uu[du],su[uu.charCodeAt(du)]=du;function fu(yu){var xu=yu.length;if(xu%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var vu=yu.indexOf("=");return vu===-1&&(vu=xu),[vu,vu===xu?0:4-vu%4]}function gu(yu,xu,vu){for(var Su,Iu,Mu=[],ku=xu;ku<vu;ku+=3)Su=(yu[ku]<<16&16711680)+(yu[ku+1]<<8&65280)+(255&yu[ku+2]),Mu.push(tu[(Iu=Su)>>18&63]+tu[Iu>>12&63]+tu[Iu>>6&63]+tu[63&Iu]);return Mu.join("")}su[45]=62,su[95]=63},911:(iu,eu,tu)=>{var su=tu(9922).hp;iu.exports=function(au,uu){if(su.isBuffer(au)&&su.isBuffer(uu)){if(typeof au.equals=="function")return au.equals(uu);if(au.length!==uu.length)return!1;for(var du=0;du<au.length;du++)if(au[du]!==uu[du])return!1;return!0}}},9922:(iu,eu,tu)=>{const su=tu(7961),au=tu(1024),uu=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;eu.hp=gu,eu.IS=50;const du=2147483647;function fu($u){if($u>du)throw new RangeError('The value "'+$u+'" is invalid for option "size"');const Vu=new Uint8Array($u);return Object.setPrototypeOf(Vu,gu.prototype),Vu}function gu($u,Vu,_h){if(typeof $u=="number"){if(typeof Vu=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return vu($u)}return yu($u,Vu,_h)}function yu($u,Vu,_h){if(typeof $u=="string")return function(Lp,Kp){if(typeof Kp=="string"&&Kp!==""||(Kp="utf8"),!gu.isEncoding(Kp))throw new TypeError("Unknown encoding: "+Kp);const vm=0|ku(Lp,Kp);let sp=fu(vm);const _d=sp.write(Lp,Kp);return _d!==vm&&(sp=sp.slice(0,_d)),sp}($u,Vu);if(ArrayBuffer.isView($u))return function(Lp){if(_f(Lp,Uint8Array)){const Kp=new Uint8Array(Lp);return Iu(Kp.buffer,Kp.byteOffset,Kp.byteLength)}return Su(Lp)}($u);if($u==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof $u);if(_f($u,ArrayBuffer)||$u&&_f($u.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(_f($u,SharedArrayBuffer)||$u&&_f($u.buffer,SharedArrayBuffer)))return Iu($u,Vu,_h);if(typeof $u=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const ap=$u.valueOf&&$u.valueOf();if(ap!=null&&ap!==$u)return gu.from(ap,Vu,_h);const mp=function(Lp){if(gu.isBuffer(Lp)){const Kp=0|Mu(Lp.length),vm=fu(Kp);return vm.length===0||Lp.copy(vm,0,0,Kp),vm}return Lp.length!==void 0?typeof Lp.length!="number"||rm(Lp.length)?fu(0):Su(Lp):Lp.type==="Buffer"&&Array.isArray(Lp.data)?Su(Lp.data):void 0}($u);if(mp)return mp;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof $u[Symbol.toPrimitive]=="function")return gu.from($u[Symbol.toPrimitive]("string"),Vu,_h);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof $u)}function xu($u){if(typeof $u!="number")throw new TypeError('"size" argument must be of type number');if($u<0)throw new RangeError('The value "'+$u+'" is invalid for option "size"')}function vu($u){return xu($u),fu($u<0?0:0|Mu($u))}function Su($u){const Vu=$u.length<0?0:0|Mu($u.length),_h=fu(Vu);for(let ap=0;ap<Vu;ap+=1)_h[ap]=255&$u[ap];return _h}function Iu($u,Vu,_h){if(Vu<0||$u.byteLength<Vu)throw new RangeError('"offset" is outside of buffer bounds');if($u.byteLength<Vu+(_h||0))throw new RangeError('"length" is outside of buffer bounds');let ap;return ap=Vu===void 0&&_h===void 0?new Uint8Array($u):_h===void 0?new Uint8Array($u,Vu):new Uint8Array($u,Vu,_h),Object.setPrototypeOf(ap,gu.prototype),ap}function Mu($u){if($u>=du)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+du.toString(16)+" bytes");return 0|$u}function ku($u,Vu){if(gu.isBuffer($u))return $u.length;if(ArrayBuffer.isView($u)||_f($u,ArrayBuffer))return $u.byteLength;if(typeof $u!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof $u);const _h=$u.length,ap=arguments.length>2&&arguments[2]===!0;if(!ap&&_h===0)return 0;let mp=!1;for(;;)switch(Vu){case"ascii":case"latin1":case"binary":return _h;case"utf8":case"utf-8":return Xp($u).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*_h;case"hex":return _h>>>1;case"base64":return sm($u).length;default:if(mp)return ap?-1:Xp($u).length;Vu=(""+Vu).toLowerCase(),mp=!0}}function Bu($u,Vu,_h){let ap=!1;if((Vu===void 0||Vu<0)&&(Vu=0),Vu>this.length||((_h===void 0||_h>this.length)&&(_h=this.length),_h<=0)||(_h>>>=0)<=(Vu>>>=0))return"";for($u||($u="utf8");;)switch($u){case"hex":return Cp(this,Vu,_h);case"utf8":case"utf-8":return ju(this,Vu,_h);case"ascii":return gp(this,Vu,_h);case"latin1":case"binary":return yp(this,Vu,_h);case"base64":return Ku(this,Vu,_h);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Hp(this,Vu,_h);default:if(ap)throw new TypeError("Unknown encoding: "+$u);$u=($u+"").toLowerCase(),ap=!0}}function _u($u,Vu,_h){const ap=$u[Vu];$u[Vu]=$u[_h],$u[_h]=ap}function Lu($u,Vu,_h,ap,mp){if($u.length===0)return-1;if(typeof _h=="string"?(ap=_h,_h=0):_h>2147483647?_h=2147483647:_h<-2147483648&&(_h=-2147483648),rm(_h=+_h)&&(_h=mp?0:$u.length-1),_h<0&&(_h=$u.length+_h),_h>=$u.length){if(mp)return-1;_h=$u.length-1}else if(_h<0){if(!mp)return-1;_h=0}if(typeof Vu=="string"&&(Vu=gu.from(Vu,ap)),gu.isBuffer(Vu))return Vu.length===0?-1:Du($u,Vu,_h,ap,mp);if(typeof Vu=="number")return Vu&=255,typeof Uint8Array.prototype.indexOf=="function"?mp?Uint8Array.prototype.indexOf.call($u,Vu,_h):Uint8Array.prototype.lastIndexOf.call($u,Vu,_h):Du($u,[Vu],_h,ap,mp);throw new TypeError("val must be string, number or Buffer")}function Du($u,Vu,_h,ap,mp){let Lp,Kp=1,vm=$u.length,sp=Vu.length;if(ap!==void 0&&((ap=String(ap).toLowerCase())==="ucs2"||ap==="ucs-2"||ap==="utf16le"||ap==="utf-16le")){if($u.length<2||Vu.length<2)return-1;Kp=2,vm/=2,sp/=2,_h/=2}function _d(Sp,tm){return Kp===1?Sp[tm]:Sp.readUInt16BE(tm*Kp)}if(mp){let Sp=-1;for(Lp=_h;Lp<vm;Lp++)if(_d($u,Lp)===_d(Vu,Sp===-1?0:Lp-Sp)){if(Sp===-1&&(Sp=Lp),Lp-Sp+1===sp)return Sp*Kp}else Sp!==-1&&(Lp-=Lp-Sp),Sp=-1}else for(_h+sp>vm&&(_h=vm-sp),Lp=_h;Lp>=0;Lp--){let Sp=!0;for(let tm=0;tm<sp;tm++)if(_d($u,Lp+tm)!==_d(Vu,tm)){Sp=!1;break}if(Sp)return Lp}return-1}function Ou($u,Vu,_h,ap){_h=Number(_h)||0;const mp=$u.length-_h;ap?(ap=Number(ap))>mp&&(ap=mp):ap=mp;const Lp=Vu.length;let Kp;for(ap>Lp/2&&(ap=Lp/2),Kp=0;Kp<ap;++Kp){const vm=parseInt(Vu.substr(2*Kp,2),16);if(rm(vm))return Kp;$u[_h+Kp]=vm}return Kp}function Wu($u,Vu,_h,ap){return $p(Xp(Vu,$u.length-_h),$u,_h,ap)}function Zu($u,Vu,_h,ap){return $p(function(mp){const Lp=[];for(let Kp=0;Kp<mp.length;++Kp)Lp.push(255&mp.charCodeAt(Kp));return Lp}(Vu),$u,_h,ap)}function Hu($u,Vu,_h,ap){return $p(sm(Vu),$u,_h,ap)}function Yu($u,Vu,_h,ap){return $p(function(mp,Lp){let Kp,vm,sp;const _d=[];for(let Sp=0;Sp<mp.length&&!((Lp-=2)<0);++Sp)Kp=mp.charCodeAt(Sp),vm=Kp>>8,sp=Kp%256,_d.push(sp),_d.push(vm);return _d}(Vu,$u.length-_h),$u,_h,ap)}function Ku($u,Vu,_h){return Vu===0&&_h===$u.length?su.fromByteArray($u):su.fromByteArray($u.slice(Vu,_h))}function ju($u,Vu,_h){_h=Math.min($u.length,_h);const ap=[];let mp=Vu;for(;mp<_h;){const Lp=$u[mp];let Kp=null,vm=Lp>239?4:Lp>223?3:Lp>191?2:1;if(mp+vm<=_h){let sp,_d,Sp,tm;switch(vm){case 1:Lp<128&&(Kp=Lp);break;case 2:sp=$u[mp+1],(192&sp)==128&&(tm=(31&Lp)<<6|63&sp,tm>127&&(Kp=tm));break;case 3:sp=$u[mp+1],_d=$u[mp+2],(192&sp)==128&&(192&_d)==128&&(tm=(15&Lp)<<12|(63&sp)<<6|63&_d,tm>2047&&(tm<55296||tm>57343)&&(Kp=tm));break;case 4:sp=$u[mp+1],_d=$u[mp+2],Sp=$u[mp+3],(192&sp)==128&&(192&_d)==128&&(192&Sp)==128&&(tm=(15&Lp)<<18|(63&sp)<<12|(63&_d)<<6|63&Sp,tm>65535&&tm<1114112&&(Kp=tm))}}Kp===null?(Kp=65533,vm=1):Kp>65535&&(Kp-=65536,ap.push(Kp>>>10&1023|55296),Kp=56320|1023&Kp),ap.push(Kp),mp+=vm}return function(Lp){const Kp=Lp.length;if(Kp<=tp)return String.fromCharCode.apply(String,Lp);let vm="",sp=0;for(;sp<Kp;)vm+=String.fromCharCode.apply(String,Lp.slice(sp,sp+=tp));return vm}(ap)}gu.TYPED_ARRAY_SUPPORT=function(){try{const $u=new Uint8Array(1),Vu={foo:function(){return 42}};return Object.setPrototypeOf(Vu,Uint8Array.prototype),Object.setPrototypeOf($u,Vu),$u.foo()===42}catch{return!1}}(),gu.TYPED_ARRAY_SUPPORT||typeof console>"u"||typeof console.error!="function"||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(gu.prototype,"parent",{enumerable:!0,get:function(){if(gu.isBuffer(this))return this.buffer}}),Object.defineProperty(gu.prototype,"offset",{enumerable:!0,get:function(){if(gu.isBuffer(this))return this.byteOffset}}),gu.poolSize=8192,gu.from=function($u,Vu,_h){return yu($u,Vu,_h)},Object.setPrototypeOf(gu.prototype,Uint8Array.prototype),Object.setPrototypeOf(gu,Uint8Array),gu.alloc=function($u,Vu,_h){return function(ap,mp,Lp){return xu(ap),ap<=0?fu(ap):mp!==void 0?typeof Lp=="string"?fu(ap).fill(mp,Lp):fu(ap).fill(mp):fu(ap)}($u,Vu,_h)},gu.allocUnsafe=function($u){return vu($u)},gu.allocUnsafeSlow=function($u){return vu($u)},gu.isBuffer=function($u){return $u!=null&&$u._isBuffer===!0&&$u!==gu.prototype},gu.compare=function($u,Vu){if(_f($u,Uint8Array)&&($u=gu.from($u,$u.offset,$u.byteLength)),_f(Vu,Uint8Array)&&(Vu=gu.from(Vu,Vu.offset,Vu.byteLength)),!gu.isBuffer($u)||!gu.isBuffer(Vu))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if($u===Vu)return 0;let _h=$u.length,ap=Vu.length;for(let mp=0,Lp=Math.min(_h,ap);mp<Lp;++mp)if($u[mp]!==Vu[mp]){_h=$u[mp],ap=Vu[mp];break}return _h<ap?-1:ap<_h?1:0},gu.isEncoding=function($u){switch(String($u).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},gu.concat=function($u,Vu){if(!Array.isArray($u))throw new TypeError('"list" argument must be an Array of Buffers');if($u.length===0)return gu.alloc(0);let _h;if(Vu===void 0)for(Vu=0,_h=0;_h<$u.length;++_h)Vu+=$u[_h].length;const ap=gu.allocUnsafe(Vu);let mp=0;for(_h=0;_h<$u.length;++_h){let Lp=$u[_h];if(_f(Lp,Uint8Array))mp+Lp.length>ap.length?(gu.isBuffer(Lp)||(Lp=gu.from(Lp)),Lp.copy(ap,mp)):Uint8Array.prototype.set.call(ap,Lp,mp);else{if(!gu.isBuffer(Lp))throw new TypeError('"list" argument must be an Array of Buffers');Lp.copy(ap,mp)}mp+=Lp.length}return ap},gu.byteLength=ku,gu.prototype._isBuffer=!0,gu.prototype.swap16=function(){const $u=this.length;if($u%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let Vu=0;Vu<$u;Vu+=2)_u(this,Vu,Vu+1);return this},gu.prototype.swap32=function(){const $u=this.length;if($u%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let Vu=0;Vu<$u;Vu+=4)_u(this,Vu,Vu+3),_u(this,Vu+1,Vu+2);return this},gu.prototype.swap64=function(){const $u=this.length;if($u%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let Vu=0;Vu<$u;Vu+=8)_u(this,Vu,Vu+7),_u(this,Vu+1,Vu+6),_u(this,Vu+2,Vu+5),_u(this,Vu+3,Vu+4);return this},gu.prototype.toString=function(){const $u=this.length;return $u===0?"":arguments.length===0?ju(this,0,$u):Bu.apply(this,arguments)},gu.prototype.toLocaleString=gu.prototype.toString,gu.prototype.equals=function($u){if(!gu.isBuffer($u))throw new TypeError("Argument must be a Buffer");return this===$u||gu.compare(this,$u)===0},gu.prototype.inspect=function(){let $u="";const Vu=eu.IS;return $u=this.toString("hex",0,Vu).replace(/(.{2})/g,"$1 ").trim(),this.length>Vu&&($u+=" ... "),"<Buffer "+$u+">"},uu&&(gu.prototype[uu]=gu.prototype.inspect),gu.prototype.compare=function($u,Vu,_h,ap,mp){if(_f($u,Uint8Array)&&($u=gu.from($u,$u.offset,$u.byteLength)),!gu.isBuffer($u))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof $u);if(Vu===void 0&&(Vu=0),_h===void 0&&(_h=$u?$u.length:0),ap===void 0&&(ap=0),mp===void 0&&(mp=this.length),Vu<0||_h>$u.length||ap<0||mp>this.length)throw new RangeError("out of range index");if(ap>=mp&&Vu>=_h)return 0;if(ap>=mp)return-1;if(Vu>=_h)return 1;if(this===$u)return 0;let Lp=(mp>>>=0)-(ap>>>=0),Kp=(_h>>>=0)-(Vu>>>=0);const vm=Math.min(Lp,Kp),sp=this.slice(ap,mp),_d=$u.slice(Vu,_h);for(let Sp=0;Sp<vm;++Sp)if(sp[Sp]!==_d[Sp]){Lp=sp[Sp],Kp=_d[Sp];break}return Lp<Kp?-1:Kp<Lp?1:0},gu.prototype.includes=function($u,Vu,_h){return this.indexOf($u,Vu,_h)!==-1},gu.prototype.indexOf=function($u,Vu,_h){return Lu(this,$u,Vu,_h,!0)},gu.prototype.lastIndexOf=function($u,Vu,_h){return Lu(this,$u,Vu,_h,!1)},gu.prototype.write=function($u,Vu,_h,ap){if(Vu===void 0)ap="utf8",_h=this.length,Vu=0;else if(_h===void 0&&typeof Vu=="string")ap=Vu,_h=this.length,Vu=0;else{if(!isFinite(Vu))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");Vu>>>=0,isFinite(_h)?(_h>>>=0,ap===void 0&&(ap="utf8")):(ap=_h,_h=void 0)}const mp=this.length-Vu;if((_h===void 0||_h>mp)&&(_h=mp),$u.length>0&&(_h<0||Vu<0)||Vu>this.length)throw new RangeError("Attempt to write outside buffer bounds");ap||(ap="utf8");let Lp=!1;for(;;)switch(ap){case"hex":return Ou(this,$u,Vu,_h);case"utf8":case"utf-8":return Wu(this,$u,Vu,_h);case"ascii":case"latin1":case"binary":return Zu(this,$u,Vu,_h);case"base64":return Hu(this,$u,Vu,_h);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Yu(this,$u,Vu,_h);default:if(Lp)throw new TypeError("Unknown encoding: "+ap);ap=(""+ap).toLowerCase(),Lp=!0}},gu.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const tp=4096;function gp($u,Vu,_h){let ap="";_h=Math.min($u.length,_h);for(let mp=Vu;mp<_h;++mp)ap+=String.fromCharCode(127&$u[mp]);return ap}function yp($u,Vu,_h){let ap="";_h=Math.min($u.length,_h);for(let mp=Vu;mp<_h;++mp)ap+=String.fromCharCode($u[mp]);return ap}function Cp($u,Vu,_h){const ap=$u.length;(!Vu||Vu<0)&&(Vu=0),(!_h||_h<0||_h>ap)&&(_h=ap);let mp="";for(let Lp=Vu;Lp<_h;++Lp)mp+=lp[$u[Lp]];return mp}function Hp($u,Vu,_h){const ap=$u.slice(Vu,_h);let mp="";for(let Lp=0;Lp<ap.length-1;Lp+=2)mp+=String.fromCharCode(ap[Lp]+256*ap[Lp+1]);return mp}function wp($u,Vu,_h){if($u%1!=0||$u<0)throw new RangeError("offset is not uint");if($u+Vu>_h)throw new RangeError("Trying to access beyond buffer length")}function Dp($u,Vu,_h,ap,mp,Lp){if(!gu.isBuffer($u))throw new TypeError('"buffer" argument must be a Buffer instance');if(Vu>mp||Vu<Lp)throw new RangeError('"value" argument is out of bounds');if(_h+ap>$u.length)throw new RangeError("Index out of range")}function dp($u,Vu,_h,ap,mp){dm(Vu,ap,mp,$u,_h,7);let Lp=Number(Vu&BigInt(4294967295));$u[_h++]=Lp,Lp>>=8,$u[_h++]=Lp,Lp>>=8,$u[_h++]=Lp,Lp>>=8,$u[_h++]=Lp;let Kp=Number(Vu>>BigInt(32)&BigInt(4294967295));return $u[_h++]=Kp,Kp>>=8,$u[_h++]=Kp,Kp>>=8,$u[_h++]=Kp,Kp>>=8,$u[_h++]=Kp,_h}function Rp($u,Vu,_h,ap,mp){dm(Vu,ap,mp,$u,_h,7);let Lp=Number(Vu&BigInt(4294967295));$u[_h+7]=Lp,Lp>>=8,$u[_h+6]=Lp,Lp>>=8,$u[_h+5]=Lp,Lp>>=8,$u[_h+4]=Lp;let Kp=Number(Vu>>BigInt(32)&BigInt(4294967295));return $u[_h+3]=Kp,Kp>>=8,$u[_h+2]=Kp,Kp>>=8,$u[_h+1]=Kp,Kp>>=8,$u[_h]=Kp,_h+8}function xp($u,Vu,_h,ap,mp,Lp){if(_h+ap>$u.length)throw new RangeError("Index out of range");if(_h<0)throw new RangeError("Index out of range")}function cm($u,Vu,_h,ap,mp){return Vu=+Vu,_h>>>=0,mp||xp($u,0,_h,4),au.write($u,Vu,_h,ap,23,4),_h+4}function lm($u,Vu,_h,ap,mp){return Vu=+Vu,_h>>>=0,mp||xp($u,0,_h,8),au.write($u,Vu,_h,ap,52,8),_h+8}gu.prototype.slice=function($u,Vu){const _h=this.length;($u=~~$u)<0?($u+=_h)<0&&($u=0):$u>_h&&($u=_h),(Vu=Vu===void 0?_h:~~Vu)<0?(Vu+=_h)<0&&(Vu=0):Vu>_h&&(Vu=_h),Vu<$u&&(Vu=$u);const ap=this.subarray($u,Vu);return Object.setPrototypeOf(ap,gu.prototype),ap},gu.prototype.readUintLE=gu.prototype.readUIntLE=function($u,Vu,_h){$u>>>=0,Vu>>>=0,_h||wp($u,Vu,this.length);let ap=this[$u],mp=1,Lp=0;for(;++Lp<Vu&&(mp*=256);)ap+=this[$u+Lp]*mp;return ap},gu.prototype.readUintBE=gu.prototype.readUIntBE=function($u,Vu,_h){$u>>>=0,Vu>>>=0,_h||wp($u,Vu,this.length);let ap=this[$u+--Vu],mp=1;for(;Vu>0&&(mp*=256);)ap+=this[$u+--Vu]*mp;return ap},gu.prototype.readUint8=gu.prototype.readUInt8=function($u,Vu){return $u>>>=0,Vu||wp($u,1,this.length),this[$u]},gu.prototype.readUint16LE=gu.prototype.readUInt16LE=function($u,Vu){return $u>>>=0,Vu||wp($u,2,this.length),this[$u]|this[$u+1]<<8},gu.prototype.readUint16BE=gu.prototype.readUInt16BE=function($u,Vu){return $u>>>=0,Vu||wp($u,2,this.length),this[$u]<<8|this[$u+1]},gu.prototype.readUint32LE=gu.prototype.readUInt32LE=function($u,Vu){return $u>>>=0,Vu||wp($u,4,this.length),(this[$u]|this[$u+1]<<8|this[$u+2]<<16)+16777216*this[$u+3]},gu.prototype.readUint32BE=gu.prototype.readUInt32BE=function($u,Vu){return $u>>>=0,Vu||wp($u,4,this.length),16777216*this[$u]+(this[$u+1]<<16|this[$u+2]<<8|this[$u+3])},gu.prototype.readBigUInt64LE=cp(function($u){nm($u>>>=0,"offset");const Vu=this[$u],_h=this[$u+7];Vu!==void 0&&_h!==void 0||Bp($u,this.length-8);const ap=Vu+256*this[++$u]+65536*this[++$u]+this[++$u]*2**24,mp=this[++$u]+256*this[++$u]+65536*this[++$u]+_h*2**24;return BigInt(ap)+(BigInt(mp)<<BigInt(32))}),gu.prototype.readBigUInt64BE=cp(function($u){nm($u>>>=0,"offset");const Vu=this[$u],_h=this[$u+7];Vu!==void 0&&_h!==void 0||Bp($u,this.length-8);const ap=Vu*2**24+65536*this[++$u]+256*this[++$u]+this[++$u],mp=this[++$u]*2**24+65536*this[++$u]+256*this[++$u]+_h;return(BigInt(ap)<<BigInt(32))+BigInt(mp)}),gu.prototype.readIntLE=function($u,Vu,_h){$u>>>=0,Vu>>>=0,_h||wp($u,Vu,this.length);let ap=this[$u],mp=1,Lp=0;for(;++Lp<Vu&&(mp*=256);)ap+=this[$u+Lp]*mp;return mp*=128,ap>=mp&&(ap-=Math.pow(2,8*Vu)),ap},gu.prototype.readIntBE=function($u,Vu,_h){$u>>>=0,Vu>>>=0,_h||wp($u,Vu,this.length);let ap=Vu,mp=1,Lp=this[$u+--ap];for(;ap>0&&(mp*=256);)Lp+=this[$u+--ap]*mp;return mp*=128,Lp>=mp&&(Lp-=Math.pow(2,8*Vu)),Lp},gu.prototype.readInt8=function($u,Vu){return $u>>>=0,Vu||wp($u,1,this.length),128&this[$u]?-1*(255-this[$u]+1):this[$u]},gu.prototype.readInt16LE=function($u,Vu){$u>>>=0,Vu||wp($u,2,this.length);const _h=this[$u]|this[$u+1]<<8;return 32768&_h?4294901760|_h:_h},gu.prototype.readInt16BE=function($u,Vu){$u>>>=0,Vu||wp($u,2,this.length);const _h=this[$u+1]|this[$u]<<8;return 32768&_h?4294901760|_h:_h},gu.prototype.readInt32LE=function($u,Vu){return $u>>>=0,Vu||wp($u,4,this.length),this[$u]|this[$u+1]<<8|this[$u+2]<<16|this[$u+3]<<24},gu.prototype.readInt32BE=function($u,Vu){return $u>>>=0,Vu||wp($u,4,this.length),this[$u]<<24|this[$u+1]<<16|this[$u+2]<<8|this[$u+3]},gu.prototype.readBigInt64LE=cp(function($u){nm($u>>>=0,"offset");const Vu=this[$u],_h=this[$u+7];Vu!==void 0&&_h!==void 0||Bp($u,this.length-8);const ap=this[$u+4]+256*this[$u+5]+65536*this[$u+6]+(_h<<24);return(BigInt(ap)<<BigInt(32))+BigInt(Vu+256*this[++$u]+65536*this[++$u]+this[++$u]*2**24)}),gu.prototype.readBigInt64BE=cp(function($u){nm($u>>>=0,"offset");const Vu=this[$u],_h=this[$u+7];Vu!==void 0&&_h!==void 0||Bp($u,this.length-8);const ap=(Vu<<24)+65536*this[++$u]+256*this[++$u]+this[++$u];return(BigInt(ap)<<BigInt(32))+BigInt(this[++$u]*2**24+65536*this[++$u]+256*this[++$u]+_h)}),gu.prototype.readFloatLE=function($u,Vu){return $u>>>=0,Vu||wp($u,4,this.length),au.read(this,$u,!0,23,4)},gu.prototype.readFloatBE=function($u,Vu){return $u>>>=0,Vu||wp($u,4,this.length),au.read(this,$u,!1,23,4)},gu.prototype.readDoubleLE=function($u,Vu){return $u>>>=0,Vu||wp($u,8,this.length),au.read(this,$u,!0,52,8)},gu.prototype.readDoubleBE=function($u,Vu){return $u>>>=0,Vu||wp($u,8,this.length),au.read(this,$u,!1,52,8)},gu.prototype.writeUintLE=gu.prototype.writeUIntLE=function($u,Vu,_h,ap){$u=+$u,Vu>>>=0,_h>>>=0,ap||Dp(this,$u,Vu,_h,Math.pow(2,8*_h)-1,0);let mp=1,Lp=0;for(this[Vu]=255&$u;++Lp<_h&&(mp*=256);)this[Vu+Lp]=$u/mp&255;return Vu+_h},gu.prototype.writeUintBE=gu.prototype.writeUIntBE=function($u,Vu,_h,ap){$u=+$u,Vu>>>=0,_h>>>=0,ap||Dp(this,$u,Vu,_h,Math.pow(2,8*_h)-1,0);let mp=_h-1,Lp=1;for(this[Vu+mp]=255&$u;--mp>=0&&(Lp*=256);)this[Vu+mp]=$u/Lp&255;return Vu+_h},gu.prototype.writeUint8=gu.prototype.writeUInt8=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,1,255,0),this[Vu]=255&$u,Vu+1},gu.prototype.writeUint16LE=gu.prototype.writeUInt16LE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,2,65535,0),this[Vu]=255&$u,this[Vu+1]=$u>>>8,Vu+2},gu.prototype.writeUint16BE=gu.prototype.writeUInt16BE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,2,65535,0),this[Vu]=$u>>>8,this[Vu+1]=255&$u,Vu+2},gu.prototype.writeUint32LE=gu.prototype.writeUInt32LE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,4,4294967295,0),this[Vu+3]=$u>>>24,this[Vu+2]=$u>>>16,this[Vu+1]=$u>>>8,this[Vu]=255&$u,Vu+4},gu.prototype.writeUint32BE=gu.prototype.writeUInt32BE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,4,4294967295,0),this[Vu]=$u>>>24,this[Vu+1]=$u>>>16,this[Vu+2]=$u>>>8,this[Vu+3]=255&$u,Vu+4},gu.prototype.writeBigUInt64LE=cp(function($u,Vu=0){return dp(this,$u,Vu,BigInt(0),BigInt("0xffffffffffffffff"))}),gu.prototype.writeBigUInt64BE=cp(function($u,Vu=0){return Rp(this,$u,Vu,BigInt(0),BigInt("0xffffffffffffffff"))}),gu.prototype.writeIntLE=function($u,Vu,_h,ap){if($u=+$u,Vu>>>=0,!ap){const vm=Math.pow(2,8*_h-1);Dp(this,$u,Vu,_h,vm-1,-vm)}let mp=0,Lp=1,Kp=0;for(this[Vu]=255&$u;++mp<_h&&(Lp*=256);)$u<0&&Kp===0&&this[Vu+mp-1]!==0&&(Kp=1),this[Vu+mp]=($u/Lp|0)-Kp&255;return Vu+_h},gu.prototype.writeIntBE=function($u,Vu,_h,ap){if($u=+$u,Vu>>>=0,!ap){const vm=Math.pow(2,8*_h-1);Dp(this,$u,Vu,_h,vm-1,-vm)}let mp=_h-1,Lp=1,Kp=0;for(this[Vu+mp]=255&$u;--mp>=0&&(Lp*=256);)$u<0&&Kp===0&&this[Vu+mp+1]!==0&&(Kp=1),this[Vu+mp]=($u/Lp|0)-Kp&255;return Vu+_h},gu.prototype.writeInt8=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,1,127,-128),$u<0&&($u=255+$u+1),this[Vu]=255&$u,Vu+1},gu.prototype.writeInt16LE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,2,32767,-32768),this[Vu]=255&$u,this[Vu+1]=$u>>>8,Vu+2},gu.prototype.writeInt16BE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,2,32767,-32768),this[Vu]=$u>>>8,this[Vu+1]=255&$u,Vu+2},gu.prototype.writeInt32LE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,4,2147483647,-2147483648),this[Vu]=255&$u,this[Vu+1]=$u>>>8,this[Vu+2]=$u>>>16,this[Vu+3]=$u>>>24,Vu+4},gu.prototype.writeInt32BE=function($u,Vu,_h){return $u=+$u,Vu>>>=0,_h||Dp(this,$u,Vu,4,2147483647,-2147483648),$u<0&&($u=4294967295+$u+1),this[Vu]=$u>>>24,this[Vu+1]=$u>>>16,this[Vu+2]=$u>>>8,this[Vu+3]=255&$u,Vu+4},gu.prototype.writeBigInt64LE=cp(function($u,Vu=0){return dp(this,$u,Vu,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),gu.prototype.writeBigInt64BE=cp(function($u,Vu=0){return Rp(this,$u,Vu,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),gu.prototype.writeFloatLE=function($u,Vu,_h){return cm(this,$u,Vu,!0,_h)},gu.prototype.writeFloatBE=function($u,Vu,_h){return cm(this,$u,Vu,!1,_h)},gu.prototype.writeDoubleLE=function($u,Vu,_h){return lm(this,$u,Vu,!0,_h)},gu.prototype.writeDoubleBE=function($u,Vu,_h){return lm(this,$u,Vu,!1,_h)},gu.prototype.copy=function($u,Vu,_h,ap){if(!gu.isBuffer($u))throw new TypeError("argument should be a Buffer");if(_h||(_h=0),ap||ap===0||(ap=this.length),Vu>=$u.length&&(Vu=$u.length),Vu||(Vu=0),ap>0&&ap<_h&&(ap=_h),ap===_h||$u.length===0||this.length===0)return 0;if(Vu<0)throw new RangeError("targetStart out of bounds");if(_h<0||_h>=this.length)throw new RangeError("Index out of range");if(ap<0)throw new RangeError("sourceEnd out of bounds");ap>this.length&&(ap=this.length),$u.length-Vu<ap-_h&&(ap=$u.length-Vu+_h);const mp=ap-_h;return this===$u&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(Vu,_h,ap):Uint8Array.prototype.set.call($u,this.subarray(_h,ap),Vu),mp},gu.prototype.fill=function($u,Vu,_h,ap){if(typeof $u=="string"){if(typeof Vu=="string"?(ap=Vu,Vu=0,_h=this.length):typeof _h=="string"&&(ap=_h,_h=this.length),ap!==void 0&&typeof ap!="string")throw new TypeError("encoding must be a string");if(typeof ap=="string"&&!gu.isEncoding(ap))throw new TypeError("Unknown encoding: "+ap);if($u.length===1){const Lp=$u.charCodeAt(0);(ap==="utf8"&&Lp<128||ap==="latin1")&&($u=Lp)}}else typeof $u=="number"?$u&=255:typeof $u=="boolean"&&($u=Number($u));if(Vu<0||this.length<Vu||this.length<_h)throw new RangeError("Out of range index");if(_h<=Vu)return this;let mp;if(Vu>>>=0,_h=_h===void 0?this.length:_h>>>0,$u||($u=0),typeof $u=="number")for(mp=Vu;mp<_h;++mp)this[mp]=$u;else{const Lp=gu.isBuffer($u)?$u:gu.from($u,ap),Kp=Lp.length;if(Kp===0)throw new TypeError('The value "'+$u+'" is invalid for argument "value"');for(mp=0;mp<_h-Vu;++mp)this[mp+Vu]=Lp[mp%Kp]}return this};const vp={};function bp($u,Vu,_h){vp[$u]=class extends _h{constructor(){super(),Object.defineProperty(this,"message",{value:Vu.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${$u}]`,this.stack,delete this.name}get code(){return $u}set code(ap){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:ap,writable:!0})}toString(){return`${this.name} [${$u}]: ${this.message}`}}}function kp($u){let Vu="",_h=$u.length;const ap=$u[0]==="-"?1:0;for(;_h>=ap+4;_h-=3)Vu=`_${$u.slice(_h-3,_h)}${Vu}`;return`${$u.slice(0,_h)}${Vu}`}function dm($u,Vu,_h,ap,mp,Lp){if($u>_h||$u<Vu){const Kp=typeof Vu=="bigint"?"n":"";let vm;throw vm=Vu===0||Vu===BigInt(0)?`>= 0${Kp} and < 2${Kp} ** ${8*(Lp+1)}${Kp}`:`>= -(2${Kp} ** ${8*(Lp+1)-1}${Kp}) and < 2 ** ${8*(Lp+1)-1}${Kp}`,new vp.ERR_OUT_OF_RANGE("value",vm,$u)}(function(Kp,vm,sp){nm(vm,"offset"),Kp[vm]!==void 0&&Kp[vm+sp]!==void 0||Bp(vm,Kp.length-(sp+1))})(ap,mp,Lp)}function nm($u,Vu){if(typeof $u!="number")throw new vp.ERR_INVALID_ARG_TYPE(Vu,"number",$u)}function Bp($u,Vu,_h){throw Math.floor($u)!==$u?(nm($u,_h),new vp.ERR_OUT_OF_RANGE("offset","an integer",$u)):Vu<0?new vp.ERR_BUFFER_OUT_OF_BOUNDS:new vp.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${Vu}`,$u)}bp("ERR_BUFFER_OUT_OF_BOUNDS",function($u){return $u?`${$u} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),bp("ERR_INVALID_ARG_TYPE",function($u,Vu){return`The "${$u}" argument must be of type number. Received type ${typeof Vu}`},TypeError),bp("ERR_OUT_OF_RANGE",function($u,Vu,_h){let ap=`The value of "${$u}" is out of range.`,mp=_h;return Number.isInteger(_h)&&Math.abs(_h)>2**32?mp=kp(String(_h)):typeof _h=="bigint"&&(mp=String(_h),(_h>BigInt(2)**BigInt(32)||_h<-(BigInt(2)**BigInt(32)))&&(mp=kp(mp)),mp+="n"),ap+=` It must be ${Vu}. Received ${mp}`,ap},RangeError);const Qp=/[^+/0-9A-Za-z-_]/g;function Xp($u,Vu){let _h;Vu=Vu||1/0;const ap=$u.length;let mp=null;const Lp=[];for(let Kp=0;Kp<ap;++Kp){if(_h=$u.charCodeAt(Kp),_h>55295&&_h<57344){if(!mp){if(_h>56319){(Vu-=3)>-1&&Lp.push(239,191,189);continue}if(Kp+1===ap){(Vu-=3)>-1&&Lp.push(239,191,189);continue}mp=_h;continue}if(_h<56320){(Vu-=3)>-1&&Lp.push(239,191,189),mp=_h;continue}_h=65536+(mp-55296<<10|_h-56320)}else mp&&(Vu-=3)>-1&&Lp.push(239,191,189);if(mp=null,_h<128){if((Vu-=1)<0)break;Lp.push(_h)}else if(_h<2048){if((Vu-=2)<0)break;Lp.push(_h>>6|192,63&_h|128)}else if(_h<65536){if((Vu-=3)<0)break;Lp.push(_h>>12|224,_h>>6&63|128,63&_h|128)}else{if(!(_h<1114112))throw new Error("Invalid code point");if((Vu-=4)<0)break;Lp.push(_h>>18|240,_h>>12&63|128,_h>>6&63|128,63&_h|128)}}return Lp}function sm($u){return su.toByteArray(function(Vu){if((Vu=(Vu=Vu.split("=")[0]).trim().replace(Qp,"")).length<2)return"";for(;Vu.length%4!=0;)Vu+="=";return Vu}($u))}function $p($u,Vu,_h,ap){let mp;for(mp=0;mp<ap&&!(mp+_h>=Vu.length||mp>=$u.length);++mp)Vu[mp+_h]=$u[mp];return mp}function _f($u,Vu){return $u instanceof Vu||$u!=null&&$u.constructor!=null&&$u.constructor.name!=null&&$u.constructor.name===Vu.name}function rm($u){return $u!=$u}const lp=function(){const $u="0123456789abcdef",Vu=new Array(256);for(let _h=0;_h<16;++_h){const ap=16*_h;for(let mp=0;mp<16;++mp)Vu[ap+mp]=$u[_h]+$u[mp]}return Vu}();function cp($u){return typeof BigInt>"u"?mm:$u}function mm(){throw new Error("BigInt not supported")}},9089:iu=>{iu.exports=function(eu){var tu=[];return tu.toString=function(){return this.map(function(su){var au="",uu=su[5]!==void 0;return su[4]&&(au+="@supports (".concat(su[4],") {")),su[2]&&(au+="@media ".concat(su[2]," {")),uu&&(au+="@layer".concat(su[5].length>0?" ".concat(su[5]):""," {")),au+=eu(su),uu&&(au+="}"),su[2]&&(au+="}"),su[4]&&(au+="}"),au}).join("")},tu.i=function(su,au,uu,du,fu){typeof su=="string"&&(su=[[null,su,void 0]]);var gu={};if(uu)for(var yu=0;yu<this.length;yu++){var xu=this[yu][0];xu!=null&&(gu[xu]=!0)}for(var vu=0;vu<su.length;vu++){var Su=[].concat(su[vu]);uu&&gu[Su[0]]||(fu!==void 0&&(Su[5]===void 0||(Su[1]="@layer".concat(Su[5].length>0?" ".concat(Su[5]):""," {").concat(Su[1],"}")),Su[5]=fu),au&&(Su[2]&&(Su[1]="@media ".concat(Su[2]," {").concat(Su[1],"}")),Su[2]=au),du&&(Su[4]?(Su[1]="@supports (".concat(Su[4],") {").concat(Su[1],"}"),Su[4]=du):Su[4]="".concat(du)),tu.push(Su))}},tu}},6492:iu=>{iu.exports=function(eu,tu){return tu||(tu={}),eu&&(eu=String(eu.__esModule?eu.default:eu),/^['"].*['"]$/.test(eu)&&(eu=eu.slice(1,-1)),tu.hash&&(eu+=tu.hash),/["'() \t\n]|(%20)/.test(eu)||tu.needQuotes?'"'.concat(eu.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):eu)}},963:iu=>{iu.exports=function(eu){var tu=eu[1],su=eu[3];if(!su)return tu;if(typeof btoa=="function"){var au=btoa(unescape(encodeURIComponent(JSON.stringify(su)))),uu="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(au),du="/*# ".concat(uu," */");return[tu].concat([du]).join(`
`)}return[tu].join(`
`)}},8878:(iu,eu,tu)=>{eu.formatArgs=function(au){if(au[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+au[0]+(this.useColors?"%c ":" ")+"+"+iu.exports.humanize(this.diff),!this.useColors)return;const uu="color: "+this.color;au.splice(1,0,uu,"color: inherit");let du=0,fu=0;au[0].replace(/%[a-zA-Z%]/g,gu=>{gu!=="%%"&&(du++,gu==="%c"&&(fu=du))}),au.splice(fu,0,uu)},eu.save=function(au){try{au?eu.storage.setItem("debug",au):eu.storage.removeItem("debug")}catch{}},eu.load=function(){let au;try{au=eu.storage.getItem("debug")}catch{}return!au&&typeof process$1<"u"&&"env"in process$1&&(au=define_process_env_default$1.DEBUG),au},eu.useColors=function(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let au;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(au=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(au[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},eu.storage=function(){try{return localStorage}catch{}}(),eu.destroy=(()=>{let au=!1;return()=>{au||(au=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),eu.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],eu.log=console.debug||console.log||(()=>{}),iu.exports=tu(8945)(eu);const{formatters:su}=iu.exports;su.j=function(au){try{return JSON.stringify(au)}catch(uu){return"[UnexpectedJSONParseError]: "+uu.message}}},8945:(iu,eu,tu)=>{iu.exports=function(su){function au(fu){let gu,yu,xu,vu=null;function Su(...Iu){if(!Su.enabled)return;const Mu=Su,ku=Number(new Date),Bu=ku-(gu||ku);Mu.diff=Bu,Mu.prev=gu,Mu.curr=ku,gu=ku,Iu[0]=au.coerce(Iu[0]),typeof Iu[0]!="string"&&Iu.unshift("%O");let _u=0;Iu[0]=Iu[0].replace(/%([a-zA-Z%])/g,(Lu,Du)=>{if(Lu==="%%")return"%";_u++;const Ou=au.formatters[Du];if(typeof Ou=="function"){const Wu=Iu[_u];Lu=Ou.call(Mu,Wu),Iu.splice(_u,1),_u--}return Lu}),au.formatArgs.call(Mu,Iu),(Mu.log||au.log).apply(Mu,Iu)}return Su.namespace=fu,Su.useColors=au.useColors(),Su.color=au.selectColor(fu),Su.extend=uu,Su.destroy=au.destroy,Object.defineProperty(Su,"enabled",{enumerable:!0,configurable:!1,get:()=>vu!==null?vu:(yu!==au.namespaces&&(yu=au.namespaces,xu=au.enabled(fu)),xu),set:Iu=>{vu=Iu}}),typeof au.init=="function"&&au.init(Su),Su}function uu(fu,gu){const yu=au(this.namespace+(gu===void 0?":":gu)+fu);return yu.log=this.log,yu}function du(fu,gu){let yu=0,xu=0,vu=-1,Su=0;for(;yu<fu.length;)if(xu<gu.length&&(gu[xu]===fu[yu]||gu[xu]==="*"))gu[xu]==="*"?(vu=xu,Su=yu,xu++):(yu++,xu++);else{if(vu===-1)return!1;xu=vu+1,Su++,yu=Su}for(;xu<gu.length&&gu[xu]==="*";)xu++;return xu===gu.length}return au.debug=au,au.default=au,au.coerce=function(fu){return fu instanceof Error?fu.stack||fu.message:fu},au.disable=function(){const fu=[...au.names,...au.skips.map(gu=>"-"+gu)].join(",");return au.enable(""),fu},au.enable=function(fu){au.save(fu),au.namespaces=fu,au.names=[],au.skips=[];const gu=(typeof fu=="string"?fu:"").trim().replace(" ",",").split(",").filter(Boolean);for(const yu of gu)yu[0]==="-"?au.skips.push(yu.slice(1)):au.names.push(yu)},au.enabled=function(fu){for(const gu of au.skips)if(du(fu,gu))return!1;for(const gu of au.names)if(du(fu,gu))return!0;return!1},au.humanize=tu(9192),au.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(su).forEach(fu=>{au[fu]=su[fu]}),au.names=[],au.skips=[],au.formatters={},au.selectColor=function(fu){let gu=0;for(let yu=0;yu<fu.length;yu++)gu=(gu<<5)-gu+fu.charCodeAt(yu),gu|=0;return au.colors[Math.abs(gu)%au.colors.length]},au.enable(au.load()),au}},1124:(iu,eu,tu)=>{var su=tu(6240),au=Object.prototype.hasOwnProperty,uu=Object.prototype.propertyIsEnumerable;function du(gu,yu,xu){var vu=yu[xu];if(vu!=null){if(au.call(gu,xu)&&(gu[xu]===void 0||gu[xu]===null))throw new TypeError("Cannot convert undefined or null to object ("+xu+")");au.call(gu,xu)&&su(vu)?gu[xu]=fu(Object(gu[xu]),yu[xu]):gu[xu]=vu}}function fu(gu,yu){if(gu===yu)return gu;for(var xu in yu=Object(yu))au.call(yu,xu)&&du(gu,yu,xu);if(Object.getOwnPropertySymbols)for(var vu=Object.getOwnPropertySymbols(yu),Su=0;Su<vu.length;Su++)uu.call(yu,vu[Su])&&du(gu,yu,vu[Su]);return gu}iu.exports=function(gu){gu=function(xu){if(xu==null)throw new TypeError("Sources cannot be null or undefined");return Object(xu)}(gu);for(var yu=1;yu<arguments.length;yu++)fu(gu,arguments[yu]);return gu}},8480:iu=>{iu.exports=function(eu){switch(eu){case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"uint8":return Uint8Array;case"uint16":return Uint16Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;case"array":return Array;case"uint8_clamped":return Uint8ClampedArray}}},919:(iu,eu,tu)=>{var su;su=typeof window<"u"?window:tu.g!==void 0?tu.g:typeof self<"u"?self:{},iu.exports=su},1024:(iu,eu)=>{eu.read=function(tu,su,au,uu,du){var fu,gu,yu=8*du-uu-1,xu=(1<<yu)-1,vu=xu>>1,Su=-7,Iu=au?du-1:0,Mu=au?-1:1,ku=tu[su+Iu];for(Iu+=Mu,fu=ku&(1<<-Su)-1,ku>>=-Su,Su+=yu;Su>0;fu=256*fu+tu[su+Iu],Iu+=Mu,Su-=8);for(gu=fu&(1<<-Su)-1,fu>>=-Su,Su+=uu;Su>0;gu=256*gu+tu[su+Iu],Iu+=Mu,Su-=8);if(fu===0)fu=1-vu;else{if(fu===xu)return gu?NaN:1/0*(ku?-1:1);gu+=Math.pow(2,uu),fu-=vu}return(ku?-1:1)*gu*Math.pow(2,fu-uu)},eu.write=function(tu,su,au,uu,du,fu){var gu,yu,xu,vu=8*fu-du-1,Su=(1<<vu)-1,Iu=Su>>1,Mu=du===23?Math.pow(2,-24)-Math.pow(2,-77):0,ku=uu?0:fu-1,Bu=uu?1:-1,_u=su<0||su===0&&1/su<0?1:0;for(su=Math.abs(su),isNaN(su)||su===1/0?(yu=isNaN(su)?1:0,gu=Su):(gu=Math.floor(Math.log(su)/Math.LN2),su*(xu=Math.pow(2,-gu))<1&&(gu--,xu*=2),(su+=gu+Iu>=1?Mu/xu:Mu*Math.pow(2,1-Iu))*xu>=2&&(gu++,xu/=2),gu+Iu>=Su?(yu=0,gu=Su):gu+Iu>=1?(yu=(su*xu-1)*Math.pow(2,du),gu+=Iu):(yu=su*Math.pow(2,Iu-1)*Math.pow(2,du),gu=0));du>=8;tu[au+ku]=255&yu,ku+=Bu,yu/=256,du-=8);for(gu=gu<<du|yu,vu+=du;vu>0;tu[au+ku]=255&gu,ku+=Bu,gu/=256,vu-=8);tu[au+ku-Bu]|=128*_u}},2225:iu=>{function eu(tu){return!!tu.constructor&&typeof tu.constructor.isBuffer=="function"&&tu.constructor.isBuffer(tu)}iu.exports=function(tu){return tu!=null&&(eu(tu)||function(su){return typeof su.readFloatLE=="function"&&typeof su.slice=="function"&&eu(su.slice(0,0))}(tu)||!!tu._isBuffer)}},8847:iu=>{iu.exports=function(tu){if(!tu)return!1;var su=eu.call(tu);return su==="[object Function]"||typeof tu=="function"&&su!=="[object RegExp]"||typeof window<"u"&&(tu===window.setTimeout||tu===window.alert||tu===window.confirm||tu===window.prompt)};var eu=Object.prototype.toString},6240:iu=>{iu.exports=function(eu){var tu=typeof eu;return eu!==null&&(tu==="object"||tu==="function")}},5651:(iu,eu,tu)=>{var su=tu(5406),au=tu(4597),uu=tu(5734),du=["x","e","a","o","n","s","r","c","u","m","v","w","z"],fu=["m","w"],gu=["H","I","N","E","F","K","L","T","U","V","W","X","Y","Z"],yu=9,xu=32;function vu(Bu){this.glyphs=[],this._measure=this.computeMetrics.bind(this),this.update(Bu)}function Su(Bu){return new Function(["return function "+Bu+"() {","  return this._"+Bu,"}"].join(`
`))()}function Iu(Bu,_u){if(!Bu.chars||Bu.chars.length===0)return null;var Lu=ku(Bu.chars,_u);return Lu>=0?Bu.chars[Lu]:null}function Mu(Bu,_u,Lu){if(!Bu.kernings||Bu.kernings.length===0)return 0;for(var Du=Bu.kernings,Ou=0;Ou<Du.length;Ou++){var Wu=Du[Ou];if(Wu.first===_u&&Wu.second===Lu)return Wu.amount}return 0}function ku(Bu,_u,Lu){for(var Du=Lu=Lu||0;Du<Bu.length;Du++)if(Bu[Du].id===_u)return Du;return-1}iu.exports=function(Bu){return new vu(Bu)},vu.prototype.update=function(Bu){if(Bu=au({measure:this._measure},Bu),this._opt=Bu,this._opt.tabSize=uu(this._opt.tabSize,4),!Bu.font)throw new Error("must provide a valid bitmap font");var _u=this.glyphs,Lu=Bu.text||"",Du=Bu.font;this._setupSpaceGlyphs(Du);var Ou=su.lines(Lu,Bu),Wu=Bu.width||0;_u.length=0;var Zu=Ou.reduce(function(wp,Dp){return Math.max(wp,Dp.width,Wu)},0),Hu=0,Yu=0,Ku=uu(Bu.lineHeight,Du.common.lineHeight),ju=Du.common.base,tp=Ku-ju,gp=Bu.letterSpacing||0,yp=Ku*Ou.length-tp,Cp=function(wp){return wp==="center"?1:wp==="right"?2:0}(this._opt.align);Yu-=yp,this._width=Zu,this._height=yp,this._descender=Ku-ju,this._baseline=ju,this._xHeight=function(wp){for(var Dp=0;Dp<du.length;Dp++){var dp=du[Dp].charCodeAt(0),Rp=ku(wp.chars,dp);if(Rp>=0)return wp.chars[Rp].height}return 0}(Du),this._capHeight=function(wp){for(var Dp=0;Dp<gu.length;Dp++){var dp=gu[Dp].charCodeAt(0),Rp=ku(wp.chars,dp);if(Rp>=0)return wp.chars[Rp].height}return 0}(Du),this._lineHeight=Ku,this._ascender=Ku-tp-this._xHeight;var Hp=this;Ou.forEach(function(wp,Dp){for(var dp,Rp=wp.start,xp=wp.end,cm=wp.width,lm=Rp;lm<xp;lm++){var vp=Lu.charCodeAt(lm),bp=Hp.getGlyph(Du,vp);if(bp){dp&&(Hu+=Mu(Du,dp.id,bp.id));var kp=Hu;Cp===1?kp+=(Zu-cm)/2:Cp===2&&(kp+=Zu-cm),_u.push({position:[kp,Yu],data:bp,index:lm,line:Dp}),Hu+=bp.xadvance+gp,dp=bp}}Yu+=Ku,Hu=0}),this._linesTotal=Ou.length},vu.prototype._setupSpaceGlyphs=function(Bu){if(this._fallbackSpaceGlyph=null,this._fallbackTabGlyph=null,Bu.chars&&Bu.chars.length!==0){var _u=Iu(Bu,xu)||function(Du){for(var Ou=0;Ou<fu.length;Ou++){var Wu=fu[Ou].charCodeAt(0),Zu=ku(Du.chars,Wu);if(Zu>=0)return Du.chars[Zu]}return 0}(Bu)||Bu.chars[0],Lu=this._opt.tabSize*_u.xadvance;this._fallbackSpaceGlyph=_u,this._fallbackTabGlyph=au(_u,{x:0,y:0,xadvance:Lu,id:yu,xoffset:0,yoffset:0,width:0,height:0})}},vu.prototype.getGlyph=function(Bu,_u){return Iu(Bu,_u)||(_u===yu?this._fallbackTabGlyph:_u===xu?this._fallbackSpaceGlyph:null)},vu.prototype.computeMetrics=function(Bu,_u,Lu,Du){var Ou,Wu=this._opt.letterSpacing||0,Zu=this._opt.font,Hu=0,Yu=0,Ku=0;if(!Zu.chars||Zu.chars.length===0)return{start:_u,end:_u,width:0};Lu=Math.min(Bu.length,Lu);for(var ju=_u;ju<Lu;ju++){var tp,gp=Bu.charCodeAt(ju);if(tp=this.getGlyph(Zu,gp)){tp.xoffset;var yp=(Hu+=Ou?Mu(Zu,Ou.id,tp.id):0)+tp.xadvance+Wu,Cp=Hu+tp.width;if(Cp>=Du||yp>=Du)break;Hu=yp,Yu=Cp,Ou=tp}Ku++}return Ou&&(Yu+=Ou.xoffset),{start:_u,end:_u+Ku,width:Yu}},["width","height","descender","ascender","xHeight","baseline","capHeight","lineHeight"].forEach(function(Bu){Object.defineProperty(vu.prototype,Bu,{get:Su(Bu),configurable:!0})})},5751:(iu,eu,tu)=>{var su=tu(9922).hp,au=tu(3558),uu=function(){},du=tu(1476),fu=tu(7034),gu=tu(7480),yu=tu(573),xu=tu(4597),vu=self.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest;iu.exports=function(Su,Iu){Iu=typeof Iu=="function"?Iu:uu,typeof Su=="string"?Su={uri:Su}:Su||(Su={}),Su.binary&&(Su=function(Mu){if(vu)return xu(Mu,{responseType:"arraybuffer"});if(self.XMLHttpRequest===void 0)throw new Error("your browser does not support XHR loading");var ku=new self.XMLHttpRequest;return ku.overrideMimeType("text/plain; charset=x-user-defined"),xu({xhr:ku},Mu)}(Su)),au(Su,function(Mu,ku,Bu){if(Mu)return Iu(Mu);if(!/^2/.test(ku.statusCode))return Iu(new Error("http status code: "+ku.statusCode));if(!Bu)return Iu(new Error("no body result"));var _u,Lu,Du=!1;if(_u=Bu,Object.prototype.toString.call(_u)==="[object ArrayBuffer]"){var Ou=new Uint8Array(Bu);Bu=su.from(Ou,"binary")}yu(Bu)&&(Du=!0,typeof Bu=="string"&&(Bu=su.from(Bu,"binary"))),Du||(su.isBuffer(Bu)&&(Bu=Bu.toString(Su.encoding)),Bu=Bu.trim());try{var Wu=ku.headers["content-type"];Lu=Du?gu(Bu):/json/.test(Wu)||Bu.charAt(0)==="{"?JSON.parse(Bu):/xml/.test(Wu)||Bu.charAt(0)==="<"?fu(Bu):du(Bu)}catch(Zu){Iu(new Error("error parsing font "+Zu.message)),Iu=uu}Iu(null,Lu)})}},573:(iu,eu,tu)=>{var su=tu(9922).hp,au=tu(911),uu=su.from([66,77,70,3]);iu.exports=function(du){return typeof du=="string"?du.substring(0,3)==="BMF":du.length>4&&au(du.slice(0,4),uu)}},9192:iu=>{var eu=1e3,tu=60*eu,su=60*tu,au=24*su,uu=7*au;function du(fu,gu,yu,xu){var vu=gu>=1.5*yu;return Math.round(fu/yu)+" "+xu+(vu?"s":"")}iu.exports=function(fu,gu){gu=gu||{};var yu,xu,vu=typeof fu;if(vu==="string"&&fu.length>0)return function(Su){if(!((Su=String(Su)).length>100)){var Iu=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(Su);if(Iu){var Mu=parseFloat(Iu[1]);switch((Iu[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*Mu;case"weeks":case"week":case"w":return Mu*uu;case"days":case"day":case"d":return Mu*au;case"hours":case"hour":case"hrs":case"hr":case"h":return Mu*su;case"minutes":case"minute":case"mins":case"min":case"m":return Mu*tu;case"seconds":case"second":case"secs":case"sec":case"s":return Mu*eu;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return Mu;default:return}}}}(fu);if(vu==="number"&&isFinite(fu))return gu.long?(yu=fu,(xu=Math.abs(yu))>=au?du(yu,xu,au,"day"):xu>=su?du(yu,xu,su,"hour"):xu>=tu?du(yu,xu,tu,"minute"):xu>=eu?du(yu,xu,eu,"second"):yu+" ms"):function(Su){var Iu=Math.abs(Su);return Iu>=au?Math.round(Su/au)+"d":Iu>=su?Math.round(Su/su)+"h":Iu>=tu?Math.round(Su/tu)+"m":Iu>=eu?Math.round(Su/eu)+"s":Su+"ms"}(fu);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(fu))}},1476:iu=>{function eu(su,au){if(!(su=su.replace(/\t+/g," ").trim()))return null;var uu=su.indexOf(" ");if(uu===-1)throw new Error("no named row at line "+au);var du=su.substring(0,uu);su=(su=(su=(su=su.substring(uu+1)).replace(/letter=[\'\"]\S+[\'\"]/gi,"")).split("=")).map(function(vu){return vu.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)});for(var fu=[],gu=0;gu<su.length;gu++){var yu=su[gu];gu===0?fu.push({key:yu[0],data:""}):gu===su.length-1?fu[fu.length-1].data=tu(yu[0]):(fu[fu.length-1].data=tu(yu[0]),fu.push({key:yu[1],data:""}))}var xu={key:du,data:{}};return fu.forEach(function(vu){xu.data[vu.key]=vu.data}),xu}function tu(su){return su&&su.length!==0?su.indexOf('"')===0||su.indexOf("'")===0?su.substring(1,su.length-1):su.indexOf(",")!==-1?function(au){return au.split(",").map(function(uu){return parseInt(uu,10)})}(su):parseInt(su,10):""}iu.exports=function(su){if(!su)throw new Error("no data provided");var au={pages:[],chars:[],kernings:[]},uu=(su=su.toString().trim()).split(/\r\n?|\n/g);if(uu.length===0)throw new Error("no data in BMFont file");for(var du=0;du<uu.length;du++){var fu=eu(uu[du],du);if(fu)if(fu.key==="page"){if(typeof fu.data.id!="number")throw new Error("malformed file at line "+du+" -- needs page id=N");if(typeof fu.data.file!="string")throw new Error("malformed file at line "+du+' -- needs page file="path"');au.pages[fu.data.id]=fu.data.file}else fu.key==="chars"||fu.key==="kernings"||(fu.key==="char"?au.chars.push(fu.data):fu.key==="kerning"?au.kernings.push(fu.data):au[fu.key]=fu.data)}return au}},7480:iu=>{var eu=[66,77,70];function tu(au,uu,du){if(du>uu.length-1)return 0;var fu=uu.readUInt8(du++),gu=uu.readInt32LE(du);switch(du+=4,fu){case 1:au.info=function(yu,xu){var vu={};vu.size=yu.readInt16LE(xu);var Su=yu.readUInt8(xu+2);return vu.smooth=Su>>7&1,vu.unicode=Su>>6&1,vu.italic=Su>>5&1,vu.bold=Su>>4&1,Su>>3&1&&(vu.fixedHeight=1),vu.charset=yu.readUInt8(xu+3)||"",vu.stretchH=yu.readUInt16LE(xu+4),vu.aa=yu.readUInt8(xu+6),vu.padding=[yu.readInt8(xu+7),yu.readInt8(xu+8),yu.readInt8(xu+9),yu.readInt8(xu+10)],vu.spacing=[yu.readInt8(xu+11),yu.readInt8(xu+12)],vu.outline=yu.readUInt8(xu+13),vu.face=function(Iu,Mu){return su(Iu,Mu).toString("utf8")}(yu,xu+14),vu}(uu,du);break;case 2:au.common=function(yu,xu){var vu={};return vu.lineHeight=yu.readUInt16LE(xu),vu.base=yu.readUInt16LE(xu+2),vu.scaleW=yu.readUInt16LE(xu+4),vu.scaleH=yu.readUInt16LE(xu+6),vu.pages=yu.readUInt16LE(xu+8),yu.readUInt8(xu+10),vu.packed=0,vu.alphaChnl=yu.readUInt8(xu+11),vu.redChnl=yu.readUInt8(xu+12),vu.greenChnl=yu.readUInt8(xu+13),vu.blueChnl=yu.readUInt8(xu+14),vu}(uu,du);break;case 3:au.pages=function(yu,xu,vu){for(var Su=[],Iu=su(yu,xu),Mu=Iu.length+1,ku=vu/Mu,Bu=0;Bu<ku;Bu++)Su[Bu]=yu.slice(xu,xu+Iu.length).toString("utf8"),xu+=Mu;return Su}(uu,du,gu);break;case 4:au.chars=function(yu,xu,vu){for(var Su=[],Iu=vu/20,Mu=0;Mu<Iu;Mu++){var ku={},Bu=20*Mu;ku.id=yu.readUInt32LE(xu+0+Bu),ku.x=yu.readUInt16LE(xu+4+Bu),ku.y=yu.readUInt16LE(xu+6+Bu),ku.width=yu.readUInt16LE(xu+8+Bu),ku.height=yu.readUInt16LE(xu+10+Bu),ku.xoffset=yu.readInt16LE(xu+12+Bu),ku.yoffset=yu.readInt16LE(xu+14+Bu),ku.xadvance=yu.readInt16LE(xu+16+Bu),ku.page=yu.readUInt8(xu+18+Bu),ku.chnl=yu.readUInt8(xu+19+Bu),Su[Mu]=ku}return Su}(uu,du,gu);break;case 5:au.kernings=function(yu,xu,vu){for(var Su=[],Iu=vu/10,Mu=0;Mu<Iu;Mu++){var ku={},Bu=10*Mu;ku.first=yu.readUInt32LE(xu+0+Bu),ku.second=yu.readUInt32LE(xu+4+Bu),ku.amount=yu.readInt16LE(xu+8+Bu),Su[Mu]=ku}return Su}(uu,du,gu)}return 5+gu}function su(au,uu){for(var du=uu;du<au.length&&au[du]!==0;du++);return au.slice(uu,du)}iu.exports=function(au){if(au.length<6)throw new Error("invalid buffer length for BMFont");var uu=eu.every(function(yu,xu){return au.readUInt8(xu)===yu});if(!uu)throw new Error("BMFont missing BMF byte header");var du=3;if(au.readUInt8(du++)>3)throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");for(var fu={kernings:[],chars:[]},gu=0;gu<5;gu++)du+=tu(fu,au,du);return fu}},7034:(iu,eu,tu)=>{var su=tu(7829),au=tu(1896),uu={scaleh:"scaleH",scalew:"scaleW",stretchh:"stretchH",lineheight:"lineHeight",alphachnl:"alphaChnl",redchnl:"redChnl",greenchnl:"greenChnl",bluechnl:"blueChnl"};function du(fu){var gu=function(yu){for(var xu=[],vu=0;vu<yu.attributes.length;vu++)xu.push(yu.attributes[vu]);return xu}(fu);return gu.reduce(function(yu,xu){var vu;return yu[vu=xu.nodeName,uu[vu.toLowerCase()]||vu]=xu.nodeValue,yu},{})}iu.exports=function(fu){fu=fu.toString();var gu=au(fu),yu={pages:[],chars:[],kernings:[]};["info","common"].forEach(function(Bu){var _u=gu.getElementsByTagName(Bu)[0];_u&&(yu[Bu]=su(du(_u)))});var xu=gu.getElementsByTagName("pages")[0];if(!xu)throw new Error("malformed file -- no <pages> element");for(var vu=xu.getElementsByTagName("page"),Su=0;Su<vu.length;Su++){var Iu=vu[Su],Mu=parseInt(Iu.getAttribute("id"),10),ku=Iu.getAttribute("file");if(isNaN(Mu))throw new Error('malformed file -- page "id" attribute is NaN');if(!ku)throw new Error('malformed file -- needs page "file" attribute');yu.pages[parseInt(Mu,10)]=ku}return["chars","kernings"].forEach(function(Bu){var _u=gu.getElementsByTagName(Bu)[0];if(_u)for(var Lu=Bu.substring(0,Bu.length-1),Du=_u.getElementsByTagName(Lu),Ou=0;Ou<Du.length;Ou++){var Wu=Du[Ou];yu[Bu].push(su(du(Wu)))}}),yu}},7829:iu=>{var eu="chasrset";iu.exports=function(tu){for(var su in tu=Object.assign({},tu),eu in tu&&(tu.charset=tu[eu],delete tu[eu]),tu)su!=="face"&&su!=="charset"&&(tu[su]=su==="padding"||su==="spacing"?tu[su].split(",").map(function(au){return parseInt(au,10)}):parseInt(tu[su],10));return tu}},3216:iu=>{var eu=function(tu){return tu.replace(/^\s+|\s+$/g,"")};iu.exports=function(tu){if(!tu)return{};for(var su,au={},uu=eu(tu).split(`
`),du=0;du<uu.length;du++){var fu=uu[du],gu=fu.indexOf(":"),yu=eu(fu.slice(0,gu)).toLowerCase(),xu=eu(fu.slice(gu+1));au[yu]===void 0?au[yu]=xu:(su=au[yu],Object.prototype.toString.call(su)==="[object Array]"?au[yu].push(xu):au[yu]=[au[yu],xu])}return au}},9035:(iu,eu,tu)=>{var su=tu(8480),au=tu(8167),uu=tu(2225),du=[0,2,3],fu=[2,1,3];iu.exports=function(gu,yu){gu&&(au(gu)||uu(gu))||(yu=gu||{},gu=null);for(var xu=typeof(yu=typeof yu=="number"?{count:yu}:yu||{}).type=="string"?yu.type:"uint16",vu=typeof yu.count=="number"?yu.count:1,Su=yu.start||0,Iu=yu.clockwise!==!1?du:fu,Mu=Iu[0],ku=Iu[1],Bu=Iu[2],_u=6*vu,Lu=gu||new(su(xu))(_u),Du=0,Ou=0;Du<_u;Du+=6,Ou+=4){var Wu=Du+Su;Lu[Wu+0]=Ou+0,Lu[Wu+1]=Ou+1,Lu[Wu+2]=Ou+2,Lu[Wu+3]=Ou+Mu,Lu[Wu+4]=Ou+ku,Lu[Wu+5]=Ou+Bu}return Lu}},4433:(iu,eu,tu)=>{var su=tu(5651),au=tu(9035),uu=tu(7106),du=tu(1684);iu.exports=function(gu){return new fu(gu)};class fu extends THREE.BufferGeometry{constructor(yu){super(),typeof yu=="string"&&(yu={text:yu}),this._opt=Object.assign({},yu),yu&&this.update(yu)}update(yu){if(typeof yu=="string"&&(yu={text:yu}),!(yu=Object.assign({},this._opt,yu)).font)throw new TypeError("must specify a { font } in options");this.layout=su(yu);var xu=yu.flipY!==!1,vu=yu.font,Su=vu.common.scaleW,Iu=vu.common.scaleH,Mu=this.layout.glyphs.filter(function(Du){var Ou=Du.data;return Ou.width*Ou.height>0});this.visibleGlyphs=Mu;var ku=uu.positions(Mu),Bu=uu.uvs(Mu,Su,Iu,xu),_u=au([],{clockwise:!0,type:"uint16",count:Mu.length});if(this.setIndex(_u),this.setAttribute("position",new THREE.BufferAttribute(ku,2)),this.setAttribute("uv",new THREE.BufferAttribute(Bu,2)),!yu.multipage&&"page"in this.attributes)this.removeAttribute("page");else if(yu.multipage){var Lu=uu.pages(Mu);this.setAttribute("page",new THREE.BufferAttribute(Lu,1))}this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere()}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new THREE.Sphere);var yu=this.attributes.position.array,xu=this.attributes.position.itemSize;if(!yu||!xu||yu.length<2)return this.boundingSphere.radius=0,void this.boundingSphere.center.set(0,0,0);du.computeSphere(yu,this.boundingSphere),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new THREE.Box3);var yu=this.boundingBox,xu=this.attributes.position.array,vu=this.attributes.position.itemSize;!xu||!vu||xu.length<2?yu.makeEmpty():du.computeBox(xu,yu)}}},1684:iu=>{var eu={min:[0,0],max:[0,0]};function tu(su){var au=su.length/2;eu.min[0]=su[0],eu.min[1]=su[1],eu.max[0]=su[0],eu.max[1]=su[1];for(var uu=0;uu<au;uu++){var du=su[2*uu+0],fu=su[2*uu+1];eu.min[0]=Math.min(du,eu.min[0]),eu.min[1]=Math.min(fu,eu.min[1]),eu.max[0]=Math.max(du,eu.max[0]),eu.max[1]=Math.max(fu,eu.max[1])}}iu.exports.computeBox=function(su,au){tu(su),au.min.set(eu.min[0],eu.min[1],0),au.max.set(eu.max[0],eu.max[1],0)},iu.exports.computeSphere=function(su,au){tu(su);var uu=eu.min[0],du=eu.min[1],fu=eu.max[0]-uu,gu=eu.max[1]-du,yu=Math.sqrt(fu*fu+gu*gu);au.center.set(uu+fu/2,du+gu/2,0),au.radius=yu/2}},7106:iu=>{iu.exports.pages=function(eu){var tu=new Float32Array(4*eu.length*1),su=0;return eu.forEach(function(au){var uu=au.data.page||0;tu[su++]=uu,tu[su++]=uu,tu[su++]=uu,tu[su++]=uu}),tu},iu.exports.uvs=function(eu,tu,su,au){var uu=new Float32Array(4*eu.length*2),du=0;return eu.forEach(function(fu){var gu=fu.data,yu=gu.x+gu.width,xu=gu.y+gu.height,vu=gu.x/tu,Su=gu.y/su,Iu=yu/tu,Mu=xu/su;au&&(Su=(su-gu.y)/su,Mu=(su-xu)/su),uu[du++]=vu,uu[du++]=Su,uu[du++]=vu,uu[du++]=Mu,uu[du++]=Iu,uu[du++]=Mu,uu[du++]=Iu,uu[du++]=Su}),uu},iu.exports.positions=function(eu){var tu=new Float32Array(4*eu.length*2),su=0;return eu.forEach(function(au){var uu=au.data,du=au.position[0]+uu.xoffset,fu=au.position[1]+uu.yoffset,gu=uu.width,yu=uu.height;tu[su++]=du,tu[su++]=fu,tu[su++]=du,tu[su++]=fu+yu,tu[su++]=du+gu,tu[su++]=fu+yu,tu[su++]=du+gu,tu[su++]=fu}),tu}},5406:iu=>{var eu=/\n/,tu=/\s/;function su(du,fu,gu,yu){var xu=du.indexOf(fu,gu);return xu===-1||xu>yu?yu:xu}function au(du){return tu.test(du)}function uu(du,fu,gu,yu){return{start:fu,end:fu+Math.min(yu,gu-fu)}}iu.exports=function(du,fu){return iu.exports.lines(du,fu).map(function(gu){return du.substring(gu.start,gu.end)}).join(`
`)},iu.exports.lines=function(du,fu){if((fu=fu||{}).width===0&&fu.mode!=="nowrap")return[];du=du||"";var gu=typeof fu.width=="number"?fu.width:Number.MAX_VALUE,yu=Math.max(0,fu.start||0),xu=typeof fu.end=="number"?fu.end:du.length,vu=fu.mode,Su=fu.measure||uu;return vu==="pre"?function(Iu,Mu,ku,Bu,_u){for(var Lu=[],Du=ku,Ou=ku;Ou<Bu&&Ou<Mu.length;Ou++){var Wu=Mu.charAt(Ou),Zu=eu.test(Wu);if(Zu||Ou===Bu-1){var Hu=Iu(Mu,Du,Zu?Ou:Ou+1,_u);Lu.push(Hu),Du=Ou+1}}return Lu}(Su,du,yu,xu,gu):function(Iu,Mu,ku,Bu,_u,Lu){var Du=[],Ou=_u;for(Lu==="nowrap"&&(Ou=Number.MAX_VALUE);ku<Bu&&ku<Mu.length;){for(var Wu=su(Mu,`
`,ku,Bu);ku<Wu&&au(Mu.charAt(ku));)ku++;var Zu=Iu(Mu,ku,Wu,Ou),Hu=ku+(Zu.end-Zu.start),Yu=Hu+1;if(Hu<Wu){for(;Hu>ku&&!au(Mu.charAt(Hu));)Hu--;if(Hu===ku)Yu>ku+1&&Yu--,Hu=Yu;else for(Yu=Hu;Hu>ku&&au(Mu.charAt(Hu-1));)Hu--}if(Hu>=ku){var Ku=Iu(Mu,ku,Hu,Ou);Du.push(Ku)}ku=Yu}return Du}(Su,du,yu,xu,gu,vu)}},3558:(iu,eu,tu)=>{var su=tu(919),au=tu(8847),uu=tu(3216),du=tu(4597);function fu(xu,vu,Su){var Iu=xu;return au(vu)?(Su=vu,typeof xu=="string"&&(Iu={uri:xu})):Iu=du(vu,{uri:xu}),Iu.callback=Su,Iu}function gu(xu,vu,Su){return yu(vu=fu(xu,vu,Su))}function yu(xu){if(xu.callback===void 0)throw new Error("callback argument missing");var vu=!1,Su=function(tp,gp,yp){vu||(vu=!0,xu.callback(tp,gp,yp))};function Iu(){var tp=void 0;if(tp=Lu.response?Lu.response:Lu.responseText||function(gp){try{if(gp.responseType==="document")return gp.responseXML;var yp=gp.responseXML&&gp.responseXML.documentElement.nodeName==="parsererror";if(gp.responseType===""&&!yp)return gp.responseXML}catch{}return null}(Lu),Ku)try{tp=JSON.parse(tp)}catch{}return tp}function Mu(tp){return clearTimeout(Du),tp instanceof Error||(tp=new Error(""+(tp||"Unknown XMLHttpRequest Error"))),tp.statusCode=0,Su(tp,ju)}function ku(){if(!_u){var tp;clearTimeout(Du),tp=xu.useXDR&&Lu.status===void 0?200:Lu.status===1223?204:Lu.status;var gp=ju,yp=null;return tp!==0?(gp={body:Iu(),statusCode:tp,method:Wu,headers:{},url:Ou,rawRequest:Lu},Lu.getAllResponseHeaders&&(gp.headers=uu(Lu.getAllResponseHeaders()))):yp=new Error("Internal XMLHttpRequest Error"),Su(yp,gp,gp.body)}}var Bu,_u,Lu=xu.xhr||null;Lu||(Lu=xu.cors||xu.useXDR?new gu.XDomainRequest:new gu.XMLHttpRequest);var Du,Ou=Lu.url=xu.uri||xu.url,Wu=Lu.method=xu.method||"GET",Zu=xu.body||xu.data,Hu=Lu.headers=xu.headers||{},Yu=!!xu.sync,Ku=!1,ju={body:void 0,headers:{},statusCode:0,method:Wu,url:Ou,rawRequest:Lu};if("json"in xu&&xu.json!==!1&&(Ku=!0,Hu.accept||Hu.Accept||(Hu.Accept="application/json"),Wu!=="GET"&&Wu!=="HEAD"&&(Hu["content-type"]||Hu["Content-Type"]||(Hu["Content-Type"]="application/json"),Zu=JSON.stringify(xu.json===!0?Zu:xu.json))),Lu.onreadystatechange=function(){Lu.readyState===4&&setTimeout(ku,0)},Lu.onload=ku,Lu.onerror=Mu,Lu.onprogress=function(){},Lu.onabort=function(){_u=!0},Lu.ontimeout=Mu,Lu.open(Wu,Ou,!Yu,xu.username,xu.password),Yu||(Lu.withCredentials=!!xu.withCredentials),!Yu&&xu.timeout>0&&(Du=setTimeout(function(){if(!_u){_u=!0,Lu.abort("timeout");var tp=new Error("XMLHttpRequest timeout");tp.code="ETIMEDOUT",Mu(tp)}},xu.timeout)),Lu.setRequestHeader)for(Bu in Hu)Hu.hasOwnProperty(Bu)&&Lu.setRequestHeader(Bu,Hu[Bu]);else if(xu.headers&&!function(tp){for(var gp in tp)if(tp.hasOwnProperty(gp))return!1;return!0}(xu.headers))throw new Error("Headers cannot be set on an XDomainRequest object");return"responseType"in xu&&(Lu.responseType=xu.responseType),"beforeSend"in xu&&typeof xu.beforeSend=="function"&&xu.beforeSend(Lu),Lu.send(Zu||null),Lu}iu.exports=gu,iu.exports.default=gu,gu.XMLHttpRequest=su.XMLHttpRequest||function(){},gu.XDomainRequest="withCredentials"in new gu.XMLHttpRequest?gu.XMLHttpRequest:su.XDomainRequest,function(xu,vu){for(var Su=0;Su<xu.length;Su++)vu(xu[Su])}(["get","put","post","patch","head","delete"],function(xu){gu[xu==="delete"?"del":xu]=function(vu,Su,Iu){return(Su=fu(vu,Su,Iu)).method=xu.toUpperCase(),yu(Su)}})},1896:iu=>{iu.exports=self.DOMParser!==void 0?function(eu){return new self.DOMParser().parseFromString(eu,"application/xml")}:self.ActiveXObject!==void 0&&new self.ActiveXObject("Microsoft.XMLDOM")?function(eu){var tu=new self.ActiveXObject("Microsoft.XMLDOM");return tu.async="false",tu.loadXML(eu),tu}:function(eu){var tu=document.createElement("div");return tu.innerHTML=eu,tu}},4597:iu=>{iu.exports=function(){for(var tu={},su=0;su<arguments.length;su++){var au=arguments[su];for(var uu in au)eu.call(au,uu)&&(tu[uu]=au[uu])}return tu};var eu=Object.prototype.hasOwnProperty},8132:()=>{window.aframeStats=function(iu){var eu=null,tu=iu;return{update:function(){var su;eu("te").set((su=tu.querySelectorAll("*"),Array.prototype.slice.call(su).filter(function(au){return au.isEntity}),su.length)),window.performance.getEntriesByName&&eu("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0))},start:function(){},end:function(){},attach:function(su){eu=su},values:{te:{caption:"Entities"},lt:{caption:"Load Time"}},groups:[{caption:"A-Frame",values:["te","lt"]}],fractions:[]}}},3729:iu=>{window.glStats=function(){var eu=null,tu=0,su=0,au=0,uu=0,du=0,fu=0,gu=0;function yu(xu,vu){return function(){vu.apply(this,arguments),xu.apply(this,arguments)}}return WebGLRenderingContext.prototype.drawArrays=yu(WebGLRenderingContext.prototype.drawArrays,function(){tu++,arguments[0]==this.POINTS?fu+=arguments[2]:du+=arguments[2]}),WebGLRenderingContext.prototype.drawElements=yu(WebGLRenderingContext.prototype.drawElements,function(){su++,uu+=arguments[1]/3,du+=arguments[1]}),WebGLRenderingContext.prototype.useProgram=yu(WebGLRenderingContext.prototype.useProgram,function(){au++}),WebGLRenderingContext.prototype.bindTexture=yu(WebGLRenderingContext.prototype.bindTexture,function(){gu++}),{update:function(){eu("allcalls").set(tu+su),eu("drawElements").set(su),eu("drawArrays").set(tu),eu("bindTexture").set(gu),eu("useProgram").set(au),eu("glfaces").set(uu),eu("glvertices").set(du),eu("glpoints").set(fu)},start:function(){tu=0,su=0,au=0,uu=0,du=0,fu=0,gu=0},end:function(){},attach:function(xu){eu=xu},values:{allcalls:{over:3e3,caption:"Calls (hook)"},drawelements:{caption:"drawElements (hook)"},drawarrays:{caption:"drawArrays (hook)"}},groups:[{caption:"WebGL",values:["allcalls","drawelements","drawarrays","useprogram","bindtexture","glfaces","glvertices","glpoints"]}],fractions:[{base:"allcalls",steps:["drawelements","drawarrays"]}]}},window.threeStats=function(eu){var tu=null;return{update:function(){var su;tu("renderer.info.memory.geometries").set(eu.info.memory.geometries),tu("renderer.info.programs").set(((su=eu.info.programs)==null?void 0:su.length)??NaN),tu("renderer.info.memory.textures").set(eu.info.memory.textures),tu("renderer.info.render.calls").set(eu.info.render.calls),tu("renderer.info.render.triangles").set(eu.info.render.triangles),tu("renderer.info.render.points").set(eu.info.render.points)},start:function(){},end:function(){},attach:function(su){tu=su},values:{"renderer.info.memory.geometries":{caption:"Geometries"},"renderer.info.memory.textures":{caption:"Textures"},"renderer.info.programs":{caption:"Programs"},"renderer.info.render.calls":{caption:"Calls"},"renderer.info.render.triangles":{caption:"Triangles",over:1e3},"renderer.info.render.points":{caption:"Points"}},groups:[{caption:"Three.js - Memory",values:["renderer.info.memory.geometries","renderer.info.programs","renderer.info.memory.textures"]},{caption:"Three.js - Render",values:["renderer.info.render.calls","renderer.info.render.triangles","renderer.info.render.points"]}],fractions:[]}},window.BrowserStats=function(){var eu=null,tu=0,su=0;window.performance&&!performance.memory&&(performance.memory={usedJSHeapSize:0,totalJSHeapSize:0}),performance.memory.totalJSHeapSize===0&&console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");var au=Math.log(1024);function uu(du){var fu=Math.floor(Math.log(du)/au);return Math.round(100*du/Math.pow(1024,fu))/100}return{update:function(){tu=uu(performance.memory.usedJSHeapSize),su=uu(performance.memory.totalJSHeapSize),eu("memory").set(tu),eu("total").set(su)},start:function(){tu=0},end:function(){},attach:function(du){eu=du},values:{memory:{caption:"Used Memory",average:!0,avgMs:1e3,over:22},total:{caption:"Total Memory"}},groups:[{caption:"Browser",values:["memory","total"]}],fractions:[{base:"total",steps:["memory"]}]}},iu.exports={glStats:window.glStats,threeStats:window.threeStats,BrowserStats:window.BrowserStats}},282:iu=>{(function(){"performance"in window==0&&(window.performance={});var eu=window.performance;if("now"in eu==0){var tu=Date.now();eu.timing&&eu.timing.navigationStart&&(tu=eu.timing.navigationStart),eu.now=function(){return Date.now()-tu}}eu.mark||(eu.mark=function(){}),eu.measure||(eu.measure=function(){})})(),window.rStats=function(eu){function tu(ku,Bu){for(var _u=Object.keys(ku),Lu=0,Du=_u.length;Lu<Du;Lu++)Bu(_u[Lu])}var su=eu||{},au=su.colours||["#850700","#c74900","#fcb300","#284280","#4c7c0c"],uu=(su.CSSPath?su.CSSPath:"")+"rStats.css";(su.css||["https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300",uu]).forEach(function(ku){var Bu,_u;Bu=ku,(_u=document.createElement("link")).href=Bu,_u.rel="stylesheet",_u.type="text/css",document.getElementsByTagName("head")[0].appendChild(_u)}),su.values||(su.values={});var du,fu,gu=10,yu={};function xu(ku,Bu,_u){var Lu=_u||{},Du=document.createElement("canvas"),Ou=Du.getContext("2d"),Wu=0,Zu=0,Hu=Lu.color?Lu.color:"#666666",Yu=document.createElement("canvas"),Ku=Yu.getContext("2d");Yu.width=1,Yu.height=20,Ku.fillStyle="#444444",Ku.fillRect(0,0,1,20),Ku.fillStyle=Hu,Ku.fillRect(0,gu,1,gu),Ku.fillStyle="#ffffff",Ku.globalAlpha=.5,Ku.fillRect(0,gu,1,1),Ku.globalAlpha=1;var ju=document.createElement("canvas"),tp=ju.getContext("2d");return ju.width=1,ju.height=20,tp.fillStyle="#444444",tp.fillRect(0,0,1,20),tp.fillStyle="#b70000",tp.fillRect(0,gu,1,gu),tp.globalAlpha=.5,tp.fillStyle="#ffffff",tp.fillRect(0,gu,1,1),tp.globalAlpha=1,Du.width=200,Du.height=gu,Du.style.width=Du.width+"px",Du.style.height=Du.height+"px",Du.className="rs-canvas",ku.appendChild(Du),Ou.fillStyle="#444444",Ou.fillRect(0,0,Du.width,Du.height),{draw:function(gp,yp){(Zu+=.1*(gp-Zu))>(Wu*=.99)&&(Wu=Zu),Ou.drawImage(Du,1,0,Du.width-1,Du.height,0,0,Du.width-1,Du.height),yp?Ou.drawImage(ju,Du.width-1,Du.height-Zu*Du.height/Wu-gu):Ou.drawImage(Yu,Du.width-1,Du.height-Zu*Du.height/Wu-gu)}}}function vu(ku,Bu){var _u=document.createElement("canvas"),Lu=_u.getContext("2d");return _u.width=200,_u.height=gu*Bu,_u.style.width=_u.width+"px",_u.style.height=_u.height+"px",_u.className="rs-canvas",ku.appendChild(_u),Lu.fillStyle="#444444",Lu.fillRect(0,0,_u.width,_u.height),{draw:function(Du){Lu.drawImage(_u,1,0,_u.width-1,_u.height,0,0,_u.width-1,_u.height);var Ou=0;tu(Du,function(Wu){var Zu=Du[Wu]*_u.height;Lu.fillStyle=au[Wu],Lu.fillRect(_u.width-1,Ou,1,Zu),Ou+=Zu})}}}function Su(ku,Bu){var _u,Lu=ku,Du=0,Ou=0,Wu=0,Zu=0,Hu=performance.now(),Yu=0,Ku=document.createElement("div"),ju=document.createElement("span"),tp=document.createElement("div"),gp=document.createTextNode(""),yp=su?su.values[Lu.toLowerCase()]:null,Cp=new xu(Ku,Lu,yp),Hp=!1;function wp(Rp){if(yp&&yp.average){Zu+=Rp,Yu++;var xp=performance.now();xp-Hu>=(yp.avgMs||1e3)&&(Wu=Zu/Yu,Zu=0,Hu=xp,Yu=0)}}function Dp(){_u=performance.now(),su.userTimingAPI&&performance.mark(Lu+"-start"),Hp=!0}function dp(){Du=performance.now()-_u,su.userTimingAPI&&(performance.mark(Lu+"-end"),Hp&&performance.measure(Lu,Lu+"-start",Lu+"-end")),wp(Du)}return ju.className="rs-counter-id",ju.textContent=yp&&yp.caption?yp.caption:Lu,tp.className="rs-counter-value",tp.appendChild(gp),Ku.appendChild(ju),Ku.appendChild(tp),Bu?Bu.div.appendChild(Ku):fu.appendChild(Ku),_u=performance.now(),{set:function(Rp){wp(Du=Rp)},start:Dp,tick:function(){dp(),Dp()},end:dp,frame:function(){var Rp=performance.now(),xp=Rp-_u;Ou++,xp>1e3&&(Du=yp&&yp.interpolate===!1?Ou:1e3*Ou/xp,Ou=0,_u=Rp,wp(Du))},value:function(){return Du},draw:function(){var Rp=yp&&yp.average?Wu:Du;gp.nodeValue=Math.round(100*Rp)/100;var xp=yp&&(yp.below&&Du<yp.below||yp.over&&Du>yp.over);Cp.draw(Du,xp),Ku.className=xp?"rs-counter-base alarm":"rs-counter-base"}}}function Iu(ku){var Bu=ku.toLowerCase();if(Bu===void 0&&(Bu="default"),yu[Bu])return yu[Bu];var _u=null;su&&su.groups&&tu(su.groups,function(Du){var Ou=su.groups[parseInt(Du,10)];_u||Ou.values.indexOf(Bu.toLowerCase())===-1||(_u=Ou)});var Lu=new Su(Bu,_u);return yu[Bu]=Lu,Lu}function Mu(){tu(su.plugins,function(ku){su.plugins[ku].update()}),tu(yu,function(ku){yu[ku].draw()}),su&&su.fractions&&tu(su.fractions,function(ku){var Bu=su.fractions[parseInt(ku,10)],_u=[],Lu=yu[Bu.base.toLowerCase()];Lu&&(Lu=Lu.value(),tu(su.fractions[ku].steps,function(Du){var Ou=su.fractions[ku].steps[parseInt(Du,10)].toLowerCase(),Wu=yu[Ou];Wu&&_u.push(Wu.value()/Lu)})),Bu.graph.draw(_u)})}return function(){if(su.plugins){su.values||(su.values={}),su.groups||(su.groups=[]),su.fractions||(su.fractions=[]);for(var ku=0;ku<su.plugins.length;ku++)su.plugins[ku].attach(Iu),tu(su.plugins[ku].values,function(Bu){su.values[Bu]=su.plugins[ku].values[Bu]}),su.groups=su.groups.concat(su.plugins[ku].groups),su.fractions=su.fractions.concat(su.plugins[ku].fractions)}else su.plugins={};(du=document.createElement("div")).className="rs-base",(fu=document.createElement("div")).className="rs-container",fu.style.height="auto",du.appendChild(fu),document.body.appendChild(du),su&&(su.groups&&tu(su.groups,function(Bu){var _u=su.groups[parseInt(Bu,10)],Lu=document.createElement("div");Lu.className="rs-group",_u.div=Lu;var Du=document.createElement("h1");Du.textContent=_u.caption,Du.addEventListener("click",(function(Ou){this.classList.toggle("hidden"),Ou.preventDefault()}).bind(Lu)),fu.appendChild(Du),fu.appendChild(Lu)}),su.fractions&&tu(su.fractions,function(Bu){var _u=su.fractions[parseInt(Bu,10)],Lu=document.createElement("div");Lu.className="rs-fraction";var Du=document.createElement("div");Du.className="rs-legend";var Ou=0;tu(su.fractions[Bu].steps,function(Zu){var Hu=document.createElement("p");Hu.textContent=su.fractions[Bu].steps[Zu],Hu.style.color=au[Ou],Du.appendChild(Hu),Ou++}),Lu.appendChild(Du),Lu.style.height=Ou*gu+"px",_u.div=Lu;var Wu=new vu(Lu,Ou);_u.graph=Wu,fu.appendChild(Lu)}))}(),function(ku){return ku?Iu(ku):{element:du,update:Mu}}},iu.exports=window.rStats},2535:iu=>{var eu={base64:function(tu,su){return"data:"+tu+";base64,"+su},isMobile:function(){var tu,su=!1;return tu=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(tu)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(tu.substr(0,4)))&&(su=!0),su},isIOS:function(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)},isIFrame:function(){try{return window.self!==window.top}catch{return!0}},appendQueryParameter:function(tu,su,au){var uu=tu.indexOf("?")<0?"?":"&";return tu+(uu+su+"=")+au},getQueryParameter:function(tu){tu=tu.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var su=new RegExp("[\\?&]"+tu+"=([^&#]*)").exec(location.search);return su===null?"":decodeURIComponent(su[1].replace(/\+/g," "))},isLandscapeMode:function(){return window.orientation==90||window.orientation==-90}};iu.exports=eu},5928:(iu,eu,tu)=>{var su,au=tu(2535);iu.exports=(su=navigator.userAgent||navigator.vendor||window.opera).match(/iPhone/i)||su.match(/iPod/i)?function(){var uu=null;this.request=function(){uu||(uu=setInterval(function(){window.location.href="/",setTimeout(window.stop,0)},15e3))},this.release=function(){uu&&(clearInterval(uu),uu=null)}}:function(){var uu=document.createElement("video");uu.addEventListener("ended",function(){uu.play()}),this.request=function(){uu.paused&&(uu.src=au.base64("video/webm","GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="),uu.play())},this.release=function(){uu.pause(),uu.src=""}}},8217:(iu,eu,tu)=>{tu.d(eu,{A:()=>Ou});var su=tu(963),au=tu.n(su),uu=tu(9089),du=tu.n(uu),fu=tu(6492),gu=tu.n(fu),yu=new URL(tu(9169),tu.b),xu=new URL(tu(6085),tu.b),vu=new URL(tu(3931),tu.b),Su=new URL(tu(7889),tu.b),Iu=new URL(tu(6517),tu.b),Mu=du()(au()),ku=gu()(yu),Bu=gu()(xu),_u=gu()(vu),Lu=gu()(Su),Du=gu()(Iu);Mu.push([iu.id,`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url(${ku}) 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url(${Bu}) 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url(${_u});
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(${Lu}) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(${Du}) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`,"",{version:3,sources:["webpack://./src/style/aframe.css"],names:[],mappings:"AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB",sourcesContent:[`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E");
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`],sourceRoot:""}]);const Ou=Mu},2470:(iu,eu,tu)=>{tu.d(eu,{A:()=>fu});var su=tu(963),au=tu.n(su),uu=tu(9089),du=tu.n(uu)()(au());du.push([iu.id,`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`,"",{version:3,sources:["webpack://./src/style/rStats.css"],names:[],mappings:"AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF",sourcesContent:[`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`],sourceRoot:""}]);const fu=du},7180:(iu,eu,tu)=>{tu.r(eu),tu.d(eu,{default:()=>_u});var su=tu(5072),au=tu.n(su),uu=tu(7825),du=tu.n(uu),fu=tu(7659),gu=tu.n(fu),yu=tu(5056),xu=tu.n(yu),vu=tu(540),Su=tu.n(vu),Iu=tu(1113),Mu=tu.n(Iu),ku=tu(8217),Bu={};Bu.styleTagTransform=Mu(),Bu.setAttributes=xu(),Bu.insert=gu().bind(null,"head"),Bu.domAPI=du(),Bu.insertStyleElement=Su(),au()(ku.A,Bu);const _u=ku.A&&ku.A.locals?ku.A.locals:void 0},9379:(iu,eu,tu)=>{tu.r(eu),tu.d(eu,{default:()=>_u});var su=tu(5072),au=tu.n(su),uu=tu(7825),du=tu.n(uu),fu=tu(7659),gu=tu.n(fu),yu=tu(5056),xu=tu.n(yu),vu=tu(540),Su=tu.n(vu),Iu=tu(1113),Mu=tu.n(Iu),ku=tu(2470),Bu={};Bu.styleTagTransform=Mu(),Bu.setAttributes=xu(),Bu.insert=gu().bind(null,"head"),Bu.domAPI=du(),Bu.insertStyleElement=Su(),au()(ku.A,Bu);const _u=ku.A&&ku.A.locals?ku.A.locals:void 0},5072:iu=>{var eu=[];function tu(uu){for(var du=-1,fu=0;fu<eu.length;fu++)if(eu[fu].identifier===uu){du=fu;break}return du}function su(uu,du){for(var fu={},gu=[],yu=0;yu<uu.length;yu++){var xu=uu[yu],vu=du.base?xu[0]+du.base:xu[0],Su=fu[vu]||0,Iu="".concat(vu," ").concat(Su);fu[vu]=Su+1;var Mu=tu(Iu),ku={css:xu[1],media:xu[2],sourceMap:xu[3],supports:xu[4],layer:xu[5]};if(Mu!==-1)eu[Mu].references++,eu[Mu].updater(ku);else{var Bu=au(ku,du);du.byIndex=yu,eu.splice(yu,0,{identifier:Iu,updater:Bu,references:1})}gu.push(Iu)}return gu}function au(uu,du){var fu=du.domAPI(du);return fu.update(uu),function(gu){if(gu){if(gu.css===uu.css&&gu.media===uu.media&&gu.sourceMap===uu.sourceMap&&gu.supports===uu.supports&&gu.layer===uu.layer)return;fu.update(uu=gu)}else fu.remove()}}iu.exports=function(uu,du){var fu=su(uu=uu||[],du=du||{});return function(gu){gu=gu||[];for(var yu=0;yu<fu.length;yu++){var xu=tu(fu[yu]);eu[xu].references--}for(var vu=su(gu,du),Su=0;Su<fu.length;Su++){var Iu=tu(fu[Su]);eu[Iu].references===0&&(eu[Iu].updater(),eu.splice(Iu,1))}fu=vu}}},7659:iu=>{var eu={};iu.exports=function(tu,su){var au=function(uu){if(eu[uu]===void 0){var du=document.querySelector(uu);if(window.HTMLIFrameElement&&du instanceof window.HTMLIFrameElement)try{du=du.contentDocument.head}catch{du=null}eu[uu]=du}return eu[uu]}(tu);if(!au)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");au.appendChild(su)}},540:iu=>{iu.exports=function(eu){var tu=document.createElement("style");return eu.setAttributes(tu,eu.attributes),eu.insert(tu,eu.options),tu}},5056:(iu,eu,tu)=>{iu.exports=function(su){var au=tu.nc;au&&su.setAttribute("nonce",au)}},7825:iu=>{iu.exports=function(eu){if(typeof document>"u")return{update:function(){},remove:function(){}};var tu=eu.insertStyleElement(eu);return{update:function(su){(function(au,uu,du){var fu="";du.supports&&(fu+="@supports (".concat(du.supports,") {")),du.media&&(fu+="@media ".concat(du.media," {"));var gu=du.layer!==void 0;gu&&(fu+="@layer".concat(du.layer.length>0?" ".concat(du.layer):""," {")),fu+=du.css,gu&&(fu+="}"),du.media&&(fu+="}"),du.supports&&(fu+="}");var yu=du.sourceMap;yu&&typeof btoa<"u"&&(fu+=`
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(yu))))," */")),uu.styleTagTransform(fu,au,uu.options)})(tu,eu,su)},remove:function(){(function(su){if(su.parentNode===null)return!1;su.parentNode.removeChild(su)})(tu)}}}},1113:iu=>{iu.exports=function(eu,tu){if(tu.styleSheet)tu.styleSheet.cssText=eu;else{for(;tu.firstChild;)tu.removeChild(tu.firstChild);tu.appendChild(document.createTextNode(eu))}}},3931:iu=>{iu.exports="data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"},6085:iu=>{iu.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},9169:iu=>{iu.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},6517:iu=>{iu.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"},7889:iu=>{iu.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"}},n={};function i$1(iu){var eu=n[iu];if(eu!==void 0)return eu.exports;var tu=n[iu]={id:iu,exports:{}};return t[iu](tu,tu.exports,i$1),tu.exports}i$1.m=t,i$1.n=iu=>{var eu=iu&&iu.__esModule?()=>iu.default:()=>iu;return i$1.d(eu,{a:eu}),eu},i$1.d=(iu,eu)=>{for(var tu in eu)i$1.o(eu,tu)&&!i$1.o(iu,tu)&&Object.defineProperty(iu,tu,{enumerable:!0,get:eu[tu]})},i$1.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),i$1.o=(iu,eu)=>Object.prototype.hasOwnProperty.call(iu,eu),i$1.r=iu=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(iu,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(iu,"__esModule",{value:!0})},i$1.b=document.baseURI||self.location.href,i$1.nc=void 0;var r={};i$1.d(r,{A:()=>qc});var o={};i$1.r(o),i$1.d(o,{computeMikkTSpaceTangents:()=>Pe,computeMorphedAttributes:()=>Ke,deepCloneAttribute:()=>je,deinterleaveAttribute:()=>He,deinterleaveGeometry:()=>qe,estimateBytesUsed:()=>Ve,interleaveAttributes:()=>_e,mergeAttributes:()=>Ne,mergeGeometries:()=>Ge,mergeGroups:()=>We,mergeVertices:()=>ze,toCreasedNormals:()=>Je,toTrianglesDrawMode:()=>Ye});var s={};i$1.r(s),i$1.d(s,{checkARSupport:()=>xi,checkHeadsetConnected:()=>wi,checkVRSupport:()=>Qi,isAppleVisionPro:()=>Ti,isBrowserEnvironment:()=>ji,isFirefoxReality:()=>Oi,isIOS:()=>Ri,isIpad:()=>ki,isLandscape:()=>Ni,isMobile:()=>Si,isMobileDeviceRequestingDesktopSite:()=>Fi,isMobileVR:()=>Pi,isNodeEnvironment:()=>_i,isOculusBrowser:()=>Ui,isR7:()=>Gi,isTablet:()=>Di,isWebXRAvailable:()=>bi});var a={};i$1.r(a),i$1.d(a,{clearObject:()=>zi,createPool:()=>Vi,removeUnusedKeys:()=>Yi});var A={};i$1.r(A),i$1.d(A,{equals:()=>er,isCoordinate:()=>nr,isCoordinates:()=>tr,parse:()=>Zi,regex:()=>Ji,stringify:()=>$i,toVector3:()=>rr});var l={};i$1.r(l),i$1.d(l,{getComponentProperty:()=>ar,getComponentPropertyPath:()=>sr,setComponentProperty:()=>Ar});var c={};i$1.r(c),i$1.d(c,{parseUrl:()=>gr,validateCubemapSrc:()=>ur,validateEnvMapSrc:()=>dr,validateSrc:()=>hr});var h={};i$1.r(h),i$1.d(h,{createCompatibleTexture:()=>xr,handleTextureEvents:()=>Ir,isCompatibleTexture:()=>wr,setTextureProperties:()=>Er,updateDistortionMap:()=>Br,updateEnvMap:()=>yr,updateMap:()=>vr,updateMapMaterialFromData:()=>Cr});var d={};i$1.r(d),i$1.d(d,{parse:()=>Lr,stringify:()=>Mr,toCamelCase:()=>Sr});var u={};i$1.r(u),i$1.d(u,{checkControllerPresentAndSetup:()=>Ur,emitIfAxesChanged:()=>Gr,findMatchingControllerWebXR:()=>Pr,isControllerPresentWebXR:()=>Or,onButtonEvent:()=>Nr});var g={};i$1.r(g),i$1.d(g,{bind:()=>_r,checkHeadsetConnected:()=>Hr,clone:()=>Zr,coordinates:()=>A,debounce:()=>Wr,debug:()=>fi,deepEqual:()=>to,device:()=>s,diff:()=>no,entity:()=>l,extend:()=>Jr,extendDeep:()=>Xr,findAllScenes:()=>Ao,forceCanvasResizeSafariMobile:()=>lr,getElData:()=>oo,getUrlParameter:()=>so,isIOS:()=>qr,isIframed:()=>ao,isMobile:()=>Vr,material:()=>h,objectPool:()=>a,shouldCaptureKeyEvent:()=>io,split:()=>or,splitString:()=>ro,srcLoader:()=>c,styleParser:()=>d,throttle:()=>zr,throttleLeadingAndTrailing:()=>Yr,throttleTick:()=>Kr,trackedControls:()=>u});var p={};i$1.r(p),i$1.d(p,{isSingleProperty:()=>No,parseProperties:()=>qo,parseProperty:()=>Vo,process:()=>jo,processPropertyDefinition:()=>_o,stringifyProperties:()=>zo,stringifyProperty:()=>Yo});var f={};i$1.r(f),i$1.d(f,{Component:()=>As,components:()=>Ko,registerComponent:()=>cs,registrationOrderWarnings:()=>ls});var m={};i$1.r(m),i$1.d(m,{System:()=>ms,registerSystem:()=>Es,systems:()=>fs});var E={update:null,begin:null,loopBegin:null,changeBegin:null,change:null,changeComplete:null,loopComplete:null,complete:null,loop:1,direction:"normal",autoplay:!0,timelineOffset:0},C={duration:1e3,delay:0,endDelay:0,easing:"easeOutElastic(1, .5)",round:0},v=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective"],B={CSS:{},springs:{}};function b(iu,eu,tu){return Math.min(Math.max(iu,eu),tu)}function y(iu,eu){return iu.indexOf(eu)>-1}function I(iu,eu){return iu.apply(null,eu)}var w=/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,x=/^rgb/,Q=/^hsl/,L={arr:function(iu){return Array.isArray(iu)},obj:function(iu){return y(Object.prototype.toString.call(iu),"Object")},pth:function(iu){return L.obj(iu)&&iu.hasOwnProperty("totalLength")},svg:function(iu){return iu instanceof SVGElement},inp:function(iu){return iu instanceof HTMLInputElement},dom:function(iu){return iu.nodeType||L.svg(iu)},str:function(iu){return typeof iu=="string"},fnc:function(iu){return typeof iu=="function"},und:function(iu){return iu===void 0},hex:function(iu){return w.test(iu)},rgb:function(iu){return x.test(iu)},hsl:function(iu){return Q.test(iu)},col:function(iu){return L.hex(iu)||L.rgb(iu)||L.hsl(iu)},key:function(iu){return!E.hasOwnProperty(iu)&&!C.hasOwnProperty(iu)&&iu!=="targets"&&iu!=="keyframes"}},M=/\(([^)]+)\)/;function S(iu){var eu=M.exec(iu);return eu?eu[1].split(",").map(function(tu){return parseFloat(tu)}):[]}function D(iu,eu){var tu=S(iu),su=b(L.und(tu[0])?1:tu[0],.1,100),au=b(L.und(tu[1])?100:tu[1],.1,100),uu=b(L.und(tu[2])?10:tu[2],.1,100),du=b(L.und(tu[3])?0:tu[3],.1,100),fu=Math.sqrt(au/su),gu=uu/(2*Math.sqrt(au*su)),yu=gu<1?fu*Math.sqrt(1-gu*gu):0,xu=gu<1?(gu*fu-du)/yu:-du+fu;function vu(Su){var Iu=eu?eu*Su/1e3:Su;return Iu=gu<1?Math.exp(-Iu*gu*fu)*(1*Math.cos(yu*Iu)+xu*Math.sin(yu*Iu)):(1+xu*Iu)*Math.exp(-Iu*fu),Su===0||Su===1?Su:1-Iu}return eu?vu:function(){var Su=B.springs[iu];if(Su)return Su;for(var Iu=1/6,Mu=0,ku=0;;)if(vu(Mu+=Iu)===1){if(++ku>=16)break}else ku=0;var Bu=Mu*Iu*1e3;return B.springs[iu]=Bu,Bu}}function k(iu,eu){iu===void 0&&(iu=1),eu===void 0&&(eu=.5);var tu=b(iu,1,10),su=b(eu,.1,2);return function(au){return au===0||au===1?au:-tu*Math.pow(2,10*(au-1))*Math.sin((au-1-su/(2*Math.PI)*Math.asin(1/tu))*(2*Math.PI)/su)}}function T(iu){return iu===void 0&&(iu=10),function(eu){return Math.round(eu*iu)*(1/iu)}}var R=function(){var iu=.1;function eu(du,fu){return 1-3*fu+3*du}function tu(du,fu){return 3*fu-6*du}function su(du){return 3*du}function au(du,fu,gu){return((eu(fu,gu)*du+tu(fu,gu))*du+su(fu))*du}function uu(du,fu,gu){return 3*eu(fu,gu)*du*du+2*tu(fu,gu)*du+su(fu)}return function(du,fu,gu,yu){if(0<=du&&du<=1&&0<=gu&&gu<=1){var xu=new Float32Array(11);if(du!==fu||gu!==yu)for(var vu=0;vu<11;++vu)xu[vu]=au(vu*iu,du,gu);return function(Su){return du===fu&&gu===yu||Su===0||Su===1?Su:au(function(Iu){for(var Mu=0,ku=1;ku!==10&&xu[ku]<=Iu;++ku)Mu+=iu;--ku;var Bu=Mu+(Iu-xu[ku])/(xu[ku+1]-xu[ku])*iu,_u=uu(Bu,du,gu);return _u>=.001?function(Lu,Du,Ou,Wu){for(var Zu=0;Zu<4;++Zu){var Hu=uu(Du,Ou,Wu);if(Hu===0)return Du;Du-=(au(Du,Ou,Wu)-Lu)/Hu}return Du}(Iu,Bu,du,gu):_u===0?Bu:function(Lu,Du,Ou,Wu,Zu){var Hu,Yu,Ku=0;do(Hu=au(Yu=Du+(Ou-Du)/2,Wu,Zu)-Lu)>0?Ou=Yu:Du=Yu;while(Math.abs(Hu)>1e-7&&++Ku<10);return Yu}(Iu,Mu,Mu+iu,du,gu)}(Su),fu,yu)}}}}(),F=function(){var iu=["Quad","Cubic","Quart","Quint","Sine","Expo","Circ","Back","Elastic"],eu={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],k],Out:[[.25,.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(du,fu){return function(gu){return 1-k(du,fu)(1-gu)}}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(du,fu){return function(gu){return gu<.5?k(du,fu)(2*gu)/2:1-k(du,fu)(-2*gu+2)/2}}]},tu={linear:[.25,.25,.75,.75]};for(var su in eu)for(var au=0,uu=eu[su].length;au<uu;au++)tu["ease"+su+iu[au]]=eu[su][au];return tu}();function U(iu,eu){if(L.fnc(iu))return iu;var tu=iu.split("(")[0],su=F[tu],au=S(iu);switch(tu){case"spring":return D(iu,eu);case"cubicBezier":return I(R,au);case"steps":return I(T,au);default:return L.fnc(su)?I(su,au):I(R,su)}}function O(iu){try{return document.querySelectorAll(iu)}catch{return}}var P=[];function G(iu,eu){for(var tu=P,su=iu.length,au=arguments.length>=2?arguments[1]:void 0,uu=0;uu<su;uu++)if(uu in iu){var du=iu[uu];eu.call(au,du,uu,iu)&&tu.push(du)}return(P=iu).length=0,tu}function N(iu,eu){eu||(eu=[]);for(var tu=0,su=iu.length;tu<su;tu++){var au=iu[tu];Array.isArray(au)?N(au,eu):eu.push(au)}return eu}function j(iu){return L.arr(iu)?iu:(L.str(iu)&&(iu=O(iu)||iu),iu instanceof NodeList||iu instanceof HTMLCollection?[].slice.call(iu):[iu])}function _(iu,eu){return iu.some(function(tu){return tu===eu})}function H(iu){var eu={};for(var tu in iu)eu[tu]=iu[tu];return eu}function q(iu,eu){var tu=H(iu);for(var su in iu)tu[su]=eu.hasOwnProperty(su)?eu[su]:iu[su];return tu}function V(iu,eu){var tu=H(iu);for(var su in eu)tu[su]=L.und(iu[su])?eu[su]:iu[su];return tu}var z=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g,Y=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,K=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,W=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g,J=/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g,X=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;function Z(iu){var eu=X.exec(iu);if(eu)return eu[2]}function $(iu,eu){return L.fnc(iu)?iu(eu.target,eu.id,eu.total):iu}function ee(iu,eu){return iu.getAttribute(eu)}function te(iu,eu,tu){if(_([tu,"deg","rad","turn"],Z(eu)))return eu;var su=B.CSS[eu+tu];if(!L.und(su))return su;var au=document.createElement(iu.tagName),uu=iu.parentNode&&iu.parentNode!==document?iu.parentNode:document.body;uu.appendChild(au),au.style.position="absolute",au.style.width=100+tu;var du=100/au.offsetWidth;uu.removeChild(au);var fu=du*parseFloat(eu);return B.CSS[eu+tu]=fu,fu}function ne(iu,eu,tu){if(eu in iu.style){var su=eu.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),au=iu.style[eu]||getComputedStyle(iu).getPropertyValue(su)||"0";return tu?te(iu,au,tu):au}}function ie(iu,eu){return L.dom(iu)&&!L.inp(iu)&&(ee(iu,eu)||L.svg(iu)&&iu[eu])?"attribute":L.dom(iu)&&_(v,eu)?"transform":L.dom(iu)&&eu!=="transform"&&ne(iu,eu)?"css":iu[eu]!=null?"object":void 0}var re=/(\w+)\(([^)]*)\)/g;function oe(iu){if(L.dom(iu)){for(var eu,tu=iu.style.transform||"",su=new Map;eu=re.exec(tu);)su.set(eu[1],eu[2]);return su}}function se(iu,eu,tu,su){switch(ie(iu,eu)){case"transform":return function(au,uu,du,fu){var gu=y(uu,"scale")?1:0+function(xu){return y(xu,"translate")||xu==="perspective"?"px":y(xu,"rotate")||y(xu,"skew")?"deg":void 0}(uu),yu=oe(au).get(uu)||gu;return du&&(du.transforms.list.set(uu,yu),du.transforms.last=uu),fu?te(au,yu,fu):yu}(iu,eu,su,tu);case"css":return ne(iu,eu,tu);case"attribute":return ee(iu,eu);default:return iu[eu]||0}}var ae=/^(\*=|\+=|-=)/;function Ae(iu,eu){var tu=ae.exec(iu);if(!tu)return iu;var su=Z(iu)||0,au=parseFloat(eu),uu=parseFloat(iu.replace(tu[0],""));switch(tu[0][0]){case"+":return au+uu+su;case"-":return au-uu+su;case"*":return au*uu+su}}var le=/\s/g;function ce(iu,eu){if(L.col(iu))return function(au){return L.rgb(au)?(uu=au,(du=z.exec(uu))?"rgba("+du[1]+",1)":uu):L.hex(au)?function(fu){var gu=fu.replace(Y,function(xu,vu,Su,Iu){return vu+vu+Su+Su+Iu+Iu}),yu=K.exec(gu);return"rgba("+parseInt(yu[1],16)+","+parseInt(yu[2],16)+","+parseInt(yu[3],16)+",1)"}(au):L.hsl(au)?function(fu){var gu,yu,xu,vu=W.exec(fu)||J.exec(fu),Su=parseInt(vu[1],10)/360,Iu=parseInt(vu[2],10)/100,Mu=parseInt(vu[3],10)/100,ku=vu[4]||1;function Bu(Du,Ou,Wu){return Wu<0&&(Wu+=1),Wu>1&&(Wu-=1),Wu<1/6?Du+6*(Ou-Du)*Wu:Wu<.5?Ou:Wu<2/3?Du+(Ou-Du)*(2/3-Wu)*6:Du}if(Iu==0)gu=yu=xu=Mu;else{var _u=Mu<.5?Mu*(1+Iu):Mu+Iu-Mu*Iu,Lu=2*Mu-_u;gu=Bu(Lu,_u,Su+1/3),yu=Bu(Lu,_u,Su),xu=Bu(Lu,_u,Su-1/3)}return"rgba("+255*gu+","+255*yu+","+255*xu+","+ku+")"}(au):void 0;var uu,du}(iu);var tu=Z(iu),su=tu?iu.substr(0,iu.length-tu.length):iu;return eu&&!le.test(iu)?su+eu:su}function he(iu,eu){return Math.sqrt(Math.pow(eu.x-iu.x,2)+Math.pow(eu.y-iu.y,2))}function de(iu){for(var eu,tu=iu.points,su=0,au=0;au<tu.numberOfItems;au++){var uu=tu.getItem(au);au>0&&(su+=he(eu,uu)),eu=uu}return su}function ue(iu){if(iu.getTotalLength)return iu.getTotalLength();switch(iu.tagName.toLowerCase()){case"circle":return function(eu){return 2*Math.PI*ee(eu,"r")}(iu);case"rect":return function(eu){return 2*ee(eu,"width")+2*ee(eu,"height")}(iu);case"line":return function(eu){return he({x:ee(eu,"x1"),y:ee(eu,"y1")},{x:ee(eu,"x2"),y:ee(eu,"y2")})}(iu);case"polyline":return de(iu);case"polygon":return function(eu){var tu=eu.points;return de(eu)+he(tu.getItem(tu.numberOfItems-1),tu.getItem(0))}(iu)}}function ge(iu,eu){var tu=eu||{},su=tu.el||function(yu){for(var xu=yu.parentNode;L.svg(xu)&&(xu=xu.parentNode,L.svg(xu.parentNode)););return xu}(iu),au=su.getBoundingClientRect(),uu=ee(su,"viewBox"),du=au.width,fu=au.height,gu=tu.viewBox||(uu?uu.split(" "):[0,0,du,fu]);return{el:su,viewBox:gu,x:gu[0]/1,y:gu[1]/1,w:du/gu[2],h:fu/gu[3]}}function pe(iu,eu){function tu(fu){fu===void 0&&(fu=0);var gu=eu+fu>=1?eu+fu:0;return iu.el.getPointAtLength(gu)}var su=ge(iu.el,iu.svg),au=tu(),uu=tu(-1),du=tu(1);switch(iu.property){case"x":return(au.x-su.x)*su.w;case"y":return(au.y-su.y)*su.h;case"angle":return 180*Math.atan2(du.y-uu.y,du.x-uu.x)/Math.PI}}var fe=/-?\d*\.?\d+/g;function me(iu,eu){var tu=ce(L.pth(iu)?iu.totalLength:iu,eu)+"";return{original:tu,numbers:tu.match(fe)?tu.match(fe).map(Number):[0],strings:L.str(iu)||eu?tu.split(fe):[]}}function Ee(iu){return G(iu?N(L.arr(iu)?iu.map(j):j(iu)):[],function(eu,tu,su){return su.indexOf(eu)===tu})}function Ce(iu){var eu=Ee(iu);return eu.map(function(tu,su){return{target:tu,id:su,total:eu.length,transforms:{list:oe(tu)}}})}var ve=/^spring/;function Be(iu,eu){var tu=H(eu);if(ve.test(tu.easing)&&(tu.duration=D(tu.easing)),L.arr(iu)){var su=iu.length;su!==2||L.obj(iu[0])?L.fnc(eu.duration)||(tu.duration=eu.duration/su):iu={value:iu}}var au=L.arr(iu)?iu:[iu];return au.map(function(uu,du){var fu=L.obj(uu)&&!L.pth(uu)?uu:{value:uu};return L.und(fu.delay)&&(fu.delay=du?0:eu.delay),L.und(fu.endDelay)&&(fu.endDelay=du===au.length-1?eu.endDelay:0),fu}).map(function(uu){return V(uu,tu)})}var be={css:function(iu,eu,tu){return iu.style[eu]=tu},attribute:function(iu,eu,tu){return iu.setAttribute(eu,tu)},object:function(iu,eu,tu){return iu[eu]=tu},transform:function(iu,eu,tu,su,au){if(su.list.set(eu,tu),eu===su.last||au){var uu="";su.list.forEach(function(du,fu){uu+=fu+"("+du+") "}),iu.style.transform=uu}}};function ye(iu,eu){for(var tu=Ce(iu),su=0,au=tu.length;su<au;su++){var uu=tu[su];for(var du in eu){var fu=$(eu[du],uu),gu=uu.target,yu=Z(fu),xu=se(gu,du,yu,uu),vu=Ae(ce(fu,yu||Z(xu)),xu),Su=ie(gu,du);be[Su](gu,du,vu,uu.transforms,!0)}}}function Ie(iu,eu){return G(N(iu.map(function(tu){return eu.map(function(su){return function(au,uu){var du=ie(au.target,uu.name);if(du){var fu=function(yu,xu){var vu;return yu.tweens.map(function(Su){var Iu=function(Zu,Hu){var Yu={};for(var Ku in Zu){var ju=$(Zu[Ku],Hu);L.arr(ju)&&(ju=ju.map(function(tp){return $(tp,Hu)})).length===1&&(ju=ju[0]),Yu[Ku]=ju}return Yu.duration=parseFloat(Yu.duration),Yu.delay=parseFloat(Yu.delay),Yu}(Su,xu),Mu=Iu.value,ku=L.arr(Mu)?Mu[1]:Mu,Bu=Z(ku),_u=se(xu.target,yu.name,Bu,xu),Lu=vu?vu.to.original:_u,Du=L.arr(Mu)?Mu[0]:Lu,Ou=Z(Du)||Z(_u),Wu=Bu||Ou;return L.und(ku)&&(ku=Lu),Iu.from=me(Du,Wu),Iu.to=me(Ae(ku,Du),Wu),Iu.start=vu?vu.end:0,Iu.end=Iu.start+Iu.delay+Iu.duration+Iu.endDelay,Iu.easing=U(Iu.easing,Iu.duration),Iu.isPath=L.pth(Mu),Iu.isColor=L.col(Iu.from.original),Iu.isColor&&(Iu.round=1),vu=Iu,Iu})}(uu,au),gu=fu[fu.length-1];return{type:du,property:uu.name,animatable:au,tweens:fu,duration:gu.end,delay:fu[0].delay,endDelay:gu.endDelay}}}(tu,su)})})),function(tu){return!L.und(tu)})}function we(iu,eu){var tu=iu.length,su=function(uu){return uu.timelineOffset?uu.timelineOffset:0},au={};return au.duration=tu?Math.max.apply(Math,iu.map(function(uu){return su(uu)+uu.duration})):eu.duration,au.delay=tu?Math.min.apply(Math,iu.map(function(uu){return su(uu)+uu.delay})):eu.delay,au.endDelay=tu?au.duration-Math.max.apply(Math,iu.map(function(uu){return su(uu)+uu.duration-uu.endDelay})):eu.endDelay,au}var xe,Qe=0,Le=[],Me=[],Se=function(){function iu(){xe=requestAnimationFrame(eu)}function eu(tu){var su=Le.length;if(su){for(var au=0;au<su;){var uu=Le[au];if(uu.paused){var du=Le.indexOf(uu);du>-1&&(Le.splice(du,1),su=Le.length)}else uu.tick(tu);au++}iu()}else xe=cancelAnimationFrame(xe)}return iu}();function De(iu){iu===void 0&&(iu={});var eu,tu=0,su=0,au=0,uu=0,du=null;function fu(){return window.Promise&&new Promise(function(_u){return du=_u})}var gu=fu(),yu=function(_u){var Lu=q(E,_u),Du=q(C,_u),Ou=function(Ku,ju){var tp=[],gp=ju.keyframes;for(var yp in gp&&(ju=V(function(Cp){for(var Hp=G(N(Cp.map(function(Rp){return Object.keys(Rp)})),function(Rp){return L.key(Rp)}).reduce(function(Rp,xp){return Rp.indexOf(xp)<0&&Rp.push(xp),Rp},[]),wp={},Dp=function(Rp){var xp=Hp[Rp];wp[xp]=Cp.map(function(cm){var lm={};for(var vp in cm)L.key(vp)?vp==xp&&(lm.value=cm[vp]):lm[vp]=cm[vp];return lm})},dp=0;dp<Hp.length;dp++)Dp(dp);return wp}(gp),ju)),ju)L.key(yp)&&tp.push({name:yp,tweens:Be(ju[yp],Ku)});return tp}(Du,_u),Wu=Ce(_u.targets),Zu=Ie(Wu,Ou),Hu=we(Zu,Du),Yu=Qe;return Qe++,V(Lu,{id:Yu,children:[],animatables:Wu,animations:Zu,duration:Hu.duration,delay:Hu.delay,endDelay:Hu.endDelay})}(iu);function xu(){yu.reversed=!yu.reversed;for(var _u=0,Lu=eu.length;_u<Lu;_u++)eu[_u].reversed=yu.reversed}function vu(_u){return yu.reversed?yu.duration-_u:_u}function Su(){tu=0,su=vu(yu.currentTime)*(1/De.speed)}function Iu(_u,Lu){Lu&&Lu.seek(_u-Lu.timelineOffset)}function Mu(_u){for(var Lu=0,Du=yu.animations,Ou=Du.length;Lu<Ou;){var Wu=Du[Lu],Zu=Wu.animatable,Hu=Wu.tweens,Yu=Hu.length-1,Ku=Hu[Yu];Yu&&(Ku=G(Hu,function(kp){return _u<kp.end})[0]||Ku);for(var ju=b(_u-Ku.start-Ku.delay,0,Ku.duration)/Ku.duration,tp=isNaN(ju)?1:Ku.easing(ju),gp=Ku.to.strings,yp=Ku.round,Cp=[],Hp=Ku.to.numbers.length,wp=void 0,Dp=0;Dp<Hp;Dp++){var dp=void 0,Rp=Ku.to.numbers[Dp],xp=Ku.from.numbers[Dp]||0;dp=Ku.isPath?pe(Ku.value,tp*Rp):xp+tp*(Rp-xp),yp&&(Ku.isColor&&Dp>2||(dp=Math.round(dp*yp)/yp)),Cp.push(dp)}var cm=gp.length;if(cm){wp=gp[0];for(var lm=0;lm<cm;lm++){gp[lm];var vp=gp[lm+1],bp=Cp[lm];isNaN(bp)||(wp+=vp?bp+vp:bp+" ")}}else wp=Cp[0];be[Wu.type](Zu.target,Wu.property,wp,Zu.transforms),Wu.currentValue=wp,Lu++}}function ku(_u){yu[_u]&&!yu.passThrough&&yu[_u](yu)}function Bu(_u){var Lu=yu.duration,Du=yu.delay,Ou=Lu-yu.endDelay,Wu=vu(_u);yu.progress=b(Wu/Lu*100,0,100),yu.reversePlayback=Wu<yu.currentTime,eu&&function(Zu){if(yu.reversePlayback)for(var Hu=uu;Hu--;)Iu(Zu,eu[Hu]);else for(var Yu=0;Yu<uu;Yu++)Iu(Zu,eu[Yu])}(Wu),!yu.began&&yu.currentTime>0&&(yu.began=!0,ku("begin"),ku("loopBegin")),Wu<=Du&&yu.currentTime!==0&&Mu(0),(Wu>=Ou&&yu.currentTime!==Lu||!Lu)&&Mu(Lu),Wu>Du&&Wu<Ou?(yu.changeBegan||(yu.changeBegan=!0,yu.changeCompleted=!1,ku("changeBegin")),ku("change"),Mu(Wu)):yu.changeBegan&&(yu.changeCompleted=!0,yu.changeBegan=!1,ku("changeComplete")),yu.currentTime=b(Wu,0,Lu),yu.began&&ku("update"),_u>=Lu&&(su=0,yu.remaining&&yu.remaining!==!0&&yu.remaining--,yu.remaining?(tu=au,ku("loopComplete"),ku("loopBegin"),yu.direction==="alternate"&&xu()):(yu.paused=!0,yu.completed||(yu.completed=!0,ku("loopComplete"),ku("complete"),"Promise"in window&&(du(),gu=fu()))))}return yu.reset=function(){var _u=yu.direction;yu.passThrough=!1,yu.currentTime=0,yu.progress=0,yu.paused=!0,yu.began=!1,yu.changeBegan=!1,yu.completed=!1,yu.changeCompleted=!1,yu.reversePlayback=!1,yu.reversed=_u==="reverse",yu.remaining=yu.loop,eu=yu.children;for(var Lu=uu=eu.length;Lu--;)yu.children[Lu].reset();(yu.reversed&&yu.loop!==!0||_u==="alternate"&&yu.loop===1)&&yu.remaining++,Mu(0)},yu.set=function(_u,Lu){return ye(_u,Lu),yu},yu.tick=function(_u){au=_u,tu||(tu=au),Bu((au+(su-tu))*De.speed)},yu.seek=function(_u){Bu(vu(_u))},yu.pause=function(){yu.paused=!0,Su()},yu.play=function(){yu.paused&&(yu.paused=!1,Le.push(yu),Su(),xe||Se())},yu.reverse=function(){xu(),Su()},yu.restart=function(){yu.reset(),yu.play()},yu.finished=gu,yu.reset(),yu.autoplay&&yu.play(),yu}function ke(iu,eu){for(var tu=eu.length;tu--;)_(iu,eu[tu].animatable.target)&&eu.splice(tu,1)}document.addEventListener("visibilitychange",function(){if(document.hidden){for(var iu=0,eu=Le.length;iu<eu;iu++)activeInstance[iu].pause();Me=Le.slice(0),Le=[]}else for(var tu=0,su=Me.length;tu<su;tu++)Me[tu].play()}),De.version="3.0.0",De.speed=1,De.running=Le,De.remove=function(iu){for(var eu=Ee(iu),tu=Le.length;tu--;){var su=Le[tu],au=su.animations,uu=su.children;ke(eu,au);for(var du=uu.length;du--;){var fu=uu[du],gu=fu.animations;ke(eu,gu),gu.length||fu.children.length||uu.splice(du,1)}au.length||uu.length||su.pause()}},De.get=se,De.set=ye,De.convertPx=te,De.path=function(iu,eu){var tu=L.str(iu)?O(iu)[0]:iu,su=eu||100;return function(au){return{property:au,el:tu,svg:ge(tu),totalLength:ue(tu)*(su/100)}}},De.setDashoffset=function(iu){var eu=ue(iu);return iu.setAttribute("stroke-dasharray",eu),eu},De.stagger=function(iu,eu){eu===void 0&&(eu={});var tu=eu.direction||"normal",su=eu.easing?U(eu.easing):null,au=eu.grid,uu=eu.axis,du=eu.from||0,fu=du==="first",gu=du==="center",yu=du==="last",xu=L.arr(iu),vu=parseFloat(xu?iu[0]:iu),Su=xu?parseFloat(iu[1]):0,Iu=Z(xu?iu[1]:iu)||0,Mu=eu.start||0+(xu?vu:0),ku=[],Bu=0;return function(_u,Lu,Du){if(fu&&(du=0),gu&&(du=(Du-1)/2),yu&&(du=Du-1),!ku.length){for(var Ou=0;Ou<Du;Ou++){if(au){var Wu=gu?(au[0]-1)/2:du%au[0],Zu=gu?(au[1]-1)/2:Math.floor(du/au[0]),Hu=Wu-Ou%au[0],Yu=Zu-Math.floor(Ou/au[0]),Ku=Math.sqrt(Hu*Hu+Yu*Yu);uu==="x"&&(Ku=-Hu),uu==="y"&&(Ku=-Yu),ku.push(Ku)}else ku.push(Math.abs(du-Ou));Bu=Math.max.apply(Math,ku)}su&&(ku=ku.map(function(ju){return su(ju/Bu)*Bu})),tu==="reverse"&&(ku=ku.map(function(ju){return uu?ju<0?-1*ju:-ju:Math.abs(Bu-ju)}))}return Mu+(xu?(Su-vu)/Bu:vu)*(Math.round(100*ku[Lu])/100)+Iu}},De.timeline=function(iu){iu===void 0&&(iu={});var eu=De(iu);return eu.duration=0,eu.add=function(tu,su){var au=Le.indexOf(eu),uu=eu.children;function du(Su){Su.passThrough=!0}au>-1&&Le.splice(au,1);for(var fu=0;fu<uu.length;fu++)du(uu[fu]);var gu=V(tu,q(C,iu));gu.targets=gu.targets||iu.targets;var yu=eu.duration;gu.autoplay=!1,gu.direction=eu.direction,gu.timelineOffset=L.und(su)?yu:Ae(su,yu),du(eu),eu.seek(gu.timelineOffset);var xu=De(gu);du(xu),uu.push(xu);var vu=we(uu,iu);return eu.delay=vu.delay,eu.endDelay=vu.endDelay,eu.duration=vu.duration,eu.seek(0),eu.reset(),eu.autoplay&&eu.play(),eu},eu},De.easing=U,De.penner=F,De.random=function(iu,eu){return Math.floor(Math.random()*(eu-iu+1))+iu};const Te=De,Re=e,Fe=new WeakMap;class Ue extends Re.Loader{constructor(eu){super(eu),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(eu){return this.decoderPath=eu,this}setDecoderConfig(eu){return this.decoderConfig=eu,this}setWorkerLimit(eu){return this.workerLimit=eu,this}load(eu,tu,su,au){const uu=new Re.FileLoader(this.manager);uu.setPath(this.path),uu.setResponseType("arraybuffer"),uu.setRequestHeader(this.requestHeader),uu.setWithCredentials(this.withCredentials),uu.load(eu,du=>{this.parse(du,tu,au)},su,au)}parse(eu,tu,su=()=>{}){this.decodeDracoFile(eu,tu,null,null,Re.SRGBColorSpace,su).catch(su)}decodeDracoFile(eu,tu,su,au,uu=Re.LinearSRGBColorSpace,du=()=>{}){const fu={attributeIDs:su||this.defaultAttributeIDs,attributeTypes:au||this.defaultAttributeTypes,useUniqueIDs:!!su,vertexColorSpace:uu};return this.decodeGeometry(eu,fu).then(tu).catch(du)}decodeGeometry(eu,tu){const su=JSON.stringify(tu);if(Fe.has(eu)){const gu=Fe.get(eu);if(gu.key===su)return gu.promise;if(eu.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let au;const uu=this.workerNextTaskID++,du=eu.byteLength,fu=this._getWorker(uu,du).then(gu=>(au=gu,new Promise((yu,xu)=>{au._callbacks[uu]={resolve:yu,reject:xu},au.postMessage({type:"decode",id:uu,taskConfig:tu,buffer:eu},[eu])}))).then(gu=>this._createGeometry(gu.geometry));return fu.catch(()=>!0).then(()=>{au&&uu&&this._releaseTask(au,uu)}),Fe.set(eu,{key:su,promise:fu}),fu}_createGeometry(eu){const tu=new Re.BufferGeometry;eu.index&&tu.setIndex(new Re.BufferAttribute(eu.index.array,1));for(let su=0;su<eu.attributes.length;su++){const au=eu.attributes[su],uu=au.name,du=au.array,fu=au.itemSize,gu=new Re.BufferAttribute(du,fu);uu==="color"&&(this._assignVertexColorSpace(gu,au.vertexColorSpace),gu.normalized=du instanceof Float32Array==0),tu.setAttribute(uu,gu)}return tu}_assignVertexColorSpace(eu,tu){if(tu!==Re.SRGBColorSpace)return;const su=new Re.Color;for(let au=0,uu=eu.count;au<uu;au++)su.fromBufferAttribute(eu,au),Re.ColorManagement.toWorkingColorSpace(su,Re.SRGBColorSpace),eu.setXYZ(au,su.r,su.g,su.b)}_loadLibrary(eu,tu){const su=new Re.FileLoader(this.manager);return su.setPath(this.decoderPath),su.setResponseType(tu),su.setWithCredentials(this.withCredentials),new Promise((au,uu)=>{su.load(eu,au,void 0,uu)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const eu=typeof WebAssembly!="object"||this.decoderConfig.type==="js",tu=[];return eu?tu.push(this._loadLibrary("draco_decoder.js","text")):(tu.push(this._loadLibrary("draco_wasm_wrapper.js","text")),tu.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(tu).then(su=>{const au=su[0];eu||(this.decoderConfig.wasmBinary=su[1]);const uu=Oe.toString(),du=["/* draco decoder */",au,"","/* worker */",uu.substring(uu.indexOf("{")+1,uu.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([du]))}),this.decoderPending}_getWorker(eu,tu){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const au=new Worker(this.workerSourceURL);au._callbacks={},au._taskCosts={},au._taskLoad=0,au.postMessage({type:"init",decoderConfig:this.decoderConfig}),au.onmessage=function(uu){const du=uu.data;switch(du.type){case"decode":au._callbacks[du.id].resolve(du);break;case"error":au._callbacks[du.id].reject(du);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+du.type+'"')}},this.workerPool.push(au)}else this.workerPool.sort(function(au,uu){return au._taskLoad>uu._taskLoad?-1:1});const su=this.workerPool[this.workerPool.length-1];return su._taskCosts[eu]=tu,su._taskLoad+=tu,su})}_releaseTask(eu,tu){eu._taskLoad-=eu._taskCosts[tu],delete eu._callbacks[tu],delete eu._taskCosts[tu]}debug(){console.log("Task load: ",this.workerPool.map(eu=>eu._taskLoad))}dispose(){for(let eu=0;eu<this.workerPool.length;++eu)this.workerPool[eu].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Oe(){let iu,eu;function tu(su,au,uu,du,fu,gu){const yu=gu.num_components(),xu=uu.num_points()*yu,vu=xu*fu.BYTES_PER_ELEMENT,Su=function(ku,Bu){switch(Bu){case Float32Array:return ku.DT_FLOAT32;case Int8Array:return ku.DT_INT8;case Int16Array:return ku.DT_INT16;case Int32Array:return ku.DT_INT32;case Uint8Array:return ku.DT_UINT8;case Uint16Array:return ku.DT_UINT16;case Uint32Array:return ku.DT_UINT32}}(su,fu),Iu=su._malloc(vu);au.GetAttributeDataArrayForAllPoints(uu,gu,Su,vu,Iu);const Mu=new fu(su.HEAPF32.buffer,Iu,xu).slice();return su._free(Iu),{name:du,array:Mu,itemSize:yu}}onmessage=function(su){const au=su.data;switch(au.type){case"init":iu=au.decoderConfig,eu=new Promise(function(fu){iu.onModuleLoaded=function(gu){fu({draco:gu})},DracoDecoderModule(iu)});break;case"decode":const uu=au.buffer,du=au.taskConfig;eu.then(fu=>{const gu=fu.draco,yu=new gu.Decoder;try{const xu=function(Su,Iu,Mu,ku){const Bu=ku.attributeIDs,_u=ku.attributeTypes;let Lu,Du;const Ou=Iu.GetEncodedGeometryType(Mu);if(Ou===Su.TRIANGULAR_MESH)Lu=new Su.Mesh,Du=Iu.DecodeArrayToMesh(Mu,Mu.byteLength,Lu);else{if(Ou!==Su.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");Lu=new Su.PointCloud,Du=Iu.DecodeArrayToPointCloud(Mu,Mu.byteLength,Lu)}if(!Du.ok()||Lu.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+Du.error_msg());const Wu={index:null,attributes:[]};for(const Zu in Bu){const Hu=self[_u[Zu]];let Yu,Ku;if(ku.useUniqueIDs)Ku=Bu[Zu],Yu=Iu.GetAttributeByUniqueId(Lu,Ku);else{if(Ku=Iu.GetAttributeId(Lu,Su[Bu[Zu]]),Ku===-1)continue;Yu=Iu.GetAttribute(Lu,Ku)}const ju=tu(Su,Iu,Lu,Zu,Hu,Yu);Zu==="color"&&(ju.vertexColorSpace=ku.vertexColorSpace),Wu.attributes.push(ju)}return Ou===Su.TRIANGULAR_MESH&&(Wu.index=function(Zu,Hu,Yu){const Ku=3*Yu.num_faces(),ju=4*Ku,tp=Zu._malloc(ju);Hu.GetTrianglesUInt32Array(Yu,ju,tp);const gp=new Uint32Array(Zu.HEAPF32.buffer,tp,Ku).slice();return Zu._free(tp),{array:gp,itemSize:1}}(Su,Iu,Lu)),Su.destroy(Lu),Wu}(gu,yu,new Int8Array(uu),du),vu=xu.attributes.map(Su=>Su.array.buffer);xu.index&&vu.push(xu.index.array.buffer),self.postMessage({type:"decode",id:au.id,geometry:xu},vu)}catch(xu){console.error(xu),self.postMessage({type:"error",id:au.id,error:xu.message})}finally{gu.destroy(yu)}})}}}function Pe(iu,eu,tu=!0){if(!eu||!eu.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!iu.hasAttribute("position")||!iu.hasAttribute("normal")||!iu.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function su(du){if(du.normalized||du.isInterleavedBufferAttribute){const fu=new Float32Array(du.count*du.itemSize);for(let gu=0,yu=0;gu<du.count;gu++)fu[yu++]=du.getX(gu),fu[yu++]=du.getY(gu),du.itemSize>2&&(fu[yu++]=du.getZ(gu));return fu}return du.array instanceof Float32Array?du.array:new Float32Array(du.array)}const au=iu.index?iu.toNonIndexed():iu,uu=eu.generateTangents(su(au.attributes.position),su(au.attributes.normal),su(au.attributes.uv));if(tu)for(let du=3;du<uu.length;du+=4)uu[du]*=-1;return au.setAttribute("tangent",new Re.BufferAttribute(uu,4)),iu!==au&&iu.copy(au),iu}function Ge(iu,eu=!1){const tu=iu[0].index!==null,su=new Set(Object.keys(iu[0].attributes)),au=new Set(Object.keys(iu[0].morphAttributes)),uu={},du={},fu=iu[0].morphTargetsRelative,gu=new Re.BufferGeometry;let yu=0;for(let xu=0;xu<iu.length;++xu){const vu=iu[xu];let Su=0;if(tu!==(vu.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+xu+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const Iu in vu.attributes){if(!su.has(Iu))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+xu+'. All geometries must have compatible attributes; make sure "'+Iu+'" attribute exists among all geometries, or in none of them.'),null;uu[Iu]===void 0&&(uu[Iu]=[]),uu[Iu].push(vu.attributes[Iu]),Su++}if(Su!==su.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+xu+". Make sure all geometries have the same number of attributes."),null;if(fu!==vu.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+xu+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const Iu in vu.morphAttributes){if(!au.has(Iu))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+xu+".  .morphAttributes must be consistent throughout all geometries."),null;du[Iu]===void 0&&(du[Iu]=[]),du[Iu].push(vu.morphAttributes[Iu])}if(eu){let Iu;if(tu)Iu=vu.index.count;else{if(vu.attributes.position===void 0)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+xu+". The geometry must have either an index or a position attribute"),null;Iu=vu.attributes.position.count}gu.addGroup(yu,Iu,xu),yu+=Iu}}if(tu){let xu=0;const vu=[];for(let Su=0;Su<iu.length;++Su){const Iu=iu[Su].index;for(let Mu=0;Mu<Iu.count;++Mu)vu.push(Iu.getX(Mu)+xu);xu+=iu[Su].attributes.position.count}gu.setIndex(vu)}for(const xu in uu){const vu=Ne(uu[xu]);if(!vu)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+xu+" attribute."),null;gu.setAttribute(xu,vu)}for(const xu in du){const vu=du[xu][0].length;if(vu===0)break;gu.morphAttributes=gu.morphAttributes||{},gu.morphAttributes[xu]=[];for(let Su=0;Su<vu;++Su){const Iu=[];for(let ku=0;ku<du[xu].length;++ku)Iu.push(du[xu][ku][Su]);const Mu=Ne(Iu);if(!Mu)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+xu+" morphAttribute."),null;gu.morphAttributes[xu].push(Mu)}}return gu}function Ne(iu){let eu,tu,su,au=-1,uu=0;for(let yu=0;yu<iu.length;++yu){const xu=iu[yu];if(eu===void 0&&(eu=xu.array.constructor),eu!==xu.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(tu===void 0&&(tu=xu.itemSize),tu!==xu.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(su===void 0&&(su=xu.normalized),su!==xu.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(au===-1&&(au=xu.gpuType),au!==xu.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;uu+=xu.count*tu}const du=new eu(uu),fu=new Re.BufferAttribute(du,tu,su);let gu=0;for(let yu=0;yu<iu.length;++yu){const xu=iu[yu];if(xu.isInterleavedBufferAttribute){const vu=gu/tu;for(let Su=0,Iu=xu.count;Su<Iu;Su++)for(let Mu=0;Mu<tu;Mu++){const ku=xu.getComponent(Su,Mu);fu.setComponent(Su+vu,Mu,ku)}}else du.set(xu.array,gu);gu+=xu.count*tu}return au!==void 0&&(fu.gpuType=au),fu}function je(iu){return iu.isInstancedInterleavedBufferAttribute||iu.isInterleavedBufferAttribute?He(iu):iu.isInstancedBufferAttribute?new Re.InstancedBufferAttribute().copy(iu):new Re.BufferAttribute().copy(iu)}function _e(iu){let eu,tu=0,su=0;for(let yu=0,xu=iu.length;yu<xu;++yu){const vu=iu[yu];if(eu===void 0&&(eu=vu.array.constructor),eu!==vu.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;tu+=vu.array.length,su+=vu.itemSize}const au=new Re.InterleavedBuffer(new eu(tu),su);let uu=0;const du=[],fu=["getX","getY","getZ","getW"],gu=["setX","setY","setZ","setW"];for(let yu=0,xu=iu.length;yu<xu;yu++){const vu=iu[yu],Su=vu.itemSize,Iu=vu.count,Mu=new Re.InterleavedBufferAttribute(au,Su,uu,vu.normalized);du.push(Mu),uu+=Su;for(let ku=0;ku<Iu;ku++)for(let Bu=0;Bu<Su;Bu++)Mu[gu[Bu]](ku,vu[fu[Bu]](ku))}return du}function He(iu){const eu=iu.data.array.constructor,tu=iu.count,su=iu.itemSize,au=iu.normalized,uu=new eu(tu*su);let du;du=iu.isInstancedInterleavedBufferAttribute?new Re.InstancedBufferAttribute(uu,su,au,iu.meshPerAttribute):new Re.BufferAttribute(uu,su,au);for(let fu=0;fu<tu;fu++)du.setX(fu,iu.getX(fu)),su>=2&&du.setY(fu,iu.getY(fu)),su>=3&&du.setZ(fu,iu.getZ(fu)),su>=4&&du.setW(fu,iu.getW(fu));return du}function qe(iu){const eu=iu.attributes,tu=iu.morphTargets,su=new Map;for(const au in eu){const uu=eu[au];uu.isInterleavedBufferAttribute&&(su.has(uu)||su.set(uu,He(uu)),eu[au]=su.get(uu))}for(const au in tu){const uu=tu[au];uu.isInterleavedBufferAttribute&&(su.has(uu)||su.set(uu,He(uu)),tu[au]=su.get(uu))}}function Ve(iu){let eu=0;for(const su in iu.attributes){const au=iu.getAttribute(su);eu+=au.count*au.itemSize*au.array.BYTES_PER_ELEMENT}const tu=iu.getIndex();return eu+=tu?tu.count*tu.itemSize*tu.array.BYTES_PER_ELEMENT:0,eu}function ze(iu,eu=1e-4){eu=Math.max(eu,Number.EPSILON);const tu={},su=iu.getIndex(),au=iu.getAttribute("position"),uu=su?su.count:au.count;let du=0;const fu=Object.keys(iu.attributes),gu={},yu={},xu=[],vu=["getX","getY","getZ","getW"],Su=["setX","setY","setZ","setW"];for(let Lu=0,Du=fu.length;Lu<Du;Lu++){const Ou=fu[Lu],Wu=iu.attributes[Ou];gu[Ou]=new Wu.constructor(new Wu.array.constructor(Wu.count*Wu.itemSize),Wu.itemSize,Wu.normalized);const Zu=iu.morphAttributes[Ou];Zu&&(yu[Ou]||(yu[Ou]=[]),Zu.forEach((Hu,Yu)=>{const Ku=new Hu.array.constructor(Hu.count*Hu.itemSize);yu[Ou][Yu]=new Hu.constructor(Ku,Hu.itemSize,Hu.normalized)}))}const Iu=.5*eu,Mu=Math.log10(1/eu),ku=Math.pow(10,Mu),Bu=Iu*ku;for(let Lu=0;Lu<uu;Lu++){const Du=su?su.getX(Lu):Lu;let Ou="";for(let Wu=0,Zu=fu.length;Wu<Zu;Wu++){const Hu=fu[Wu],Yu=iu.getAttribute(Hu),Ku=Yu.itemSize;for(let ju=0;ju<Ku;ju++)Ou+=~~(Yu[vu[ju]](Du)*ku+Bu)+","}if(Ou in tu)xu.push(tu[Ou]);else{for(let Wu=0,Zu=fu.length;Wu<Zu;Wu++){const Hu=fu[Wu],Yu=iu.getAttribute(Hu),Ku=iu.morphAttributes[Hu],ju=Yu.itemSize,tp=gu[Hu],gp=yu[Hu];for(let yp=0;yp<ju;yp++){const Cp=vu[yp],Hp=Su[yp];if(tp[Hp](du,Yu[Cp](Du)),Ku)for(let wp=0,Dp=Ku.length;wp<Dp;wp++)gp[wp][Hp](du,Ku[wp][Cp](Du))}}tu[Ou]=du,xu.push(du),du++}}const _u=iu.clone();for(const Lu in iu.attributes){const Du=gu[Lu];if(_u.setAttribute(Lu,new Du.constructor(Du.array.slice(0,du*Du.itemSize),Du.itemSize,Du.normalized)),Lu in yu)for(let Ou=0;Ou<yu[Lu].length;Ou++){const Wu=yu[Lu][Ou];_u.morphAttributes[Lu][Ou]=new Wu.constructor(Wu.array.slice(0,du*Wu.itemSize),Wu.itemSize,Wu.normalized)}}return _u.setIndex(xu),_u}function Ye(iu,eu){if(eu===Re.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),iu;if(eu===Re.TriangleFanDrawMode||eu===Re.TriangleStripDrawMode){let tu=iu.getIndex();if(tu===null){const du=[],fu=iu.getAttribute("position");if(fu===void 0)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),iu;for(let gu=0;gu<fu.count;gu++)du.push(gu);iu.setIndex(du),tu=iu.getIndex()}const su=tu.count-2,au=[];if(eu===Re.TriangleFanDrawMode)for(let du=1;du<=su;du++)au.push(tu.getX(0)),au.push(tu.getX(du)),au.push(tu.getX(du+1));else for(let du=0;du<su;du++)du%2==0?(au.push(tu.getX(du)),au.push(tu.getX(du+1)),au.push(tu.getX(du+2))):(au.push(tu.getX(du+2)),au.push(tu.getX(du+1)),au.push(tu.getX(du)));au.length/3!==su&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const uu=iu.clone();return uu.setIndex(au),uu.clearGroups(),uu}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",eu),iu}function Ke(iu){const eu=new Re.Vector3,tu=new Re.Vector3,su=new Re.Vector3,au=new Re.Vector3,uu=new Re.Vector3,du=new Re.Vector3,fu=new Re.Vector3,gu=new Re.Vector3,yu=new Re.Vector3;function xu(Dp,dp,Rp,xp,cm,lm,vp,bp){eu.fromBufferAttribute(dp,cm),tu.fromBufferAttribute(dp,lm),su.fromBufferAttribute(dp,vp);const kp=Dp.morphTargetInfluences;if(Rp&&kp){fu.set(0,0,0),gu.set(0,0,0),yu.set(0,0,0);for(let dm=0,nm=Rp.length;dm<nm;dm++){const Bp=kp[dm],Qp=Rp[dm];Bp!==0&&(au.fromBufferAttribute(Qp,cm),uu.fromBufferAttribute(Qp,lm),du.fromBufferAttribute(Qp,vp),xp?(fu.addScaledVector(au,Bp),gu.addScaledVector(uu,Bp),yu.addScaledVector(du,Bp)):(fu.addScaledVector(au.sub(eu),Bp),gu.addScaledVector(uu.sub(tu),Bp),yu.addScaledVector(du.sub(su),Bp)))}eu.add(fu),tu.add(gu),su.add(yu)}Dp.isSkinnedMesh&&(Dp.applyBoneTransform(cm,eu),Dp.applyBoneTransform(lm,tu),Dp.applyBoneTransform(vp,su)),bp[3*cm+0]=eu.x,bp[3*cm+1]=eu.y,bp[3*cm+2]=eu.z,bp[3*lm+0]=tu.x,bp[3*lm+1]=tu.y,bp[3*lm+2]=tu.z,bp[3*vp+0]=su.x,bp[3*vp+1]=su.y,bp[3*vp+2]=su.z}const vu=iu.geometry,Su=iu.material;let Iu,Mu,ku;const Bu=vu.index,_u=vu.attributes.position,Lu=vu.morphAttributes.position,Du=vu.morphTargetsRelative,Ou=vu.attributes.normal,Wu=vu.morphAttributes.position,Zu=vu.groups,Hu=vu.drawRange;let Yu,Ku,ju,tp,gp,yp,Cp;const Hp=new Float32Array(_u.count*_u.itemSize),wp=new Float32Array(Ou.count*Ou.itemSize);if(Bu!==null)if(Array.isArray(Su))for(Yu=0,ju=Zu.length;Yu<ju;Yu++)for(gp=Zu[Yu],yp=Math.max(gp.start,Hu.start),Cp=Math.min(gp.start+gp.count,Hu.start+Hu.count),Ku=yp,tp=Cp;Ku<tp;Ku+=3)Iu=Bu.getX(Ku),Mu=Bu.getX(Ku+1),ku=Bu.getX(Ku+2),xu(iu,_u,Lu,Du,Iu,Mu,ku,Hp),xu(iu,Ou,Wu,Du,Iu,Mu,ku,wp);else for(yp=Math.max(0,Hu.start),Cp=Math.min(Bu.count,Hu.start+Hu.count),Yu=yp,ju=Cp;Yu<ju;Yu+=3)Iu=Bu.getX(Yu),Mu=Bu.getX(Yu+1),ku=Bu.getX(Yu+2),xu(iu,_u,Lu,Du,Iu,Mu,ku,Hp),xu(iu,Ou,Wu,Du,Iu,Mu,ku,wp);else if(Array.isArray(Su))for(Yu=0,ju=Zu.length;Yu<ju;Yu++)for(gp=Zu[Yu],yp=Math.max(gp.start,Hu.start),Cp=Math.min(gp.start+gp.count,Hu.start+Hu.count),Ku=yp,tp=Cp;Ku<tp;Ku+=3)Iu=Ku,Mu=Ku+1,ku=Ku+2,xu(iu,_u,Lu,Du,Iu,Mu,ku,Hp),xu(iu,Ou,Wu,Du,Iu,Mu,ku,wp);else for(yp=Math.max(0,Hu.start),Cp=Math.min(_u.count,Hu.start+Hu.count),Yu=yp,ju=Cp;Yu<ju;Yu+=3)Iu=Yu,Mu=Yu+1,ku=Yu+2,xu(iu,_u,Lu,Du,Iu,Mu,ku,Hp),xu(iu,Ou,Wu,Du,Iu,Mu,ku,wp);return{positionAttribute:_u,normalAttribute:Ou,morphedPositionAttribute:new Re.Float32BufferAttribute(Hp,3),morphedNormalAttribute:new Re.Float32BufferAttribute(wp,3)}}function We(iu){if(iu.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),iu;let eu=iu.groups;if(eu=eu.sort((du,fu)=>du.materialIndex!==fu.materialIndex?du.materialIndex-fu.materialIndex:du.start-fu.start),iu.getIndex()===null){const du=iu.getAttribute("position"),fu=[];for(let gu=0;gu<du.count;gu+=3)fu.push(gu,gu+1,gu+2);iu.setIndex(fu)}const tu=iu.getIndex(),su=[];for(let du=0;du<eu.length;du++){const fu=eu[du],gu=fu.start,yu=gu+fu.count;for(let xu=gu;xu<yu;xu++)su.push(tu.getX(xu))}iu.dispose(),iu.setIndex(su);let au=0;for(let du=0;du<eu.length;du++){const fu=eu[du];fu.start=au,au+=fu.count}let uu=eu[0];iu.groups=[uu];for(let du=1;du<eu.length;du++){const fu=eu[du];uu.materialIndex===fu.materialIndex?uu.count+=fu.count:(uu=fu,iu.groups.push(uu))}return iu}function Je(iu,eu=Math.PI/3){const tu=Math.cos(eu),su=100*(1+1e-10),au=[new Re.Vector3,new Re.Vector3,new Re.Vector3],uu=new Re.Vector3,du=new Re.Vector3,fu=new Re.Vector3,gu=new Re.Vector3;function yu(ku){return`${~~(ku.x*su)},${~~(ku.y*su)},${~~(ku.z*su)}`}const xu=iu.index?iu.toNonIndexed():iu,vu=xu.attributes.position,Su={};for(let ku=0,Bu=vu.count/3;ku<Bu;ku++){const _u=3*ku,Lu=au[0].fromBufferAttribute(vu,_u+0),Du=au[1].fromBufferAttribute(vu,_u+1),Ou=au[2].fromBufferAttribute(vu,_u+2);uu.subVectors(Ou,Du),du.subVectors(Lu,Du);const Wu=new Re.Vector3().crossVectors(uu,du).normalize();for(let Zu=0;Zu<3;Zu++){const Hu=yu(au[Zu]);Hu in Su||(Su[Hu]=[]),Su[Hu].push(Wu)}}const Iu=new Float32Array(3*vu.count),Mu=new Re.BufferAttribute(Iu,3,!1);for(let ku=0,Bu=vu.count/3;ku<Bu;ku++){const _u=3*ku,Lu=au[0].fromBufferAttribute(vu,_u+0),Du=au[1].fromBufferAttribute(vu,_u+1),Ou=au[2].fromBufferAttribute(vu,_u+2);uu.subVectors(Ou,Du),du.subVectors(Lu,Du),fu.crossVectors(uu,du).normalize();for(let Wu=0;Wu<3;Wu++){const Zu=Su[yu(au[Wu])];gu.set(0,0,0);for(let Hu=0,Yu=Zu.length;Hu<Yu;Hu++){const Ku=Zu[Hu];fu.dot(Ku)>tu&&gu.add(Ku)}gu.normalize(),Mu.setXYZ(_u+Wu,gu.x,gu.y,gu.z)}}return xu.setAttribute("normal",Mu),xu}class Xe extends Re.Loader{constructor(eu){super(eu),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(tu){return new it(tu)}),this.register(function(tu){return new rt(tu)}),this.register(function(tu){return new ut(tu)}),this.register(function(tu){return new gt(tu)}),this.register(function(tu){return new pt(tu)}),this.register(function(tu){return new st(tu)}),this.register(function(tu){return new at(tu)}),this.register(function(tu){return new At(tu)}),this.register(function(tu){return new lt(tu)}),this.register(function(tu){return new nt(tu)}),this.register(function(tu){return new ct(tu)}),this.register(function(tu){return new ot(tu)}),this.register(function(tu){return new dt(tu)}),this.register(function(tu){return new ht(tu)}),this.register(function(tu){return new et(tu)}),this.register(function(tu){return new ft(tu)}),this.register(function(tu){return new mt(tu)})}load(eu,tu,su,au){const uu=this;let du;if(this.resourcePath!=="")du=this.resourcePath;else if(this.path!==""){const yu=Re.LoaderUtils.extractUrlBase(eu);du=Re.LoaderUtils.resolveURL(yu,this.path)}else du=Re.LoaderUtils.extractUrlBase(eu);this.manager.itemStart(eu);const fu=function(yu){au?au(yu):console.error(yu),uu.manager.itemError(eu),uu.manager.itemEnd(eu)},gu=new Re.FileLoader(this.manager);gu.setPath(this.path),gu.setResponseType("arraybuffer"),gu.setRequestHeader(this.requestHeader),gu.setWithCredentials(this.withCredentials),gu.load(eu,function(yu){try{uu.parse(yu,du,function(xu){tu(xu),uu.manager.itemEnd(eu)},fu)}catch(xu){fu(xu)}},su,fu)}setDRACOLoader(eu){return this.dracoLoader=eu,this}setKTX2Loader(eu){return this.ktx2Loader=eu,this}setMeshoptDecoder(eu){return this.meshoptDecoder=eu,this}register(eu){return this.pluginCallbacks.indexOf(eu)===-1&&this.pluginCallbacks.push(eu),this}unregister(eu){return this.pluginCallbacks.indexOf(eu)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(eu),1),this}parse(eu,tu,su,au){let uu;const du={},fu={},gu=new TextDecoder;if(typeof eu=="string")uu=JSON.parse(eu);else if(eu instanceof ArrayBuffer)if(gu.decode(new Uint8Array(eu,0,4))===Et){try{du[$e.KHR_BINARY_GLTF]=new Ct(eu)}catch(xu){return void(au&&au(xu))}uu=JSON.parse(du[$e.KHR_BINARY_GLTF].content)}else uu=JSON.parse(gu.decode(eu));else uu=eu;if(uu.asset===void 0||uu.asset.version[0]<2)return void(au&&au(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const yu=new _t(uu,{path:tu||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});yu.fileLoader.setRequestHeader(this.requestHeader);for(let xu=0;xu<this.pluginCallbacks.length;xu++){const vu=this.pluginCallbacks[xu](yu);vu.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),fu[vu.name]=vu,du[vu.name]=!0}if(uu.extensionsUsed)for(let xu=0;xu<uu.extensionsUsed.length;++xu){const vu=uu.extensionsUsed[xu],Su=uu.extensionsRequired||[];switch(vu){case $e.KHR_MATERIALS_UNLIT:du[vu]=new tt;break;case $e.KHR_DRACO_MESH_COMPRESSION:du[vu]=new vt(uu,this.dracoLoader);break;case $e.KHR_TEXTURE_TRANSFORM:du[vu]=new Bt;break;case $e.KHR_MESH_QUANTIZATION:du[vu]=new bt;break;default:Su.indexOf(vu)>=0&&fu[vu]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+vu+'".')}}yu.setExtensions(du),yu.setPlugins(fu),yu.parse(su,au)}parseAsync(eu,tu){const su=this;return new Promise(function(au,uu){su.parse(eu,tu,au,uu)})}}function Ze(){let iu={};return{get:function(eu){return iu[eu]},add:function(eu,tu){iu[eu]=tu},remove:function(eu){delete iu[eu]},removeAll:function(){iu={}}}}const $e={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class et{constructor(eu){this.parser=eu,this.name=$e.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const eu=this.parser,tu=this.parser.json.nodes||[];for(let su=0,au=tu.length;su<au;su++){const uu=tu[su];uu.extensions&&uu.extensions[this.name]&&uu.extensions[this.name].light!==void 0&&eu._addNodeRef(this.cache,uu.extensions[this.name].light)}}_loadLight(eu){const tu=this.parser,su="light:"+eu;let au=tu.cache.get(su);if(au)return au;const uu=tu.json,du=((uu.extensions&&uu.extensions[this.name]||{}).lights||[])[eu];let fu;const gu=new Re.Color(16777215);du.color!==void 0&&gu.setRGB(du.color[0],du.color[1],du.color[2],Re.LinearSRGBColorSpace);const yu=du.range!==void 0?du.range:0;switch(du.type){case"directional":fu=new Re.DirectionalLight(gu),fu.target.position.set(0,0,-1),fu.add(fu.target);break;case"point":fu=new Re.PointLight(gu),fu.distance=yu;break;case"spot":fu=new Re.SpotLight(gu),fu.distance=yu,du.spot=du.spot||{},du.spot.innerConeAngle=du.spot.innerConeAngle!==void 0?du.spot.innerConeAngle:0,du.spot.outerConeAngle=du.spot.outerConeAngle!==void 0?du.spot.outerConeAngle:Math.PI/4,fu.angle=du.spot.outerConeAngle,fu.penumbra=1-du.spot.innerConeAngle/du.spot.outerConeAngle,fu.target.position.set(0,0,-1),fu.add(fu.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+du.type)}return fu.position.set(0,0,0),Ut(fu,du),du.intensity!==void 0&&(fu.intensity=du.intensity),fu.name=tu.createUniqueName(du.name||"light_"+eu),au=Promise.resolve(fu),tu.cache.add(su,au),au}getDependency(eu,tu){if(eu==="light")return this._loadLight(tu)}createNodeAttachment(eu){const tu=this,su=this.parser,au=su.json.nodes[eu],uu=(au.extensions&&au.extensions[this.name]||{}).light;return uu===void 0?null:this._loadLight(uu).then(function(du){return su._getNodeRef(tu.cache,uu,du)})}}class tt{constructor(){this.name=$e.KHR_MATERIALS_UNLIT}getMaterialType(){return Re.MeshBasicMaterial}extendParams(eu,tu,su){const au=[];eu.color=new Re.Color(1,1,1),eu.opacity=1;const uu=tu.pbrMetallicRoughness;if(uu){if(Array.isArray(uu.baseColorFactor)){const du=uu.baseColorFactor;eu.color.setRGB(du[0],du[1],du[2],Re.LinearSRGBColorSpace),eu.opacity=du[3]}uu.baseColorTexture!==void 0&&au.push(su.assignTexture(eu,"map",uu.baseColorTexture,Re.SRGBColorSpace))}return Promise.all(au)}}class nt{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(eu,tu){const su=this.parser.json.materials[eu];if(!su.extensions||!su.extensions[this.name])return Promise.resolve();const au=su.extensions[this.name].emissiveStrength;return au!==void 0&&(tu.emissiveIntensity=au),Promise.resolve()}}class it{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_CLEARCOAT}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];if(du.clearcoatFactor!==void 0&&(tu.clearcoat=du.clearcoatFactor),du.clearcoatTexture!==void 0&&uu.push(su.assignTexture(tu,"clearcoatMap",du.clearcoatTexture)),du.clearcoatRoughnessFactor!==void 0&&(tu.clearcoatRoughness=du.clearcoatRoughnessFactor),du.clearcoatRoughnessTexture!==void 0&&uu.push(su.assignTexture(tu,"clearcoatRoughnessMap",du.clearcoatRoughnessTexture)),du.clearcoatNormalTexture!==void 0&&(uu.push(su.assignTexture(tu,"clearcoatNormalMap",du.clearcoatNormalTexture)),du.clearcoatNormalTexture.scale!==void 0)){const fu=du.clearcoatNormalTexture.scale;tu.clearcoatNormalScale=new Re.Vector2(fu,fu)}return Promise.all(uu)}}class rt{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_DISPERSION}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser.json.materials[eu];if(!su.extensions||!su.extensions[this.name])return Promise.resolve();const au=su.extensions[this.name];return tu.dispersion=au.dispersion!==void 0?au.dispersion:0,Promise.resolve()}}class ot{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_IRIDESCENCE}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];return du.iridescenceFactor!==void 0&&(tu.iridescence=du.iridescenceFactor),du.iridescenceTexture!==void 0&&uu.push(su.assignTexture(tu,"iridescenceMap",du.iridescenceTexture)),du.iridescenceIor!==void 0&&(tu.iridescenceIOR=du.iridescenceIor),tu.iridescenceThicknessRange===void 0&&(tu.iridescenceThicknessRange=[100,400]),du.iridescenceThicknessMinimum!==void 0&&(tu.iridescenceThicknessRange[0]=du.iridescenceThicknessMinimum),du.iridescenceThicknessMaximum!==void 0&&(tu.iridescenceThicknessRange[1]=du.iridescenceThicknessMaximum),du.iridescenceThicknessTexture!==void 0&&uu.push(su.assignTexture(tu,"iridescenceThicknessMap",du.iridescenceThicknessTexture)),Promise.all(uu)}}class st{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_SHEEN}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[];tu.sheenColor=new Re.Color(0,0,0),tu.sheenRoughness=0,tu.sheen=1;const du=au.extensions[this.name];if(du.sheenColorFactor!==void 0){const fu=du.sheenColorFactor;tu.sheenColor.setRGB(fu[0],fu[1],fu[2],Re.LinearSRGBColorSpace)}return du.sheenRoughnessFactor!==void 0&&(tu.sheenRoughness=du.sheenRoughnessFactor),du.sheenColorTexture!==void 0&&uu.push(su.assignTexture(tu,"sheenColorMap",du.sheenColorTexture,Re.SRGBColorSpace)),du.sheenRoughnessTexture!==void 0&&uu.push(su.assignTexture(tu,"sheenRoughnessMap",du.sheenRoughnessTexture)),Promise.all(uu)}}class at{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_TRANSMISSION}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];return du.transmissionFactor!==void 0&&(tu.transmission=du.transmissionFactor),du.transmissionTexture!==void 0&&uu.push(su.assignTexture(tu,"transmissionMap",du.transmissionTexture)),Promise.all(uu)}}class At{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_VOLUME}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];tu.thickness=du.thicknessFactor!==void 0?du.thicknessFactor:0,du.thicknessTexture!==void 0&&uu.push(su.assignTexture(tu,"thicknessMap",du.thicknessTexture)),tu.attenuationDistance=du.attenuationDistance||1/0;const fu=du.attenuationColor||[1,1,1];return tu.attenuationColor=new Re.Color().setRGB(fu[0],fu[1],fu[2],Re.LinearSRGBColorSpace),Promise.all(uu)}}class lt{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_IOR}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser.json.materials[eu];if(!su.extensions||!su.extensions[this.name])return Promise.resolve();const au=su.extensions[this.name];return tu.ior=au.ior!==void 0?au.ior:1.5,Promise.resolve()}}class ct{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_SPECULAR}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];tu.specularIntensity=du.specularFactor!==void 0?du.specularFactor:1,du.specularTexture!==void 0&&uu.push(su.assignTexture(tu,"specularIntensityMap",du.specularTexture));const fu=du.specularColorFactor||[1,1,1];return tu.specularColor=new Re.Color().setRGB(fu[0],fu[1],fu[2],Re.LinearSRGBColorSpace),du.specularColorTexture!==void 0&&uu.push(su.assignTexture(tu,"specularColorMap",du.specularColorTexture,Re.SRGBColorSpace)),Promise.all(uu)}}class ht{constructor(eu){this.parser=eu,this.name=$e.EXT_MATERIALS_BUMP}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];return tu.bumpScale=du.bumpFactor!==void 0?du.bumpFactor:1,du.bumpTexture!==void 0&&uu.push(su.assignTexture(tu,"bumpMap",du.bumpTexture)),Promise.all(uu)}}class dt{constructor(eu){this.parser=eu,this.name=$e.KHR_MATERIALS_ANISOTROPY}getMaterialType(eu){const tu=this.parser.json.materials[eu];return tu.extensions&&tu.extensions[this.name]?Re.MeshPhysicalMaterial:null}extendMaterialParams(eu,tu){const su=this.parser,au=su.json.materials[eu];if(!au.extensions||!au.extensions[this.name])return Promise.resolve();const uu=[],du=au.extensions[this.name];return du.anisotropyStrength!==void 0&&(tu.anisotropy=du.anisotropyStrength),du.anisotropyRotation!==void 0&&(tu.anisotropyRotation=du.anisotropyRotation),du.anisotropyTexture!==void 0&&uu.push(su.assignTexture(tu,"anisotropyMap",du.anisotropyTexture)),Promise.all(uu)}}class ut{constructor(eu){this.parser=eu,this.name=$e.KHR_TEXTURE_BASISU}loadTexture(eu){const tu=this.parser,su=tu.json,au=su.textures[eu];if(!au.extensions||!au.extensions[this.name])return null;const uu=au.extensions[this.name],du=tu.options.ktx2Loader;if(!du){if(su.extensionsRequired&&su.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return tu.loadTextureImage(eu,uu.source,du)}}class gt{constructor(eu){this.parser=eu,this.name=$e.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(eu){const tu=this.name,su=this.parser,au=su.json,uu=au.textures[eu];if(!uu.extensions||!uu.extensions[tu])return null;const du=uu.extensions[tu],fu=au.images[du.source];let gu=su.textureLoader;if(fu.uri){const yu=su.options.manager.getHandler(fu.uri);yu!==null&&(gu=yu)}return this.detectSupport().then(function(yu){if(yu)return su.loadTextureImage(eu,du.source,gu);if(au.extensionsRequired&&au.extensionsRequired.indexOf(tu)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return su.loadTexture(eu)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(eu){const tu=new Image;tu.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",tu.onload=tu.onerror=function(){eu(tu.height===1)}})),this.isSupported}}class pt{constructor(eu){this.parser=eu,this.name=$e.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(eu){const tu=this.name,su=this.parser,au=su.json,uu=au.textures[eu];if(!uu.extensions||!uu.extensions[tu])return null;const du=uu.extensions[tu],fu=au.images[du.source];let gu=su.textureLoader;if(fu.uri){const yu=su.options.manager.getHandler(fu.uri);yu!==null&&(gu=yu)}return this.detectSupport().then(function(yu){if(yu)return su.loadTextureImage(eu,du.source,gu);if(au.extensionsRequired&&au.extensionsRequired.indexOf(tu)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return su.loadTexture(eu)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(eu){const tu=new Image;tu.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",tu.onload=tu.onerror=function(){eu(tu.height===1)}})),this.isSupported}}class ft{constructor(eu){this.name=$e.EXT_MESHOPT_COMPRESSION,this.parser=eu}loadBufferView(eu){const tu=this.parser.json,su=tu.bufferViews[eu];if(su.extensions&&su.extensions[this.name]){const au=su.extensions[this.name],uu=this.parser.getDependency("buffer",au.buffer),du=this.parser.options.meshoptDecoder;if(!du||!du.supported){if(tu.extensionsRequired&&tu.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return uu.then(function(fu){const gu=au.byteOffset||0,yu=au.byteLength||0,xu=au.count,vu=au.byteStride,Su=new Uint8Array(fu,gu,yu);return du.decodeGltfBufferAsync?du.decodeGltfBufferAsync(xu,vu,Su,au.mode,au.filter).then(function(Iu){return Iu.buffer}):du.ready.then(function(){const Iu=new ArrayBuffer(xu*vu);return du.decodeGltfBuffer(new Uint8Array(Iu),xu,vu,Su,au.mode,au.filter),Iu})})}return null}}class mt{constructor(eu){this.name=$e.EXT_MESH_GPU_INSTANCING,this.parser=eu}createNodeMesh(eu){const tu=this.parser.json,su=tu.nodes[eu];if(!su.extensions||!su.extensions[this.name]||su.mesh===void 0)return null;const au=tu.meshes[su.mesh];for(const gu of au.primitives)if(gu.mode!==xt.TRIANGLES&&gu.mode!==xt.TRIANGLE_STRIP&&gu.mode!==xt.TRIANGLE_FAN&&gu.mode!==void 0)return null;const uu=su.extensions[this.name].attributes,du=[],fu={};for(const gu in uu)du.push(this.parser.getDependency("accessor",uu[gu]).then(yu=>(fu[gu]=yu,fu[gu])));return du.length<1?null:(du.push(this.parser.createNodeMesh(eu)),Promise.all(du).then(gu=>{const yu=gu.pop(),xu=yu.isGroup?yu.children:[yu],vu=gu[0].count,Su=[];for(const Iu of xu){const Mu=new Re.Matrix4,ku=new Re.Vector3,Bu=new Re.Quaternion,_u=new Re.Vector3(1,1,1),Lu=new Re.InstancedMesh(Iu.geometry,Iu.material,vu);for(let Du=0;Du<vu;Du++)fu.TRANSLATION&&ku.fromBufferAttribute(fu.TRANSLATION,Du),fu.ROTATION&&Bu.fromBufferAttribute(fu.ROTATION,Du),fu.SCALE&&_u.fromBufferAttribute(fu.SCALE,Du),Lu.setMatrixAt(Du,Mu.compose(ku,Bu,_u));for(const Du in fu)if(Du==="_COLOR_0"){const Ou=fu[Du];Lu.instanceColor=new Re.InstancedBufferAttribute(Ou.array,Ou.itemSize,Ou.normalized)}else Du!=="TRANSLATION"&&Du!=="ROTATION"&&Du!=="SCALE"&&Iu.geometry.setAttribute(Du,fu[Du]);Re.Object3D.prototype.copy.call(Lu,Iu),this.parser.assignFinalMaterial(Lu),Su.push(Lu)}return yu.isGroup?(yu.clear(),yu.add(...Su),yu):Su[0]}))}}const Et="glTF";class Ct{constructor(eu){this.name=$e.KHR_BINARY_GLTF,this.content=null,this.body=null;const tu=new DataView(eu,0,12),su=new TextDecoder;if(this.header={magic:su.decode(new Uint8Array(eu.slice(0,4))),version:tu.getUint32(4,!0),length:tu.getUint32(8,!0)},this.header.magic!==Et)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const au=this.header.length-12,uu=new DataView(eu,12);let du=0;for(;du<au;){const fu=uu.getUint32(du,!0);du+=4;const gu=uu.getUint32(du,!0);if(du+=4,gu===1313821514){const yu=new Uint8Array(eu,12+du,fu);this.content=su.decode(yu)}else if(gu===5130562){const yu=12+du;this.body=eu.slice(yu,yu+fu)}du+=fu}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class vt{constructor(eu,tu){if(!tu)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=$e.KHR_DRACO_MESH_COMPRESSION,this.json=eu,this.dracoLoader=tu,this.dracoLoader.preload()}decodePrimitive(eu,tu){const su=this.json,au=this.dracoLoader,uu=eu.extensions[this.name].bufferView,du=eu.extensions[this.name].attributes,fu={},gu={},yu={};for(const xu in du){const vu=Dt[xu]||xu.toLowerCase();fu[vu]=du[xu]}for(const xu in eu.attributes){const vu=Dt[xu]||xu.toLowerCase();if(du[xu]!==void 0){const Su=su.accessors[eu.attributes[xu]],Iu=Qt[Su.componentType];yu[vu]=Iu.name,gu[vu]=Su.normalized===!0}}return tu.getDependency("bufferView",uu).then(function(xu){return new Promise(function(vu,Su){au.decodeDracoFile(xu,function(Iu){for(const Mu in Iu.attributes){const ku=Iu.attributes[Mu],Bu=gu[Mu];Bu!==void 0&&(ku.normalized=Bu)}vu(Iu)},fu,yu,Re.LinearSRGBColorSpace,Su)})})}}class Bt{constructor(){this.name=$e.KHR_TEXTURE_TRANSFORM}extendTexture(eu,tu){return(tu.texCoord!==void 0&&tu.texCoord!==eu.channel||tu.offset!==void 0||tu.rotation!==void 0||tu.scale!==void 0)&&(eu=eu.clone(),tu.texCoord!==void 0&&(eu.channel=tu.texCoord),tu.offset!==void 0&&eu.offset.fromArray(tu.offset),tu.rotation!==void 0&&(eu.rotation=tu.rotation),tu.scale!==void 0&&eu.repeat.fromArray(tu.scale),eu.needsUpdate=!0),eu}}class bt{constructor(){this.name=$e.KHR_MESH_QUANTIZATION}}class yt extends Re.Interpolant{constructor(eu,tu,su,au){super(eu,tu,su,au)}copySampleValue_(eu){const tu=this.resultBuffer,su=this.sampleValues,au=this.valueSize,uu=eu*au*3+au;for(let du=0;du!==au;du++)tu[du]=su[uu+du];return tu}interpolate_(eu,tu,su,au){const uu=this.resultBuffer,du=this.sampleValues,fu=this.valueSize,gu=2*fu,yu=3*fu,xu=au-tu,vu=(su-tu)/xu,Su=vu*vu,Iu=Su*vu,Mu=eu*yu,ku=Mu-yu,Bu=-2*Iu+3*Su,_u=Iu-Su,Lu=1-Bu,Du=_u-Su+vu;for(let Ou=0;Ou!==fu;Ou++){const Wu=du[ku+Ou+fu],Zu=du[ku+Ou+gu]*xu,Hu=du[Mu+Ou+fu],Yu=du[Mu+Ou]*xu;uu[Ou]=Lu*Wu+Du*Zu+Bu*Hu+_u*Yu}return uu}}const It=new Re.Quaternion;class wt extends yt{interpolate_(eu,tu,su,au){const uu=super.interpolate_(eu,tu,su,au);return It.fromArray(uu).normalize().toArray(uu),uu}}const xt={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Qt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Lt={9728:Re.NearestFilter,9729:Re.LinearFilter,9984:Re.NearestMipmapNearestFilter,9985:Re.LinearMipmapNearestFilter,9986:Re.NearestMipmapLinearFilter,9987:Re.LinearMipmapLinearFilter},Mt={33071:Re.ClampToEdgeWrapping,33648:Re.MirroredRepeatWrapping,10497:Re.RepeatWrapping},St={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Dt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},kt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Tt={CUBICSPLINE:void 0,LINEAR:Re.InterpolateLinear,STEP:Re.InterpolateDiscrete};function Rt(iu){return iu.DefaultMaterial===void 0&&(iu.DefaultMaterial=new Re.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Re.FrontSide})),iu.DefaultMaterial}function Ft(iu,eu,tu){for(const su in tu.extensions)iu[su]===void 0&&(eu.userData.gltfExtensions=eu.userData.gltfExtensions||{},eu.userData.gltfExtensions[su]=tu.extensions[su])}function Ut(iu,eu){eu.extras!==void 0&&(typeof eu.extras=="object"?Object.assign(iu.userData,eu.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+eu.extras))}function Ot(iu,eu){if(iu.updateMorphTargets(),eu.weights!==void 0)for(let tu=0,su=eu.weights.length;tu<su;tu++)iu.morphTargetInfluences[tu]=eu.weights[tu];if(eu.extras&&Array.isArray(eu.extras.targetNames)){const tu=eu.extras.targetNames;if(iu.morphTargetInfluences.length===tu.length){iu.morphTargetDictionary={};for(let su=0,au=tu.length;su<au;su++)iu.morphTargetDictionary[tu[su]]=su}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Pt(iu){let eu;const tu=iu.extensions&&iu.extensions[$e.KHR_DRACO_MESH_COMPRESSION];if(eu=tu?"draco:"+tu.bufferView+":"+tu.indices+":"+Gt(tu.attributes):iu.indices+":"+Gt(iu.attributes)+":"+iu.mode,iu.targets!==void 0)for(let su=0,au=iu.targets.length;su<au;su++)eu+=":"+Gt(iu.targets[su]);return eu}function Gt(iu){let eu="";const tu=Object.keys(iu).sort();for(let su=0,au=tu.length;su<au;su++)eu+=tu[su]+":"+iu[tu[su]]+";";return eu}function Nt(iu){switch(iu){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const jt=new Re.Matrix4;class _t{constructor(eu={},tu={}){this.json=eu,this.extensions={},this.plugins={},this.options=tu,this.cache=new Ze,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let su=!1,au=-1,uu=!1,du=-1;if(typeof navigator<"u"){const fu=navigator.userAgent;su=/^((?!chrome|android).)*safari/i.test(fu)===!0;const gu=fu.match(/Version\/(\d+)/);au=su&&gu?parseInt(gu[1],10):-1,uu=fu.indexOf("Firefox")>-1,du=uu?fu.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||su&&au<17||uu&&du<98?this.textureLoader=new Re.TextureLoader(this.options.manager):this.textureLoader=new Re.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Re.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(eu){this.extensions=eu}setPlugins(eu){this.plugins=eu}parse(eu,tu){const su=this,au=this.json,uu=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(du){return du._markDefs&&du._markDefs()}),Promise.all(this._invokeAll(function(du){return du.beforeRoot&&du.beforeRoot()})).then(function(){return Promise.all([su.getDependencies("scene"),su.getDependencies("animation"),su.getDependencies("camera")])}).then(function(du){const fu={scene:du[0][au.scene||0],scenes:du[0],animations:du[1],cameras:du[2],asset:au.asset,parser:su,userData:{}};return Ft(uu,fu,au),Ut(fu,au),Promise.all(su._invokeAll(function(gu){return gu.afterRoot&&gu.afterRoot(fu)})).then(function(){for(const gu of fu.scenes)gu.updateMatrixWorld();eu(fu)})}).catch(tu)}_markDefs(){const eu=this.json.nodes||[],tu=this.json.skins||[],su=this.json.meshes||[];for(let au=0,uu=tu.length;au<uu;au++){const du=tu[au].joints;for(let fu=0,gu=du.length;fu<gu;fu++)eu[du[fu]].isBone=!0}for(let au=0,uu=eu.length;au<uu;au++){const du=eu[au];du.mesh!==void 0&&(this._addNodeRef(this.meshCache,du.mesh),du.skin!==void 0&&(su[du.mesh].isSkinnedMesh=!0)),du.camera!==void 0&&this._addNodeRef(this.cameraCache,du.camera)}}_addNodeRef(eu,tu){tu!==void 0&&(eu.refs[tu]===void 0&&(eu.refs[tu]=eu.uses[tu]=0),eu.refs[tu]++)}_getNodeRef(eu,tu,su){if(eu.refs[tu]<=1)return su;const au=su.clone(),uu=(du,fu)=>{const gu=this.associations.get(du);gu!=null&&this.associations.set(fu,gu);for(const[yu,xu]of du.children.entries())uu(xu,fu.children[yu])};return uu(su,au),au.name+="_instance_"+eu.uses[tu]++,au}_invokeOne(eu){const tu=Object.values(this.plugins);tu.push(this);for(let su=0;su<tu.length;su++){const au=eu(tu[su]);if(au)return au}return null}_invokeAll(eu){const tu=Object.values(this.plugins);tu.unshift(this);const su=[];for(let au=0;au<tu.length;au++){const uu=eu(tu[au]);uu&&su.push(uu)}return su}getDependency(eu,tu){const su=eu+":"+tu;let au=this.cache.get(su);if(!au){switch(eu){case"scene":au=this.loadScene(tu);break;case"node":au=this._invokeOne(function(uu){return uu.loadNode&&uu.loadNode(tu)});break;case"mesh":au=this._invokeOne(function(uu){return uu.loadMesh&&uu.loadMesh(tu)});break;case"accessor":au=this.loadAccessor(tu);break;case"bufferView":au=this._invokeOne(function(uu){return uu.loadBufferView&&uu.loadBufferView(tu)});break;case"buffer":au=this.loadBuffer(tu);break;case"material":au=this._invokeOne(function(uu){return uu.loadMaterial&&uu.loadMaterial(tu)});break;case"texture":au=this._invokeOne(function(uu){return uu.loadTexture&&uu.loadTexture(tu)});break;case"skin":au=this.loadSkin(tu);break;case"animation":au=this._invokeOne(function(uu){return uu.loadAnimation&&uu.loadAnimation(tu)});break;case"camera":au=this.loadCamera(tu);break;default:if(au=this._invokeOne(function(uu){return uu!=this&&uu.getDependency&&uu.getDependency(eu,tu)}),!au)throw new Error("Unknown type: "+eu)}this.cache.add(su,au)}return au}getDependencies(eu){let tu=this.cache.get(eu);if(!tu){const su=this,au=this.json[eu+(eu==="mesh"?"es":"s")]||[];tu=Promise.all(au.map(function(uu,du){return su.getDependency(eu,du)})),this.cache.add(eu,tu)}return tu}loadBuffer(eu){const tu=this.json.buffers[eu],su=this.fileLoader;if(tu.type&&tu.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+tu.type+" buffer type is not supported.");if(tu.uri===void 0&&eu===0)return Promise.resolve(this.extensions[$e.KHR_BINARY_GLTF].body);const au=this.options;return new Promise(function(uu,du){su.load(Re.LoaderUtils.resolveURL(tu.uri,au.path),uu,void 0,function(){du(new Error('THREE.GLTFLoader: Failed to load buffer "'+tu.uri+'".'))})})}loadBufferView(eu){const tu=this.json.bufferViews[eu];return this.getDependency("buffer",tu.buffer).then(function(su){const au=tu.byteLength||0,uu=tu.byteOffset||0;return su.slice(uu,uu+au)})}loadAccessor(eu){const tu=this,su=this.json,au=this.json.accessors[eu];if(au.bufferView===void 0&&au.sparse===void 0){const du=St[au.type],fu=Qt[au.componentType],gu=au.normalized===!0,yu=new fu(au.count*du);return Promise.resolve(new Re.BufferAttribute(yu,du,gu))}const uu=[];return au.bufferView!==void 0?uu.push(this.getDependency("bufferView",au.bufferView)):uu.push(null),au.sparse!==void 0&&(uu.push(this.getDependency("bufferView",au.sparse.indices.bufferView)),uu.push(this.getDependency("bufferView",au.sparse.values.bufferView))),Promise.all(uu).then(function(du){const fu=du[0],gu=St[au.type],yu=Qt[au.componentType],xu=yu.BYTES_PER_ELEMENT,vu=xu*gu,Su=au.byteOffset||0,Iu=au.bufferView!==void 0?su.bufferViews[au.bufferView].byteStride:void 0,Mu=au.normalized===!0;let ku,Bu;if(Iu&&Iu!==vu){const _u=Math.floor(Su/Iu),Lu="InterleavedBuffer:"+au.bufferView+":"+au.componentType+":"+_u+":"+au.count;let Du=tu.cache.get(Lu);Du||(ku=new yu(fu,_u*Iu,au.count*Iu/xu),Du=new Re.InterleavedBuffer(ku,Iu/xu),tu.cache.add(Lu,Du)),Bu=new Re.InterleavedBufferAttribute(Du,gu,Su%Iu/xu,Mu)}else ku=fu===null?new yu(au.count*gu):new yu(fu,Su,au.count*gu),Bu=new Re.BufferAttribute(ku,gu,Mu);if(au.sparse!==void 0){const _u=St.SCALAR,Lu=Qt[au.sparse.indices.componentType],Du=au.sparse.indices.byteOffset||0,Ou=au.sparse.values.byteOffset||0,Wu=new Lu(du[1],Du,au.sparse.count*_u),Zu=new yu(du[2],Ou,au.sparse.count*gu);fu!==null&&(Bu=new Re.BufferAttribute(Bu.array.slice(),Bu.itemSize,Bu.normalized)),Bu.normalized=!1;for(let Hu=0,Yu=Wu.length;Hu<Yu;Hu++){const Ku=Wu[Hu];if(Bu.setX(Ku,Zu[Hu*gu]),gu>=2&&Bu.setY(Ku,Zu[Hu*gu+1]),gu>=3&&Bu.setZ(Ku,Zu[Hu*gu+2]),gu>=4&&Bu.setW(Ku,Zu[Hu*gu+3]),gu>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}Bu.normalized=Mu}return Bu})}loadTexture(eu){const tu=this.json,su=this.options,au=tu.textures[eu].source,uu=tu.images[au];let du=this.textureLoader;if(uu.uri){const fu=su.manager.getHandler(uu.uri);fu!==null&&(du=fu)}return this.loadTextureImage(eu,au,du)}loadTextureImage(eu,tu,su){const au=this,uu=this.json,du=uu.textures[eu],fu=uu.images[tu],gu=(fu.uri||fu.bufferView)+":"+du.sampler;if(this.textureCache[gu])return this.textureCache[gu];const yu=this.loadImageSource(tu,su).then(function(xu){xu.flipY=!1,xu.name=du.name||fu.name||"",xu.name===""&&typeof fu.uri=="string"&&fu.uri.startsWith("data:image/")===!1&&(xu.name=fu.uri);const vu=(uu.samplers||{})[du.sampler]||{};return xu.magFilter=Lt[vu.magFilter]||Re.LinearFilter,xu.minFilter=Lt[vu.minFilter]||Re.LinearMipmapLinearFilter,xu.wrapS=Mt[vu.wrapS]||Re.RepeatWrapping,xu.wrapT=Mt[vu.wrapT]||Re.RepeatWrapping,xu.generateMipmaps=!xu.isCompressedTexture&&xu.minFilter!==Re.NearestFilter&&xu.minFilter!==Re.LinearFilter,au.associations.set(xu,{textures:eu}),xu}).catch(function(){return null});return this.textureCache[gu]=yu,yu}loadImageSource(eu,tu){const su=this.json,au=this.options;if(this.sourceCache[eu]!==void 0)return this.sourceCache[eu].then(xu=>xu.clone());const uu=su.images[eu],du=self.URL||self.webkitURL;let fu=uu.uri||"",gu=!1;if(uu.bufferView!==void 0)fu=this.getDependency("bufferView",uu.bufferView).then(function(xu){gu=!0;const vu=new Blob([xu],{type:uu.mimeType});return fu=du.createObjectURL(vu),fu});else if(uu.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+eu+" is missing URI and bufferView");const yu=Promise.resolve(fu).then(function(xu){return new Promise(function(vu,Su){let Iu=vu;tu.isImageBitmapLoader===!0&&(Iu=function(Mu){const ku=new Re.Texture(Mu);ku.needsUpdate=!0,vu(ku)}),tu.load(Re.LoaderUtils.resolveURL(xu,au.path),Iu,void 0,Su)})}).then(function(xu){var vu;return gu===!0&&du.revokeObjectURL(fu),Ut(xu,uu),xu.userData.mimeType=uu.mimeType||((vu=uu.uri).search(/\.jpe?g($|\?)/i)>0||vu.search(/^data\:image\/jpeg/)===0?"image/jpeg":vu.search(/\.webp($|\?)/i)>0||vu.search(/^data\:image\/webp/)===0?"image/webp":vu.search(/\.ktx2($|\?)/i)>0||vu.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"),xu}).catch(function(xu){throw console.error("THREE.GLTFLoader: Couldn't load texture",fu),xu});return this.sourceCache[eu]=yu,yu}assignTexture(eu,tu,su,au){const uu=this;return this.getDependency("texture",su.index).then(function(du){if(!du)return null;if(su.texCoord!==void 0&&su.texCoord>0&&((du=du.clone()).channel=su.texCoord),uu.extensions[$e.KHR_TEXTURE_TRANSFORM]){const fu=su.extensions!==void 0?su.extensions[$e.KHR_TEXTURE_TRANSFORM]:void 0;if(fu){const gu=uu.associations.get(du);du=uu.extensions[$e.KHR_TEXTURE_TRANSFORM].extendTexture(du,fu),uu.associations.set(du,gu)}}return au!==void 0&&(du.colorSpace=au),eu[tu]=du,du})}assignFinalMaterial(eu){const tu=eu.geometry;let su=eu.material;const au=tu.attributes.tangent===void 0,uu=tu.attributes.color!==void 0,du=tu.attributes.normal===void 0;if(eu.isPoints){const fu="PointsMaterial:"+su.uuid;let gu=this.cache.get(fu);gu||(gu=new Re.PointsMaterial,Re.Material.prototype.copy.call(gu,su),gu.color.copy(su.color),gu.map=su.map,gu.sizeAttenuation=!1,this.cache.add(fu,gu)),su=gu}else if(eu.isLine){const fu="LineBasicMaterial:"+su.uuid;let gu=this.cache.get(fu);gu||(gu=new Re.LineBasicMaterial,Re.Material.prototype.copy.call(gu,su),gu.color.copy(su.color),gu.map=su.map,this.cache.add(fu,gu)),su=gu}if(au||uu||du){let fu="ClonedMaterial:"+su.uuid+":";au&&(fu+="derivative-tangents:"),uu&&(fu+="vertex-colors:"),du&&(fu+="flat-shading:");let gu=this.cache.get(fu);gu||(gu=su.clone(),uu&&(gu.vertexColors=!0),du&&(gu.flatShading=!0),au&&(gu.normalScale&&(gu.normalScale.y*=-1),gu.clearcoatNormalScale&&(gu.clearcoatNormalScale.y*=-1)),this.cache.add(fu,gu),this.associations.set(gu,this.associations.get(su))),su=gu}eu.material=su}getMaterialType(){return Re.MeshStandardMaterial}loadMaterial(eu){const tu=this,su=this.json,au=this.extensions,uu=su.materials[eu];let du;const fu={},gu=[];if((uu.extensions||{})[$e.KHR_MATERIALS_UNLIT]){const xu=au[$e.KHR_MATERIALS_UNLIT];du=xu.getMaterialType(),gu.push(xu.extendParams(fu,uu,tu))}else{const xu=uu.pbrMetallicRoughness||{};if(fu.color=new Re.Color(1,1,1),fu.opacity=1,Array.isArray(xu.baseColorFactor)){const vu=xu.baseColorFactor;fu.color.setRGB(vu[0],vu[1],vu[2],Re.LinearSRGBColorSpace),fu.opacity=vu[3]}xu.baseColorTexture!==void 0&&gu.push(tu.assignTexture(fu,"map",xu.baseColorTexture,Re.SRGBColorSpace)),fu.metalness=xu.metallicFactor!==void 0?xu.metallicFactor:1,fu.roughness=xu.roughnessFactor!==void 0?xu.roughnessFactor:1,xu.metallicRoughnessTexture!==void 0&&(gu.push(tu.assignTexture(fu,"metalnessMap",xu.metallicRoughnessTexture)),gu.push(tu.assignTexture(fu,"roughnessMap",xu.metallicRoughnessTexture))),du=this._invokeOne(function(vu){return vu.getMaterialType&&vu.getMaterialType(eu)}),gu.push(Promise.all(this._invokeAll(function(vu){return vu.extendMaterialParams&&vu.extendMaterialParams(eu,fu)})))}uu.doubleSided===!0&&(fu.side=Re.DoubleSide);const yu=uu.alphaMode||"OPAQUE";if(yu==="BLEND"?(fu.transparent=!0,fu.depthWrite=!1):(fu.transparent=!1,yu==="MASK"&&(fu.alphaTest=uu.alphaCutoff!==void 0?uu.alphaCutoff:.5)),uu.normalTexture!==void 0&&du!==Re.MeshBasicMaterial&&(gu.push(tu.assignTexture(fu,"normalMap",uu.normalTexture)),fu.normalScale=new Re.Vector2(1,1),uu.normalTexture.scale!==void 0)){const xu=uu.normalTexture.scale;fu.normalScale.set(xu,xu)}if(uu.occlusionTexture!==void 0&&du!==Re.MeshBasicMaterial&&(gu.push(tu.assignTexture(fu,"aoMap",uu.occlusionTexture)),uu.occlusionTexture.strength!==void 0&&(fu.aoMapIntensity=uu.occlusionTexture.strength)),uu.emissiveFactor!==void 0&&du!==Re.MeshBasicMaterial){const xu=uu.emissiveFactor;fu.emissive=new Re.Color().setRGB(xu[0],xu[1],xu[2],Re.LinearSRGBColorSpace)}return uu.emissiveTexture!==void 0&&du!==Re.MeshBasicMaterial&&gu.push(tu.assignTexture(fu,"emissiveMap",uu.emissiveTexture,Re.SRGBColorSpace)),Promise.all(gu).then(function(){const xu=new du(fu);return uu.name&&(xu.name=uu.name),Ut(xu,uu),tu.associations.set(xu,{materials:eu}),uu.extensions&&Ft(au,xu,uu),xu})}createUniqueName(eu){const tu=Re.PropertyBinding.sanitizeNodeName(eu||"");return tu in this.nodeNamesUsed?tu+"_"+ ++this.nodeNamesUsed[tu]:(this.nodeNamesUsed[tu]=0,tu)}loadGeometries(eu){const tu=this,su=this.extensions,au=this.primitiveCache;function uu(fu){return su[$e.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(fu,tu).then(function(gu){return Ht(gu,fu,tu)})}const du=[];for(let fu=0,gu=eu.length;fu<gu;fu++){const yu=eu[fu],xu=Pt(yu),vu=au[xu];if(vu)du.push(vu.promise);else{let Su;Su=yu.extensions&&yu.extensions[$e.KHR_DRACO_MESH_COMPRESSION]?uu(yu):Ht(new Re.BufferGeometry,yu,tu),au[xu]={primitive:yu,promise:Su},du.push(Su)}}return Promise.all(du)}loadMesh(eu){const tu=this,su=this.json,au=this.extensions,uu=su.meshes[eu],du=uu.primitives,fu=[];for(let gu=0,yu=du.length;gu<yu;gu++){const xu=du[gu].material===void 0?Rt(this.cache):this.getDependency("material",du[gu].material);fu.push(xu)}return fu.push(tu.loadGeometries(du)),Promise.all(fu).then(function(gu){const yu=gu.slice(0,gu.length-1),xu=gu[gu.length-1],vu=[];for(let Iu=0,Mu=xu.length;Iu<Mu;Iu++){const ku=xu[Iu],Bu=du[Iu];let _u;const Lu=yu[Iu];if(Bu.mode===xt.TRIANGLES||Bu.mode===xt.TRIANGLE_STRIP||Bu.mode===xt.TRIANGLE_FAN||Bu.mode===void 0)_u=uu.isSkinnedMesh===!0?new Re.SkinnedMesh(ku,Lu):new Re.Mesh(ku,Lu),_u.isSkinnedMesh===!0&&_u.normalizeSkinWeights(),Bu.mode===xt.TRIANGLE_STRIP?_u.geometry=Ye(_u.geometry,Re.TriangleStripDrawMode):Bu.mode===xt.TRIANGLE_FAN&&(_u.geometry=Ye(_u.geometry,Re.TriangleFanDrawMode));else if(Bu.mode===xt.LINES)_u=new Re.LineSegments(ku,Lu);else if(Bu.mode===xt.LINE_STRIP)_u=new Re.Line(ku,Lu);else if(Bu.mode===xt.LINE_LOOP)_u=new Re.LineLoop(ku,Lu);else{if(Bu.mode!==xt.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+Bu.mode);_u=new Re.Points(ku,Lu)}Object.keys(_u.geometry.morphAttributes).length>0&&Ot(_u,uu),_u.name=tu.createUniqueName(uu.name||"mesh_"+eu),Ut(_u,uu),Bu.extensions&&Ft(au,_u,Bu),tu.assignFinalMaterial(_u),vu.push(_u)}for(let Iu=0,Mu=vu.length;Iu<Mu;Iu++)tu.associations.set(vu[Iu],{meshes:eu,primitives:Iu});if(vu.length===1)return uu.extensions&&Ft(au,vu[0],uu),vu[0];const Su=new Re.Group;uu.extensions&&Ft(au,Su,uu),tu.associations.set(Su,{meshes:eu});for(let Iu=0,Mu=vu.length;Iu<Mu;Iu++)Su.add(vu[Iu]);return Su})}loadCamera(eu){let tu;const su=this.json.cameras[eu],au=su[su.type];if(au)return su.type==="perspective"?tu=new Re.PerspectiveCamera(Re.MathUtils.radToDeg(au.yfov),au.aspectRatio||1,au.znear||1,au.zfar||2e6):su.type==="orthographic"&&(tu=new Re.OrthographicCamera(-au.xmag,au.xmag,au.ymag,-au.ymag,au.znear,au.zfar)),su.name&&(tu.name=this.createUniqueName(su.name)),Ut(tu,su),Promise.resolve(tu);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(eu){const tu=this.json.skins[eu],su=[];for(let au=0,uu=tu.joints.length;au<uu;au++)su.push(this._loadNodeShallow(tu.joints[au]));return tu.inverseBindMatrices!==void 0?su.push(this.getDependency("accessor",tu.inverseBindMatrices)):su.push(null),Promise.all(su).then(function(au){const uu=au.pop(),du=au,fu=[],gu=[];for(let yu=0,xu=du.length;yu<xu;yu++){const vu=du[yu];if(vu){fu.push(vu);const Su=new Re.Matrix4;uu!==null&&Su.fromArray(uu.array,16*yu),gu.push(Su)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',tu.joints[yu])}return new Re.Skeleton(fu,gu)})}loadAnimation(eu){const tu=this.json,su=this,au=tu.animations[eu],uu=au.name?au.name:"animation_"+eu,du=[],fu=[],gu=[],yu=[],xu=[];for(let vu=0,Su=au.channels.length;vu<Su;vu++){const Iu=au.channels[vu],Mu=au.samplers[Iu.sampler],ku=Iu.target,Bu=ku.node,_u=au.parameters!==void 0?au.parameters[Mu.input]:Mu.input,Lu=au.parameters!==void 0?au.parameters[Mu.output]:Mu.output;ku.node!==void 0&&(du.push(this.getDependency("node",Bu)),fu.push(this.getDependency("accessor",_u)),gu.push(this.getDependency("accessor",Lu)),yu.push(Mu),xu.push(ku))}return Promise.all([Promise.all(du),Promise.all(fu),Promise.all(gu),Promise.all(yu),Promise.all(xu)]).then(function(vu){const Su=vu[0],Iu=vu[1],Mu=vu[2],ku=vu[3],Bu=vu[4],_u=[];for(let Lu=0,Du=Su.length;Lu<Du;Lu++){const Ou=Su[Lu],Wu=Iu[Lu],Zu=Mu[Lu],Hu=ku[Lu],Yu=Bu[Lu];if(Ou===void 0)continue;Ou.updateMatrix&&Ou.updateMatrix();const Ku=su._createAnimationTracks(Ou,Wu,Zu,Hu,Yu);if(Ku)for(let ju=0;ju<Ku.length;ju++)_u.push(Ku[ju])}return new Re.AnimationClip(uu,void 0,_u)})}createNodeMesh(eu){const tu=this.json,su=this,au=tu.nodes[eu];return au.mesh===void 0?null:su.getDependency("mesh",au.mesh).then(function(uu){const du=su._getNodeRef(su.meshCache,au.mesh,uu);return au.weights!==void 0&&du.traverse(function(fu){if(fu.isMesh)for(let gu=0,yu=au.weights.length;gu<yu;gu++)fu.morphTargetInfluences[gu]=au.weights[gu]}),du})}loadNode(eu){const tu=this,su=this.json.nodes[eu],au=tu._loadNodeShallow(eu),uu=[],du=su.children||[];for(let gu=0,yu=du.length;gu<yu;gu++)uu.push(tu.getDependency("node",du[gu]));const fu=su.skin===void 0?Promise.resolve(null):tu.getDependency("skin",su.skin);return Promise.all([au,Promise.all(uu),fu]).then(function(gu){const yu=gu[0],xu=gu[1],vu=gu[2];vu!==null&&yu.traverse(function(Su){Su.isSkinnedMesh&&Su.bind(vu,jt)});for(let Su=0,Iu=xu.length;Su<Iu;Su++)yu.add(xu[Su]);return yu})}_loadNodeShallow(eu){const tu=this.json,su=this.extensions,au=this;if(this.nodeCache[eu]!==void 0)return this.nodeCache[eu];const uu=tu.nodes[eu],du=uu.name?au.createUniqueName(uu.name):"",fu=[],gu=au._invokeOne(function(yu){return yu.createNodeMesh&&yu.createNodeMesh(eu)});return gu&&fu.push(gu),uu.camera!==void 0&&fu.push(au.getDependency("camera",uu.camera).then(function(yu){return au._getNodeRef(au.cameraCache,uu.camera,yu)})),au._invokeAll(function(yu){return yu.createNodeAttachment&&yu.createNodeAttachment(eu)}).forEach(function(yu){fu.push(yu)}),this.nodeCache[eu]=Promise.all(fu).then(function(yu){let xu;if(xu=uu.isBone===!0?new Re.Bone:yu.length>1?new Re.Group:yu.length===1?yu[0]:new Re.Object3D,xu!==yu[0])for(let vu=0,Su=yu.length;vu<Su;vu++)xu.add(yu[vu]);if(uu.name&&(xu.userData.name=uu.name,xu.name=du),Ut(xu,uu),uu.extensions&&Ft(su,xu,uu),uu.matrix!==void 0){const vu=new Re.Matrix4;vu.fromArray(uu.matrix),xu.applyMatrix4(vu)}else uu.translation!==void 0&&xu.position.fromArray(uu.translation),uu.rotation!==void 0&&xu.quaternion.fromArray(uu.rotation),uu.scale!==void 0&&xu.scale.fromArray(uu.scale);return au.associations.has(xu)||au.associations.set(xu,{}),au.associations.get(xu).nodes=eu,xu}),this.nodeCache[eu]}loadScene(eu){const tu=this.extensions,su=this.json.scenes[eu],au=this,uu=new Re.Group;su.name&&(uu.name=au.createUniqueName(su.name)),Ut(uu,su),su.extensions&&Ft(tu,uu,su);const du=su.nodes||[],fu=[];for(let gu=0,yu=du.length;gu<yu;gu++)fu.push(au.getDependency("node",du[gu]));return Promise.all(fu).then(function(gu){for(let yu=0,xu=gu.length;yu<xu;yu++)uu.add(gu[yu]);return au.associations=(yu=>{const xu=new Map;for(const[vu,Su]of au.associations)(vu instanceof Re.Material||vu instanceof Re.Texture)&&xu.set(vu,Su);return yu.traverse(vu=>{const Su=au.associations.get(vu);Su!=null&&xu.set(vu,Su)}),xu})(uu),uu})}_createAnimationTracks(eu,tu,su,au,uu){const du=[],fu=eu.name?eu.name:eu.uuid,gu=[];let yu;switch(kt[uu.path]===kt.weights?eu.traverse(function(Su){Su.morphTargetInfluences&&gu.push(Su.name?Su.name:Su.uuid)}):gu.push(fu),kt[uu.path]){case kt.weights:yu=Re.NumberKeyframeTrack;break;case kt.rotation:yu=Re.QuaternionKeyframeTrack;break;case kt.position:case kt.scale:yu=Re.VectorKeyframeTrack;break;default:yu=su.itemSize===1?Re.NumberKeyframeTrack:Re.VectorKeyframeTrack}const xu=au.interpolation!==void 0?Tt[au.interpolation]:Re.InterpolateLinear,vu=this._getArrayFromAccessor(su);for(let Su=0,Iu=gu.length;Su<Iu;Su++){const Mu=new yu(gu[Su]+"."+kt[uu.path],tu.array,vu,xu);au.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(Mu),du.push(Mu)}return du}_getArrayFromAccessor(eu){let tu=eu.array;if(eu.normalized){const su=Nt(tu.constructor),au=new Float32Array(tu.length);for(let uu=0,du=tu.length;uu<du;uu++)au[uu]=tu[uu]*su;tu=au}return tu}_createCubicSplineTrackInterpolant(eu){eu.createInterpolant=function(tu){return new(this instanceof Re.QuaternionKeyframeTrack?wt:yt)(this.times,this.values,this.getValueSize()/3,tu)},eu.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Ht(iu,eu,tu){const su=eu.attributes,au=[];function uu(du,fu){return tu.getDependency("accessor",du).then(function(gu){iu.setAttribute(fu,gu)})}for(const du in su){const fu=Dt[du]||du.toLowerCase();fu in iu.attributes||au.push(uu(su[du],fu))}if(eu.indices!==void 0&&!iu.index){const du=tu.getDependency("accessor",eu.indices).then(function(fu){iu.setIndex(fu)});au.push(du)}return Re.ColorManagement.workingColorSpace!==Re.LinearSRGBColorSpace&&"COLOR_0"in su&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Re.ColorManagement.workingColorSpace}" not supported.`),Ut(iu,eu),function(du,fu,gu){const yu=fu.attributes,xu=new Re.Box3;if(yu.POSITION===void 0)return;{const Iu=gu.json.accessors[yu.POSITION],Mu=Iu.min,ku=Iu.max;if(Mu===void 0||ku===void 0)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(xu.set(new Re.Vector3(Mu[0],Mu[1],Mu[2]),new Re.Vector3(ku[0],ku[1],ku[2])),Iu.normalized){const Bu=Nt(Qt[Iu.componentType]);xu.min.multiplyScalar(Bu),xu.max.multiplyScalar(Bu)}}const vu=fu.targets;if(vu!==void 0){const Iu=new Re.Vector3,Mu=new Re.Vector3;for(let ku=0,Bu=vu.length;ku<Bu;ku++){const _u=vu[ku];if(_u.POSITION!==void 0){const Lu=gu.json.accessors[_u.POSITION],Du=Lu.min,Ou=Lu.max;if(Du!==void 0&&Ou!==void 0){if(Mu.setX(Math.max(Math.abs(Du[0]),Math.abs(Ou[0]))),Mu.setY(Math.max(Math.abs(Du[1]),Math.abs(Ou[1]))),Mu.setZ(Math.max(Math.abs(Du[2]),Math.abs(Ou[2]))),Lu.normalized){const Wu=Nt(Qt[Lu.componentType]);Mu.multiplyScalar(Wu)}Iu.max(Mu)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}xu.expandByVector(Iu)}du.boundingBox=xu;const Su=new Re.Sphere;xu.getCenter(Su.center),Su.radius=xu.min.distanceTo(xu.max)/2,du.boundingSphere=Su}(iu,eu,tu),Promise.all(au).then(function(){return eu.targets!==void 0?function(du,fu,gu){let yu=!1,xu=!1,vu=!1;for(let ku=0,Bu=fu.length;ku<Bu;ku++){const _u=fu[ku];if(_u.POSITION!==void 0&&(yu=!0),_u.NORMAL!==void 0&&(xu=!0),_u.COLOR_0!==void 0&&(vu=!0),yu&&xu&&vu)break}if(!yu&&!xu&&!vu)return Promise.resolve(du);const Su=[],Iu=[],Mu=[];for(let ku=0,Bu=fu.length;ku<Bu;ku++){const _u=fu[ku];if(yu){const Lu=_u.POSITION!==void 0?gu.getDependency("accessor",_u.POSITION):du.attributes.position;Su.push(Lu)}if(xu){const Lu=_u.NORMAL!==void 0?gu.getDependency("accessor",_u.NORMAL):du.attributes.normal;Iu.push(Lu)}if(vu){const Lu=_u.COLOR_0!==void 0?gu.getDependency("accessor",_u.COLOR_0):du.attributes.color;Mu.push(Lu)}}return Promise.all([Promise.all(Su),Promise.all(Iu),Promise.all(Mu)]).then(function(ku){const Bu=ku[0],_u=ku[1],Lu=ku[2];return yu&&(du.morphAttributes.position=Bu),xu&&(du.morphAttributes.normal=_u),vu&&(du.morphAttributes.color=Lu),du.morphTargetsRelative=!0,du})}(iu,eu.targets,tu):iu})}class qt{constructor(eu=4){this.pool=eu,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}_initWorker(eu){if(!this.workers[eu]){const tu=this.workerCreator();tu.addEventListener("message",this._onMessage.bind(this,eu)),this.workers[eu]=tu}}_getIdleWorker(){for(let eu=0;eu<this.pool;eu++)if(!(this.workerStatus&1<<eu))return eu;return-1}_onMessage(eu,tu){const su=this.workersResolve[eu];if(su&&su(tu),this.queue.length){const{resolve:au,msg:uu,transfer:du}=this.queue.shift();this.workersResolve[eu]=au,this.workers[eu].postMessage(uu,du)}else this.workerStatus^=1<<eu}setWorkerCreator(eu){this.workerCreator=eu}setWorkerLimit(eu){this.pool=eu}postMessage(eu,tu){return new Promise(su=>{const au=this._getIdleWorker();au!==-1?(this._initWorker(au),this.workerStatus|=1<<au,this.workersResolve[au]=su,this.workers[au].postMessage(eu,tu)):this.queue.push({resolve:su,msg:eu,transfer:tu})})}dispose(){this.workers.forEach(eu=>eu.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const Vt=9,zt=15,Yt=16,Kt=22,Wt=37,Jt=43,Xt=76,Zt=83,$t=97,en=100,tn=103,nn=109,rn=165,on=166,sn=1000066e3;class an{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class An{constructor(eu,tu,su,au){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(eu.buffer,eu.byteOffset+tu,su),this._littleEndian=au,this._offset=0}_nextUint8(){const eu=this._dataView.getUint8(this._offset);return this._offset+=1,eu}_nextUint16(){const eu=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,eu}_nextUint32(){const eu=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,eu}_nextUint64(){const eu=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,eu}_nextInt32(){const eu=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,eu}_nextUint8Array(eu){const tu=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,eu);return this._offset+=eu,tu}_skip(eu){return this._offset+=eu,this}_scan(eu,tu){tu===void 0&&(tu=0);const su=this._offset;let au=0;for(;this._dataView.getUint8(this._offset)!==tu&&au<eu;)au++,this._offset++;return au<eu&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+su,au)}}const ln=[171,75,84,88,32,50,48,187,13,10,26,10];function cn(iu){return new TextDecoder().decode(iu)}var hn=i$1(9922).hp;let dn,un,gn;const pn={env:{emscripten_notify_memory_growth:function(iu){gn=new Uint8Array(un.exports.memory.buffer)}}};class fn{init(){return dn||(dn=typeof fetch<"u"?fetch("data:application/wasm;base64,"+mn).then(eu=>eu.arrayBuffer()).then(eu=>WebAssembly.instantiate(eu,pn)).then(this._init):WebAssembly.instantiate(hn.from(mn,"base64"),pn).then(this._init),dn)}_init(eu){un=eu.instance,pn.env.emscripten_notify_memory_growth(0)}decode(eu,tu=0){if(!un)throw new Error("ZSTDDecoder: Await .init() before decoding.");const su=eu.byteLength,au=un.exports.malloc(su);gn.set(eu,au),tu=tu||Number(un.exports.ZSTD_findDecompressedSize(au,su));const uu=un.exports.malloc(tu),du=un.exports.ZSTD_decompress(uu,tu,au,su),fu=gn.slice(uu,uu+du);return un.exports.free(au),un.exports.free(uu),fu}}const mn="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",En=new WeakMap;let Cn,vn=0;class Bn extends Re.Loader{constructor(eu){super(eu),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new qt,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(eu){return this.transcoderPath=eu,this}setWorkerLimit(eu){return this.workerPool.setWorkerLimit(eu),this}async detectSupportAsync(eu){return this.workerConfig={astcSupported:await eu.hasFeatureAsync("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:await eu.hasFeatureAsync("texture-compression-etc1"),etc2Supported:await eu.hasFeatureAsync("texture-compression-etc2"),dxtSupported:await eu.hasFeatureAsync("texture-compression-bc"),bptcSupported:await eu.hasFeatureAsync("texture-compression-bptc"),pvrtcSupported:await eu.hasFeatureAsync("texture-compression-pvrtc")},this}detectSupport(eu){return eu.isWebGPURenderer===!0?this.workerConfig={astcSupported:eu.hasFeature("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:eu.hasFeature("texture-compression-etc1"),etc2Supported:eu.hasFeature("texture-compression-etc2"),dxtSupported:eu.hasFeature("texture-compression-bc"),bptcSupported:eu.hasFeature("texture-compression-bptc"),pvrtcSupported:eu.hasFeature("texture-compression-pvrtc")}:this.workerConfig={astcSupported:eu.extensions.has("WEBGL_compressed_texture_astc"),astcHDRSupported:eu.extensions.has("WEBGL_compressed_texture_astc")&&eu.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),etc1Supported:eu.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:eu.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:eu.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:eu.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:eu.extensions.has("WEBGL_compressed_texture_pvrtc")||eu.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}init(){if(!this.transcoderPending){const eu=new Re.FileLoader(this.manager);eu.setPath(this.transcoderPath),eu.setWithCredentials(this.withCredentials);const tu=eu.loadAsync("basis_transcoder.js"),su=new Re.FileLoader(this.manager);su.setPath(this.transcoderPath),su.setResponseType("arraybuffer"),su.setWithCredentials(this.withCredentials);const au=su.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([tu,au]).then(([uu,du])=>{const fu=Bn.BasisWorker.toString(),gu=["/* constants */","let _EngineFormat = "+JSON.stringify(Bn.EngineFormat),"let _EngineType = "+JSON.stringify(Bn.EngineType),"let _TranscoderFormat = "+JSON.stringify(Bn.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(Bn.BasisFormat),"/* basis_transcoder.js */",uu,"/* worker */",fu.substring(fu.indexOf("{")+1,fu.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([gu])),this.transcoderBinary=du,this.workerPool.setWorkerCreator(()=>{const yu=new Worker(this.workerSourceURL),xu=this.transcoderBinary.slice(0);return yu.postMessage({type:"init",config:this.workerConfig,transcoderBinary:xu},[xu]),yu})}),vn>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),vn++}return this.transcoderPending}load(eu,tu,su,au){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const uu=new Re.FileLoader(this.manager);uu.setResponseType("arraybuffer"),uu.setWithCredentials(this.withCredentials),uu.load(eu,du=>{this.parse(du,tu,au)},su,au)}parse(eu,tu,su){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");if(En.has(eu))return En.get(eu).promise.then(tu).catch(su);this._createTexture(eu).then(au=>tu?tu(au):null).catch(su)}_createTextureFrom(eu,tu){const{type:su,error:au,data:{faces:uu,width:du,height:fu,format:gu,type:yu,dfdFlags:xu}}=eu;if(su==="error")return Promise.reject(au);let vu;if(tu.faceCount===6)vu=new Re.CompressedCubeTexture(uu,gu,yu);else{const Su=uu[0].mipmaps;vu=tu.layerCount>1?new Re.CompressedArrayTexture(Su,du,fu,tu.layerCount,gu,yu):new Re.CompressedTexture(Su,du,fu,gu,yu)}return vu.minFilter=uu[0].mipmaps.length===1?Re.LinearFilter:Re.LinearMipmapLinearFilter,vu.magFilter=Re.LinearFilter,vu.generateMipmaps=!1,vu.needsUpdate=!0,vu.colorSpace=wn(tu),vu.premultiplyAlpha=!!(1&xu),vu}async _createTexture(eu,tu={}){const su=function(fu){const gu=new Uint8Array(fu.buffer,fu.byteOffset,ln.length);if(gu[0]!==ln[0]||gu[1]!==ln[1]||gu[2]!==ln[2]||gu[3]!==ln[3]||gu[4]!==ln[4]||gu[5]!==ln[5]||gu[6]!==ln[6]||gu[7]!==ln[7]||gu[8]!==ln[8]||gu[9]!==ln[9]||gu[10]!==ln[10]||gu[11]!==ln[11])throw new Error("Missing KTX 2.0 identifier.");const yu=new an,xu=17*Uint32Array.BYTES_PER_ELEMENT,vu=new An(fu,ln.length,xu,!0);yu.vkFormat=vu._nextUint32(),yu.typeSize=vu._nextUint32(),yu.pixelWidth=vu._nextUint32(),yu.pixelHeight=vu._nextUint32(),yu.pixelDepth=vu._nextUint32(),yu.layerCount=vu._nextUint32(),yu.faceCount=vu._nextUint32();const Su=vu._nextUint32();yu.supercompressionScheme=vu._nextUint32();const Iu=vu._nextUint32(),Mu=vu._nextUint32(),ku=vu._nextUint32(),Bu=vu._nextUint32(),_u=vu._nextUint64(),Lu=vu._nextUint64(),Du=new An(fu,ln.length+xu,3*Su*8,!0);for(let bp=0;bp<Su;bp++)yu.levels.push({levelData:new Uint8Array(fu.buffer,fu.byteOffset+Du._nextUint64(),Du._nextUint64()),uncompressedByteLength:Du._nextUint64()});const Ou=new An(fu,Iu,Mu,!0),Wu={vendorId:Ou._skip(4)._nextUint16(),descriptorType:Ou._nextUint16(),versionNumber:Ou._nextUint16(),descriptorBlockSize:Ou._nextUint16(),colorModel:Ou._nextUint8(),colorPrimaries:Ou._nextUint8(),transferFunction:Ou._nextUint8(),flags:Ou._nextUint8(),texelBlockDimension:[Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8()],bytesPlane:[Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8()],samples:[]},Zu=(Wu.descriptorBlockSize/4-6)/4;for(let bp=0;bp<Zu;bp++){const kp={bitOffset:Ou._nextUint16(),bitLength:Ou._nextUint8(),channelType:Ou._nextUint8(),samplePosition:[Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8(),Ou._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};64&kp.channelType?(kp.sampleLower=Ou._nextInt32(),kp.sampleUpper=Ou._nextInt32()):(kp.sampleLower=Ou._nextUint32(),kp.sampleUpper=Ou._nextUint32()),Wu.samples[bp]=kp}yu.dataFormatDescriptor.length=0,yu.dataFormatDescriptor.push(Wu);const Hu=new An(fu,ku,Bu,!0);for(;Hu._offset<Bu;){const bp=Hu._nextUint32(),kp=Hu._scan(bp),dm=cn(kp);if(yu.keyValue[dm]=Hu._nextUint8Array(bp-kp.byteLength-1),dm.match(/^ktx/i)){const nm=cn(yu.keyValue[dm]);yu.keyValue[dm]=nm.substring(0,nm.lastIndexOf("\0"))}Hu._skip(bp%4?4-bp%4:0)}if(Lu<=0)return yu;const Yu=new An(fu,_u,Lu,!0),Ku=Yu._nextUint16(),ju=Yu._nextUint16(),tp=Yu._nextUint32(),gp=Yu._nextUint32(),yp=Yu._nextUint32(),Cp=Yu._nextUint32(),Hp=[];for(let bp=0;bp<Su;bp++)Hp.push({imageFlags:Yu._nextUint32(),rgbSliceByteOffset:Yu._nextUint32(),rgbSliceByteLength:Yu._nextUint32(),alphaSliceByteOffset:Yu._nextUint32(),alphaSliceByteLength:Yu._nextUint32()});const wp=_u+Yu._offset,Dp=wp+tp,dp=Dp+gp,Rp=dp+yp,xp=new Uint8Array(fu.buffer,fu.byteOffset+wp,tp),cm=new Uint8Array(fu.buffer,fu.byteOffset+Dp,gp),lm=new Uint8Array(fu.buffer,fu.byteOffset+dp,yp),vp=new Uint8Array(fu.buffer,fu.byteOffset+Rp,Cp);return yu.globalData={endpointCount:Ku,selectorCount:ju,imageDescs:Hp,endpointsData:xp,selectorsData:cm,tablesData:lm,extendedData:vp},yu}(new Uint8Array(eu)),au=su.vkFormat===sn&&su.dataFormatDescriptor[0].colorModel===167;if(su.vkFormat!==0&&(!au||this.workerConfig.astcHDRSupported))return async function(fu){const{vkFormat:gu}=fu;if(yn[gu]===void 0)throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");let yu;fu.supercompressionScheme===2&&(Cn||(Cn=new Promise(async Su=>{const Iu=new fn;await Iu.init(),Su(Iu)})),yu=await Cn);const xu=[];for(let Su=0;Su<fu.levels.length;Su++){const Iu=Math.max(1,fu.pixelWidth>>Su),Mu=Math.max(1,fu.pixelHeight>>Su),ku=fu.pixelDepth?Math.max(1,fu.pixelDepth>>Su):0,Bu=fu.levels[Su];let _u,Lu;if(fu.supercompressionScheme===0)_u=Bu.levelData;else{if(fu.supercompressionScheme!==2)throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");_u=yu.decode(Bu.levelData,Bu.uncompressedByteLength)}Lu=In[gu]===Re.FloatType?new Float32Array(_u.buffer,_u.byteOffset,_u.byteLength/Float32Array.BYTES_PER_ELEMENT):In[gu]===Re.HalfFloatType?new Uint16Array(_u.buffer,_u.byteOffset,_u.byteLength/Uint16Array.BYTES_PER_ELEMENT):_u,xu.push({data:Lu,width:Iu,height:Mu,depth:ku})}let vu;if(bn.has(yn[gu]))vu=fu.pixelDepth===0?new Re.DataTexture(xu[0].data,fu.pixelWidth,fu.pixelHeight):new Re.Data3DTexture(xu[0].data,fu.pixelWidth,fu.pixelHeight,fu.pixelDepth);else{if(fu.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");vu=new Re.CompressedTexture(xu,fu.pixelWidth,fu.pixelHeight),vu.minFilter=xu.length===1?Re.LinearFilter:Re.LinearMipmapLinearFilter,vu.magFilter=Re.LinearFilter}return vu.mipmaps=xu,vu.type=In[gu],vu.format=yn[gu],vu.colorSpace=wn(fu),vu.needsUpdate=!0,Promise.resolve(vu)}(su);const uu=tu,du=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffer:eu,taskConfig:uu},[eu])).then(fu=>this._createTextureFrom(fu.data,su));return En.set(eu,{promise:du}),du}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),vn--,this}}Bn.BasisFormat={ETC1S:0,UASTC:1,UASTC_HDR:2},Bn.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16,BC6H:22,RGB_HALF:24,RGBA_HALF:25},Bn.EngineFormat={RGBAFormat:Re.RGBAFormat,RGBA_ASTC_4x4_Format:Re.RGBA_ASTC_4x4_Format,RGB_BPTC_UNSIGNED_Format:Re.RGB_BPTC_UNSIGNED_Format,RGBA_BPTC_Format:Re.RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:Re.RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format:Re.RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format:Re.RGBA_S3TC_DXT5_Format,RGB_ETC1_Format:Re.RGB_ETC1_Format,RGB_ETC2_Format:Re.RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format:Re.RGB_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format:Re.RGBA_S3TC_DXT1_Format},Bn.EngineType={UnsignedByteType:Re.UnsignedByteType,HalfFloatType:Re.HalfFloatType,FloatType:Re.FloatType},Bn.BasisWorker=function(){let iu,eu,tu;const su=_EngineFormat,au=_EngineType,uu=_TranscoderFormat,du=_BasisFormat;self.addEventListener("message",function(vu){const Su=vu.data;switch(Su.type){case"init":iu=Su.config,Iu=Su.transcoderBinary,eu=new Promise(Mu=>{tu={wasmBinary:Iu,onRuntimeInitialized:Mu},BASIS(tu)}).then(()=>{tu.initializeBasis(),tu.KTX2File===void 0&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")});break;case"transcode":eu.then(()=>{try{const{faces:Mu,buffers:ku,width:Bu,height:_u,hasAlpha:Lu,format:Du,type:Ou,dfdFlags:Wu}=function(Zu){const Hu=new tu.KTX2File(new Uint8Array(Zu));function Yu(){Hu.close(),Hu.delete()}if(!Hu.isValid())throw Yu(),new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");let Ku;if(Hu.isUASTC())Ku=du.UASTC;else if(Hu.isETC1S())Ku=du.ETC1S;else{if(!Hu.isHDR())throw new Error("THREE.KTX2Loader: Unknown Basis encoding");Ku=du.UASTC_HDR}const ju=Hu.getWidth(),tp=Hu.getHeight(),gp=Hu.getLayers()||1,yp=Hu.getLevels(),Cp=Hu.getFaces(),Hp=Hu.getHasAlpha(),wp=Hu.getDFDFlags(),{transcoderFormat:Dp,engineFormat:dp,engineType:Rp}=function(lm,vp,bp,kp){const dm=gu[lm];for(let nm=0;nm<dm.length;nm++){const Bp=dm[nm];if((!Bp.if||iu[Bp.if])&&Bp.basisFormat.includes(lm)&&!(kp&&Bp.transcoderFormat.length<2)&&(!Bp.needsPowerOfTwo||yu(vp)&&yu(bp)))return{transcoderFormat:Bp.transcoderFormat[kp?1:0],engineFormat:Bp.engineFormat[kp?1:0],engineType:Bp.engineType[0]}}throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")}(Ku,ju,tp,Hp);if(!ju||!tp||!yp)throw Yu(),new Error("THREE.KTX2Loader:	Invalid texture");if(!Hu.startTranscoding())throw Yu(),new Error("THREE.KTX2Loader: .startTranscoding failed");const xp=[],cm=[];for(let lm=0;lm<Cp;lm++){const vp=[];for(let bp=0;bp<yp;bp++){const kp=[];let dm,nm;for(let Qp=0;Qp<gp;Qp++){const Xp=Hu.getImageLevelInfo(bp,Qp,lm);lm!==0||bp!==0||Qp!==0||Xp.origWidth%4==0&&Xp.origHeight%4==0||console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),yp>1?(dm=Xp.origWidth,nm=Xp.origHeight):(dm=Xp.width,nm=Xp.height);let sm=new Uint8Array(Hu.getImageTranscodedSizeInBytes(bp,Qp,0,Dp));const $p=Hu.transcodeImage(sm,bp,Qp,lm,Dp,0,-1,-1);if(Rp===au.HalfFloatType&&(sm=new Uint16Array(sm.buffer,sm.byteOffset,sm.byteLength/Uint16Array.BYTES_PER_ELEMENT)),!$p)throw Yu(),new Error("THREE.KTX2Loader: .transcodeImage failed.");kp.push(sm)}const Bp=xu(kp);vp.push({data:Bp,width:dm,height:nm}),cm.push(Bp.buffer)}xp.push({mipmaps:vp,width:ju,height:tp,format:dp,type:Rp})}return Yu(),{faces:xp,buffers:cm,width:ju,height:tp,hasAlpha:Hp,dfdFlags:wp,format:dp,type:Rp}}(Su.buffer);self.postMessage({type:"transcode",id:Su.id,data:{faces:Mu,width:Bu,height:_u,hasAlpha:Lu,format:Du,type:Ou,dfdFlags:Wu}},ku)}catch(Mu){console.error(Mu),self.postMessage({type:"error",id:Su.id,error:Mu.message})}})}var Iu});const fu=[{if:"astcSupported",basisFormat:[du.UASTC],transcoderFormat:[uu.ASTC_4x4,uu.ASTC_4x4],engineFormat:[su.RGBA_ASTC_4x4_Format,su.RGBA_ASTC_4x4_Format],engineType:[au.UnsignedByteType],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[du.ETC1S,du.UASTC],transcoderFormat:[uu.BC7_M5,uu.BC7_M5],engineFormat:[su.RGBA_BPTC_Format,su.RGBA_BPTC_Format],engineType:[au.UnsignedByteType],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[du.ETC1S,du.UASTC],transcoderFormat:[uu.BC1,uu.BC3],engineFormat:[su.RGBA_S3TC_DXT1_Format,su.RGBA_S3TC_DXT5_Format],engineType:[au.UnsignedByteType],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[du.ETC1S,du.UASTC],transcoderFormat:[uu.ETC1,uu.ETC2],engineFormat:[su.RGB_ETC2_Format,su.RGBA_ETC2_EAC_Format],engineType:[au.UnsignedByteType],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[du.ETC1S,du.UASTC],transcoderFormat:[uu.ETC1],engineFormat:[su.RGB_ETC1_Format],engineType:[au.UnsignedByteType],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[du.ETC1S,du.UASTC],transcoderFormat:[uu.PVRTC1_4_RGB,uu.PVRTC1_4_RGBA],engineFormat:[su.RGB_PVRTC_4BPPV1_Format,su.RGBA_PVRTC_4BPPV1_Format],engineType:[au.UnsignedByteType],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0},{if:"bptcSupported",basisFormat:[du.UASTC_HDR],transcoderFormat:[uu.BC6H],engineFormat:[su.RGB_BPTC_UNSIGNED_Format],engineType:[au.HalfFloatType],priorityHDR:1,needsPowerOfTwo:!1},{basisFormat:[du.ETC1S,du.UASTC],transcoderFormat:[uu.RGBA32,uu.RGBA32],engineFormat:[su.RGBAFormat,su.RGBAFormat],engineType:[au.UnsignedByteType,au.UnsignedByteType],priorityETC1S:100,priorityUASTC:100,needsPowerOfTwo:!1},{basisFormat:[du.UASTC_HDR],transcoderFormat:[uu.RGBA_HALF],engineFormat:[su.RGBAFormat],engineType:[au.HalfFloatType],priorityHDR:100,needsPowerOfTwo:!1}],gu={[du.ETC1S]:fu.filter(vu=>vu.basisFormat.includes(du.ETC1S)).sort((vu,Su)=>vu.priorityUASTC-Su.priorityUASTC),[du.UASTC]:fu.filter(vu=>vu.basisFormat.includes(du.UASTC)).sort((vu,Su)=>vu.priorityUASTC-Su.priorityUASTC),[du.UASTC_HDR]:fu.filter(vu=>vu.basisFormat.includes(du.UASTC_HDR)).sort((vu,Su)=>vu.priorityHDR-Su.priorityHDR)};function yu(vu){return vu<=2||!(vu&vu-1)&&vu!==0}function xu(vu){if(vu.length===1)return vu[0];let Su=0;for(let ku=0;ku<vu.length;ku++)Su+=vu[ku].byteLength;const Iu=new Uint8Array(Su);let Mu=0;for(let ku=0;ku<vu.length;ku++){const Bu=vu[ku];Iu.set(Bu,Mu),Mu+=Bu.byteLength}return Iu}};const bn=new Set([Re.RGBAFormat,Re.RGFormat,Re.RedFormat]),yn={[nn]:Re.RGBAFormat,[$t]:Re.RGBAFormat,[Wt]:Re.RGBAFormat,[Jt]:Re.RGBAFormat,[tn]:Re.RGFormat,[Zt]:Re.RGFormat,[Yt]:Re.RGFormat,[Kt]:Re.RGFormat,[en]:Re.RedFormat,[Xt]:Re.RedFormat,[zt]:Re.RedFormat,[Vt]:Re.RedFormat,[sn]:Re.RGBA_ASTC_4x4_Format,[on]:Re.RGBA_ASTC_6x6_Format,[rn]:Re.RGBA_ASTC_6x6_Format},In={[nn]:Re.FloatType,[$t]:Re.HalfFloatType,[Wt]:Re.UnsignedByteType,[Jt]:Re.UnsignedByteType,[tn]:Re.FloatType,[Zt]:Re.HalfFloatType,[Yt]:Re.UnsignedByteType,[Kt]:Re.UnsignedByteType,[en]:Re.FloatType,[Xt]:Re.HalfFloatType,[zt]:Re.UnsignedByteType,[Vt]:Re.UnsignedByteType,[sn]:Re.HalfFloatType,[on]:Re.UnsignedByteType,[rn]:Re.UnsignedByteType};function wn(iu){const eu=iu.dataFormatDescriptor[0];return eu.colorPrimaries===1?eu.transferFunction===2?Re.SRGBColorSpace:Re.LinearSRGBColorSpace:eu.colorPrimaries===10?eu.transferFunction===2?"display-p3":"display-p3-linear":(eu.colorPrimaries===0||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${eu.colorPrimaries}"`),Re.NoColorSpace)}const xn={c:null,u:[new Re.Vector3,new Re.Vector3,new Re.Vector3],e:[]},Qn={c:null,u:[new Re.Vector3,new Re.Vector3,new Re.Vector3],e:[]},Ln=[[],[],[]],Mn=[[],[],[]],Sn=[],Dn=new Re.Vector3,kn=new Re.Vector3,Tn=new Re.Vector3,Rn=new Re.Vector3,Fn=new Re.Vector3,Un=new Re.Vector3,On=new Re.Matrix3,Pn=new Re.Box3,Gn=new Re.Matrix4,Nn=new Re.Matrix4,jn=new Re.Ray;class _n{constructor(eu=new Re.Vector3,tu=new Re.Vector3,su=new Re.Matrix3){this.center=eu,this.halfSize=tu,this.rotation=su}set(eu,tu,su){return this.center=eu,this.halfSize=tu,this.rotation=su,this}copy(eu){return this.center.copy(eu.center),this.halfSize.copy(eu.halfSize),this.rotation.copy(eu.rotation),this}clone(){return new this.constructor().copy(this)}getSize(eu){return eu.copy(this.halfSize).multiplyScalar(2)}clampPoint(eu,tu){const su=this.halfSize;Rn.subVectors(eu,this.center),this.rotation.extractBasis(Dn,kn,Tn),tu.copy(this.center);const au=Re.MathUtils.clamp(Rn.dot(Dn),-su.x,su.x);tu.add(Dn.multiplyScalar(au));const uu=Re.MathUtils.clamp(Rn.dot(kn),-su.y,su.y);tu.add(kn.multiplyScalar(uu));const du=Re.MathUtils.clamp(Rn.dot(Tn),-su.z,su.z);return tu.add(Tn.multiplyScalar(du)),tu}containsPoint(eu){return Rn.subVectors(eu,this.center),this.rotation.extractBasis(Dn,kn,Tn),Math.abs(Rn.dot(Dn))<=this.halfSize.x&&Math.abs(Rn.dot(kn))<=this.halfSize.y&&Math.abs(Rn.dot(Tn))<=this.halfSize.z}intersectsBox3(eu){return this.intersectsOBB(Hn.fromBox3(eu))}intersectsSphere(eu){return this.clampPoint(eu.center,Un),Un.distanceToSquared(eu.center)<=eu.radius*eu.radius}intersectsOBB(eu,tu=Number.EPSILON){xn.c=this.center,xn.e[0]=this.halfSize.x,xn.e[1]=this.halfSize.y,xn.e[2]=this.halfSize.z,this.rotation.extractBasis(xn.u[0],xn.u[1],xn.u[2]),Qn.c=eu.center,Qn.e[0]=eu.halfSize.x,Qn.e[1]=eu.halfSize.y,Qn.e[2]=eu.halfSize.z,eu.rotation.extractBasis(Qn.u[0],Qn.u[1],Qn.u[2]);for(let uu=0;uu<3;uu++)for(let du=0;du<3;du++)Ln[uu][du]=xn.u[uu].dot(Qn.u[du]);Rn.subVectors(Qn.c,xn.c),Sn[0]=Rn.dot(xn.u[0]),Sn[1]=Rn.dot(xn.u[1]),Sn[2]=Rn.dot(xn.u[2]);for(let uu=0;uu<3;uu++)for(let du=0;du<3;du++)Mn[uu][du]=Math.abs(Ln[uu][du])+tu;let su,au;for(let uu=0;uu<3;uu++)if(su=xn.e[uu],au=Qn.e[0]*Mn[uu][0]+Qn.e[1]*Mn[uu][1]+Qn.e[2]*Mn[uu][2],Math.abs(Sn[uu])>su+au)return!1;for(let uu=0;uu<3;uu++)if(su=xn.e[0]*Mn[0][uu]+xn.e[1]*Mn[1][uu]+xn.e[2]*Mn[2][uu],au=Qn.e[uu],Math.abs(Sn[0]*Ln[0][uu]+Sn[1]*Ln[1][uu]+Sn[2]*Ln[2][uu])>su+au)return!1;return su=xn.e[1]*Mn[2][0]+xn.e[2]*Mn[1][0],au=Qn.e[1]*Mn[0][2]+Qn.e[2]*Mn[0][1],!(Math.abs(Sn[2]*Ln[1][0]-Sn[1]*Ln[2][0])>su+au||(su=xn.e[1]*Mn[2][1]+xn.e[2]*Mn[1][1],au=Qn.e[0]*Mn[0][2]+Qn.e[2]*Mn[0][0],Math.abs(Sn[2]*Ln[1][1]-Sn[1]*Ln[2][1])>su+au||(su=xn.e[1]*Mn[2][2]+xn.e[2]*Mn[1][2],au=Qn.e[0]*Mn[0][1]+Qn.e[1]*Mn[0][0],Math.abs(Sn[2]*Ln[1][2]-Sn[1]*Ln[2][2])>su+au||(su=xn.e[0]*Mn[2][0]+xn.e[2]*Mn[0][0],au=Qn.e[1]*Mn[1][2]+Qn.e[2]*Mn[1][1],Math.abs(Sn[0]*Ln[2][0]-Sn[2]*Ln[0][0])>su+au||(su=xn.e[0]*Mn[2][1]+xn.e[2]*Mn[0][1],au=Qn.e[0]*Mn[1][2]+Qn.e[2]*Mn[1][0],Math.abs(Sn[0]*Ln[2][1]-Sn[2]*Ln[0][1])>su+au||(su=xn.e[0]*Mn[2][2]+xn.e[2]*Mn[0][2],au=Qn.e[0]*Mn[1][1]+Qn.e[1]*Mn[1][0],Math.abs(Sn[0]*Ln[2][2]-Sn[2]*Ln[0][2])>su+au||(su=xn.e[0]*Mn[1][0]+xn.e[1]*Mn[0][0],au=Qn.e[1]*Mn[2][2]+Qn.e[2]*Mn[2][1],Math.abs(Sn[1]*Ln[0][0]-Sn[0]*Ln[1][0])>su+au||(su=xn.e[0]*Mn[1][1]+xn.e[1]*Mn[0][1],au=Qn.e[0]*Mn[2][2]+Qn.e[2]*Mn[2][0],Math.abs(Sn[1]*Ln[0][1]-Sn[0]*Ln[1][1])>su+au||(su=xn.e[0]*Mn[1][2]+xn.e[1]*Mn[0][2],au=Qn.e[0]*Mn[2][1]+Qn.e[1]*Mn[2][0],Math.abs(Sn[1]*Ln[0][2]-Sn[0]*Ln[1][2])>su+au)))))))))}intersectsPlane(eu){this.rotation.extractBasis(Dn,kn,Tn);const tu=this.halfSize.x*Math.abs(eu.normal.dot(Dn))+this.halfSize.y*Math.abs(eu.normal.dot(kn))+this.halfSize.z*Math.abs(eu.normal.dot(Tn)),su=eu.normal.dot(this.center)-eu.constant;return Math.abs(su)<=tu}intersectRay(eu,tu){return this.getSize(Fn),Pn.setFromCenterAndSize(Rn.set(0,0,0),Fn),Gn.setFromMatrix3(this.rotation),Gn.setPosition(this.center),Nn.copy(Gn).invert(),jn.copy(eu).applyMatrix4(Nn),jn.intersectBox(Pn,tu)?tu.applyMatrix4(Gn):null}intersectsRay(eu){return this.intersectRay(eu,Rn)!==null}fromBox3(eu){return eu.getCenter(this.center),eu.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(eu){return eu.center.equals(this.center)&&eu.halfSize.equals(this.halfSize)&&eu.rotation.equals(this.rotation)}applyMatrix4(eu){const tu=eu.elements;let su=Rn.set(tu[0],tu[1],tu[2]).length();const au=Rn.set(tu[4],tu[5],tu[6]).length(),uu=Rn.set(tu[8],tu[9],tu[10]).length();eu.determinant()<0&&(su=-su),On.setFromMatrix4(eu);const du=1/su,fu=1/au,gu=1/uu;return On.elements[0]*=du,On.elements[1]*=du,On.elements[2]*=du,On.elements[3]*=fu,On.elements[4]*=fu,On.elements[5]*=fu,On.elements[6]*=gu,On.elements[7]*=gu,On.elements[8]*=gu,this.rotation.multiply(On),this.halfSize.x*=su,this.halfSize.y*=au,this.halfSize.z*=uu,Rn.setFromMatrixPosition(eu),this.center.add(Rn),this}}const Hn=new _n,qn=/^[og]\s*(.+)?/,Vn=/^mtllib /,zn=/^usemtl /,Yn=/^usemap /,Kn=/\s+/,Wn=new Re.Vector3,Jn=new Re.Vector3,Xn=new Re.Vector3,Zn=new Re.Vector3,$n=new Re.Vector3,ei=new Re.Color;function ti(){const iu={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(eu,tu){if(this.object&&this.object.fromDeclaration===!1)return this.object.name=eu,void(this.object.fromDeclaration=tu!==!1);const su=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:eu||"",fromDeclaration:tu!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(au,uu){const du=this._finalize(!1);du&&(du.inherited||du.groupCount<=0)&&this.materials.splice(du.index,1);const fu={index:this.materials.length,name:au||"",mtllib:Array.isArray(uu)&&uu.length>0?uu[uu.length-1]:"",smooth:du!==void 0?du.smooth:this.smooth,groupStart:du!==void 0?du.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(gu){const yu={index:typeof gu=="number"?gu:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return yu.clone=this.clone.bind(yu),yu}};return this.materials.push(fu),fu},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(au){const uu=this.currentMaterial();if(uu&&uu.groupEnd===-1&&(uu.groupEnd=this.geometry.vertices.length/3,uu.groupCount=uu.groupEnd-uu.groupStart,uu.inherited=!1),au&&this.materials.length>1)for(let du=this.materials.length-1;du>=0;du--)this.materials[du].groupCount<=0&&this.materials.splice(du,1);return au&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),uu}},su&&su.name&&typeof su.clone=="function"){const au=su.clone(0);au.inherited=!0,this.object.materials.push(au)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(eu,tu){const su=parseInt(eu,10);return 3*(su>=0?su-1:su+tu/3)},parseNormalIndex:function(eu,tu){const su=parseInt(eu,10);return 3*(su>=0?su-1:su+tu/3)},parseUVIndex:function(eu,tu){const su=parseInt(eu,10);return 2*(su>=0?su-1:su+tu/2)},addVertex:function(eu,tu,su){const au=this.vertices,uu=this.object.geometry.vertices;uu.push(au[eu+0],au[eu+1],au[eu+2]),uu.push(au[tu+0],au[tu+1],au[tu+2]),uu.push(au[su+0],au[su+1],au[su+2])},addVertexPoint:function(eu){const tu=this.vertices;this.object.geometry.vertices.push(tu[eu+0],tu[eu+1],tu[eu+2])},addVertexLine:function(eu){const tu=this.vertices;this.object.geometry.vertices.push(tu[eu+0],tu[eu+1],tu[eu+2])},addNormal:function(eu,tu,su){const au=this.normals,uu=this.object.geometry.normals;uu.push(au[eu+0],au[eu+1],au[eu+2]),uu.push(au[tu+0],au[tu+1],au[tu+2]),uu.push(au[su+0],au[su+1],au[su+2])},addFaceNormal:function(eu,tu,su){const au=this.vertices,uu=this.object.geometry.normals;Wn.fromArray(au,eu),Jn.fromArray(au,tu),Xn.fromArray(au,su),$n.subVectors(Xn,Jn),Zn.subVectors(Wn,Jn),$n.cross(Zn),$n.normalize(),uu.push($n.x,$n.y,$n.z),uu.push($n.x,$n.y,$n.z),uu.push($n.x,$n.y,$n.z)},addColor:function(eu,tu,su){const au=this.colors,uu=this.object.geometry.colors;au[eu]!==void 0&&uu.push(au[eu+0],au[eu+1],au[eu+2]),au[tu]!==void 0&&uu.push(au[tu+0],au[tu+1],au[tu+2]),au[su]!==void 0&&uu.push(au[su+0],au[su+1],au[su+2])},addUV:function(eu,tu,su){const au=this.uvs,uu=this.object.geometry.uvs;uu.push(au[eu+0],au[eu+1]),uu.push(au[tu+0],au[tu+1]),uu.push(au[su+0],au[su+1])},addDefaultUV:function(){const eu=this.object.geometry.uvs;eu.push(0,0),eu.push(0,0),eu.push(0,0)},addUVLine:function(eu){const tu=this.uvs;this.object.geometry.uvs.push(tu[eu+0],tu[eu+1])},addFace:function(eu,tu,su,au,uu,du,fu,gu,yu){const xu=this.vertices.length;let vu=this.parseVertexIndex(eu,xu),Su=this.parseVertexIndex(tu,xu),Iu=this.parseVertexIndex(su,xu);if(this.addVertex(vu,Su,Iu),this.addColor(vu,Su,Iu),fu!==void 0&&fu!==""){const Mu=this.normals.length;vu=this.parseNormalIndex(fu,Mu),Su=this.parseNormalIndex(gu,Mu),Iu=this.parseNormalIndex(yu,Mu),this.addNormal(vu,Su,Iu)}else this.addFaceNormal(vu,Su,Iu);if(au!==void 0&&au!==""){const Mu=this.uvs.length;vu=this.parseUVIndex(au,Mu),Su=this.parseUVIndex(uu,Mu),Iu=this.parseUVIndex(du,Mu),this.addUV(vu,Su,Iu),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(eu){this.object.geometry.type="Points";const tu=this.vertices.length;for(let su=0,au=eu.length;su<au;su++){const uu=this.parseVertexIndex(eu[su],tu);this.addVertexPoint(uu),this.addColor(uu)}},addLineGeometry:function(eu,tu){this.object.geometry.type="Line";const su=this.vertices.length,au=this.uvs.length;for(let uu=0,du=eu.length;uu<du;uu++)this.addVertexLine(this.parseVertexIndex(eu[uu],su));for(let uu=0,du=tu.length;uu<du;uu++)this.addUVLine(this.parseUVIndex(tu[uu],au))}};return iu.startObject("",!1),iu}class ni extends Re.Loader{constructor(eu){super(eu),this.materials=null}load(eu,tu,su,au){const uu=this,du=new Re.FileLoader(this.manager);du.setPath(this.path),du.setRequestHeader(this.requestHeader),du.setWithCredentials(this.withCredentials),du.load(eu,function(fu){try{tu(uu.parse(fu))}catch(gu){au?au(gu):console.error(gu),uu.manager.itemError(eu)}},su,au)}setMaterials(eu){return this.materials=eu,this}parse(eu){const tu=new ti;eu.indexOf(`\r
`)!==-1&&(eu=eu.replace(/\r\n/g,`
`)),eu.indexOf(`\\
`)!==-1&&(eu=eu.replace(/\\\n/g,""));const su=eu.split(`
`);let au=[];for(let du=0,fu=su.length;du<fu;du++){const gu=su[du].trimStart();if(gu.length===0)continue;const yu=gu.charAt(0);if(yu!=="#")if(yu==="v"){const xu=gu.split(Kn);switch(xu[0]){case"v":tu.vertices.push(parseFloat(xu[1]),parseFloat(xu[2]),parseFloat(xu[3])),xu.length>=7?(ei.setRGB(parseFloat(xu[4]),parseFloat(xu[5]),parseFloat(xu[6]),Re.SRGBColorSpace),tu.colors.push(ei.r,ei.g,ei.b)):tu.colors.push(void 0,void 0,void 0);break;case"vn":tu.normals.push(parseFloat(xu[1]),parseFloat(xu[2]),parseFloat(xu[3]));break;case"vt":tu.uvs.push(parseFloat(xu[1]),parseFloat(xu[2]))}}else if(yu==="f"){const xu=gu.slice(1).trim().split(Kn),vu=[];for(let Iu=0,Mu=xu.length;Iu<Mu;Iu++){const ku=xu[Iu];if(ku.length>0){const Bu=ku.split("/");vu.push(Bu)}}const Su=vu[0];for(let Iu=1,Mu=vu.length-1;Iu<Mu;Iu++){const ku=vu[Iu],Bu=vu[Iu+1];tu.addFace(Su[0],ku[0],Bu[0],Su[1],ku[1],Bu[1],Su[2],ku[2],Bu[2])}}else if(yu==="l"){const xu=gu.substring(1).trim().split(" ");let vu=[];const Su=[];if(gu.indexOf("/")===-1)vu=xu;else for(let Iu=0,Mu=xu.length;Iu<Mu;Iu++){const ku=xu[Iu].split("/");ku[0]!==""&&vu.push(ku[0]),ku[1]!==""&&Su.push(ku[1])}tu.addLineGeometry(vu,Su)}else if(yu==="p"){const xu=gu.slice(1).trim().split(" ");tu.addPointGeometry(xu)}else if((au=qn.exec(gu))!==null){const xu=(" "+au[0].slice(1).trim()).slice(1);tu.startObject(xu)}else if(zn.test(gu))tu.object.startMaterial(gu.substring(7).trim(),tu.materialLibraries);else if(Vn.test(gu))tu.materialLibraries.push(gu.substring(7).trim());else if(Yn.test(gu))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(yu==="s"){if(au=gu.split(" "),au.length>1){const vu=au[1].trim().toLowerCase();tu.object.smooth=vu!=="0"&&vu!=="off"}else tu.object.smooth=!0;const xu=tu.object.currentMaterial();xu&&(xu.smooth=tu.object.smooth)}else{if(gu==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+gu+'"')}}tu.finalize();const uu=new Re.Group;if(uu.materialLibraries=[].concat(tu.materialLibraries),!(tu.objects.length===1&&tu.objects[0].geometry.vertices.length===0))for(let du=0,fu=tu.objects.length;du<fu;du++){const gu=tu.objects[du],yu=gu.geometry,xu=gu.materials,vu=yu.type==="Line",Su=yu.type==="Points";let Iu=!1;if(yu.vertices.length===0)continue;const Mu=new Re.BufferGeometry;Mu.setAttribute("position",new Re.Float32BufferAttribute(yu.vertices,3)),yu.normals.length>0&&Mu.setAttribute("normal",new Re.Float32BufferAttribute(yu.normals,3)),yu.colors.length>0&&(Iu=!0,Mu.setAttribute("color",new Re.Float32BufferAttribute(yu.colors,3))),yu.hasUVIndices===!0&&Mu.setAttribute("uv",new Re.Float32BufferAttribute(yu.uvs,2));const ku=[];for(let _u=0,Lu=xu.length;_u<Lu;_u++){const Du=xu[_u],Ou=Du.name+"_"+Du.smooth+"_"+Iu;let Wu=tu.materials[Ou];if(this.materials!==null)if(Wu=this.materials.create(Du.name),!vu||!Wu||Wu instanceof Re.LineBasicMaterial){if(Su&&Wu&&!(Wu instanceof Re.PointsMaterial)){const Zu=new Re.PointsMaterial({size:10,sizeAttenuation:!1});Re.Material.prototype.copy.call(Zu,Wu),Zu.color.copy(Wu.color),Zu.map=Wu.map,Wu=Zu}}else{const Zu=new Re.LineBasicMaterial;Re.Material.prototype.copy.call(Zu,Wu),Zu.color.copy(Wu.color),Wu=Zu}Wu===void 0&&(Wu=vu?new Re.LineBasicMaterial:Su?new Re.PointsMaterial({size:1,sizeAttenuation:!1}):new Re.MeshPhongMaterial,Wu.name=Du.name,Wu.flatShading=!Du.smooth,Wu.vertexColors=Iu,tu.materials[Ou]=Wu),ku.push(Wu)}let Bu;if(ku.length>1){for(let _u=0,Lu=xu.length;_u<Lu;_u++){const Du=xu[_u];Mu.addGroup(Du.groupStart,Du.groupCount,_u)}Bu=vu?new Re.LineSegments(Mu,ku):Su?new Re.Points(Mu,ku):new Re.Mesh(Mu,ku)}else Bu=vu?new Re.LineSegments(Mu,ku[0]):Su?new Re.Points(Mu,ku[0]):new Re.Mesh(Mu,ku[0]);Bu.name=gu.name,uu.add(Bu)}else if(tu.vertices.length>0){const du=new Re.PointsMaterial({size:1,sizeAttenuation:!1}),fu=new Re.BufferGeometry;fu.setAttribute("position",new Re.Float32BufferAttribute(tu.vertices,3)),tu.colors.length>0&&tu.colors[0]!==void 0&&(fu.setAttribute("color",new Re.Float32BufferAttribute(tu.colors,3)),du.vertexColors=!0);const gu=new Re.Points(fu,du);uu.add(gu)}return uu}}class ii extends Re.Loader{constructor(eu){super(eu)}load(eu,tu,su,au){const uu=this,du=this.path===""?Re.LoaderUtils.extractUrlBase(eu):this.path,fu=new Re.FileLoader(this.manager);fu.setPath(this.path),fu.setRequestHeader(this.requestHeader),fu.setWithCredentials(this.withCredentials),fu.load(eu,function(gu){try{tu(uu.parse(gu,du))}catch(yu){au?au(yu):console.error(yu),uu.manager.itemError(eu)}},su,au)}setMaterialOptions(eu){return this.materialOptions=eu,this}parse(eu,tu){const su=eu.split(`
`);let au={};const uu=/\s+/,du={};for(let gu=0;gu<su.length;gu++){let yu=su[gu];if(yu=yu.trim(),yu.length===0||yu.charAt(0)==="#")continue;const xu=yu.indexOf(" ");let vu=xu>=0?yu.substring(0,xu):yu;vu=vu.toLowerCase();let Su=xu>=0?yu.substring(xu+1):"";if(Su=Su.trim(),vu==="newmtl")au={name:Su},du[Su]=au;else if(vu==="ka"||vu==="kd"||vu==="ks"||vu==="ke"){const Iu=Su.split(uu,3);au[vu]=[parseFloat(Iu[0]),parseFloat(Iu[1]),parseFloat(Iu[2])]}else au[vu]=Su}const fu=new ri(this.resourcePath||tu,this.materialOptions);return fu.setCrossOrigin(this.crossOrigin),fu.setManager(this.manager),fu.setMaterials(du),fu}}class ri{constructor(eu="",tu={}){this.baseUrl=eu,this.options=tu,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=this.options.side!==void 0?this.options.side:Re.FrontSide,this.wrap=this.options.wrap!==void 0?this.options.wrap:Re.RepeatWrapping}setCrossOrigin(eu){return this.crossOrigin=eu,this}setManager(eu){this.manager=eu}setMaterials(eu){this.materialsInfo=this.convert(eu),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(eu){if(!this.options)return eu;const tu={};for(const su in eu){const au=eu[su],uu={};tu[su]=uu;for(const du in au){let fu=!0,gu=au[du];const yu=du.toLowerCase();switch(yu){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(gu=[gu[0]/255,gu[1]/255,gu[2]/255]),this.options&&this.options.ignoreZeroRGBs&&gu[0]===0&&gu[1]===0&&gu[2]===0&&(fu=!1)}fu&&(uu[yu]=gu)}}return tu}preload(){for(const eu in this.materialsInfo)this.create(eu)}getIndex(eu){return this.nameLookup[eu]}getAsArray(){let eu=0;for(const tu in this.materialsInfo)this.materialsArray[eu]=this.create(tu),this.nameLookup[tu]=eu,eu++;return this.materialsArray}create(eu){return this.materials[eu]===void 0&&this.createMaterial_(eu),this.materials[eu]}createMaterial_(eu){const tu=this,su=this.materialsInfo[eu],au={name:eu,side:this.side};function uu(du,fu){if(au[du])return;const gu=tu.getTextureParams(fu,au),yu=tu.loadTexture((xu=tu.baseUrl,typeof(vu=gu.url)!="string"||vu===""?"":/^https?:\/\//i.test(vu)?vu:xu+vu));var xu,vu;yu.repeat.copy(gu.scale),yu.offset.copy(gu.offset),yu.wrapS=tu.wrap,yu.wrapT=tu.wrap,du!=="map"&&du!=="emissiveMap"||(yu.colorSpace=Re.SRGBColorSpace),au[du]=yu}for(const du in su){const fu=su[du];let gu;if(fu!=="")switch(du.toLowerCase()){case"kd":au.color=Re.ColorManagement.toWorkingColorSpace(new Re.Color().fromArray(fu),Re.SRGBColorSpace);break;case"ks":au.specular=Re.ColorManagement.toWorkingColorSpace(new Re.Color().fromArray(fu),Re.SRGBColorSpace);break;case"ke":au.emissive=Re.ColorManagement.toWorkingColorSpace(new Re.Color().fromArray(fu),Re.SRGBColorSpace);break;case"map_kd":uu("map",fu);break;case"map_ks":uu("specularMap",fu);break;case"map_ke":uu("emissiveMap",fu);break;case"norm":uu("normalMap",fu);break;case"map_bump":case"bump":uu("bumpMap",fu);break;case"map_d":uu("alphaMap",fu),au.transparent=!0;break;case"ns":au.shininess=parseFloat(fu);break;case"d":gu=parseFloat(fu),gu<1&&(au.opacity=gu,au.transparent=!0);break;case"tr":gu=parseFloat(fu),this.options&&this.options.invertTrProperty&&(gu=1-gu),gu>0&&(au.opacity=1-gu,au.transparent=!0)}}return this.materials[eu]=new Re.MeshPhongMaterial(au),this.materials[eu]}getTextureParams(eu,tu){const su={scale:new Re.Vector2(1,1),offset:new Re.Vector2(0,0)},au=eu.split(/\s+/);let uu;return uu=au.indexOf("-bm"),uu>=0&&(tu.bumpScale=parseFloat(au[uu+1]),au.splice(uu,2)),uu=au.indexOf("-s"),uu>=0&&(su.scale.set(parseFloat(au[uu+1]),parseFloat(au[uu+2])),au.splice(uu,4)),uu=au.indexOf("-o"),uu>=0&&(su.offset.set(parseFloat(au[uu+1]),parseFloat(au[uu+2])),au.splice(uu,4)),su.url=au.join(" ").trim(),su}loadTexture(eu,tu,su,au,uu){const du=this.manager!==void 0?this.manager:Re.DefaultLoadingManager;let fu=du.getHandler(eu);fu===null&&(fu=new Re.TextureLoader(du)),fu.setCrossOrigin&&fu.setCrossOrigin(this.crossOrigin);const gu=fu.load(eu,su,au,uu);return tu!==void 0&&(gu.mapping=tu),gu}}class oi{static fromCubeTexture(eu){let tu=0;const su=new Re.Vector3,au=new Re.Vector3,uu=new Re.Color,du=[0,0,0,0,0,0,0,0,0],fu=new Re.SphericalHarmonics3,gu=fu.coefficients;for(let xu=0;xu<6;xu++){const vu=eu.image[xu],Su=vu.width,Iu=vu.height,Mu=document.createElement("canvas");Mu.width=Su,Mu.height=Iu;const ku=Mu.getContext("2d");ku.drawImage(vu,0,0,Su,Iu);const Bu=ku.getImageData(0,0,Su,Iu),_u=Bu.data,Lu=Bu.width,Du=2/Lu;for(let Ou=0,Wu=_u.length;Ou<Wu;Ou+=4){uu.setRGB(_u[Ou]/255,_u[Ou+1]/255,_u[Ou+2]/255),si(uu,eu.colorSpace);const Zu=Ou/4,Hu=(Zu%Lu+.5)*Du-1,Yu=1-(Math.floor(Zu/Lu)+.5)*Du;switch(xu){case 0:su.set(-1,Yu,-Hu);break;case 1:su.set(1,Yu,Hu);break;case 2:su.set(-Hu,1,-Yu);break;case 3:su.set(-Hu,-1,Yu);break;case 4:su.set(-Hu,Yu,1);break;case 5:su.set(Hu,Yu,-1)}const Ku=su.lengthSq(),ju=4/(Math.sqrt(Ku)*Ku);tu+=ju,au.copy(su).normalize(),Re.SphericalHarmonics3.getBasisAt(au,du);for(let tp=0;tp<9;tp++)gu[tp].x+=du[tp]*uu.r*ju,gu[tp].y+=du[tp]*uu.g*ju,gu[tp].z+=du[tp]*uu.b*ju}}const yu=4*Math.PI/tu;for(let xu=0;xu<9;xu++)gu[xu].x*=yu,gu[xu].y*=yu,gu[xu].z*=yu;return new Re.LightProbe(fu)}static async fromCubeRenderTarget(eu,tu){const su=eu.coordinateSystem===Re.WebGLCoordinateSystem?-1:1;let au=0;const uu=new Re.Vector3,du=new Re.Vector3,fu=new Re.Color,gu=[0,0,0,0,0,0,0,0,0],yu=new Re.SphericalHarmonics3,xu=yu.coefficients,vu=tu.texture.type,Su=tu.width;let Iu;eu.isWebGLRenderer&&(Iu=vu===Re.HalfFloatType?new Uint16Array(Su*Su*4):new Uint8Array(Su*Su*4));for(let ku=0;ku<6;ku++){eu.isWebGLRenderer?await eu.readRenderTargetPixelsAsync(tu,0,0,Su,Su,Iu,ku):Iu=await eu.readRenderTargetPixelsAsync(tu,0,0,Su,Su,0,ku);const Bu=2/Su;for(let _u=0,Lu=Iu.length;_u<Lu;_u+=4){let Du,Ou,Wu;vu===Re.HalfFloatType?(Du=Re.DataUtils.fromHalfFloat(Iu[_u]),Ou=Re.DataUtils.fromHalfFloat(Iu[_u+1]),Wu=Re.DataUtils.fromHalfFloat(Iu[_u+2])):(Du=Iu[_u]/255,Ou=Iu[_u+1]/255,Wu=Iu[_u+2]/255),fu.setRGB(Du,Ou,Wu),si(fu,tu.texture.colorSpace);const Zu=_u/4,Hu=(1-(Zu%Su+.5)*Bu)*su,Yu=1-(Math.floor(Zu/Su)+.5)*Bu;switch(ku){case 0:uu.set(-1*su,Yu,Hu*su);break;case 1:uu.set(1*su,Yu,-Hu*su);break;case 2:uu.set(Hu,1,-Yu);break;case 3:uu.set(Hu,-1,Yu);break;case 4:uu.set(Hu,Yu,1);break;case 5:uu.set(-Hu,Yu,-1)}const Ku=uu.lengthSq(),ju=4/(Math.sqrt(Ku)*Ku);au+=ju,du.copy(uu).normalize(),Re.SphericalHarmonics3.getBasisAt(du,gu);for(let tp=0;tp<9;tp++)xu[tp].x+=gu[tp]*fu.r*ju,xu[tp].y+=gu[tp]*fu.g*ju,xu[tp].z+=gu[tp]*fu.b*ju}}const Mu=4*Math.PI/au;for(let ku=0;ku<9;ku++)xu[ku].x*=Mu,xu[ku].y*=Mu,xu[ku].z*=Mu;return new Re.LightProbe(yu)}}function si(iu,eu){switch(eu){case Re.SRGBColorSpace:iu.convertSRGBToLinear();break;case Re.LinearSRGBColorSpace:case Re.NoColorSpace:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.")}return iu}var ai=function(iu){var eu=this;this.object=iu,this.object.rotation.reorder("YXZ"),this.enabled=!0,this.deviceOrientation={},this.screenOrientation=0,this.alphaOffset=0;var tu,su,au,uu,du=function(yu){eu.deviceOrientation=yu},fu=function(){eu.screenOrientation=window.orientation||0},gu=(tu=new THREE.Vector3(0,0,1),su=new THREE.Euler,au=new THREE.Quaternion,uu=new THREE.Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)),function(yu,xu,vu,Su,Iu){su.set(vu,xu,-Su,"YXZ"),yu.setFromEuler(su),yu.multiply(uu),yu.multiply(au.setFromAxisAngle(tu,-Iu))});this.connect=function(){fu(),window.addEventListener("orientationchange",fu,!1),window.addEventListener("deviceorientation",du,!1),eu.enabled=!0},this.disconnect=function(){window.removeEventListener("orientationchange",fu,!1),window.removeEventListener("deviceorientation",du,!1),eu.enabled=!1},this.update=function(){if(eu.enabled!==!1){var yu=eu.deviceOrientation;if(yu){var xu=yu.alpha?THREE.MathUtils.degToRad(yu.alpha)+eu.alphaOffset:0,vu=yu.beta?THREE.MathUtils.degToRad(yu.beta):0,Su=yu.gamma?THREE.MathUtils.degToRad(yu.gamma):0,Iu=eu.screenOrientation?THREE.MathUtils.degToRad(eu.screenOrientation):0;gu(eu.object.quaternion,xu,vu,Su,Iu)}}},this.dispose=function(){eu.disconnect()},this.connect()},Ai=globalThis.THREE={...Re};Ai.DRACOLoader=Ue,Ai.GLTFLoader=Xe,Ai.KTX2Loader=Bn,Ai.OBJLoader=ni,Ai.MTLLoader=ii,Ai.OBB=_n,Ai.BufferGeometryUtils=o,Ai.LightProbeGenerator=oi,Ai.DeviceOrientationControls=ai,Ai.Cache.enabled=!0;const li=Ai;var ci=window.AFRAME_CDN_ROOT||"https://cdn.aframe.io/",hi="aframe-injected",di=i$1(8878),ui=i$1.n(di),gi={colors:{debug:"gray",error:"red",info:"gray",warn:"orange"}};ui().formatArgs=function(iu){if(iu[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+iu[0]+(this.useColors?"%c ":" "),this.useColors){var eu;this.color=(eu=function(uu){var du=uu.split(":");return du[du.length-1]}(this.namespace),gi.colors&&gi.colors[eu]||null);var tu="color: "+this.color;iu.splice(1,0,tu,"color: inherit");var su=0,au=0;iu[0].replace(/%[a-zA-Z%]/g,function(uu){uu!=="%%"&&(su++,uu==="%c"&&(au=su))}),iu.splice(au,0,tu)}};var pi=function(){try{return window.localStorage}catch{}}();pi&&(parseInt(pi.logs,10)||pi.logs==="true")?ui().enable("*"):ui().enable("*:error,*:info,*:warn");const fi=ui();var mi=i$1(1124),Ei=i$1.n(mi),Ci=fi("device:error"),vi=!1,Bi=!1,bi=navigator.xr!==void 0;if(bi){var yi=function(){var iu=document.querySelector("a-scene");iu?iu.hasLoaded?iu.components["xr-mode-ui"].updateEnterInterfaces():iu.addEventListener("loaded",yi):window.addEventListener("DOMContentLoaded",yi)},Ii=function(iu){Ci("WebXR session support error: "+iu.message)};navigator.xr.isSessionSupported?(navigator.xr.isSessionSupported("immersive-vr").then(function(iu){vi=iu,yi()}).catch(Ii),navigator.xr.isSessionSupported("immersive-ar").then(function(iu){Bi=iu,yi()}).catch(function(){})):navigator.xr.supportsSession?(navigator.xr.supportsSession("immersive-vr").then(function(){vi=!0,yi()}).catch(Ii),navigator.xr.supportsSession("immersive-ar").then(function(){Bi=!0,yi()}).catch(function(){})):Ci("WebXR has neither isSessionSupported or supportsSession?!")}function wi(){return vi||Bi}function xi(){return Bi}function Qi(){return vi}var Li,Mi,Si=(Li=!1,Mi=window.navigator.userAgent||window.navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(Mi)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(Mi.substr(0,4)))&&(Li=!0),(Ri()||Di()||Gi())&&(Li=!0),Pi()&&(Li=!1),function(){return Li});function Di(iu){var eu=iu||window.navigator.userAgent;return/Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(eu)||ki()}function ki(iu,eu,tu){var su=iu||window.navigator.userAgent,au=eu||window.navigator.platform,uu=tu||window.navigator.maxTouchPoints||0;return(au==="iPad"||au==="MacIntel")&&uu>0&&/Macintosh|Intel|iPad|ipad/i.test(su)&&!window.MSStream}function Ti(){var iu=navigator.userAgent.includes("Macintosh"),eu=navigator.maxTouchPoints===5;return iu&&eu&&bi}function Ri(){return/iPad|iPhone|iPod/.test(window.navigator.platform)}function Fi(){return!Si()&&!Pi()&&window.orientation!==void 0}function Ui(){return/(OculusBrowser)/i.test(window.navigator.userAgent)}function Oi(){return/(Mobile VR)/i.test(window.navigator.userAgent)}function Pi(){return Ui()||Oi()||Ti()}function Gi(){return/R7 Build/.test(window.navigator.userAgent)}function Ni(){var iu=window.orientation;return Gi()&&(iu+=90),iu===90||iu===-90}var ji=typeof process$1>"u"||process$1.browser===!0,_i=!ji,Hi=Object.freeze(Object.create(null));function qi(){return{}}function Vi(iu){var eu=[],tu=null;function su(au){var uu,du;if((au=au===void 0?eu.length:au)>0&&tu==null&&(tu=0),au>0)for(uu=eu.length,eu.length+=Number(au),du=uu;du<eu.length;du++)eu[du]=iu();return eu.length}return iu=iu||qi,{grow:su,pool:eu,recycle:function(au){au instanceof Object&&(tu!==null&&tu!==-1?eu[--tu]=au:eu[eu.length]=au)},size:function(){return eu.length},use:function(){var au;return tu!==null&&tu!==eu.length||su(eu.length||5),au=eu[tu],eu[tu++]=Hi,zi(au),au}}}function zi(iu){var eu;if(iu&&iu.constructor===Object)for(eu in iu)iu[eu]=void 0}function Yi(iu,eu){var tu;if(iu&&iu.constructor===Object)for(tu in iu)tu in eu||delete iu[tu]}var Ki=fi("utils:coordinates:warn"),Wi=["x","y","z","w"],Ji=/^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/,Xi=/\s+/g;function Zi(iu,eu,tu){var su,au,uu,du,fu,gu,yu,xu,vu=tu&&typeof tu=="object"?tu:{};if(iu&&iu instanceof Object)return fu=iu.x===void 0?eu&&eu.x:iu.x,gu=iu.y===void 0?eu&&eu.y:iu.y,yu=iu.z===void 0?eu&&eu.z:iu.z,xu=iu.w===void 0?eu&&eu.w:iu.w,fu!=null&&(vu.x=ir(fu)),gu!=null&&(vu.y=ir(gu)),yu!=null&&(vu.z=ir(yu)),xu!=null&&(vu.w=ir(xu)),vu;if(iu==null)return typeof eu=="object"?Object.assign(vu,eu):eu;for(su=iu.trim().split(Xi),du=0;du<Wi.length;du++)if(uu=Wi[du],su[du])vu[uu]=parseFloat(su[du],10);else{if((au=eu&&eu[uu])===void 0)continue;vu[uu]=ir(au)}return vu}function $i(iu){var eu;return typeof iu!="object"?iu:(eu=iu.x+" "+iu.y,iu.z!=null&&(eu+=" "+iu.z),iu.w!=null&&(eu+=" "+iu.w),eu)}function er(iu,eu){return typeof iu!="object"||typeof eu!="object"?iu===eu:iu.x===eu.x&&iu.y===eu.y&&iu.z===eu.z&&iu.w===eu.w}function tr(iu){return Ji.test(iu)}function nr(iu){return Ki("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"),tr(iu)}function ir(iu){return iu!=null&&iu.constructor===String?parseFloat(iu,10):iu}function rr(iu){return new Re.Vector3(iu.x,iu.y,iu.z)}var or=function(){var iu={};return function(eu,tu){return tu in iu||(iu[tu]={}),eu in iu[tu]||(iu[tu][eu]=eu.split(tu)),iu[tu][eu]}}();function sr(iu,eu){var tu=or(iu,eu=eu||".");return tu.length===1?tu[0]:tu}function ar(iu,eu,tu){var su;return tu=tu||".",eu.indexOf(tu)!==-1?(su=sr(eu,tu)).constructor===String?iu.getAttribute(su):iu.getAttribute(su[0])[su[1]]:iu.getAttribute(eu)}function Ar(iu,eu,tu,su){var au;su=su||".",eu.indexOf(su)===-1?iu.setAttribute(eu,tu):(au=sr(eu,su)).constructor===String?iu.setAttribute(au,tu):iu.setAttribute(au[0],au[1],tu)}function lr(iu){var eu=iu.style.width,tu=iu.style.height;iu.style.width=parseInt(eu,10)+1+"px",iu.style.height=parseInt(tu,10)+1+"px",setTimeout(function(){iu.style.width=eu,iu.style.height=tu},200)}var cr=fi("utils:src-loader:warn");function hr(iu,eu,tu){(function(su,au){var uu;su.tagName?au(su.tagName==="IMG"):((uu=new XMLHttpRequest).open("HEAD",su),uu.addEventListener("load",function(du){var fu;uu.status>=200&&uu.status<300?(fu=uu.getResponseHeader("Content-Type"))==null?pr(su,au):fu.startsWith("image")?au(!0):au(!1):pr(su,au),uu.abort()}),uu.send())})(iu,function(su){su?eu(iu):tu(iu)})}function dr(iu,eu,tu){var su,au,uu,du="",fu=[];if(typeof iu=="string"){let gu=function(yu){fu.push(yu),fu.length===6&&eu(fu)};for(au=0;au<5;au++)du+="(url\\((?:[^\\)]+)\\),\\s*)";if(du+="(url\\((?:[^\\)]+)\\)\\s*)",uu=iu.match(new RegExp(du))){for(au=1;au<7;au++)hr(gr(uu[au]),gu);return}if(!iu.startsWith("#"))return void hr(gr(iu)||iu,tu)}if(su=iu.tagName?iu:function(gu){try{var yu=document.querySelector(gu);return yu||cr('No element was found matching the selector: "%s"',gu),yu}catch{return void cr('"%s" is not a valid selector',gu)}}(iu))return su.tagName==="A-CUBEMAP"&&su.srcs?eu(su.srcs):su.tagName==="IMG"?tu(su):void cr('Selector "%s" does not point to <a-cubemap> or <img>',iu)}function ur(iu,eu){return dr(iu,eu,function(){cr("Expected cubemap but got image")})}function gr(iu){var eu=iu.match(/url\((.+)\)/);if(eu)return eu[1]}function pr(iu,eu){var tu=new Image;tu.addEventListener("load",function(){eu(!0)}),tu.addEventListener("error",function(){eu(!1)}),tu.src=iu}var fr=fi("utils:material:warn"),mr=new Set(["emissiveMap","envMap","map","specularMap"]);function Er(iu,eu){var tu=eu.offset||{x:0,y:0},su=eu.repeat||{x:1,y:1},au=eu.npot||!1,uu=eu.anisotropy||Re.Texture.DEFAULT_ANISOTROPY,du=iu.wrapS,fu=iu.wrapT,gu=iu.magFilter,yu=iu.minFilter;au&&(du=Re.ClampToEdgeWrapping,fu=Re.ClampToEdgeWrapping,gu=Re.LinearFilter,yu=Re.LinearFilter),su.x===1&&su.y===1||(du=Re.RepeatWrapping,fu=Re.RepeatWrapping),iu.offset.set(tu.x,tu.y),iu.repeat.set(su.x,su.y),iu.wrapS===du&&iu.wrapT===fu&&iu.magFilter===gu&&iu.minFilter===yu&&iu.anisotropy===uu||(iu.wrapS=du,iu.wrapT=fu,iu.magFilter=gu,iu.minFilter=yu,iu.anisotropy=uu,iu.needsUpdate=!0)}function Cr(iu,eu,tu,su){var au=tu.el,uu=tu.material,du=au.sceneEl.systems.renderer,fu=su[eu];if(tu.materialSrcs||(tu.materialSrcs={}),!fu)return delete tu.materialSrcs[iu],void gu(null);function gu(yu){uu[iu]!==yu&&(uu[iu]&&uu[iu].dispose(),uu[iu]=yu,uu.needsUpdate=!0,Ir(au,yu))}fu===tu.materialSrcs[iu]&&uu[iu]?Er(uu[iu],su):(tu.materialSrcs[iu]=fu,fu instanceof Re.Texture?gu(fu):au.sceneEl.systems.material.loadTextureSource(fu,function(yu){if(tu.materialSrcs[iu]===fu){var xu=uu[iu];!xu||yu!==null&&wr(xu,yu)||(xu=null),!xu&&yu&&(xu=xr(yu)),xu&&(xu.source!==yu&&(xu.source=yu,xu.needsUpdate=!0),mr.has(iu)&&du.applyColorCorrection(xu),Er(xu,su)),gu(xu)}}))}function vr(iu,eu){return Cr("map","src",iu,eu)}function Br(iu,eu,tu){var su=iu;iu==="ambientOcclusion"&&(su="ao");var au={};return au.src=tu[iu+"Map"],au.offset=tu[iu+"TextureOffset"],au.repeat=tu[iu+"TextureRepeat"],au.wrap=tu[iu+"TextureWrap"],Cr(su+"Map","src",eu,au)}var br={};function yr(iu,eu){var tu=iu.material,su=iu.el,au="envMap",uu=eu.envMap,du=eu.sphericalEnvMap,fu=eu.refract;if(du&&(uu=du,fr("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")),iu.materialSrcs||(iu.materialSrcs={}),!uu)return delete iu.materialSrcs[au],tu.envMap=null,void(tu.needsUpdate=!0);function gu(yu){iu.materialSrcs[au]===uu&&(tu.envMap=yu,tu.needsUpdate=!0,Ir(su,yu))}iu.materialSrcs[au]=uu,br[uu]?br[uu].then(gu):br[uu]=new Promise(function(yu){dr(uu,function(xu){su.sceneEl.systems.material.loadCubeMapTexture(xu,function(vu){vu.mapping=fu?Re.CubeRefractionMapping:Re.CubeReflectionMapping,gu(vu),yu(vu)})},function(xu){su.sceneEl.systems.material.loadTexture(xu,{src:xu},function(vu){vu.mapping=fu?Re.EquirectangularRefractionMapping:Re.EquirectangularReflectionMapping,gu(vu),yu(vu)})})})}function Ir(iu,eu){function tu(){iu.emit("materialvideoloadeddata",{src:eu.image,texture:eu})}function su(){iu.emit("materialvideoended",{src:eu.image,texture:eu})}eu&&(iu.emit("materialtextureloaded",{src:eu.image,texture:eu}),eu.image&&eu.image.tagName==="VIDEO"&&(eu.image.addEventListener("loadeddata",tu),eu.image.addEventListener("ended",su),eu.addEventListener("dispose",function(){eu.image.removeEventListener("loadeddata",tu),eu.image.removeEventListener("ended",su)})))}function wr(iu,eu){return iu.source===eu&&(eu.data instanceof HTMLCanvasElement?iu.isCanvasTexture:eu.data instanceof HTMLVideoElement?iu.isVideoTexture:iu.isTexture&&!iu.isCanvasTexture&&!iu.isVideoTexture)}function xr(iu){var eu;return(eu=iu.data instanceof HTMLCanvasElement?new Re.CanvasTexture:iu.data instanceof HTMLVideoElement?new Re.VideoTexture(iu.data):new Re.Texture).source=iu,eu.needsUpdate=!0,eu}var Qr=/-([a-z])/g;function Lr(iu,eu){var tu;return typeof iu!="string"?iu:(tu=function(su,au){var uu,du,fu,gu,yu,xu;for(au=au||{},uu=Tr(su),du=0;du<uu.length;du++)(fu=uu[du])&&(gu=fu.indexOf(":"),yu=fu.substr(0,gu).trim(),xu=fu.substr(gu+1).trim(),au[Sr(yu)]=xu);return au}(iu,eu),tu[""]?iu:tu)}function Mr(iu){return typeof iu=="string"?iu:function(eu){var tu,su=0,au=0,uu="";for(tu in eu)su++;for(tu in eu)uu+=tu+": "+eu[tu],au<su-1&&(uu+="; "),au++;return uu}(iu)}function Sr(iu){return iu.replace(Qr,Rr)}var Dr,kr,Tr=(Dr=[],kr=/url\([^)]+$/,function(iu){var eu,tu="",su=0;for(Dr.length=0;su<iu.length;)(eu=iu.indexOf(";",su))===-1&&(eu=iu.length),tu+=iu.substring(su,eu),kr.test(tu)?(tu+=";",su=eu+1):(Dr.push(tu.trim()),tu="",su=eu+1);return Dr});function Rr(iu){return iu[1].toUpperCase()}var Fr=["x","y","z","w"];function Ur(iu,eu,tu){var su,au,uu=iu.el;if((au=!!(su=Or(iu,eu,tu)))===iu.controllerPresent)return au;iu.controllerPresent=au,au?(iu.addEventListeners(),iu.injectTrackedControls(su),uu.emit("controllerconnected",{name:iu.name,component:iu})):(iu.removeEventListeners(),uu.emit("controllerdisconnected",{name:iu.name,component:iu}))}function Or(iu,eu,tu){var su,au=iu.el.sceneEl,uu=au&&au.systems["tracked-controls"];return!!uu&&!(!(su=uu.controllers)||!su.length)&&Pr(su,eu,tu.hand,tu.index,tu.iterateControllerProfiles,tu.handTracking)}function Pr(iu,eu,tu,su,au,uu){var du,fu,gu,yu,xu=!1;for(du=0;du<iu.length;du++){if(yu=(gu=iu[du]).profiles,uu)xu=gu.hand;else if(au)for(fu=0;fu<yu.length&&!(xu=yu[fu].startsWith(eu));fu++);else xu=yu.length>0&&yu[0].startsWith(eu);if(xu){if(gu.handedness==="right"||gu.handedness==="left"){if(gu.handedness===tu)return iu[du]}else if(du===su)return iu[du]}}}function Gr(iu,eu,tu){var su,au,uu,du,fu;for(au in eu){for(su=eu[au],uu=!1,fu=0;fu<su.length;fu++)tu.detail.changed[su[fu]]&&(uu=!0);if(uu){for(du={},fu=0;fu<su.length;fu++)du[Fr[fu]]=tu.detail.axis[su[fu]];iu.el.emit(au+"moved",du)}}}function Nr(iu,eu,tu,su){var au=(su?tu.mapping[su]:tu.mapping).buttons[iu];tu.el.emit(au+eu),tu.updateModel&&tu.updateModel(au,eu)}var jr=fi("utils:warn");function _r(iu){return iu.bind.apply(iu,Array.prototype.slice.call(arguments,1))}function Hr(){return jr("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"),wi()}function qr(){return jr("`utils.isIOS` has moved to `utils.device.isIOS`"),Ri()}function Vr(){return jr("`utils.isMobile has moved to `utils.device.isMobile`"),Si(arguments)}function zr(iu,eu,tu){var su;return tu&&(iu=iu.bind(tu)),function(){var au=Date.now();(su===void 0||(su===void 0?eu:au-su)>=eu)&&(su=au,iu.apply(null,arguments))}}function Yr(iu,eu,tu){var su,au,uu;tu&&(iu=iu.bind(tu));var du=function(){su=Date.now(),iu.apply(this,uu),au=void 0};return function(){var fu=Date.now(),gu=su===void 0?eu:fu-su;gu>=eu?(clearTimeout(au),au=void 0,su=fu,iu.apply(null,arguments)):(au=au||setTimeout(du,eu-gu),uu=arguments)}}function Kr(iu,eu,tu){var su;return tu&&(iu=iu.bind(tu)),function(au,uu){var du=su===void 0?uu:au-su;(su===void 0||du>=eu)&&(su=au,iu(au,du))}}function Wr(iu,eu,tu){var su;return function(){var au=this,uu=arguments,du=tu&&!su;clearTimeout(su),su=setTimeout(function(){su=null,tu||iu.apply(au,uu)},eu),du&&iu.apply(au,uu)}}var Jr=Object.assign,Xr=Ei();function Zr(iu){return JSON.parse(JSON.stringify(iu))}var $r,eo,to=($r=Vi(function(){return[]}),function(iu,eu){var tu,su,au,uu,du,fu;if(iu===void 0||eu===void 0||iu===null||eu===null||!(iu&&eu&&iu.constructor===Object&&eu.constructor===Object||iu.constructor===Array&&eu.constructor===Array))return iu===eu;for(tu in su=$r.use(),au=$r.use(),su.length=0,au.length=0,iu)su.push(tu);for(tu in eu)au.push(tu);if(su.length!==au.length)return $r.recycle(su),$r.recycle(au),!1;for(uu=0;uu<su.length;++uu)if(du=iu[su[uu]],fu=eu[su[uu]],typeof du=="object"||typeof fu=="object"||Array.isArray(du)&&Array.isArray(fu)){if(du===fu)continue;if(!to(du,fu))return $r.recycle(su),$r.recycle(au),!1}else if(du!==fu)return $r.recycle(su),$r.recycle(au),!1;return $r.recycle(su),$r.recycle(au),!0}),no=(eo=[],function(iu,eu,tu){var su,au,uu,du,fu,gu,yu;for(fu in du=tu||{},eo.length=0,iu)eo.push(fu);if(!eu)return du;for(uu in eu)eo.indexOf(uu)===-1&&eo.push(uu);for(gu=0;gu<eo.length;gu++)su=iu[fu=eo[gu]],au=eu[fu],((yu=su&&au&&su.constructor===Object&&au.constructor===Object)&&!to(su,au)||!yu&&su!==au)&&(du[fu]=au);return du});function io(iu){return!iu.metaKey&&document.activeElement===document.body}function ro(iu,eu){eu===void 0&&(eu=" ");var tu=new RegExp(eu,"g");return(iu=(iu||"").replace(tu,eu)).split(eu)}function oo(iu,eu){eu=eu||{};var tu={};return Object.keys(eu).forEach(function(su){iu.hasAttribute(su)&&(tu[su]=iu.getAttribute(su))}),tu}function so(iu){iu=iu.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var eu=new RegExp("[\\?&]"+iu+"=([^&#]*)").exec(location.search);return eu===null?"":decodeURIComponent(eu[1].replace(/\+/g," "))}function ao(){return window.top!==window.self}function Ao(iu){for(var eu=[],tu=iu.getElementsByTagName("*"),su=0,au=tu.length;su<au;su++)tu[su].isScene&&eu.push(tu[su]);return eu}var lo,co=[uo({name:"viewport",content:"width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"}),uo({name:"mobile-web-app-capable",content:"yes"}),uo({name:"theme-color",content:"black"})],ho=[uo({name:"apple-mobile-web-app-capable",content:"yes"}),uo({name:"apple-mobile-web-app-status-bar-style",content:"black"}),(lo={rel:"apple-touch-icon",href:"https://aframe.io/images/aframe-logo-152.png"},{tagName:"link",attributes:lo,exists:function(){return document.querySelector('link[rel="'+lo.rel+'"]')}})];function uo(iu){return{tagName:"meta",attributes:iu,exists:function(){return document.querySelector('meta[name="'+iu.name+'"]')}}}var go,po,fo,mo=i$1(5928),Eo=i$1.n(mo),Co=d,vo="loading-screen";function Bo(iu){var eu=go.hasAttribute("embedded"),tu=fo(go.canvas,eu,go.maxCanvasSize,go.is("vr-mode"));iu.aspect=tu.width/tu.height,iu.updateProjectionMatrix(),go.renderer.setSize(tu.width,tu.height,!1)}const bo=[];var yo=ui()("core:propertyTypes:warn"),Io={},wo=/[,> .[\]:]/,xo=/url\((.+)\)/;function Qo(iu,eu,tu,su,au,uu){if(iu in Io)throw new Error("Property type "+iu+" is already registered.");Io[iu]={default:eu,parse:tu||Do,stringify:su||ko,equals:au||To,isCacheable:uu!==!1}}function Lo(iu,eu){if(!Array.isArray(iu)||!Array.isArray(eu))return iu===eu;if(iu.length!==eu.length)return!1;for(var tu=0;tu<iu.length;tu++)if(iu[tu]!==eu[tu])return!1;return!0}function Mo(iu){var eu,tu;return typeof iu!="string"?iu:(tu=iu.match(xo))?tu[1]:iu.charAt(0)==="#"?(eu=document.getElementById(iu.substring(1)))?eu.tagName==="CANVAS"||eu.tagName==="VIDEO"||eu.tagName==="IMG"?eu:eu.getAttribute("src"):void yo('"'+iu+'" asset not found.'):iu}function So(iu){return iu.getAttribute?iu.getAttribute("id")?"#"+iu.getAttribute("id"):iu.getAttribute("src"):ko(iu)}function Do(iu){return iu}function ko(iu){return iu===null?"null":iu.toString()}function To(iu,eu){return iu===eu}function Ro(iu){return parseInt(iu,10)}function Fo(iu,eu,tu){return Zi(iu,eu,tu)}function Uo(iu,eu){if(iu===null)return!0;if(typeof iu!="object"||Object.keys(iu).length!==eu)return!1;var tu=iu.x,su=iu.y,au=iu.z,uu=iu.w;return!(typeof tu!="number"||typeof su!="number"||eu>2&&typeof au!="number"||eu>3&&typeof uu!="number")}Qo("audio","",Mo,So),Qo("array",[],function(iu){return Array.isArray(iu)?iu:iu&&typeof iu=="string"?iu.split(",").map(function(eu){return eu.trim()}):[]},function(iu){return iu.join(", ")},Lo),Qo("asset","",Mo,So),Qo("boolean",!1,function(iu){return iu!=="false"&&iu!==!1}),Qo("color","#FFF"),Qo("int",0,Ro),Qo("number",0,function(iu){return parseFloat(iu,10)}),Qo("map","",Mo,So),Qo("model","",Mo,So),Qo("selector",null,function(iu){return iu?typeof iu!="string"?iu:iu[0]!=="#"||wo.test(iu)?document.querySelector(iu):document.getElementById(iu.substring(1)):null},function(iu){return iu.getAttribute?"#"+iu.getAttribute("id"):ko(iu)},To,!1),Qo("selectorAll",null,function(iu){return iu?typeof iu!="string"?iu:Array.prototype.slice.call(document.querySelectorAll(iu),0):null},function(iu){return iu instanceof Array?iu.map(function(eu){return"#"+eu.getAttribute("id")}).join(", "):ko(iu)},Lo,!1),Qo("src","",function(iu){return yo("`src` property type is deprecated. Use `asset` instead."),Mo(iu)},So),Qo("string",""),Qo("time",0,Ro),Qo("vec2",{x:0,y:0},Fo,$i,er),Qo("vec3",{x:0,y:0,z:0},Fo,$i,er),Qo("vec4",{x:0,y:0,z:0,w:1},Fo,$i,er);var Oo=function(iu,eu){return(iu!=="audio"||typeof eu=="string")&&!(iu==="array"&&!Array.isArray(eu))&&(iu!=="asset"||typeof eu=="string")&&(iu!=="boolean"||typeof eu=="boolean")&&(iu!=="color"||typeof eu=="string")&&(iu!=="int"||typeof eu=="number")&&(iu!=="number"||typeof eu=="number")&&(iu!=="map"||typeof eu=="string")&&(iu!=="model"||typeof eu=="string")&&(iu!=="selector"||typeof eu=="string"||eu===null)&&(iu!=="selectorAll"||typeof eu=="string"||eu===null)&&(iu!=="src"||typeof eu=="string")&&(iu!=="string"||typeof eu=="string")&&(iu!=="time"||typeof eu=="number")&&(iu==="vec2"?Uo(eu,2):iu==="vec3"?Uo(eu,3):iu!=="vec4"||Uo(eu,4))},Po=Io,Go=fi("core:schema:warn");function No(iu){return"type"in iu?typeof iu.type=="string":"default"in iu}function jo(iu,eu){var tu;if(No(iu))return _o(iu,eu);for(tu in iu)iu[tu]=_o(iu[tu],eu);return iu}function _o(iu,eu){var tu,su,au=iu.default,uu=iu.type;return iu.type?iu.type==="bool"?uu="boolean":iu.type==="float"&&(uu="number"):uu=au===void 0||typeof au!="boolean"&&typeof au!="number"?Array.isArray(au)?"array":"string":typeof au,(su=Po[uu])||Go("Unknown property type for component `"+eu+"`: "+uu),tu=!!iu.parse,iu.parse=iu.parse||su.parse,iu.stringify=iu.stringify||su.stringify,iu.equals=iu.equals||su.equals,iu.isCacheable=iu.isCacheable===!0||su.isCacheable,iu.type=uu,"default"in iu?tu||Oo(uu,au)||Go("Default value `"+au+"` does not match type `"+uu+"` in component `"+eu+"`"):iu.default=su.default,iu}var Ho,qo=(Ho=[],function(iu,eu,tu,su,au){var uu,du,fu,gu;for(du in Ho.length=0,tu?iu:eu)tu&&iu[du]===void 0||Ho.push(du);if(iu===null||typeof iu!="object")return iu;for(du in iu)iu[du]===void 0||eu[du]||au||Go("Unknown property `"+du+"` for component/system `"+su+"`.");for(uu=0;uu<Ho.length;uu++){if(fu=eu[du=Ho[uu]],gu=iu[du],!eu[du])return;iu[du]=Vo(gu,fu)}return iu});function Vo(iu,eu,tu){return iu!=null&&iu!==""||(iu=eu.default,Array.isArray(iu)&&(iu=iu.slice())),eu.parse(iu,eu.default,tu)}function zo(iu,eu){var tu,su,au,uu,du={};for(tu in iu)su=eu[tu],typeof(uu=au=iu[tu])=="object"&&(uu=Yo(au,su),su||Go("Unknown component property: "+tu)),uu!==void 0&&(du[tu]=uu);return du}function Yo(iu,eu){return typeof iu!="object"?iu:eu&&iu!==null?eu.stringify(iu):JSON.stringify(iu)}var Ko={},Wo=Vo,Jo=jo,Xo=No,Zo=zo,$o=Yo,es=d,ts=fi("core:component:warn"),ns=document.currentScript,is=new RegExp("[A-Z]+"),rs={},os=Object.freeze({}),ss=[],as={get:function(iu,eu){return iu.getComputedPropertyValue(eu)},set:function(iu,eu,tu){return eu in iu.schema?iu.recomputeProperty(eu,tu):tu!==void 0&&iu.handleUnknownProperty(eu,tu),!0}},As=function(iu,eu,tu){var su=this;if(this.sceneOnly&&!iu.isScene)throw new Error("Component `"+this.name+"` can only be applied to <a-scene>");if(tu&&!this.multiple)throw new Error("Trying to initialize multiple components of type `"+this.name+"`. There can only be one component of this type per entity.");this.el=iu,this.id=tu,this.attrName=this.name+(tu?"__"+tu:""),this.evtDetail={id:this.id,name:this.name},this.initialized=!1,this.el.components[this.attrName]=this,this.objectPool=rs[this.name];var au=this.events;this.events={},function(uu,du){var fu;for(fu in du)uu.events[fu]=du[fu].bind(uu)}(this,au),this.attrValue=void 0,this.isObjectBased?(this.data=this.objectPool.use(),Yi(this.data,this.schema),this.oldData=this.objectPool.use(),Yi(this.oldData,this.schema),this.attrValueProxy=new Proxy(this,as)):(this.data=void 0,this.oldData=void 0,this.attrValueProxy=void 0),this.deferUnknownPropertyWarnings=!!this.updateSchema,this.throttledEmitComponentChanged=Yr(function(){iu.emit("componentchanged",su.evtDetail,!1)},200),this.updateProperties(eu,!0)};As.prototype={schema:{},init:function(){},events:{},update:function(iu){},updateSchema:void 0,tick:void 0,tock:void 0,play:function(){},pause:function(){},remove:function(){},stringify:function(iu){var eu=this.schema;return typeof iu=="string"?iu:this.isSingleProperty?$o(iu,eu):(iu=Zo(iu,eu),es.stringify(iu))},flushToDOM:function(iu){var eu=iu?this.data:this.attrValue;eu!=null&&window.HTMLElement.prototype.setAttribute.call(this.el,this.attrName,this.stringify(eu))},updateProperties:function(iu,eu){var tu=this.el;this.updateData(iu,eu),(tu.hasLoaded||tu.isLoading)&&(this.initialized?this.callUpdateHandler():this.initComponent())},initComponent:function(){var iu,eu=this.el;eu.initializingComponents[this.name]||(eu.initializingComponents[this.name]=!0,this.init(),this.initialized=!0,delete eu.initializingComponents[this.name],iu=this.isObjectBased?os:void 0,this.dataChanged=!1,this.storeOldData(),this.update(iu),eu.isPlaying&&this.play(),eu.emit("componentinitialized",this.evtDetail,!1))},updateData:function(iu,eu){this.isSingleProperty?this.recomputeProperty(void 0,iu):(eu?(zi(this.attrValue),this.recomputeData(iu),this.schemaChangeRequired=!!this.updateSchema):typeof iu=="string"?es.parse(iu,this.attrValueProxy):Jr(this.attrValueProxy,iu),this.updateSchemaIfNeeded(iu))},updateSchemaIfNeeded:function(iu){if(this.schemaChangeRequired&&this.updateSchema)for(var eu in ss.length=0,this.updateSchema(this.data),Yi(this.data,this.schema),this.recomputeData(iu),this.schemaChangeRequired=!1,this.attrValue)this.attrValue[eu]!==void 0&&ss.indexOf(eu)===-1&&(eu in this.schema||ts("Unknown property `"+eu+"` for component `"+this.name+"`."));for(var tu=0;tu<ss.length;tu++)ts("Unknown property `"+ss[tu]+"` for component `"+this.name+"`.");ss.length=0},callUpdateHandler:function(){if(this.isPositionRotationScale||this.dataChanged){this.dataChanged=!1;var iu=this.oldData;this.oldDataInUse=!0,this.update(iu),iu!==this.oldData&&this.objectPool.recycle(iu),this.oldDataInUse=!1,this.storeOldData(),this.throttledEmitComponentChanged()}},handleMixinUpdate:function(){this.recomputeData(),this.updateSchemaIfNeeded(),this.callUpdateHandler()},resetProperty:function(iu){(this.isSingleProperty||iu in this.schema)&&(iu?this.attrValue[iu]=void 0:(this.isObjectBased&&this.objectPool.recycle(this.attrValue),this.attrValue=void 0),this.recomputeProperty(iu,void 0),this.updateSchemaIfNeeded(),this.callUpdateHandler())},extendSchema:function(iu){var eu;eu=Jr({},Ko[this.name].schema),Jr(eu,iu),this.schema=Jo(eu),this.el.emit("schemachanged",this.evtDetail)},getComputedPropertyValue:function(iu){var eu=this.el.mixinEls,tu=this.attrValue&&iu?this.attrValue[iu]:this.attrValue;if(tu!==void 0)return tu;for(var su=eu.length-1;su>=0;su--){var au=eu[su].getAttribute(this.attrName);if(au!==null&&(!iu||iu in au))return iu?au[iu]:au}return iu?this.schema[iu].default:this.schema.default},recomputeProperty:function(iu,eu){var tu=iu?this.schema[iu]:this.schema;if(eu!=null){this.attrValue===void 0&&this.isObjectBased&&(this.attrValue=this.objectPool.use());var su=iu?this.attrValue[iu]:this.attrValue;typeof(su=tu.isCacheable?Wo(eu,tu,su):eu)=="string"&&(su=eu===""?void 0:eu),iu?this.attrValue[iu]=su:this.attrValue=su}this.oldDataInUse&&(this.oldData=this.objectPool.use(),Yi(this.oldData,this.schema),this.storeOldData(),this.oldDataInUse=!1);var au=iu?this.oldData[iu]:this.oldData,uu=iu?this.data[iu]:this.data,du=Wo(this.getComputedPropertyValue(iu),tu,uu);return tu.type!=="array"||iu||(du=Zr(du)),tu.equals(du,au)||(this.dataChanged=!0,tu.schemaChange&&(this.schemaChangeRequired=!0)),iu?this.data[iu]=du:this.data=du,du},handleUnknownProperty:function(iu,eu){this.attrValue===void 0&&(this.attrValue=this.objectPool.use()),this.attrValue[iu]=eu,this.deferUnknownPropertyWarnings?ss.push(iu):this.silenceUnknownPropertyWarnings||ts("Unknown property `"+iu+"` for component `"+this.name+"`.")},storeOldData:function(){var iu;if(this.isObjectBased)if(this.isSingleProperty)this.oldData=Wo(this.data,this.schema,this.oldData);else for(iu in this.schema)this.data[iu]!==void 0&&(this.data[iu]&&typeof this.data[iu]=="object"?this.oldData[iu]=Wo(this.data[iu],this.schema[iu],this.oldData[iu]):this.oldData[iu]=this.data[iu]);else this.oldData=this.data},recomputeData:function(iu){var eu;if(this.isSingleProperty)this.recomputeProperty(void 0,iu);else{for(eu in this.schema)this.attrValueProxy[eu]=void 0;iu&&typeof iu=="object"?Jr(this.attrValueProxy,iu):typeof iu=="string"&&es.parse(iu,this.attrValueProxy)}},eventsAttach:function(){var iu;for(iu in this.eventsDetach(),this.events)this.el.addEventListener(iu,this.events[iu])},eventsDetach:function(){var iu;for(iu in this.events)this.el.removeEventListener(iu,this.events[iu])},destroy:function(){this.objectPool.recycle(this.attrValue),this.objectPool.recycle(this.data),this.objectPool.recycle(this.oldData),this.attrValue=this.data=this.oldData=this.attrValueProxy=void 0}};var ls={};function cs(iu,eu){var tu,su,au,uu,du,fu={};if(document.currentScript&&document.currentScript!==ns&&bo.forEach(function(yu){yu.hasLoaded||document.currentScript.compareDocumentPosition(yu)!==Node.DOCUMENT_POSITION_FOLLOWING&&(ts("The component `"+iu+"` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."),window.debug&&(ls[iu]=!0))}),is.test(iu)===!0&&ts("The component name `"+iu+"` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `"+iu.toLowerCase()+"`"),iu.indexOf("__")!==-1)throw new Error("The component name `"+iu+"` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");if(Object.keys(eu).forEach(function(yu){fu[yu]={value:eu[yu],writable:!0}}),Ko[iu])throw new Error("The component `"+iu+"` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");((tu=function(yu,xu,vu){As.call(this,yu,xu,vu)}).prototype=Object.create(As.prototype,fu)).name=iu,tu.prototype.isPositionRotationScale=iu==="position"||iu==="rotation"||iu==="scale",tu.prototype.constructor=tu,tu.prototype.system=m&&fs[iu],tu.prototype.play=(uu=tu.prototype.play,function(){var yu=this.el.sceneEl,xu=this.el.isPlaying&&!this.isPlaying;this.initialized&&xu&&(uu.call(this),this.isPlaying=!0,this.eventsAttach(),hs(this)&&yu.addBehavior(this))}),tu.prototype.pause=(du=tu.prototype.pause,function(){var yu=this.el.sceneEl;this.isPlaying&&(du.call(this),this.isPlaying=!1,this.eventsDetach(),hs(this)&&yu.removeBehavior(this))}),su=Jr(Jo(tu.prototype.schema,tu.prototype.name)),tu.prototype.isSingleProperty=au=Xo(tu.prototype.schema),tu.prototype.isObjectBased=!au||au&&(ds(su.default)||ds(Wo(void 0,su))),rs[iu]=Vi(),Ko[iu]={Component:tu,dependencies:tu.prototype.dependencies,before:tu.prototype.before,after:tu.prototype.after,isSingleProperty:tu.prototype.isSingleProperty,isObjectBased:tu.prototype.isObjectBased,multiple:tu.prototype.multiple,sceneOnly:tu.prototype.sceneOnly,name:iu,schema:su,stringify:tu.prototype.stringify};for(var gu=0;gu<bo.length;gu++)bo[gu].emit("componentregistered",{name:iu},!1);return tu}function hs(iu){return iu.tick||iu.tock}function ds(iu){return iu&&iu.constructor===Object&&!(iu instanceof window.HTMLElement)}var us=!1;function gs(){us||(us=!0,setTimeout(function(){document.dispatchEvent(new CustomEvent("aframeready"))}))}var ps=d,fs={},ms=function(iu){var eu=f&&Ko[this.name];this.el=iu,this.sceneEl=iu,eu&&(eu.Component.prototype.system=this),this.buildData(),this.init(),this.update({})};function Es(iu,eu){var tu,su,au={},uu=Ao(document);if(Object.keys(eu).forEach(function(du){au[du]={value:eu[du],writable:!0}}),fs[iu])throw new Error("The system `"+iu+"` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");if(su=function(du){ms.call(this,du)},(su.prototype=Object.create(ms.prototype,au)).name=iu,su.prototype.constructor=su,su.prototype.schema=Jr(jo(su.prototype.schema)),fs[iu]=su,us)for(tu=0;tu<uu.length;tu++)uu[tu].initSystem(iu)}ms.prototype={schema:{},init:function(){},update:function(iu){},updateProperties:function(iu){var eu=this.data;Object.keys(this.schema).length!==0&&(this.buildData(iu),this.update(eu))},buildData:function(iu){var eu=this.schema;Object.keys(eu).length!==0&&(iu=iu||window.HTMLElement.prototype.getAttribute.call(this.sceneEl,this.name),No(eu)?this.data=Vo(iu,eu):this.data=qo(ps.parse(iu)||{},eu,!1,this.name))},tick:void 0,tock:void 0,play:function(){},pause:function(){}};var Cs=fi("core:a-node:warn"),vs={"a-scene":!0,"a-assets":!0,"a-assets-items":!0,"a-cubemap":!0,"a-mixin":!0,"a-node":!0,"a-entity":!0};function Bs(iu){return iu.tagName.toLowerCase()in vs||iu.isANode}class bs extends HTMLElement{constructor(){super(),this.computedMixinStr="",this.hasLoaded=!1,this.isANode=!0,this.mixinEls=[]}connectedCallback(){us?this.doConnectedCallback():document.addEventListener("aframeready",this.connectedCallback.bind(this))}doConnectedCallback(){var eu;this.sceneEl=this.closestScene(),this.sceneEl||Cs("You are attempting to attach <"+this.tagName+"> outside of an A-Frame scene. Append this element to `<a-scene>` instead."),this.hasLoaded=!1,this.emit("nodeready",void 0,!1),this.isMixin||(eu=this.getAttribute("mixin"))&&this.updateMixins(eu)}attributeChangedCallback(eu,tu,su){su!==this.computedMixinStr&&(eu!=="mixin"||this.isMixin||this.updateMixins(su,tu))}closestScene(){for(var eu=this;eu&&!eu.isScene;)eu=eu.parentElement;return eu}closest(eu){for(var tu=this.matches||this.mozMatchesSelector||this.msMatchesSelector||this.oMatchesSelector||this.webkitMatchesSelector,su=this;su&&!tu.call(su,eu);)su=su.parentElement;return su}disconnectedCallback(){this.hasLoaded=!1}load(eu,tu){var su,au=this;this.hasLoaded||(tu=tu||Bs,su=this.getChildren().filter(tu).map(function(uu){return new Promise(function(du,fu){if(uu.hasLoaded)return du();uu.addEventListener("loaded",du),uu.addEventListener("error",fu)})}),Promise.allSettled(su).then(function(uu){uu.forEach(function(du){du.status==="rejected"&&Cs("Rendering scene with errors on node: ",du.reason.target)}),au.isLoading=!0,au.setupMutationObserver(),eu&&eu(),au.isLoading=!1,au.hasLoaded=!0,au.emit("loaded-private",void 0,!1),au.emit("loaded",void 0,!1)}))}setupMutationObserver(){var eu=this;new MutationObserver(function(tu){var su;for(su=0;su<tu.length;su++)if(tu[su].type==="attributes"){var au=tu[su].attributeName,uu=window.HTMLElement.prototype.getAttribute.call(eu,au),du=tu[su].oldValue;eu.attributeChangedCallback(au,du,uu)}}).observe(this,{attributes:!0,attributeOldValue:!0})}getChildren(){return Array.prototype.slice.call(this.children,0)}updateMixins(eu,tu){var su,au,uu,du=bs.newMixinIdArray,fu=bs.oldMixinIdArray,gu=bs.mixinIds;for(du.length=0,fu.length=0,au=eu?or(eu.trim(),/\s+/):du,uu=tu?or(tu.trim(),/\s+/):fu,gu.newMixinIds=au,gu.oldMixinIds=uu,su=0;su<uu.length;su++)au.indexOf(uu[su])===-1&&this.unregisterMixin(uu[su]);for(this.computedMixinStr="",this.mixinEls.length=0,su=0;su<au.length;su++)this.registerMixin(au[su]);return this.computedMixinStr&&(this.computedMixinStr=this.computedMixinStr.trim(),window.HTMLElement.prototype.setAttribute.call(this,"mixin",this.computedMixinStr)),au.length===0&&window.HTMLElement.prototype.removeAttribute.call(this,"mixin"),gu}registerMixin(eu){var tu,su,au,uu=document.getElementById(eu);if(uu){if(au=uu.getAttribute("mixin"))for(tu=or(au.trim(),/\s+/),su=0;su<tu.length;su++)this.registerMixin(tu[su]);this.computedMixinStr=this.computedMixinStr+" "+uu.id,this.mixinEls.push(uu)}else Cs("No mixin was found with id `%s`",eu)}setAttribute(eu,tu){eu==="mixin"&&this.updateMixins(tu),window.HTMLElement.prototype.setAttribute.call(this,eu,tu)}unregisterMixin(eu){var tu,su=this.mixinEls;for(tu=0;tu<su.length;++tu)if(eu===su[tu].id){su.splice(tu,1);break}}emit(eu,tu,su,au){var uu=bs.evtData;su===void 0&&(su=!0),uu.bubbles=!!su,uu.detail=tu,au&&(uu=Jr({},au,uu)),this.dispatchEvent(new CustomEvent(eu,uu))}}bs.evtData={},bs.newMixinIdArray=[],bs.oldMixinIdArray=[],bs.mixinIds={},customElements.define("a-node",bs);var ys=fi("core:a-entity:debug"),Is=fi("core:a-entity:warn"),ws="__",xs=["position","rotation","scale","visible"],Qs={once:!0};class Ls extends bs{constructor(){super(),this.components={},this.initializingComponents={},this.componentsToUpdate={},this.isEntity=!0,this.isPlaying=!1,this.object3D=new Re.Group,this.object3D.rotation.order="YXZ",this.object3D.el=this,this.object3DMap={},this.parentEl=null,this.rotationObj={},this.states=[]}attributeChangedCallback(eu,tu,su){var au=this.components[eu];super.attributeChangedCallback(),au&&au.justInitialized&&su===""?delete au.justInitialized:(au||su!==null)&&this.setEntityAttribute(eu,tu,su)}doConnectedCallback(){var eu,tu,su=this;super.doConnectedCallback(),tu=this.sceneEl,this.addToParent(),this.isScene||(tu?!(eu=tu.querySelector("a-assets"))||eu.hasLoaded?this.load():eu.addEventListener("loaded",function(){su.load()}):this.load())}disconnectedCallback(){var eu;if(this.parentEl){for(eu in this.components)this.removeComponent(eu,!1);this.isScene||(this.removeFromParent(),super.disconnectedCallback(),this.object3D.el=null)}}getObject3D(eu){return this.object3DMap[eu]}setObject3D(eu,tu){var su,au=this;if(!(tu instanceof Re.Object3D))throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");(su=this.getObject3D(eu))&&this.object3D.remove(su),tu.el=this,tu.children.length&&tu.traverse(function(uu){uu.el=au}),this.object3D.add(tu),this.object3DMap[eu]=tu,this.emit("object3dset",{object:tu,type:eu})}removeObject3D(eu){var tu=this.getObject3D(eu);tu?(this.object3D.remove(tu),delete this.object3DMap[eu],this.emit("object3dremove",{type:eu})):Is("Tried to remove `Object3D` of type:",eu,"which was not defined.")}getOrCreateObject3D(eu,tu){var su=this.getObject3D(eu);return!su&&tu&&(su=new tu,this.setObject3D(eu,su)),Is("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."),su}add(eu){if(!eu.object3D)throw new Error("Trying to add an element that doesn't have an `object3D`");this.object3D.add(eu.object3D),this.emit("child-attached",{el:eu})}addToParent(){var eu=this.parentEl=this.parentNode;eu&&eu.add&&!this.attachedToParent&&(eu.add(this),this.attachedToParent=!0)}removeFromParent(){var eu=this.parentEl;this.parentEl.remove(this),this.attachedToParent=!1,this.parentEl=null,eu.emit("child-detached",{el:this})}load(){var eu=this;!this.hasLoaded&&this.parentEl&&super.load.call(this,function(){eu.parentEl&&(eu.updateComponents(),(eu.isScene||eu.parentEl.isPlaying)&&eu.play())})}remove(eu){eu?this.object3D.remove(eu.object3D):this.parentNode.removeChild(this)}getChildEntities(){for(var eu=this.children,tu=[],su=0;su<eu.length;su++){var au=eu[su];au instanceof Ls&&tu.push(au)}return tu}initComponent(eu,tu,su){var au,uu,du,fu;fu=(du=or(eu,ws))[0],uu=du.length>2?du.slice(1).join("__"):du[1],Ko[fu]&&(Ms(this,eu)||tu!==void 0||su)&&(eu in this.components||(this.initComponentDependencies(fu),au=new Ko[fu].Component(this,tu,uu),this.isPlaying&&au.play(),this.hasAttribute(eu)||(au.justInitialized=!0,window.HTMLElement.prototype.setAttribute.call(this,eu,"")),ys("Component initialized: %s",eu)))}initComponentDependencies(eu){var tu,su;if(Ko[eu]&&(tu=Ko[eu].dependencies))for(su=0;su<tu.length;su++)this.initComponent(tu[su],window.HTMLElement.prototype.getAttribute.call(this,tu[su])||void 0,!0)}removeComponent(eu,tu){var su;(su=this.components[eu])&&(su.initialized?(su.pause(),su.remove(),tu&&(su.destroy(),delete this.components[eu],this.hasAttribute(eu)&&window.HTMLElement.prototype.removeAttribute.call(this,eu)),this.emit("componentremoved",su.evtDetail,!1)):this.addEventListener("componentinitialized",function au(uu){uu.detail.name===eu&&(this.removeComponent(eu,tu),this.removeEventListener("componentinitialized",au))}))}updateComponents(){var eu,tu,su,au,uu,du,fu=this.componentsToUpdate;if(this.hasLoaded||this.isLoading){for(su=0;su<this.mixinEls.length;su++)for(au in this.mixinEls[su].componentCache)Ss(au)&&(fu[au]=!0);if(this.getExtraComponents)for(au in tu=this.getExtraComponents())Ss(au)&&(fu[au]=!0);for(su=0;su<this.attributes.length;++su)au=this.attributes[su].name,xs.indexOf(au)===-1&&Ss(au)&&(fu[au]=!0);for(su=0;su<xs.length;su++)au=xs[su],this.hasAttribute(au)&&this.updateComponent(au,this.getDOMAttribute(au));for(au in fu)uu=this.getDOMAttribute(au),eu=(du=tu&&tu[au])?du.constructor===Object?Jr(du,Lr(uu||{})):uu||du:uu,this.updateComponent(au,eu),delete fu[au]}}updateComponent(eu,tu,su){var au=this.components[eu];if(au)return tu!==null||Ms(this,eu)?void au.updateProperties(tu,su):void this.removeComponent(eu,!0);this.initComponent(eu,tu,!1)}removeAttribute(eu,tu){var su=this.components[eu];su&&tu===void 0&&this.removeComponent(eu,!0),su&&tu!==void 0?su.resetProperty(tu):(eu==="mixin"&&this.mixinUpdate(""),window.HTMLElement.prototype.removeAttribute.call(this,eu))}play(){var eu,tu,su;if(!this.isPlaying&&(this.hasLoaded||this.isLoading)){for(su in this.isPlaying=!0,this.components)this.components[su].play();for(eu=this.getChildEntities(),tu=0;tu<eu.length;tu++)eu[tu].play();this.emit("play")}}pause(){var eu,tu,su;if(this.isPlaying){for(su in this.isPlaying=!1,this.components)this.components[su].pause();for(eu=this.getChildEntities(),tu=0;tu<eu.length;tu++)eu[tu].pause();this.emit("pause")}}setEntityAttribute(eu,tu,su){if(Ko[eu]||this.components[eu])this.updateComponent(eu,su);else if(eu==="mixin"){if(su===this.computedMixinStr)return;this.mixinUpdate(su,tu)}}mixinUpdate(eu,tu,su){var au,uu,du,fu,gu=Ls.componentsUpdated,yu=this;if(su||(tu=tu||this.getAttribute("mixin")),this.hasLoaded){for(du=this.updateMixins(eu,tu),gu.length=0,fu=0;fu<this.mixinEls.length;fu++)for(au in this.mixinEls[fu].componentCache)gu.indexOf(au)===-1&&(this.components[au]?this.components[au].handleMixinUpdate():this.initComponent(au,null),gu.push(au));for(fu=0;fu<du.oldMixinIds.length;fu++)if(uu=document.getElementById(du.oldMixinIds[fu]))for(au in uu.componentCache)gu.indexOf(au)===-1&&this.components[au]&&(this.getDOMAttribute(au)?this.components[au].handleMixinUpdate():this.removeComponent(au,!0))}else this.addEventListener("loaded-private",function(){yu.mixinUpdate(eu,tu,!0)},Qs)}setAttribute(eu,tu,su){var au,uu,du,fu,gu,yu=Ls.singlePropUpdate;if(du=(fu=eu.indexOf(ws))>0?eu.substring(0,fu):eu,!Ko[du])return eu==="mixin"&&this.mixinUpdate(tu),void super.setAttribute.call(this,eu,tu);if(!this.components[eu]&&this.hasAttribute(eu)&&this.updateComponent(eu,window.HTMLElement.prototype.getAttribute.call(this,eu)),su!==void 0&&typeof tu=="string"&&tu.length>0&&typeof Lr(tu)=="string"){for(gu in yu)delete yu[gu];(au=yu)[tu]=su,uu=!1}else au=tu,uu=su===!0;this.updateComponent(eu,au,uu),this.sceneEl&&this.sceneEl.getAttribute("debug")&&this.components[eu].flushToDOM()}flushToDOM(eu){var tu,su,au,uu=this.components,du=this.children;for(au in uu)uu[au].flushToDOM();if(eu)for(su=0;su<du.length;++su)(tu=du[su]).flushToDOM&&tu.flushToDOM(eu)}getAttribute(eu){var tu,su,au,uu;return eu==="position"?this.object3D.position:eu==="rotation"?(su=Re.MathUtils.radToDeg,au=this.object3D.rotation,(uu=this.rotationObj).x=su(au.x),uu.y=su(au.y),uu.z=su(au.z),uu):eu==="scale"?this.object3D.scale:eu==="visible"?this.object3D.visible:(tu=this.components[eu])?tu.data:window.HTMLElement.prototype.getAttribute.call(this,eu)}getDOMAttribute(eu){var tu=this.components[eu];return tu?tu.attrValue:window.HTMLElement.prototype.getAttribute.call(this,eu)}addState(eu){this.is(eu)||(this.states.push(eu),this.emit("stateadded",eu))}removeState(eu){var tu=this.states.indexOf(eu);tu!==-1&&(this.states.splice(tu,1),this.emit("stateremoved",eu))}is(eu){return this.states.indexOf(eu)!==-1}inspect(){this.sceneEl.components.inspector.openInspector(this)}destroy(){var eu;if(this.parentNode)Is("Entity can only be destroyed if detached from scenegraph.");else for(eu in this.components)this.components[eu].destroy()}}function Ms(iu,eu){return!(!iu.components[eu]||!iu.components[eu].attrValue)||function(tu,su){var au,uu=!1;for(au=0;au<su.length&&!(uu=su[au].hasAttribute(tu));++au);return uu}(eu,iu.mixinEls)}function Ss(iu){return iu.indexOf(ws)!==-1&&(iu=or(iu,ws)[0]),!!Ko[iu]}function Ds(iu){if(iu.data&&iu.data.type==="vr")switch(iu.data.data){case"enter":this.enterVR();break;case"exit":this.exitVR()}}Ls.componentsUpdated=[],Ls.singlePropUpdate={},customElements.define("a-entity",Ls),Ri()&&window.addEventListener("orientationchange",function(){document.documentElement.style.height="initial",setTimeout(function(){document.documentElement.style.height="100%",setTimeout(function(){window.scrollTo(0,1)},500)},500)});var ks=fi("core:a-scene:warn"),Ts=Ri(),Rs=Si(),Fs=bi;class Us extends Ls{constructor(){var eu;super(),(eu=this).clock=new Re.Clock,eu.isIOS=Ts,eu.isMobile=Rs,eu.hasWebXR=Fs,eu.isAR=!1,eu.isScene=!0,eu.object3D=new Re.Scene,eu.resize=eu.resize.bind(eu),eu.render=eu.render.bind(eu),eu.systems={},eu.systemNames=[],eu.time=eu.delta=0,eu.usedOfferSession=!1,eu.componentOrder=[],eu.behaviors={},eu.hasLoaded=!1,eu.isPlaying=!1,eu.originalHTML=eu.innerHTML}addFullScreenStyles(){document.documentElement.classList.add("a-fullscreen")}removeFullScreenStyles(){document.documentElement.classList.remove("a-fullscreen")}doConnectedCallback(){var eu=this,tu=this.hasAttribute("embedded");this.setAttribute("inspector",""),this.setAttribute("keyboard-shortcuts",""),this.setAttribute("screenshot",""),this.setAttribute("xr-mode-ui",""),this.setAttribute("device-orientation-permission-ui",""),super.doConnectedCallback(),function(su){var au;function uu(){document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||su.exitVR(),document.activeElement.blur(),document.body.focus()}(au=document.createElement("canvas")).classList.add("a-canvas"),au.dataset.aframeCanvas=!0,su.appendChild(au),document.addEventListener("fullscreenchange",uu),document.addEventListener("mozfullscreenchange",uu),document.addEventListener("webkitfullscreenchange",uu),document.addEventListener("MSFullscreenChange",uu),au.addEventListener("touchmove",function(du){du.preventDefault()},{passive:!1}),su.canvas=au,su.emit("render-target-loaded",{target:au}),setTimeout(su.resize.bind(su),0)}(this),this.setupRenderer(),function(su,au){fo=au;var uu,du,fu,gu,yu,xu,vu,Su,Iu,Mu,ku=(go=su).hasAttribute(vo)?Co.parse(go.getAttribute(vo)):void 0,Bu=ku&&ku.dotsColor||"white",_u=ku&&ku.backgroundColor||"#24CAFF";(ku===void 0||ku.enabled==="true"||ku.enabled===void 0)&&(uu=new Re.Scene,du=new Re.SphereGeometry(.2,36,18,0,2*Math.PI,0,Math.PI),fu=new Re.MeshBasicMaterial({color:Bu}),gu=new Re.Mesh(du,fu),yu=gu.clone(),xu=gu.clone(),vu=new Re.PerspectiveCamera(80,window.innerWidth/window.innerHeight,5e-4,1e4),Su=new Re.Clock,Iu=0,Mu=function(){go.renderer.render(uu,vu),Iu=Su.getElapsedTime()%4,gu.visible=Iu>=1,yu.visible=Iu>=2,xu.visible=Iu>=3},uu.background=new Re.Color(_u),uu.add(vu),gu.position.set(-1,0,-15),yu.position.set(0,0,-15),xu.position.set(1,0,-15),vu.add(gu),vu.add(yu),vu.add(xu),(po=document.createElement("div")).className="a-loader-title",po.innerHTML=document.title,po.style.display="none",po.setAttribute(hi,""),go.appendChild(po),setTimeout(function(){go.hasLoaded||(Bo(vu),po.style.display="block",window.addEventListener("resize",function(){Bo(vu)}),go.renderer.setAnimationLoop(Mu))},200))}(this,Gs),this.resize(),tu||this.addFullScreenStyles(),ao()&&window.addEventListener("message",Ds.bind(this)),function(su){var au,uu=document.head,du=uu.querySelector("script"),fu=[];return co.forEach(gu),su.isIOS&&ho.forEach(gu),fu;function gu(yu){yu&&!yu.exists()&&(au=function(xu){if(xu&&xu.tagName){var vu=document.createElement(xu.tagName);return vu.setAttribute(hi,""),Jr(vu,xu.attributes)}}(yu),au&&(du?du.parentNode.insertBefore(au,du):uu.appendChild(au),fu.push(au)))}}(this),function(su){if(su.isMobile){var au=su.wakelock=new(Eo());su.addEventListener("enter-vr",function(){au.request()}),su.addEventListener("exit-vr",function(){au.release()})}}(this),this.enterVRBound=function(){eu.enterVR()},this.exitVRBound=function(){eu.exitVR()},window.addEventListener("sessionend",this.resize),this.addEventListener("cameraready",function(){eu.attachedCallbackPostCamera()}),this.initSystems(),this.componentOrder=Os(Ko,this.componentOrder),this.addEventListener("componentregistered",function(){eu.componentOrder=Os(Ko,eu.componentOrder)}),this.hasWebXR&&navigator.xr&&navigator.xr.addEventListener&&navigator.xr.addEventListener("sessiongranted",function(){eu.enterVR()})}attachedCallbackPostCamera(){var eu=this;window.addEventListener("load",void 0),window.addEventListener("resize",function(){eu.isIOS?setTimeout(eu.resize,100):eu.resize()}),this.play(),bo.push(this)}initSystems(){var eu;for(eu in this.initSystem("camera"),fs)eu!=="camera"&&this.initSystem(eu)}initSystem(eu){this.systems[eu]||(this.systems[eu]=new fs[eu](this),this.systemNames.push(eu))}disconnectedCallback(){var eu=bo.indexOf(this);super.disconnectedCallback(),bo.splice(eu,1),window.removeEventListener("sessionend",this.resize),this.removeFullScreenStyles(),this.renderer.dispose()}addBehavior(eu){var tu,su,au=this.behaviors[eu.name];for(su in au||(au=this.behaviors[eu.name]={tick:{inUse:!1,array:[],markedForRemoval:[]},tock:{inUse:!1,array:[],markedForRemoval:[]}}),au)if(eu[su]){if((tu=au[su]).inUse){var uu=tu.markedForRemoval.indexOf(eu);uu!==-1&&tu.markedForRemoval.splice(uu,1)}tu.array.indexOf(eu)===-1&&tu.array.push(eu)}}getPointerLockElement(){return document.pointerLockElement}checkHeadsetConnected(){return wi()}enterAR(){var eu;if(!this.hasWebXR)throw eu="Failed to enter AR mode, WebXR not supported.",new Error(eu);if(!xi())throw eu="Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.",new Error(eu);return this.enterVR(!0)}enterVR(eu,tu){var su,au=this,uu=au.renderer.xr;if(tu&&(!navigator.xr||!navigator.xr.offerSession))return Promise.resolve("OfferSession is not supported.");if(au.usedOfferSession&&tu)return Promise.resolve("OfferSession was already called.");if(this.is("vr-mode"))return Promise.resolve("Already in VR.");if(this.checkHeadsetConnected()||this.isMobile){var du=au.getAttribute("renderer");if(uu.enabled=!0,this.hasWebXR){this.xrSession&&this.xrSession.removeEventListener("end",this.exitVRBound);var fu=this.sceneEl.systems.webxr.sessionReferenceSpaceType;uu.setReferenceSpaceType(fu);var gu=eu?"immersive-ar":"immersive-vr";return su=this.sceneEl.systems.webxr.sessionConfiguration,new Promise(function(xu,vu){var Su=tu?navigator.xr.offerSession.bind(navigator.xr):navigator.xr.requestSession.bind(navigator.xr);au.usedOfferSession|=tu,Su(gu,su).then(function(Iu){tu&&(au.usedOfferSession=!1),uu.layersEnabled=su.requiredFeatures.indexOf("layers")!==-1,uu.setSession(Iu).then(function(){uu.setFoveation(du.foveationLevel),au.xrSession=Iu,au.systems.renderer.setWebXRFrameRate(Iu),Iu.addEventListener("end",au.exitVRBound),yu(xu)})},function(Iu){vu(new Error("Failed to enter "+(gu==="immersive-ar"?"AR":"VR")+" mode (`requestSession`)",{cause:Iu}))})})}throw new Error("Failed to enter "+(eu?"AR":"VR")+" no WebXR")}return yu(),Promise.resolve();function yu(xu){var vu;eu?au.addState("ar-mode"):au.addState("vr-mode"),au.emit("enter-vr",{target:au}),!au.hasWebXR&&au.isMobile&&screen.orientation&&screen.orientation.lock&&screen.orientation.lock("landscape"),au.addFullScreenStyles(),au.isMobile||au.checkHeadsetConnected()||((vu=au.canvas).requestFullscreen||vu.webkitRequestFullscreen||vu.mozRequestFullScreen||vu.msRequestFullscreen).apply(vu,[{navigationUI:"hide"}]),au.resize(),xu&&xu()}}exitVR(){var eu=this,tu=this.renderer.xr;if(!this.is("vr-mode")&&!this.is("ar-mode"))return Promise.resolve("Not in immersive mode.");if(this.checkHeadsetConnected()||this.isMobile){if(tu.enabled=!1,!this.hasWebXR)throw Error("Failed to exit VR - no WebXR");this.xrSession.removeEventListener("end",this.exitVRBound),this.xrSession.end().then(function(){},function(){}),this.xrSession=void 0}else(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement)&&(document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen());return eu.removeState("vr-mode"),eu.removeState("ar-mode"),eu.isMobile&&screen.orientation&&screen.orientation.unlock&&screen.orientation.unlock(),eu.hasAttribute("embedded")&&eu.removeFullScreenStyles(),eu.resize(),eu.isIOS&&lr(eu.canvas),eu.renderer.setPixelRatio(window.devicePixelRatio),eu.emit("exit-vr",{target:eu}),Promise.resolve()}getAttribute(eu){var tu=this.systems[eu];return tu?tu.data:Ls.prototype.getAttribute.call(this,eu)}getDOMAttribute(eu){var tu=this.systems[eu];return tu?tu.data:Ls.prototype.getDOMAttribute.call(this,eu)}setAttribute(eu,tu,su){if(fs[eu]){bs.prototype.setAttribute.call(this,eu,tu);var au=this.systems[eu];au&&au.updateProperties(tu)}else Ls.prototype.setAttribute.call(this,eu,tu,su)}removeBehavior(eu){var tu,su,au,uu=this.behaviors[eu.name];for(su in uu)eu[su]&&(au=(tu=uu[su]).array.indexOf(eu))!==-1&&(tu.inUse?tu.markedForRemoval.indexOf(eu)===-1&&tu.markedForRemoval.push(eu):(tu.array[au]=tu.array[tu.array.length-1],tu.array.pop()))}resize(){var eu,tu,su=this.camera,au=this.canvas,uu=this.renderer.xr.isPresenting;eu=this.renderer.xr.enabled&&uu,!su||!au||this.is("vr-mode")&&(this.isMobile||eu)||(tu=Gs(au,this.getAttribute("embedded")&&!this.is("vr-mode"),this.maxCanvasSize,this.is("vr-mode")),su.aspect=tu.width/tu.height,su.updateProjectionMatrix(),this.renderer.setSize(tu.width,tu.height,!1),this.emit("rendererresize",null,!1))}setupRenderer(){var eu,tu,su,au=this;su={alpha:!0,antialias:!Rs,canvas:this.canvas,logarithmicDepthBuffer:!1,powerPreference:"high-performance"},this.maxCanvasSize={height:-1,width:-1},this.hasAttribute("renderer")&&((tu=Lr(this.getAttribute("renderer"))).precision&&(su.precision=tu.precision+"p"),tu.antialias&&tu.antialias!=="auto"&&(su.antialias=tu.antialias==="true"),tu.logarithmicDepthBuffer&&tu.logarithmicDepthBuffer!=="auto"&&(su.logarithmicDepthBuffer=tu.logarithmicDepthBuffer==="true"),tu.alpha&&(su.alpha=tu.alpha==="true"),tu.stencil&&(su.stencil=tu.stencil==="true"),tu.multiviewStereo&&(su.multiviewStereo=tu.multiviewStereo==="true"),this.maxCanvasSize={width:tu.maxCanvasWidth?parseInt(tu.maxCanvasWidth):this.maxCanvasSize.width,height:tu.maxCanvasHeight?parseInt(tu.maxCanvasHeight):this.maxCanvasSize.height});var uu=["WebGLRenderer","WebGPURenderer"].find(function(du){return Re[du]});(eu=this.renderer=new Re[uu](su)).xr.setPoseTarget||(eu.xr.setPoseTarget=function(){}),eu.setPixelRatio(window.devicePixelRatio),this.camera&&eu.xr.setPoseTarget(this.camera.el.object3D),this.addEventListener("camera-set-active",function(){eu.xr.setPoseTarget(au.camera.el.object3D)})}play(){var eu=this,tu=this;this.renderStarted?Ls.prototype.play.call(this):(this.addEventListener("loaded",function(){var su=this.renderer;Ls.prototype.play.call(this),tu.renderStarted||(tu.resize(),tu.renderer&&(window.performance&&window.performance.mark("render-started"),window.removeEventListener("resize",Bo),po&&(po.style.display="none"),su.setAnimationLoop(this.render),tu.renderStarted=!0,tu.emit("renderstart")))}),setTimeout(function(){Ls.prototype.load.call(eu)}))}updateComponent(eu){eu in fs||Ls.prototype.updateComponent.apply(this,arguments)}tick(eu,tu){var su,au=this.systems;for(this.callComponentBehaviors("tick",eu,tu),su=0;su<this.systemNames.length;su++)au[this.systemNames[su]].tick&&au[this.systemNames[su]].tick(eu,tu)}tock(eu,tu,su){var au,uu=this.systems;for(this.callComponentBehaviors("tock",eu,tu),au=0;au<this.systemNames.length;au++)uu[this.systemNames[au]].tock&&uu[this.systemNames[au]].tock(eu,tu,su)}render(eu,tu){var su=this.renderer;this.frame=tu,this.delta=1e3*this.clock.getDelta(),this.time=1e3*this.clock.elapsedTime,this.isPlaying&&this.tick(this.time,this.delta);var au=null;if(this.is("ar-mode")&&(au=this.object3D.background,this.object3D.background=null),su.render(this.object3D,this.camera),au&&(this.object3D.background=au),this.isPlaying){var uu=su.xr.isPresenting?su.xr.getCamera():this.camera;this.tock(this.time,this.delta,uu)}}callComponentBehaviors(eu,tu,su){for(var au,uu=0;uu<this.componentOrder.length;uu++){var du=this.behaviors[this.componentOrder[uu]];if(du){var fu=du[eu];for(fu.inUse=!0,au=0;au<fu.array.length;au++)fu.array[au].isPlaying&&fu.array[au][eu](tu,su);for(fu.inUse=!1,au=0;au<fu.markedForRemoval.length;au++)this.removeBehavior(fu.markedForRemoval[au]);fu.markedForRemoval.length=0}}}}function Os(iu,eu){var tu,su,au={},uu=eu||[];for(su in uu.length=0,iu){var du=iu[su];if(du!==void 0){var fu=du.before?du.before.slice(0):[],gu=du.after?du.after.slice(0):[];au[su]={before:fu,after:gu,visited:!1,done:!1}}}for(su in au)for(tu=0;tu<au[su].before.length;tu++){var yu=au[su].before[tu];yu in au?au[yu].after.push(su):ks("Invalid ordering constraint, no component named `"+yu+"` referenced by `"+su+"`")}function xu(vu){if(vu in au&&!au[vu].done)if(au[vu].visited)ks("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");else{au[vu].visited=!0;for(var Su=0;Su<au[vu].after.length;Su++){var Iu=au[vu].after[Su];Iu in au||ks("Invalid before/after constraint, no component named `"+Iu+"` referenced in `"+vu+"`"),xu(Iu)}au[vu].done=!0,uu.push(vu)}}for(su in au)au[su].done||xu(su);return uu}function Ps(iu,eu){var tu,su=window.devicePixelRatio;return!eu||eu.width===-1&&eu.height===-1||iu.width*su<eu.width&&iu.height*su<eu.height||(tu=iu.width/iu.height,iu.width*su>eu.width&&eu.width!==-1&&(iu.width=Math.round(eu.width/su),iu.height=Math.round(eu.width/tu/su)),iu.height*su>eu.height&&eu.height!==-1&&(iu.height=Math.round(eu.height/su),iu.width=Math.round(eu.height*tu/su))),iu}function Gs(iu,eu,tu,su){return iu.parentElement?eu?Ps({height:iu.parentElement.offsetHeight,width:iu.parentElement.offsetWidth},tu):function(au,uu){var du;return du={height:document.body.offsetHeight,width:document.body.offsetWidth},uu?du:Ps(du,au)}(tu,su):{height:0,width:0}}customElements.define("a-scene",Us);var Ns=jo,js={},_s=[],Hs=function(){};function qs(iu,eu){var tu,su={};if(Object.keys(eu).forEach(function(au){su[au]={value:eu[au],writable:!0}}),js[iu])throw new Error("The geometry `"+iu+"` has been already registered");return((tu=function(){Hs.call(this)}).prototype=Object.create(Hs.prototype,su)).name=iu,tu.prototype.constructor=tu,js[iu]={Geometry:tu,schema:Ns(tu.prototype.schema)},_s.push(iu),tu}Hs.prototype={schema:{},init:function(iu){return this.geometry=new Re.BufferGeometry,this.geometry},update:function(iu){}};var Vs=fi,zs=Ar,Ys=Vs("extras:primitives:debug"),Ks=Vs("extras:primitives:warn"),Ws=Vs("extras:primitives:error"),Js={};function Xs(iu,eu){if(iu=iu.toLowerCase(),!vs[iu]){vs[iu]=!0,Ys("Registering <%s>",iu),eu.defaultAttributes&&Ks("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");var tu=eu.mappings||{},su=class extends Ls{constructor(){super(),this.defaultComponentsFromPrimitive=eu.defaultComponents||eu.defaultAttributes||{},this.deprecated=eu.deprecated||null,this.deprecatedMappings=eu.deprecatedMappings||{},this.mappings=tu,eu.deprecated&&console.warn(eu.deprecated),this.resolveMappingCollisions()}resolveMappingCollisions(){var au=this.mappings,uu=this;Object.keys(au).forEach(function(du){var fu;du!==du.toLowerCase()&&Ks("Mapping keys should be specified in lower case. The mapping key "+du+" may not be recognized"),Ko[du]&&(fu=au[du].replace(".","-"),au[fu]=au[du],delete au[du],console.warn("The primitive "+uu.tagName.toLowerCase()+" has a mapping collision. The attribute "+du+" has the same name as a registered component and has been renamed to "+fu))})}getExtraComponents(){var au,uu,du,fu,gu,yu=this;for(uu=Zr(this.defaultComponentsFromPrimitive),(gu=this.getAttribute("mixin"))&&(gu=or(gu.trim(),/\s+/)).forEach(function(Iu){var Mu,ku,Bu=document.getElementById(Iu);if(Bu){var _u=Bu.rawAttributeCache,Lu=Bu.componentCache;for(var Du in _u){if(fu=yu.mappings[Du])return void Zs(fu,_u[Du],uu);Du in Lu&&(uu[Du]=(Mu=uu[Du],ku=Lu[Du],xu(Mu)?vu(ku):xu(ku)?vu(Mu):Su(Mu)&&Su(ku)?Xr(Mu,ku):vu(ku)))}}}),du=0;du<this.attributes.length;du++)au=this.attributes[du],(fu=this.mappings[au.name])&&Zs(fu,au.value,uu);return uu;function xu(Iu){return Iu===void 0}function vu(Iu){return Su(Iu)?Xr({},Iu):Iu}function Su(Iu){return Iu!==null&&Iu.constructor===Object}}attributeChangedCallback(au,uu,du){var fu=this.mappings[au];au in this.deprecatedMappings&&console.warn(this.deprecatedMappings[au]),au&&fu?zs(this,fu,du):super.attributeChangedCallback(au,uu,du)}};return customElements.define(iu,su),su.mappings=tu,Js[iu]=su,su}Ws("Trying to register primitive "+iu+" that has been already previously registered")}function Zs(iu,eu,tu){var su=sr(iu);su.constructor===Array?(tu[su[0]]=tu[su[0]]||{},tu[su[0]][su[1]]=eu.trim()):tu[su]=eu.trim()}var $s={},ea=[],ta={array:"v3",color:"v3",int:"i",number:"f",map:"t",time:"f",vec2:"v2",vec3:"v3",vec4:"v4"},na=function(){};function ia(iu,eu){var tu,su={};if(Object.keys(eu).forEach(function(au){su[au]={value:eu[au],writable:!0}}),$s[iu])throw new Error("The shader "+iu+" has already been registered");return((tu=function(){na.call(this)}).prototype=Object.create(na.prototype,su)).name=iu,tu.prototype.constructor=tu,$s[iu]={Shader:tu,schema:jo(tu.prototype.schema)},ea.push(iu),tu}na.prototype={schema:{},vertexShader:"void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",fragmentShader:"void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",init:function(iu){return this.uniforms=this.initUniforms(),this.material=new(this.raw?Re.RawShaderMaterial:Re.ShaderMaterial)({uniforms:this.uniforms,glslVersion:this.raw||this.glsl3?Re.GLSL3:null,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader}),this.material},initUniforms:function(){var iu,eu,tu=this.schema,su={};for(iu in tu)tu[iu].is==="uniform"&&(eu=ta[tu[iu].type],su[iu]={type:eu,value:void 0});return su},update:function(iu){var eu,tu,su=this.schema,au=this.uniforms;for(eu in iu)if(su[eu]&&su[eu].is==="uniform")if(su[eu].type!=="map")au[eu].value=this.parseValue(su[eu].type,iu[eu]),au[eu].needsUpdate=!0;else{if(!au[eu]||au[eu].value===iu[eu])continue;tu="_texture_"+eu,this.setMapOnTextureLoad(au,eu,tu),Cr(tu,eu,this,iu)}},parseValue:function(iu,eu){var tu;switch(iu){case"vec2":return new Re.Vector2(eu.x,eu.y);case"vec3":return new Re.Vector3(eu.x,eu.y,eu.z);case"vec4":return new Re.Vector4(eu.x,eu.y,eu.z,eu.w);case"color":return tu=new Re.Color(eu),new Re.Vector3(tu.r,tu.g,tu.b);default:return eu}},setMapOnTextureLoad:function(iu,eu,tu){var su=this;this.el.addEventListener("materialtextureloaded",function(){iu[eu].value=su.material[tu],iu[eu].needsUpdate=!0})}};var ra=new Re.FileLoader,oa=fi("core:a-assets:warn");function sa(iu){if(iu.hasAttribute("autoplay")||iu.getAttribute("preload")==="auto")return new Promise(function(eu,tu){if(iu.readyState===4)return eu();if(iu.error)return tu();function su(){for(var au=0,uu=0;uu<iu.buffered.length;uu++)au+=iu.buffered.end(uu)-iu.buffered.start(uu);au>=iu.duration&&(iu.tagName==="VIDEO"&&Re.Cache.add(iu.getAttribute("src"),iu),eu())}iu.addEventListener("loadeddata",su,!1),iu.addEventListener("progress",su,!1),iu.addEventListener("error",tu,!1)})}function aa(iu){var eu=function(tu){var su,au,uu;return tu.hasAttribute("crossorigin")||(su=tu.getAttribute("src"))!==null&&(su.indexOf("://")===-1||(uu=(au=su).indexOf("://")>-1?au.split("/")[2]:au.split("/")[0]).substring(0,uu.indexOf(":"))===window.location.host)?tu:(oa('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)',su),tu.crossOrigin="anonymous",tu.cloneNode(!0))}(iu);return eu.tagName&&eu.tagName.toLowerCase()==="video"&&(eu.setAttribute("playsinline",""),eu.setAttribute("webkit-playsinline","")),eu!==iu&&(iu.parentNode.appendChild(eu),iu.parentNode.removeChild(iu)),eu}customElements.define("a-assets",class extends bs{constructor(){super(),this.isAssets=!0,this.fileLoader=ra,this.timeout=null}doConnectedCallback(){var iu,eu,tu,su,au,uu,du=this,fu=[];if(super.doConnectedCallback(),!this.parentNode.isScene)throw new Error("<a-assets> must be a child of a <a-scene>.");for(au=this.querySelectorAll("img"),iu=0;iu<au.length;iu++)su=aa(au[iu]),fu.push(new Promise(function(gu,yu){Re.Cache.add(au[iu].getAttribute("src"),su),su.complete?gu():(su.onload=gu,su.onerror=yu)}));for(tu=this.querySelectorAll("audio, video"),iu=0;iu<tu.length;iu++)(eu=aa(tu[iu])).src||eu.srcObject||oa("Audio/video asset has neither `src` nor `srcObject` attributes."),fu.push(sa(eu));this.getChildren().forEach(function(gu){gu.isAssetItem&&gu.hasAttribute("src")&&fu.push(new Promise(function(yu,xu){if(gu.hasLoaded)return yu();gu.addEventListener("loaded",yu),gu.addEventListener("error",xu)}))}),Promise.allSettled(fu).then(function(){du.timeout!==null&&du.load()}),uu=parseInt(this.getAttribute("timeout"),10)||3e3,this.timeout=setTimeout(function(){du.hasLoaded||(oa("Asset loading timed out in",uu,"ms"),du.timeout=null,du.emit("timeout"),du.load())},uu)}disconnectedCallback(){super.disconnectedCallback(),this.timeout&&clearTimeout(this.timeout)}load(){super.load.call(this,null,function(){return!1})}}),customElements.define("a-asset-item",class extends bs{constructor(){super(),this.data=null,this.isAssetItem=!0}connectedCallback(){var iu=this,eu=this.getAttribute("src");ra.setResponseType(this.getAttribute("response-type")||function(tu){var su=function(uu){var du=document.createElement("a");du.href=uu;var fu=du.search.replace(/^\?/,""),gu=uu.replace(fu,"").replace("?","");return gu.substring(gu.lastIndexOf("/")+1)}(tu),au=su.lastIndexOf(".");return au>=0&&su.slice(au,tu.search(/\?|#|$/))===".glb"?"arraybuffer":"text"}(eu)),ra.load(eu,function(tu){iu.data=tu,bs.prototype.load.call(iu)},function(tu){iu.emit("progress",{loadedBytes:tu.loaded,totalBytes:tu.total,xhr:tu})},function(tu){iu.emit("error",{xhr:tu},!1)})}});var Aa=fi("core:cubemap:warn");class la extends HTMLElement{constructor(eu){return super(eu)}onReadyStateChange(){document.readyState==="complete"&&this.doConnectedCallback()}connectedCallback(){document.readyState==="complete"?la.prototype.doConnectedCallback.call(this):document.addEventListener("readystatechange",this.onReadyStateChange.bind(this))}doConnectedCallback(){this.srcs=this.validate()}validate(){var eu,tu=this.querySelectorAll("[src]"),su=[];if(tu.length===6){for(eu=0;eu<tu.length;eu++)tu[eu].tagName==="IMG"?su.push(tu[eu]):su.push(tu[eu].getAttribute("src"));return su}Aa("<a-cubemap> did not contain exactly six elements each with a `src` attribute.")}}customElements.define("a-cubemap",la),customElements.define("a-mixin",class extends bs{constructor(){super(),this.componentCache={},this.rawAttributeCache={},this.isMixin=!0}doConnectedCallback(){super.doConnectedCallback(),this.sceneEl=this.closestScene(),this.id=this.getAttribute("id"),this.cacheAttributes(),this.updateEntities(),this.load()}attributeChangedCallback(iu,eu,tu){super.attributeChangedCallback(),this.cacheAttribute(iu,tu),this.updateEntities()}setAttribute(iu,eu){window.HTMLElement.prototype.setAttribute.call(this,iu,eu),this.cacheAttribute(iu,eu)}cacheAttribute(iu,eu){var tu,su;su=or(iu,"__")[0],tu=Ko[su],eu===void 0&&(eu=window.HTMLElement.prototype.getAttribute.call(this,iu)),this.rawAttributeCache[iu]=eu,tu&&(this.componentCache[iu]=this.parseComponentAttrValue(tu,eu))}parseComponentAttrValue(iu,eu){var tu;return typeof eu!="string"?eu:(iu.isSingleProperty?typeof(tu=iu.schema.parse(eu))=="string"&&(tu=eu):tu=Lr(eu),tu)}getAttribute(iu){return this.componentCache[iu]||window.HTMLElement.prototype.getAttribute.call(this,iu)}cacheAttributes(){var iu,eu,tu=this.attributes;for(eu=0;eu<tu.length;eu++)iu=tu[eu].name,this.cacheAttribute(iu)}updateEntities(){var iu,eu,tu;if(this.sceneEl)for(eu=this.sceneEl.querySelectorAll("[mixin~="+this.id+"]"),tu=0;tu<eu.length;tu++)(iu=eu[tu]).hasLoaded&&!iu.isMixin&&iu.mixinUpdate(this.id)}});const ca="1.7.0";var ha=new Re.Color,da=new Re.Color,ua=ar,ga=Ar,pa={},fa="color",ma="rotation",Ea="components";function Ca(iu){iu.x=Re.MathUtils.degToRad(iu.x),iu.y=Re.MathUtils.degToRad(iu.y),iu.z=Re.MathUtils.degToRad(iu.z)}function va(iu,eu,tu){var su;for(su=0;su<eu.length;su++)iu.addEventListener(eu[su],tu)}function Ba(iu,eu,tu){var su;for(su=0;su<eu.length;su++)iu.removeEventListener(eu[su],tu)}function ba(iu,eu){var tu,su,au;for(su=Ia(eu),au=iu,tu=0;tu<su.length;tu++)au=au[su[tu]];if(au===void 0)throw console.log(iu),new Error("[animation] property ("+eu+") could not be found");return au}function ya(iu,eu,tu,su){var au,uu,du,fu;for(eu.startsWith("object3D.rotation")&&(tu=Re.MathUtils.degToRad(tu)),uu=Ia(eu),fu=iu,au=0;au<uu.length-1;au++)fu=fu[uu[au]];du=uu[uu.length-1],su!==fa?fu[du]=tu:"r"in fu[du]?(fu[du].r=tu.r,fu[du].g=tu.g,fu[du].b=tu.b):(fu[du].x=tu.r,fu[du].y=tu.g,fu[du].z=tu.b)}function Ia(iu){return iu in pa||(pa[iu]=iu.split(".")),pa[iu]}function wa(iu){return iu.isRawProperty||iu.property.startsWith(Ea)||iu.property.startsWith("object3D")}cs("animation",{schema:{autoplay:{default:!0},delay:{default:0},dir:{default:""},dur:{default:1e3},easing:{default:"easeInQuad"},elasticity:{default:400},enabled:{default:!0},from:{default:""},loop:{default:0,parse:function(iu){return iu===!0||iu==="true"||iu!==!1&&iu!=="false"&&parseInt(iu,10)}},property:{default:""},startEvents:{type:"array"},pauseEvents:{type:"array"},resumeEvents:{type:"array"},round:{default:!1},to:{default:""},type:{default:""},isRawProperty:{default:!1}},multiple:!0,init:function(){var iu=this;this.eventDetail={name:this.attrName},this.time=0,this.animation=null,this.animationIsPlaying=!1,this.onStartEvent=this.onStartEvent.bind(this),this.beginAnimation=this.beginAnimation.bind(this),this.pauseAnimation=this.pauseAnimation.bind(this),this.resumeAnimation=this.resumeAnimation.bind(this),this.fromColor={},this.toColor={},this.targets={},this.targetsArray=[],this.updateConfigForDefault=this.updateConfigForDefault.bind(this),this.updateConfigForRawColor=this.updateConfigForRawColor.bind(this),this.config={complete:function(){iu.animationIsPlaying=!1,iu.el.emit("animationcomplete",iu.eventDetail,!1),iu.id&&iu.el.emit("animationcomplete__"+iu.id,iu.eventDetail,!1)}}},update:function(iu){var eu=this.config,tu=this.data;this.animationIsPlaying=!1,this.data.enabled&&tu.property&&(eu.autoplay=!1,eu.direction=tu.dir,eu.duration=tu.dur,eu.easing=tu.easing,eu.elasticity=tu.elasticity,eu.loop=tu.loop,eu.round=tu.round,this.createAndStartAnimation())},tick:function(iu,eu){this.animationIsPlaying&&(this.time+=eu,this.animation.tick(this.time))},remove:function(){this.pauseAnimation(),this.removeEventListeners()},pause:function(){this.paused=!0,this.pausedWasPlaying=this.animationIsPlaying,this.pauseAnimation(),this.removeEventListeners()},play:function(){this.paused&&(this.paused=!1,this.addEventListeners(),this.pausedWasPlaying&&(this.resumeAnimation(),this.pausedWasPlaying=!1))},createAndStartAnimation:function(){var iu=this.data;this.updateConfig(),this.animationIsPlaying=!1,this.animation=Te(this.config),this.animation.began=!0,this.removeEventListeners(),this.addEventListeners(),!iu.autoplay||iu.startEvents&&iu.startEvents.length||(iu.delay?setTimeout(this.beginAnimation,iu.delay):this.beginAnimation())},beginAnimation:function(){this.updateConfig(),this.animation.began=!0,this.time=0,this.animationIsPlaying=!0,this.stopRelatedAnimations(),this.el.emit("animationbegin",this.eventDetail,!1)},pauseAnimation:function(){this.animationIsPlaying=!1},resumeAnimation:function(){this.animationIsPlaying=!0},onStartEvent:function(){this.data.enabled&&(this.updateConfig(),this.animation&&this.animation.pause(),this.animation=Te(this.config),this.data.delay?setTimeout(this.beginAnimation,this.data.delay):this.beginAnimation())},updateConfigForRawColor:function(){var iu,eu,tu,su=this.config,au=this.data,uu=this.el;if(!this.waitComponentInitRawProperty(this.updateConfigForRawColor)){for(eu in iu=au.from===""?ba(uu,au.property):au.from,tu=au.to,this.setColorConfig(iu,tu),iu=this.fromColor,tu=this.toColor,this.targetsArray.length=0,this.targetsArray.push(iu),su.targets=this.targetsArray,tu)su[eu]=tu[eu];var du;su.update=(du={},function(fu){var gu;(gu=fu.animatables[0].target).r===du.r&&gu.g===du.g&&gu.b===du.b||ya(uu,au.property,gu,au.type)})}},updateConfigForDefault:function(){var iu,eu,tu,su,au=this.config,uu=this.data,du=this.el;this.waitComponentInitRawProperty(this.updateConfigForDefault)||(iu=uu.from===""?wa(uu)?ba(du,uu.property):ua(du,uu.property):uu.from,tu=uu.to,isNaN(iu||tu)?(iu=iu&&iu.toString(),tu=tu&&tu.toString()):(iu=parseFloat(iu),tu=parseFloat(tu)),(eu=uu.to==="true"||uu.to==="false"||uu.to===!0||uu.to===!1)&&(iu=uu.from==="true"||uu.from===!0?1:0,tu=uu.to==="true"||uu.to===!0?1:0),this.targets.aframeProperty=iu,au.targets=this.targets,au.aframeProperty=tu,au.update=function(fu){var gu;(gu=fu.animatables[0].target.aframeProperty)!==su&&(su=gu,eu&&(gu=gu>=1),wa(uu)?ya(du,uu.property,gu,uu.type):ga(du,uu.property,gu))})},updateConfigForVector:function(){var iu,eu,tu,su,au=this.config,uu=this.data,du=this.el,fu=Ia(uu.property),gu=fu[0]==="object3D"?fu[1]:fu[0];for(iu in eu=uu.from!==""?Zi(uu.from):ua(du,gu),tu=Zi(uu.to),gu===ma&&(Ca(eu),Ca(tu)),this.targetsArray.length=0,this.targetsArray.push(eu),au.targets=this.targetsArray,tu)au[iu]=tu[iu];au.update=gu!=="position"&&gu!==ma&&gu!=="scale"?function(){var yu={};return function(xu){var vu=xu.animatables[0].target;vu.x===yu.x&&vu.y===yu.y&&vu.z===yu.z||(yu.x=vu.x,yu.y=vu.y,yu.z=vu.z,ga(du,uu.property,vu))}}():(su={},function(yu){var xu=yu.animatables[0].target;xu.x===su.x&&xu.y===su.y&&xu.z===su.z||(su.x=xu.x,su.y=xu.y,su.z=xu.z,du.object3D[gu].set(xu.x,xu.y,xu.z))})},updateConfig:function(){var iu;iu=function(eu,tu){var su,au,uu,du;return(uu=tu.split("."))[0]!=="object3D"||uu[2]||uu[1]!=="position"&&uu[1]!=="rotation"&&uu[1]!=="scale"?(au=uu[0],du=uu[1],(su=eu.components[au]||Ko[au])?du&&!su.schema[du]?null:du?su.schema[du].type:su.schema.type:null):"vec3"}(this.el,this.data.property),wa(this.data)&&this.data.type===fa?this.updateConfigForRawColor():iu==="vec2"||iu==="vec3"||iu==="vec4"?this.updateConfigForVector():this.updateConfigForDefault()},waitComponentInitRawProperty:function(iu){var eu,tu=this.data,su=this.el,au=this;return tu.from===""&&!!tu.property.startsWith(Ea)&&(eu=Ia(tu.property)[1],!su.components[eu]&&(su.addEventListener("componentinitialized",function uu(du){du.detail.name===eu&&(iu(),au.animation=Te(au.config),su.removeEventListener("componentinitialized",uu))}),!0))},stopRelatedAnimations:function(){var iu,eu;for(eu in this.el.components)iu=this.el.components[eu],eu!==this.attrName&&iu.name==="animation"&&iu.animationIsPlaying&&iu.data.property===this.data.property&&(iu.animationIsPlaying=!1)},addEventListeners:function(){var iu=this.data,eu=this.el;va(eu,iu.startEvents,this.onStartEvent),va(eu,iu.pauseEvents,this.pauseAnimation),va(eu,iu.resumeEvents,this.resumeAnimation)},removeEventListeners:function(){var iu=this.data,eu=this.el;Ba(eu,iu.startEvents,this.onStartEvent),Ba(eu,iu.pauseEvents,this.pauseAnimation),Ba(eu,iu.resumeEvents,this.resumeAnimation)},setColorConfig:function(iu,eu){ha.set(iu),da.set(eu),iu=this.fromColor,eu=this.toColor,iu.r=ha.r,iu.g=ha.g,iu.b=ha.b,eu.r=da.r,eu.g=da.g,eu.b=da.b}});var xa=fi("components:anchored:warn");cs("anchored",{schema:{persistent:{default:!1}},init:function(){var iu=this.el.sceneEl.getAttribute("webxr"),eu=iu.optionalFeatures;eu.indexOf("anchors")===-1&&(eu.push("anchors"),this.el.sceneEl.setAttribute("webxr",iu)),this.auxQuaternion=new Re.Quaternion,this.onEnterVR=this.onEnterVR.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR)},onEnterVR:function(){this.anchor=void 0,this.requestPersistentAnchorPending=this.data.persistent,this.requestAnchorPending=!this.data.persistent},tick:function(){var iu,eu,tu,su=this.el.sceneEl,au=su.renderer.xr,uu=this.el.object3D;(su.is("ar-mode")||su.is("vr-mode"))&&(!this.anchor&&this.requestPersistentAnchorPending&&this.restorePersistentAnchor(),!this.anchor&&this.requestAnchorPending&&this.createAnchor(),this.anchor&&(iu=su.frame,eu=au.getReferenceSpace(),tu=iu.getPose(this.anchor.anchorSpace,eu),uu.position.copy(tu.transform.position),uu.quaternion.copy(tu.transform.orientation)))},createAnchor:async function(iu,eu){var tu,su,au,uu,du=this.el.sceneEl,fu=du.renderer.xr,gu=this.el.object3D;iu=iu||gu.position,eu=eu||this.auxQuaternion.setFromEuler(gu.rotation),function(yu){var xu=yu.renderer.xr.getSession();return xu&&xu.restorePersistentAnchor}(du)?(this.anchor&&this.deleteAnchor(),tu=du.frame,su=fu.getReferenceSpace(),au=new XRRigidTransform({x:iu.x,y:iu.y,z:iu.z},{x:eu.x,y:eu.y,z:eu.z,w:eu.w}),this.requestAnchorPending=!1,uu=await tu.createAnchor(au,su),this.data.persistent&&(this.el.id?(this.persistentHandle=await uu.requestPersistentHandle(),localStorage.setItem(this.el.id,this.persistentHandle)):xa("The anchor won't be persisted because the entity has no assigned id.")),du.object3D.attach(this.el.object3D),this.anchor=uu):xa("This browser doesn't support the WebXR anchors module")},restorePersistentAnchor:async function(){var iu,eu=this.el.sceneEl.renderer.xr.getSession(),tu=eu.persistentAnchors;if(this.requestPersistentAnchorPending=!1,!this.el.id)return xa("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."),void(this.requestAnchorPending=!0);if(tu){iu=localStorage.getItem(this.el.id);for(var su=0;su<tu.length;++su)if(iu===tu[su]){this.anchor=await eu.restorePersistentAnchor(tu[su]),this.anchor&&(this.persistentHandle=tu[su]);break}this.anchor||(this.requestAnchorPending=!0)}else this.requestPersistentAnchorPending=!0},deleteAnchor:function(){var iu,eu=this.anchor;eu&&(iu=this.el.sceneEl.renderer.xr.getSession(),eu.delete(),this.el.sceneEl.object3D.add(this.el.object3D),this.persistentHandle&&iu.deletePersistentAnchor(this.persistentHandle),this.anchor=void 0)}}),cs("camera",{schema:{active:{default:!0},far:{default:1e4},fov:{default:80,min:0},near:{default:.005,min:0},spectator:{default:!1},zoom:{default:1,min:0}},init:function(){var iu,eu=this.el;iu=this.camera=new Re.PerspectiveCamera,eu.setObject3D("camera",iu)},update:function(iu){var eu=this.data,tu=this.camera;tu.aspect=eu.aspect||window.innerWidth/window.innerHeight,tu.far=eu.far,tu.fov=eu.fov,tu.near=eu.near,tu.zoom=eu.zoom,tu.updateProjectionMatrix(),this.updateActiveCamera(iu),this.updateSpectatorCamera(iu)},updateActiveCamera:function(iu){var eu=this.data,tu=this.el,su=this.system;iu&&iu.active===eu.active||eu.spectator||(eu.active&&su.activeCameraEl!==tu?su.setActiveCamera(tu):eu.active||su.activeCameraEl!==tu||su.disableActiveCamera())},updateSpectatorCamera:function(iu){var eu=this.data,tu=this.el,su=this.system;iu&&iu.spectator===eu.spectator||(eu.spectator&&su.spectatorCameraEl!==tu?su.setSpectatorCamera(tu):eu.spectator||su.spectatorCameraEl!==tu||su.disableSpectatorCamera())},remove:function(){this.el.removeObject3D("camera")}});var Qa,La,Ma,Sa,Da="click",ka="mouseup",Ta="cursor-fusing",Ra="cursor-hovering",Fa="cursor-hovered",Ua={DOWN:["mousedown","touchstart"],UP:["mouseup","touchend"]},Oa={DOWN:["selectstart"],UP:["selectend"]},Pa="a-mouse-cursor-hover",Ga=(cs("cursor",{dependencies:["raycaster"],schema:{downEvents:{default:[]},fuse:{default:Si()},fuseTimeout:{default:1500,min:0},mouseCursorStylesEnabled:{default:!0},upEvents:{default:[]},rayOrigin:{default:"entity",oneOf:["mouse","entity","xrselect"]}},after:["tracked-controls"],multiple:!0,init:function(){var iu=this;this.fuseTimeout=void 0,this.cursorDownEl=null,this.intersectedEl=null,this.canvasBounds=document.body.getBoundingClientRect(),this.isCursorDown=!1,this.activeXRInput=null,this.updateCanvasBounds=Wr(function(){iu.canvasBounds=iu.el.sceneEl.canvas.getBoundingClientRect()},500),this.eventDetail={},this.intersectedEventDetail={cursorEl:this.el},this.onCursorDown=this.onCursorDown.bind(this),this.onCursorUp=this.onCursorUp.bind(this),this.onIntersection=this.onIntersection.bind(this),this.onIntersectionCleared=this.onIntersectionCleared.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onEnterVR=this.onEnterVR.bind(this)},update:function(iu){var eu=this.data.rayOrigin;eu!==iu.rayOrigin&&(eu==="entity"&&this.resetRaycaster(),this.updateMouseEventListeners(),eu!=="xrselect"&&eu!=="entity"||this.addWebXREventListeners(),iu.rayOrigin!=="xrselect"&&iu.rayOrigin!=="entity"||this.removeWebXREventListeners())},tick:function(){var iu=this.el.sceneEl.frame,eu=this.activeXRInput;this.data.rayOrigin==="xrselect"&&iu&&eu&&this.onMouseMove({frame:iu,inputSource:eu,type:"fakeselectevent"})},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){var iu=this.el;iu.removeState(Ra),iu.removeState(Ta),clearTimeout(this.fuseTimeout),this.intersectedEl&&this.intersectedEl.removeState(Fa),this.removeEventListeners()},addEventListeners:function(){var iu,eu=this.data,tu=this.el,su=this;function au(){iu=tu.sceneEl.canvas,eu.downEvents.length||eu.upEvents.length||(Ua.DOWN.forEach(function(uu){iu.addEventListener(uu,su.onCursorDown,{passive:!1})}),Ua.UP.forEach(function(uu){iu.addEventListener(uu,su.onCursorUp,{passive:!1})}))}(iu=tu.sceneEl.canvas)?au():tu.sceneEl.addEventListener("render-target-loaded",au),eu.downEvents.forEach(function(uu){tu.addEventListener(uu,su.onCursorDown)}),eu.upEvents.forEach(function(uu){tu.addEventListener(uu,su.onCursorUp)}),tu.addEventListener("raycaster-intersection",this.onIntersection),tu.addEventListener("raycaster-closest-entity-changed",this.onIntersection),tu.addEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),tu.sceneEl.addEventListener("rendererresize",this.updateCanvasBounds),tu.sceneEl.addEventListener("enter-vr",this.onEnterVR),window.addEventListener("resize",this.updateCanvasBounds),window.addEventListener("scroll",this.updateCanvasBounds),this.updateMouseEventListeners()},removeEventListeners:function(){var iu,eu=this.data,tu=this.el,su=this;!(iu=tu.sceneEl.canvas)||eu.downEvents.length||eu.upEvents.length||(Ua.DOWN.forEach(function(au){iu.removeEventListener(au,su.onCursorDown)}),Ua.UP.forEach(function(au){iu.removeEventListener(au,su.onCursorUp)})),eu.downEvents.forEach(function(au){tu.removeEventListener(au,su.onCursorDown)}),eu.upEvents.forEach(function(au){tu.removeEventListener(au,su.onCursorUp)}),tu.removeEventListener("raycaster-intersection",this.onIntersection),tu.removeEventListener("raycaster-closest-entity-changed",this.onIntersection),tu.removeEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),iu.removeEventListener("mousemove",this.onMouseMove),iu.removeEventListener("touchstart",this.onMouseMove),iu.removeEventListener("touchmove",this.onMouseMove),tu.sceneEl.removeEventListener("rendererresize",this.updateCanvasBounds),tu.sceneEl.removeEventListener("enter-vr",this.onEnterVR),window.removeEventListener("resize",this.updateCanvasBounds),window.removeEventListener("scroll",this.updateCanvasBounds),this.removeWebXREventListeners()},updateMouseEventListeners:function(){var iu,eu=this.el;(iu=eu.sceneEl.canvas).removeEventListener("mousemove",this.onMouseMove),iu.removeEventListener("touchmove",this.onMouseMove),eu.setAttribute("raycaster","useWorldCoordinates",!1),this.data.rayOrigin==="mouse"&&(iu.addEventListener("mousemove",this.onMouseMove),iu.addEventListener("touchmove",this.onMouseMove,{passive:!1}),eu.setAttribute("raycaster","useWorldCoordinates",!0),this.updateCanvasBounds())},resetRaycaster:function(){this.el.setAttribute("raycaster",{direction:new Re.Vector3().set(0,0,-1),origin:new Re.Vector3})},addWebXREventListeners:function(){var iu=this,eu=this.el.sceneEl.xrSession;eu&&(Oa.DOWN.forEach(function(tu){eu.addEventListener(tu,iu.onCursorDown)}),Oa.UP.forEach(function(tu){eu.addEventListener(tu,iu.onCursorUp)}))},removeWebXREventListeners:function(){var iu=this,eu=this.el.sceneEl.xrSession;eu&&(Oa.DOWN.forEach(function(tu){eu.removeEventListener(tu,iu.onCursorDown)}),Oa.UP.forEach(function(tu){eu.removeEventListener(tu,iu.onCursorUp)}))},onMouseMove:(Qa=new Re.Vector3,La=new Re.Vector2,Ma=new Re.Vector3,Sa={origin:Ma,direction:Qa},function(iu){var eu,tu,su,au,uu,du,fu,gu,yu,xu=this.canvasBounds,vu=this.el.sceneEl.camera;vu.parent.updateMatrixWorld(),tu=(su=iu.type==="touchmove"||iu.type==="touchstart"?iu.touches.item(0):iu).clientX-xu.left,au=su.clientY-xu.top,La.x=tu/xu.width*2-1,La.y=-au/xu.height*2+1,this.data.rayOrigin!=="xrselect"||iu.type!=="selectstart"&&iu.type!=="fakeselectevent"?iu.type==="fakeselectout"?(Qa.set(0,1,0),Ma.set(0,9999,0)):vu&&vu.isPerspectiveCamera?(Ma.setFromMatrixPosition(vu.matrixWorld),Qa.set(La.x,La.y,.5).unproject(vu).sub(Ma).normalize()):vu&&vu.isOrthographicCamera?(Ma.set(La.x,La.y,(vu.near+vu.far)/(vu.near-vu.far)).unproject(vu),Qa.set(0,0,-1).transformDirection(vu.matrixWorld)):console.error("AFRAME.Raycaster: Unsupported camera type: "+vu.type):(uu=iu.frame,du=iu.inputSource,fu=this.el.sceneEl.renderer.xr.getReferenceSpace(),(gu=uu.getPose(du.targetRaySpace,fu))&&(yu=gu.transform,Qa.set(0,0,-1),Qa.applyQuaternion(yu.orientation),Ma.copy(yu.position),(eu=vu.el.object3D.parent).localToWorld(Ma),Qa.transformDirection(eu.matrixWorld))),this.el.setAttribute("raycaster",Sa),iu.type==="touchmove"&&iu.preventDefault()}),onCursorDown:function(iu){this.isCursorDown=!0,this.data.rayOrigin==="mouse"&&iu.type==="touchstart"&&(this.onMouseMove(iu),this.el.components.raycaster.checkIntersections(),iu.preventDefault()),this.data.rayOrigin==="xrselect"&&iu.type==="selectstart"&&(this.activeXRInput=iu.inputSource,this.onMouseMove(iu),this.el.components.raycaster.checkIntersections(),this.el.components.raycaster.intersectedEls.length&&this.el.sceneEl.components["ar-hit-test"]!==void 0&&this.el.sceneEl.getAttribute("ar-hit-test").enabled&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!1),this.reenableARHitTest=!0)),this.twoWayEmit("mousedown",iu),this.cursorDownEl=this.intersectedEl},onCursorUp:function(iu){if(this.isCursorDown&&(this.data.rayOrigin!=="xrselect"||this.activeXRInput===iu.inputSource)){this.isCursorDown=!1;var eu=this.data;this.twoWayEmit(ka,iu),this.reenableARHitTest===!0&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!0),this.reenableARHitTest=void 0),this.cursorDownEl&&this.cursorDownEl!==this.intersectedEl&&(this.intersectedEventDetail.intersection=null,this.cursorDownEl.emit(ka,this.intersectedEventDetail)),eu.fuse&&eu.rayOrigin!=="mouse"&&eu.rayOrigin!=="xrselect"||!this.intersectedEl||this.cursorDownEl!==this.intersectedEl||this.twoWayEmit(Da,iu),eu.rayOrigin==="xrselect"&&this.onMouseMove({type:"fakeselectout"}),this.activeXRInput=null,this.cursorDownEl=null,iu.type==="touchend"&&iu.preventDefault()}},onIntersection:function(iu){var eu,tu,su,au,uu=this.el;tu=iu.detail.els[0]===uu?1:0,au=iu.detail.intersections[tu],(su=iu.detail.els[tu])&&this.intersectedEl!==su&&(this.intersectedEl&&(eu=this.el.components.raycaster.getIntersection(this.intersectedEl))&&eu.distance<=au.distance||(this.clearCurrentIntersection(!0),this.setIntersection(su,au)))},onIntersectionCleared:function(iu){iu.detail.clearedEls.indexOf(this.intersectedEl)!==-1&&this.clearCurrentIntersection()},onEnterVR:function(){var iu=this.data.rayOrigin;this.clearCurrentIntersection(!0),iu!=="xrselect"&&iu!=="entity"||this.addWebXREventListeners()},setIntersection:function(iu,eu){var tu=this.el,su=this.data,au=this;this.intersectedEl!==iu&&(this.intersectedEl=iu,tu.addState(Ra),iu.addState(Fa),this.twoWayEmit("mouseenter"),this.data.mouseCursorStylesEnabled&&this.data.rayOrigin==="mouse"&&this.el.sceneEl.canvas.classList.add(Pa),su.fuseTimeout!==0&&su.fuse&&su.rayOrigin!=="xrselect"&&su.rayOrigin!=="mouse"&&(tu.addState(Ta),this.twoWayEmit("fusing"),this.fuseTimeout=setTimeout(function(){tu.removeState(Ta),au.twoWayEmit(Da)},su.fuseTimeout)))},clearCurrentIntersection:function(iu){var eu,tu,su=this.el;this.intersectedEl&&(this.intersectedEl.removeState(Fa),su.removeState(Ra),su.removeState(Ta),this.twoWayEmit("mouseleave"),this.data.mouseCursorStylesEnabled&&this.data.rayOrigin==="mouse"&&this.el.sceneEl.canvas.classList.remove(Pa),this.intersectedEl=null,clearTimeout(this.fuseTimeout),iu!==!0&&(tu=this.el.components.raycaster.intersections).length!==0&&(eu=tu[tu[0].object.el===su?1:0])&&this.setIntersection(eu.object.el,eu))},twoWayEmit:function(iu,eu){var tu,su=this.el,au=this.intersectedEl;function uu(du,fu){eu instanceof MouseEvent?du.mouseEvent=eu:typeof TouchEvent<"u"&&eu instanceof TouchEvent&&(du.touchEvent=eu)}tu=this.el.components.raycaster.getIntersection(au),this.eventDetail.intersectedEl=au,this.eventDetail.intersection=tu,uu(this.eventDetail),su.emit(iu,this.eventDetail),au&&(this.intersectedEventDetail.intersection=tu,uu(this.intersectedEventDetail),au.emit(iu,this.intersectedEventDetail))}}),new Re.BufferGeometry),Na=(cs("geometry",{schema:{buffer:{default:!0},primitive:{default:"box",oneOf:_s,schemaChange:!0},skipCache:{default:!1}},init:function(){this.geometry=null},update:function(iu){var eu,tu=this.data,su=this.el,au=this.system;this.geometry&&(au.unuseGeometry(iu),this.geometry=null),this.geometry=au.getOrCreateGeometry(tu),(eu=su.getObject3D("mesh"))?eu.geometry=this.geometry:((eu=new Re.Mesh).geometry=this.geometry,this.el.getAttribute("material")||(eu.material=new Re.MeshStandardMaterial({color:16777215*Math.random(),metalness:0,roughness:.5})),su.setObject3D("mesh",eu))},remove:function(){this.system.unuseGeometry(this.data),this.el.getObject3D("mesh").geometry=Ga,this.geometry=null},updateSchema:function(iu){var eu=this.oldData&&this.oldData.primitive,tu=iu.primitive,su=js[tu]&&js[tu].schema;if(!su)throw new Error("Unknown geometry schema `"+tu+"`");eu&&eu===tu||this.extendSchema(su)}}),"generic"),ja=(cs("generic-tracked-controller-controls",{schema:{hand:{default:""},defaultModel:{default:!0},defaultModelColor:{default:"gray"},disabled:{default:!1}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick"]},bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var iu=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu)},this.controllerPresent=!1,this.wasControllerConnected=!1,this.bindMethods(),this.el.addEventListener("controllerconnected",function(eu){eu.detail.name!==iu.name&&(iu.wasControllerConnected=!0,iu.removeEventListeners(),iu.removeControllersUpdateListener())})},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.data,eu=iu.hand?iu.hand:void 0;Ur(this,Na,{hand:eu,iterateControllerProfiles:!0})},play:function(){this.wasControllerConnected||(this.checkIfControllerPresent(),this.addControllersUpdateListener())},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var iu=this.el,eu=this.data;this.el.components["tracked-controls"]?this.removeEventListeners():(iu.setAttribute("tracked-controls",{hand:eu.hand,idPrefix:Na,iterateControllerProfiles:!0}),this.data.defaultModel&&this.initDefaultModel())},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.wasControllerConnected&&this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu=this.mapping.buttons[iu.detail.id];eu&&this.el.emit(eu+"changed",iu.detail.state)},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)},initDefaultModel:function(){var iu=this.modelEl=document.createElement("a-entity");iu.setAttribute("geometry",{primitive:"sphere",radius:.03}),iu.setAttribute("material",{color:this.data.color}),this.el.appendChild(iu),this.el.emit("controllermodelready",{name:"generic-tracked-controller-controls",model:this.modelEl,rayOrigin:{origin:{x:0,y:0,z:-.01},direction:{x:0,y:0,z:-1}}})}}),fi("components:gltf-model:warn"));cs("gltf-model",{schema:{type:"model"},init:function(){var iu=this,eu=this.system.getDRACOLoader(),tu=this.system.getMeshoptDecoder(),su=this.system.getKTX2Loader();this.model=null,this.loader=new Xe,eu&&this.loader.setDRACOLoader(eu),this.ready=tu?tu.then(function(au){iu.loader.setMeshoptDecoder(au)}):Promise.resolve(),su&&this.loader.setKTX2Loader(su)},update:function(){var iu=this,eu=this.el,tu=this.data;tu&&(this.remove(),this.ready.then(function(){iu.loader.load(tu,function(su){iu.model=su.scene||su.scenes[0],iu.model.animations=su.animations,eu.setObject3D("mesh",iu.model),eu.emit("model-loaded",{format:"gltf",model:iu.model})},void 0,function(su){var au=su&&su.message?su.message:"Failed to load glTF model";ja(au),eu.emit("model-error",{format:"gltf",src:tu})})}))},remove:function(){this.model&&this.el.removeObject3D("mesh")}}),cs("grabbable",{init:function(){this.el.setAttribute("obb-collider","centerModel: true")}});var _a,Ha=ci+"controllers/oculus-hands/v4/left.glb",qa=ci+"controllers/oculus-hands/v4/right.glb",Va=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];cs("hand-tracking-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},modelStyle:{default:"mesh",oneOf:["dots","mesh"]},modelColor:{default:"white"},modelOpacity:{default:1}},after:["tracked-controls"],bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this)},addEventListeners:function(){this.el.addEventListener("model-loaded",this.onModelLoaded);for(var iu=0;iu<this.jointEls.length;++iu)this.jointEls[iu].object3D.visible=!0},removeEventListeners:function(){this.el.removeEventListener("model-loaded",this.onModelLoaded);for(var iu=0;iu<this.jointEls.length;++iu)this.jointEls[iu].object3D.visible=!1},init:function(){var iu=this.el.sceneEl,eu=iu.getAttribute("webxr"),tu=eu.optionalFeatures;tu.indexOf("hand-tracking")===-1&&(tu.push("hand-tracking"),iu.setAttribute("webxr",eu)),this.wristObject3D=new Re.Object3D,this.el.sceneEl.object3D.add(this.wristObject3D),this.onModelLoaded=this.onModelLoaded.bind(this),this.onChildAttached=this.onChildAttached.bind(this),this.jointEls=[],this.controllerPresent=!1,this.isPinched=!1,this.pinchEventDetail={position:new Re.Vector3,wristRotation:new Re.Quaternion},this.indexTipPosition=new Re.Vector3,this.hasPoses=!1,this.jointPoses=new Float32Array(16*Va.length),this.jointRadii=new Float32Array(Va.length),this.bindMethods(),this.updateReferenceSpace=this.updateReferenceSpace.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.updateReferenceSpace),this.el.sceneEl.addEventListener("exit-vr",this.updateReferenceSpace),this.el.addEventListener("child-attached",this.onChildAttached),this.wristObject3D.visible=!1},onChildAttached:function(iu){this.addChildEntity(iu.detail.el)},update:function(){this.updateModelMaterial()},updateModelMaterial:function(){var iu=this.jointEls,eu=this.skinnedMesh,tu=this.data.modelOpacity!==1;eu&&(this.skinnedMesh.material.color.set(this.data.modelColor),this.skinnedMesh.material.transparent=tu,this.skinnedMesh.material.opacity=this.data.modelOpacity);for(var su=0;su<iu.length;su++)iu[su].setAttribute("material",{color:this.data.modelColor,transparent:tu,opacity:this.data.modelOpacity})},updateReferenceSpace:function(){var iu=this,eu=this.el.sceneEl.xrSession;if(this.referenceSpace=void 0,eu){var tu=iu.el.sceneEl.systems.webxr.sessionReferenceSpaceType;eu.requestReferenceSpace(tu).then(function(su){iu.referenceSpace=su}).catch(function(su){throw iu.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(tu,"tracked-controls-webxr uses reference space "+tu),su})}},checkIfControllerPresent:function(){var iu=this.data;Ur(this,"",{hand:iu.hand?iu.hand:void 0,iterateControllerProfiles:!0,handTracking:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},tick:function(){var iu=this.el.sceneEl,eu=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,tu=iu.frame,su=this.el.components["tracked-controls"],au=this.referenceSpace;eu&&tu&&au&&su&&(this.hasPoses=!1,eu.hand&&(this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),this.hasPoses=tu.fillPoses(eu.hand.values(),au,this.jointPoses)&&tu.fillJointRadii(eu.hand.values(),this.jointRadii),this.updateHandModel(),this.detectGesture(),this.updateWristObject()))},updateWristObject:(_a=new Re.Matrix4,function(){var iu=this.wristObject3D;iu&&this.hasPoses&&(_a.fromArray(this.jointPoses,0),iu.position.setFromMatrixPosition(_a),iu.quaternion.setFromRotationMatrix(_a))}),updateHandModel:function(){this.wristObject3D.visible=!0,this.el.object3D.visible=!0,this.data.modelStyle==="dots"&&this.updateHandDotsModel(),this.data.modelStyle==="mesh"&&this.updateHandMeshModel()},getBone:function(iu){for(var eu=this.bones,tu=0;tu<eu.length;tu++)if(eu[tu].name===iu)return eu[tu];return null},updateHandMeshModel:function(){var iu=new Re.Matrix4;return function(){var eu=0,tu=this.jointPoses,su=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller;if(su&&this.mesh&&(this.mesh.visible=!1,this.hasPoses))for(var au of su.hand.values()){var uu=this.getBone(au.jointName);uu!=null&&(this.mesh.visible=!0,iu.fromArray(tu,16*eu),uu.position.setFromMatrixPosition(iu),uu.quaternion.setFromRotationMatrix(iu)),eu++}}}(),updateHandDotsModel:function(){for(var iu,eu,tu=this.jointPoses,su=this.jointRadii,au=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,uu=0;uu<au.hand.size;uu++)eu=(iu=this.jointEls[uu]).object3D,iu.object3D.visible=this.hasPoses,this.hasPoses&&(eu.matrix.fromArray(tu,16*uu),eu.matrix.decompose(eu.position,eu.rotation,eu.scale),iu.setAttribute("scale",{x:su[uu],y:su[uu],z:su[uu]}))},detectGesture:function(){this.detectPinch()},detectPinch:function(){var iu=new Re.Vector3,eu=new Re.Matrix4;return function(){var tu=this.indexTipPosition,su=this.pinchEventDetail;if(this.hasPoses){iu.setFromMatrixPosition(eu.fromArray(this.jointPoses,64)),tu.setFromMatrixPosition(eu.fromArray(this.jointPoses,144)),su.wristRotation.setFromRotationMatrix(eu.fromArray(this.jointPoses,0));var au=tu.distanceTo(iu);au<.015&&this.isPinched===!1&&(this.isPinched=!0,su.position.copy(tu).add(iu).multiplyScalar(.5),this.el.emit("pinchstarted",su)),au>.02&&this.isPinched===!0&&(this.isPinched=!1,su.position.copy(tu).add(iu).multiplyScalar(.5),this.el.emit("pinchended",su)),this.isPinched&&(su.position.copy(tu).add(iu).multiplyScalar(.5),this.el.emit("pinchmoved",su))}}}(),pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{id:"",hand:eu.hand,iterateControllerProfiles:!0,handTrackingEnabled:!0}),this.mesh?this.mesh!==iu.getObject3D("mesh")&&iu.setObject3D("mesh",this.mesh):this.initDefaultModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){var iu,eu=this.el;this.checkIfControllerPresent(),iu=eu.components["tracked-controls"]&&eu.components["tracked-controls"].controller,this.mesh&&iu&&iu.hand&&iu.hand instanceof XRHand&&eu.setObject3D("mesh",this.mesh)},initDefaultModel:function(){var iu=this.data;iu.modelStyle==="dots"&&this.initDotsModel(),iu.modelStyle==="mesh"&&this.initMeshHandModel(),this.el.object3D.visible=!0,this.wristObject3D.visible=!0},initDotsModel:function(){if(this.jointEls.length===0){for(var iu=0;iu<Va.length;++iu){var eu=this.jointEl=document.createElement("a-entity");eu.setAttribute("geometry",{primitive:"sphere",radius:1}),eu.object3D.visible=!1,this.el.appendChild(eu),this.jointEls.push(eu)}this.updateModelMaterial()}},initMeshHandModel:function(){var iu=this.data.hand==="left"?Ha:qa;this.el.setAttribute("gltf-model",iu)},onModelLoaded:function(){var iu=this.mesh=this.el.getObject3D("mesh").children[0],eu=this.skinnedMesh=iu.getObjectByProperty("type","SkinnedMesh");this.skinnedMesh&&(this.bones=eu.skeleton.bones,this.el.removeObject3D("mesh"),iu.position.set(0,0,0),iu.rotation.set(0,0,0),eu.frustumCulled=!1,eu.material=new Re.MeshStandardMaterial,this.updateModelMaterial(),this.setupChildrenEntities(),this.el.setObject3D("mesh",iu),this.el.emit("controllermodelready",{name:"hand-tracking-controls",model:this.data.model,rayOrigin:new Re.Vector3(0,0,0)}))},setupChildrenEntities:function(){for(var iu=this.el.children,eu=0;eu<iu.length;++eu)iu[eu]instanceof Ls&&this.addChildEntity(iu[eu])},addChildEntity:function(iu){iu instanceof Ls&&this.wristObject3D.add(iu.object3D)}}),cs("hand-tracking-grab-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},color:{type:"color",default:"white"},hoverColor:{type:"color",default:"#538df1"},hoverEnabled:{default:!1}},init:function(){var iu,eu=this.el,tu=this.data;iu=tu.hand==="right"?"components.hand-tracking-controls.bones.3":"components.hand-tracking-controls.bones.21",eu.setAttribute("hand-tracking-controls",{hand:tu.hand}),eu.setAttribute("obb-collider",{trackedObject3D:iu,size:.04}),this.auxMatrix=new Re.Matrix4,this.onCollisionStarted=this.onCollisionStarted.bind(this),this.el.addEventListener("obbcollisionstarted",this.onCollisionStarted),this.onCollisionEnded=this.onCollisionEnded.bind(this),this.el.addEventListener("obbcollisionended",this.onCollisionEnded),this.onPinchStarted=this.onPinchStarted.bind(this),this.el.addEventListener("pinchstarted",this.onPinchStarted),this.onPinchEnded=this.onPinchEnded.bind(this),this.el.addEventListener("pinchended",this.onPinchEnded)},transferEntityOwnership:function(){for(var iu,eu=this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"),tu=0;tu<eu.length;++tu)(iu=eu[tu].components["hand-tracking-grab-controls"])!==this&&this.grabbedEl&&this.grabbedEl===iu.grabbedEl&&iu.releaseGrabbedEntity();return!1},onCollisionStarted:function(iu){var eu=iu.detail.withEl;this.collidedEl||eu.getAttribute("grabbable")&&(this.collidedEl=eu,this.grabbingObject3D=iu.detail.trackedObject3D,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.hoverColor))},onCollisionEnded:function(){this.collidedEl=void 0,this.grabbedEl||(this.grabbingObject3D=void 0,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.color))},onPinchStarted:function(iu){this.collidedEl&&(this.grabbedEl=this.collidedEl,this.transferEntityOwnership(),this.grab())},onPinchEnded:function(){this.releaseGrabbedEntity()},releaseGrabbedEntity:function(){var iu=this.grabbedEl;if(iu){var eu=iu.object3D,tu=eu.parent,su=this.originalParent;eu.applyMatrix4(tu.matrixWorld),eu.applyMatrix4(this.auxMatrix.copy(su.matrixWorld).invert()),tu.remove(eu),su.add(eu),this.el.emit("grabended",{grabbedEl:iu}),this.grabbedEl=void 0,this.originalParent=void 0}},grab:function(){var iu=this.grabbedEl,eu=iu.object3D,tu=eu.parent;this.originalParent=tu;var su=this.el.components["hand-tracking-controls"].wristObject3D;eu.applyMatrix4(tu.matrixWorld),eu.applyMatrix4(this.auxMatrix.copy(su.matrixWorld).invert()),tu.remove(eu),su.add(eu),this.el.emit("grabstarted",{grabbedEl:iu})}});var za={toonLeft:ci+"controllers/hands/leftHand.glb",toonRight:ci+"controllers/hands/rightHand.glb",lowPolyLeft:ci+"controllers/hands/leftHandLow.glb",lowPolyRight:ci+"controllers/hands/rightHandLow.glb",highPolyLeft:ci+"controllers/hands/leftHandHigh.glb",highPolyRight:ci+"controllers/hands/rightHandHigh.glb"},Ya="Point",Ka="Fist",Wa="Thumb Up",Ja={};function Xa(iu,eu){var tu;if(iu)return(tu=Ja[iu])==="grip"?tu+(eu?"close":"open"):tu==="point"?tu+(eu?"up":"down"):tu==="pointing"||tu==="pistol"?tu+(eu?"start":"end"):void 0}Ja[Ka]="grip",Ja[Wa]="pistol",Ja[Ya]="pointing",cs("hand-controls",{schema:{color:{default:"white",type:"color"},hand:{default:"left"},handModelStyle:{default:"lowPoly",oneOf:["lowPoly","highPoly","toon"]}},after:["tracked-controls"],init:function(){var iu=this,eu=this.el;this.pressedButtons={},this.touchedButtons={},this.loader=new Xe,this.loader.setCrossOrigin("anonymous"),this.onGripDown=function(){iu.handleButton("grip","down")},this.onGripUp=function(){iu.handleButton("grip","up")},this.onTrackpadDown=function(){iu.handleButton("trackpad","down")},this.onTrackpadUp=function(){iu.handleButton("trackpad","up")},this.onTrackpadTouchStart=function(){iu.handleButton("trackpad","touchstart")},this.onTrackpadTouchEnd=function(){iu.handleButton("trackpad","touchend")},this.onTriggerDown=function(){iu.handleButton("trigger","down")},this.onTriggerUp=function(){iu.handleButton("trigger","up")},this.onTriggerTouchStart=function(){iu.handleButton("trigger","touchstart")},this.onTriggerTouchEnd=function(){iu.handleButton("trigger","touchend")},this.onGripTouchStart=function(){iu.handleButton("grip","touchstart")},this.onGripTouchEnd=function(){iu.handleButton("grip","touchend")},this.onThumbstickDown=function(){iu.handleButton("thumbstick","down")},this.onThumbstickUp=function(){iu.handleButton("thumbstick","up")},this.onAorXTouchStart=function(){iu.handleButton("AorX","touchstart")},this.onAorXTouchEnd=function(){iu.handleButton("AorX","touchend")},this.onBorYTouchStart=function(){iu.handleButton("BorY","touchstart")},this.onBorYTouchEnd=function(){iu.handleButton("BorY","touchend")},this.onSurfaceTouchStart=function(){iu.handleButton("surface","touchstart")},this.onSurfaceTouchEnd=function(){iu.handleButton("surface","touchend")},this.onControllerConnected=this.onControllerConnected.bind(this),this.onControllerDisconnected=this.onControllerDisconnected.bind(this),eu.addEventListener("controllerconnected",this.onControllerConnected),eu.addEventListener("controllerdisconnected",this.onControllerDisconnected),eu.object3D.visible=!1},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},tick:function(iu,eu){var tu=this.el.getObject3D("mesh");tu&&tu.mixer&&tu.mixer.update(eu/1e3)},onControllerConnected:function(iu){var eu=this.el,tu=this.data.hand,su=this.el.getObject3D("mesh");eu.object3D.visible=!0;var au=tu==="left"?Math.PI/2:-Math.PI/2,uu=eu.sceneEl.hasWebXR?-Math.PI/2:0;iu.detail.name==="pico-controls"&&(uu+=Math.PI/4),su.position.set(0,0,0),su.rotation.set(uu,0,au)},onControllerDisconnected:function(){this.el.object3D.visible=!1},addEventListeners:function(){var iu=this.el;iu.addEventListener("gripdown",this.onGripDown),iu.addEventListener("gripup",this.onGripUp),iu.addEventListener("trackpaddown",this.onTrackpadDown),iu.addEventListener("trackpadup",this.onTrackpadUp),iu.addEventListener("trackpadtouchstart",this.onTrackpadTouchStart),iu.addEventListener("trackpadtouchend",this.onTrackpadTouchEnd),iu.addEventListener("triggerdown",this.onTriggerDown),iu.addEventListener("triggerup",this.onTriggerUp),iu.addEventListener("triggertouchstart",this.onTriggerTouchStart),iu.addEventListener("triggertouchend",this.onTriggerTouchEnd),iu.addEventListener("griptouchstart",this.onGripTouchStart),iu.addEventListener("griptouchend",this.onGripTouchEnd),iu.addEventListener("thumbstickdown",this.onThumbstickDown),iu.addEventListener("thumbstickup",this.onThumbstickUp),iu.addEventListener("abuttontouchstart",this.onAorXTouchStart),iu.addEventListener("abuttontouchend",this.onAorXTouchEnd),iu.addEventListener("bbuttontouchstart",this.onBorYTouchStart),iu.addEventListener("bbuttontouchend",this.onBorYTouchEnd),iu.addEventListener("xbuttontouchstart",this.onAorXTouchStart),iu.addEventListener("xbuttontouchend",this.onAorXTouchEnd),iu.addEventListener("ybuttontouchstart",this.onBorYTouchStart),iu.addEventListener("ybuttontouchend",this.onBorYTouchEnd),iu.addEventListener("surfacetouchstart",this.onSurfaceTouchStart),iu.addEventListener("surfacetouchend",this.onSurfaceTouchEnd)},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("gripdown",this.onGripDown),iu.removeEventListener("gripup",this.onGripUp),iu.removeEventListener("trackpaddown",this.onTrackpadDown),iu.removeEventListener("trackpadup",this.onTrackpadUp),iu.removeEventListener("trackpadtouchstart",this.onTrackpadTouchStart),iu.removeEventListener("trackpadtouchend",this.onTrackpadTouchEnd),iu.removeEventListener("triggerdown",this.onTriggerDown),iu.removeEventListener("triggerup",this.onTriggerUp),iu.removeEventListener("triggertouchstart",this.onTriggerTouchStart),iu.removeEventListener("triggertouchend",this.onTriggerTouchEnd),iu.removeEventListener("griptouchstart",this.onGripTouchStart),iu.removeEventListener("griptouchend",this.onGripTouchEnd),iu.removeEventListener("thumbstickdown",this.onThumbstickDown),iu.removeEventListener("thumbstickup",this.onThumbstickUp),iu.removeEventListener("abuttontouchstart",this.onAorXTouchStart),iu.removeEventListener("abuttontouchend",this.onAorXTouchEnd),iu.removeEventListener("bbuttontouchstart",this.onBorYTouchStart),iu.removeEventListener("bbuttontouchend",this.onBorYTouchEnd),iu.removeEventListener("xbuttontouchstart",this.onAorXTouchStart),iu.removeEventListener("xbuttontouchend",this.onAorXTouchEnd),iu.removeEventListener("ybuttontouchstart",this.onBorYTouchStart),iu.removeEventListener("ybuttontouchend",this.onBorYTouchEnd),iu.removeEventListener("surfacetouchstart",this.onSurfaceTouchStart),iu.removeEventListener("surfacetouchend",this.onSurfaceTouchEnd)},update:function(iu){var eu,tu=this.el,su=this.data.hand,au=this.data.handModelStyle,uu=this.data.color,du=this;if(eu={hand:su,model:!1},su!==iu){var fu=za[au+su.charAt(0).toUpperCase()+su.slice(1)];this.loader.load(fu,function(gu){var yu=gu.scene.children[0];yu.mixer=new Re.AnimationMixer(yu),du.clips=gu.animations,tu.setObject3D("mesh",yu),yu.traverse(function(xu){xu.isMesh&&(xu.material.color=new Re.Color(uu))}),tu.setAttribute("magicleap-controls",eu),tu.setAttribute("vive-controls",eu),tu.setAttribute("meta-touch-controls",eu),tu.setAttribute("pico-controls",eu),tu.setAttribute("windows-motion-controls",eu),tu.setAttribute("hp-mixed-reality-controls",eu)})}},remove:function(){this.el.removeObject3D("mesh")},handleButton:function(iu,eu){var tu,su=eu==="down",au=eu==="touchstart";if(eu.indexOf("touch")===0){if(au===this.touchedButtons[iu])return;this.touchedButtons[iu]=au}else{if(su===this.pressedButtons[iu])return;this.pressedButtons[iu]=su}tu=this.gesture,this.gesture=this.determineGesture(),this.gesture!==tu&&(this.animateGesture(this.gesture,tu),this.emitGestureEvents(this.gesture,tu))},determineGesture:function(){var iu,eu,tu,su=this.pressedButtons.grip,au=this.pressedButtons.surface||this.touchedButtons.surface,uu=this.pressedButtons.trackpad||this.touchedButtons.trackpad,du=this.pressedButtons.trigger||this.touchedButtons.trigger,fu=this.touchedButtons.AorX||this.touchedButtons.BorY;return eu=this.el.components["tracked-controls"],(tu=eu&&eu.controller)&&(tu.id&&tu.id.indexOf("OpenVR ")===0||tu.profiles&&tu.profiles[0]&&tu.profiles[0]==="htc-vive")?su||du?iu=Ka:uu&&(iu=Ya):su?iu=au||fu||uu?du?Ka:Ya:du?Wa:"Point + Thumb":du&&(iu="Hold"),iu},getClip:function(iu){var eu,tu;for(tu=0;tu<this.clips.length;tu++)if((eu=this.clips[tu]).name===iu)return eu},animateGesture:function(iu,eu){iu?this.playAnimation(iu||"Open",eu,!1):this.playAnimation(eu,eu,!0)},emitGestureEvents:function(iu,eu){var tu,su=this.el;eu!==iu&&((tu=Xa(eu,!1))&&su.emit(tu),(tu=Xa(iu,!0))&&su.emit(tu))},playAnimation:function(iu,eu,tu){var su,au,uu=this.el.getObject3D("mesh");if(uu){if(su=this.getClip(iu),au=uu.mixer.clipAction(su),tu)return au.paused=!1,void(au.timeScale=-1);if(au.clampWhenFinished=!0,au.loop=Re.LoopOnce,au.repetitions=0,au.timeScale=1,au.time=0,au.weight=1,!eu)return uu.mixer.stopAllAction(),void au.play();su=this.getClip(eu),au.reset(),au.play(),uu.mixer.clipAction(su).crossFadeTo(au,.15,!0)}}}),cs("hide-on-enter-ar",{init:function(){var iu=this;this.el.sceneEl.addEventListener("enter-vr",function(){iu.el.sceneEl.is("ar-mode")&&(iu.el.object3D.visible=!1)}),this.el.sceneEl.addEventListener("exit-vr",function(){iu.el.object3D.visible=!0})}}),cs("hide-on-enter-vr",{init:function(){var iu=this;this.el.sceneEl.addEventListener("enter-vr",function(){iu.el.sceneEl.is("vr-mode")&&(iu.el.object3D.visible=!1)}),this.el.sceneEl.addEventListener("exit-vr",function(){iu.el.object3D.visible=!0})}});var Za="hp-mixed-reality",$a=ci+"controllers/hp/mixed-reality/",eA={x:0,y:0,z:.06},tA={_x:Math.PI/4,_y:0,_z:0,_order:"XYZ"},nA=(cs("hp-mixed-reality-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{left:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var iu=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu,iu.data.hand)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu,iu.data.hand)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu,iu.data.hand)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu,iu.data.hand)},this.previousButtonValues={},this.bindMethods()},update:function(){var iu=this.data;this.controllerIndex=iu.hand==="right"?0:iu.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),iu.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),iu.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.data;Ur(this,Za,{index:this.controllerIndex,hand:iu.hand})},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{idPrefix:Za,hand:eu.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",$a+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu,tu=this.mapping[this.data.hand].buttons[iu.detail.id];tu&&(tu==="trigger"&&(eu=iu.detail.state.value,console.log("analog value of trigger press: "+eu)),this.el.emit(tu+"changed",iu.detail.state))},onModelLoaded:function(iu){var eu=iu.detail.model;this.data.model&&(eu.position.copy(eA),eu.rotation.copy(tA),this.el.emit("controllermodelready",{name:"hp-mixed-reality-controls",model:this.data.model,rayOrigin:new Re.Vector3(0,0,0)}))},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)}}),fi("components:layer:warn"));function iA(iu,eu,tu){return(eu.dot(iu)-eu.dot(tu))/eu.length()}cs("layer",{schema:{type:{default:"quad",oneOf:["quad","monocubemap","stereocubemap"]},src:{type:"map"},rotateCubemap:{default:!1},width:{default:0},height:{default:0}},init:function(){var iu=this.el.sceneEl.renderer.getContext();this.quaternion=new Re.Quaternion,this.position=new Re.Vector3,this.bindMethods(),this.needsRedraw=!1,this.frameBuffer=iu.createFramebuffer();var eu=this.el.sceneEl.getAttribute("webxr"),tu=eu.requiredFeatures;tu.indexOf("layers")===-1&&(tu.push("layers"),this.el.sceneEl.setAttribute("webxr",eu)),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR),this.el.sceneEl.addEventListener("exit-vr",this.onExitVR)},bindMethods:function(){this.onRequestedReferenceSpace=this.onRequestedReferenceSpace.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this)},update:function(iu){this.data.src!==iu.src&&this.updateSrc()},updateSrc:function(){var iu=this.data.type;this.texture=void 0,iu!=="quad"?iu!=="monocubemap"&&iu!=="stereocubemap"||this.loadCubeMapImages():this.loadQuadImage()},loadCubeMapImages:function(){var iu,eu=this.xrGLFactory,tu=this.el.sceneEl.frame,su=this.data.src,au=this.data.type;this.visibilityChanged=!1,this.layer&&(au!=="monocubemap"&&au!=="stereocubemap"||(su.complete?this.pendingCubeMapUpdate=!1:this.pendingCubeMapUpdate=!0,this.loadingScreen?this.loadingScreen=!1:this.loadingScreen=!0,au==="monocubemap"?(iu=eu.getSubImage(this.layer,tu),this.loadCubeMapImage(iu.colorTexture,su,0)):(iu=eu.getSubImage(this.layer,tu,"left"),this.loadCubeMapImage(iu.colorTexture,su,0),iu=eu.getSubImage(this.layer,tu,"right"),this.loadCubeMapImage(iu.colorTexture,su,6))))},loadQuadImage:function(){var iu=this.data.src,eu=this;this.el.sceneEl.systems.material.loadTexture(iu,{src:iu},function(tu){eu.el.sceneEl.renderer.initTexture(tu),eu.texture=tu,iu.tagName==="VIDEO"&&setTimeout(function(){eu.textureIsVideo=!0},1e3),eu.layer&&(eu.layer.height=eu.data.height/2||eu.texture.image.height/1e3,eu.layer.width=eu.data.width/2||eu.texture.image.width/1e3,eu.needsRedraw=!0),eu.updateQuadPanel()})},preGenerateCubeMapTextures:function(iu,eu){this.data.type==="monocubemap"?this.generateCubeMapTextures(iu,0,eu):(this.generateCubeMapTextures(iu,0,eu),this.generateCubeMapTextures(iu,6,eu))},generateCubeMapTextures:function(iu,eu,tu){for(var su,au,uu=this.data,du=this.cubeFaceSize,fu=Math.min(iu.width,iu.height),gu=[],yu=0;yu<6;yu++){var xu=document.createElement("CANVAS");xu.width=xu.height=du;var vu=xu.getContext("2d");uu.rotateCubemap&&(yu!==2&&yu!==3||(vu.save(),vu.translate(du,du),vu.rotate(Math.PI))),vu.drawImage(iu,(yu+eu)*fu,0,fu,fu,0,0,du,du),vu.restore(),tu&&tu(),gu.push(xu)}return uu.rotateCubemap&&(su=gu[0],au=gu[1],gu[0]=au,gu[1]=su,su=gu[4],au=gu[5],gu[4]=au,gu[5]=su),tu&&tu(),gu},loadCubeMapImage:function(iu,eu,tu){var su,au=this.el.sceneEl.renderer.getContext();au.pixelStorei(au.UNPACK_FLIP_Y_WEBGL,!1),au.bindTexture(au.TEXTURE_CUBE_MAP,iu),su=!eu.complete||this.loadingScreen?this.loadingScreenImages:this.generateCubeMapTextures(eu,tu);var uu=0;su.forEach(function(du,fu){au.texSubImage2D(au.TEXTURE_CUBE_MAP_POSITIVE_X+fu,0,0,0,au.RGBA,au.UNSIGNED_BYTE,du),uu=au.getError()}),uu!==0&&console.log("renderingError, WebGL Error Code: "+uu),au.bindTexture(au.TEXTURE_CUBE_MAP,null)},tick:function(){this.el.sceneEl.xrSession&&this.referenceSpace&&(this.layer||!this.el.sceneEl.is("vr-mode")&&!this.el.sceneEl.is("ar-mode")||this.initLayer(),this.updateTransform(),this.data.src.complete&&(this.pendingCubeMapUpdate||this.loadingScreen||this.visibilityChanged)&&this.loadCubeMapImages(),(this.needsRedraw||this.layer.needsRedraw||this.textureIsVideo)&&(this.data.type==="quad"&&this.draw(),this.needsRedraw=!1))},initLayer:function(){var iu=this,eu=this.data.type;this.el.sceneEl.xrSession.onvisibilitychange=function(tu){iu.visibilityChanged=tu.session.visibilityState!=="hidden"},eu!=="quad"?eu!=="monocubemap"&&eu!=="stereocubemap"||this.initCubeMapLayer():this.initQuadLayer()},initQuadLayer:function(){var iu=this.el.sceneEl,eu=iu.renderer.getContext(),tu=this.xrGLFactory=new XRWebGLBinding(iu.xrSession,eu);this.texture&&(this.layer=tu.createQuadLayer({space:this.referenceSpace,viewPixelHeight:2048,viewPixelWidth:2048,height:this.data.height/2||this.texture.image.height/1e3,width:this.data.width/2||this.texture.image.width/1e3}),this.initLoadingScreenImages(),iu.renderer.xr.addLayer(this.layer))},initCubeMapLayer:function(){var iu=this.data.src,eu=this.el.sceneEl,tu=eu.renderer.getContext(),su=tu.getParameter(tu.MAX_CUBE_MAP_TEXTURE_SIZE),au=this.cubeFaceSize=Math.min(su,Math.min(iu.width,iu.height)),uu=this.xrGLFactory=new XRWebGLBinding(eu.xrSession,tu);this.layer=uu.createCubeLayer({space:this.referenceSpace,viewPixelWidth:au,viewPixelHeight:au,layout:this.data.type==="monocubemap"?"mono":"stereo",isStatic:!1}),this.initLoadingScreenImages(),this.loadCubeMapImages(),eu.renderer.xr.addLayer(this.layer)},initLoadingScreenImages:function(){for(var iu=this.cubeFaceSize,eu=this.loadingScreenImages=[],tu=0;tu<6;tu++){var su=document.createElement("CANVAS");su.width=su.height=iu;var au=su.getContext("2d");su.width=su.height=iu,au.fillStyle="black",au.fillRect(0,0,iu,iu),tu!==2&&tu!==3&&(au.translate(iu,0),au.scale(-1,1),au.fillStyle="white",au.font="30px Arial",au.fillText("Loading",iu/2,iu/2)),eu.push(su)}},destroyLayer:function(){this.layer&&(this.el.sceneEl.renderer.xr.removeLayer(this.layer),this.layer.destroy(),this.layer=void 0)},toggleCompositorLayer:function(){this.enableCompositorLayer(!this.layerEnabled)},enableCompositorLayer:function(iu){this.layerEnabled=iu,this.quadPanelEl.object3D.visible=!this.layerEnabled},updateQuadPanel:function(){var iu=this.quadPanelEl;this.quadPanelEl||(iu=this.quadPanelEl=document.createElement("a-entity"),this.el.appendChild(iu)),iu.setAttribute("material",{shader:"flat",src:this.data.src,transparent:!0}),iu.setAttribute("geometry",{primitive:"plane",height:this.data.height||this.texture.image.height/1e3,width:this.data.width||this.texture.image.height/1e3})},draw:function(){var iu=this.el.sceneEl,eu=this.el.sceneEl.renderer.getContext(),tu=this.xrGLFactory.getSubImage(this.layer,iu.frame),su=iu.renderer.properties.get(this.texture).__webglTexture,au=eu.getParameter(eu.FRAMEBUFFER_BINDING);eu.viewport(tu.viewport.x,tu.viewport.y,tu.viewport.width,tu.viewport.height),eu.bindFramebuffer(eu.FRAMEBUFFER,this.frameBuffer),eu.framebufferTexture2D(eu.FRAMEBUFFER,eu.COLOR_ATTACHMENT0,eu.TEXTURE_2D,tu.colorTexture,0),function(uu,du,fu,gu){var yu=uu.createFramebuffer(),xu=fu.viewport.x,vu=fu.viewport.y,Su=fu.viewport.x+fu.viewport.width,Iu=fu.viewport.y+fu.viewport.height;gu.tagName==="VIDEO"&&(uu.bindTexture(uu.TEXTURE_2D,du),uu.texSubImage2D(uu.TEXTURE_2D,0,0,0,gu.width,gu.height,uu.RGB,uu.UNSIGNED_BYTE,gu)),uu.bindFramebuffer(uu.READ_FRAMEBUFFER,yu),uu.framebufferTexture2D(uu.READ_FRAMEBUFFER,uu.COLOR_ATTACHMENT0,uu.TEXTURE_2D,du,0),uu.readBuffer(uu.COLOR_ATTACHMENT0),uu.blitFramebuffer(0,0,gu.width,gu.height,xu,vu,Su,Iu,uu.COLOR_BUFFER_BIT,uu.NEAREST),uu.bindFramebuffer(uu.READ_FRAMEBUFFER,null),uu.deleteFramebuffer(yu)}(eu,su,tu,this.data.src),eu.bindFramebuffer(eu.FRAMEBUFFER,au)},updateTransform:function(){var iu=this.el,eu=this.position,tu=this.quaternion;iu.object3D.updateMatrixWorld(),eu.setFromMatrixPosition(iu.object3D.matrixWorld),tu.setFromRotationMatrix(iu.object3D.matrixWorld),this.layerEnabled||eu.set(0,0,1e8),this.layer.transform=new XRRigidTransform(eu,tu)},onEnterVR:function(){var iu=this.el.sceneEl,eu=iu.xrSession;iu.hasWebXR&&XRWebGLBinding&&eu?(eu.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace),this.layerEnabled=!0,this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!1),this.data.src.play&&this.data.src.play()):nA("The layer component requires WebXR and the layers API enabled")},onExitVR:function(){this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!0),this.destroyLayer()},onRequestedReferenceSpace:function(iu){this.referenceSpace=iu}}),cs("laser-controls",{schema:{hand:{default:"right"},model:{default:!0},defaultModelColor:{type:"color",default:"grey"}},init:function(){var iu=this.config,eu=this.data,tu=this.el,su=this,au={hand:eu.hand,model:eu.model};function uu(du){var fu=iu[du.detail.name];if(fu){var gu=Jr({showLine:!0},fu.raycaster||{});du.detail.rayOrigin&&(gu.origin=du.detail.rayOrigin.origin,gu.direction=du.detail.rayOrigin.direction,gu.showLine=!0),du.detail.rayOrigin||!su.modelReady?tu.setAttribute("raycaster",gu):tu.setAttribute("raycaster","showLine",!0),tu.setAttribute("cursor",Jr({fuse:!1},fu.cursor))}}tu.setAttribute("hp-mixed-reality-controls",au),tu.setAttribute("magicleap-controls",au),tu.setAttribute("oculus-go-controls",au),tu.setAttribute("meta-touch-controls",au),tu.setAttribute("pico-controls",au),tu.setAttribute("valve-index-controls",au),tu.setAttribute("vive-controls",au),tu.setAttribute("vive-focus-controls",au),tu.setAttribute("windows-motion-controls",au),tu.setAttribute("generic-tracked-controller-controls",{hand:au.hand}),tu.addEventListener("controllerconnected",uu),tu.addEventListener("controllerdisconnected",function(du){iu[du.detail.name]&&tu.setAttribute("raycaster","showLine",!1)}),tu.addEventListener("controllermodelready",function(du){uu(du),su.modelReady=!0})},config:{"generic-tracked-controller-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"hp-mixed-reality-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"magicleap-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"oculus-go-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:5e-4,z:0}}},"meta-touch-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"pico-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"valve-index-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-focus-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"windows-motion-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{showLine:!1}}}});var rA,oA,sA,aA,AA,lA,cA,hA,dA,uA,gA=Re.MathUtils.degToRad,pA=fi("components:light:warn"),fA=new Re.CubeTextureLoader,mA={};function EA(iu,eu){return!(!iu||!eu)&&iu.x===eu.x&&iu.y===eu.y&&iu.z===eu.z}cs("light",{schema:{angle:{default:60,if:{type:["spot"]}},color:{type:"color",if:{type:["ambient","directional","hemisphere","point","spot"]}},envMap:{default:"",if:{type:["probe"]}},groundColor:{type:"color",if:{type:["hemisphere"]}},decay:{default:1,if:{type:["point","spot"]}},distance:{default:0,min:0,if:{type:["point","spot"]}},intensity:{default:3.14,min:0,if:{type:["ambient","directional","hemisphere","point","spot","probe"]}},penumbra:{default:0,min:0,max:1,if:{type:["spot"]}},type:{default:"directional",oneOf:["ambient","directional","hemisphere","point","spot","probe"],schemaChange:!0},target:{type:"selector",if:{type:["spot","directional"]}},castShadow:{default:!1,if:{type:["point","spot","directional"]}},shadowBias:{default:0,if:{castShadow:!0}},shadowCameraFar:{default:500,if:{castShadow:!0}},shadowCameraFov:{default:90,if:{castShadow:!0}},shadowCameraNear:{default:.5,if:{castShadow:!0}},shadowCameraTop:{default:5,if:{castShadow:!0}},shadowCameraRight:{default:5,if:{castShadow:!0}},shadowCameraBottom:{default:-5,if:{castShadow:!0}},shadowCameraLeft:{default:-5,if:{castShadow:!0}},shadowCameraVisible:{default:!1,if:{castShadow:!0}},shadowCameraAutomatic:{default:"",if:{type:["directional"]}},shadowMapHeight:{default:512,if:{castShadow:!0}},shadowMapWidth:{default:512,if:{castShadow:!0}},shadowRadius:{default:1,if:{castShadow:!0}}},init:function(){var iu=this.el;this.light=null,this.defaultTarget=null,this.system.registerLight(iu)},update:function(iu){var eu=this.data,tu=no(eu,iu),su=this.light,au=this;if(!su||"type"in tu)this.setLight(this.data),this.updateShadow();else{var uu=!1;Object.keys(tu).forEach(function(du){var fu=eu[du];switch(du){case"color":su.color.set(fu);break;case"groundColor":su.groundColor.set(fu);break;case"angle":su.angle=gA(fu);break;case"target":fu===null?eu.type!=="spot"&&eu.type!=="directional"||(su.target=au.defaultTarget):fu.hasLoaded?au.onSetTarget(fu,su):fu.addEventListener("loaded",au.onSetTarget.bind(au,fu,su));break;case"envMap":au.updateProbeMap(eu,su);break;case"castShadow":case"shadowBias":case"shadowCameraFar":case"shadowCameraFov":case"shadowCameraNear":case"shadowCameraTop":case"shadowCameraRight":case"shadowCameraBottom":case"shadowCameraLeft":case"shadowCameraVisible":case"shadowMapHeight":case"shadowMapWidth":case"shadowRadius":uu||(au.updateShadow(),uu=!0);break;case"shadowCameraAutomatic":eu.shadowCameraAutomatic?au.shadowCameraAutomaticEls=Array.from(document.querySelectorAll(eu.shadowCameraAutomatic)):au.shadowCameraAutomaticEls=[];break;default:su[du]=fu}})}},tick:(rA=new Re.Box3,oA=new Re.Vector3,sA=new Re.Vector3,aA=new Re.Matrix4,AA=new Re.Sphere,lA=new Re.Vector3,function(){if(this.data.type==="directional"&&this.light.shadow&&this.light.shadow.camera instanceof Re.OrthographicCamera&&this.shadowCameraAutomaticEls.length){var iu=this.light.shadow.camera;iu.getWorldDirection(oA),iu.getWorldPosition(sA),aA.copy(iu.matrixWorld),aA.invert(),iu.near=1,iu.left=1e5,iu.right=-1e5,iu.top=-1e5,iu.bottom=1e5,this.shadowCameraAutomaticEls.forEach(function(eu){rA.setFromObject(eu.object3D),rA.getBoundingSphere(AA);var tu,su,au,uu,du,fu=iA(sA,oA,AA.center),gu=(tu=sA,su=oA,au=AA.center,uu=lA,du=iA(tu,su,au),uu.copy(su),uu.multiplyScalar(du),uu.add(au),uu).applyMatrix4(aA);iu.near=Math.min(-fu-AA.radius-1,iu.near),iu.left=Math.min(-AA.radius+gu.x,iu.left),iu.right=Math.max(AA.radius+gu.x,iu.right),iu.top=Math.max(AA.radius+gu.y,iu.top),iu.bottom=Math.min(-AA.radius+gu.y,iu.bottom)}),iu.updateProjectionMatrix()}}),setLight:function(iu){var eu=this.el,tu=this.getLight(iu);tu&&(this.light&&eu.removeObject3D("light"),this.light=tu,this.light.el=eu,eu.setObject3D("light",this.light),iu.type!=="spot"&&iu.type!=="directional"&&iu.type!=="hemisphere"||eu.getObject3D("light").translateY(-1),iu.type==="spot"&&(eu.setObject3D("light-target",this.defaultTarget),eu.getObject3D("light-target").position.set(0,0,-1)),iu.shadowCameraAutomatic?this.shadowCameraAutomaticEls=Array.from(document.querySelectorAll(iu.shadowCameraAutomatic)):this.shadowCameraAutomaticEls=[])},updateShadow:function(){var iu=this.el,eu=this.data,tu=this.light;tu.castShadow=eu.castShadow;var su=iu.getObject3D("cameraHelper");if(eu.shadowCameraVisible&&!su?(su=new Re.CameraHelper(tu.shadow.camera),iu.setObject3D("cameraHelper",su)):!eu.shadowCameraVisible&&su&&iu.removeObject3D("cameraHelper"),!eu.castShadow)return tu;tu.shadow.bias=eu.shadowBias,tu.shadow.radius=eu.shadowRadius,tu.shadow.mapSize.height=eu.shadowMapHeight,tu.shadow.mapSize.width=eu.shadowMapWidth,tu.shadow.camera.near=eu.shadowCameraNear,tu.shadow.camera.far=eu.shadowCameraFar,tu.shadow.camera instanceof Re.OrthographicCamera?(tu.shadow.camera.top=eu.shadowCameraTop,tu.shadow.camera.right=eu.shadowCameraRight,tu.shadow.camera.bottom=eu.shadowCameraBottom,tu.shadow.camera.left=eu.shadowCameraLeft):tu.shadow.camera.fov=eu.shadowCameraFov,tu.shadow.camera.updateProjectionMatrix(),su&&su.update()},getLight:function(iu){var eu=iu.angle,tu=new Re.Color(iu.color);tu=tu.getHex();var su=iu.decay,au=iu.distance,uu=new Re.Color(iu.groundColor);uu=uu.getHex();var du=iu.intensity,fu=iu.type,gu=iu.target,yu=null;switch(fu.toLowerCase()){case"ambient":return new Re.AmbientLight(tu,du);case"directional":return yu=new Re.DirectionalLight(tu,du),this.defaultTarget=yu.target,gu&&(gu.hasLoaded?this.onSetTarget(gu,yu):gu.addEventListener("loaded",this.onSetTarget.bind(this,gu,yu))),yu;case"hemisphere":return new Re.HemisphereLight(tu,uu,du);case"point":return new Re.PointLight(tu,du,au,su);case"spot":return yu=new Re.SpotLight(tu,du,au,gA(eu),iu.penumbra,su),this.defaultTarget=yu.target,gu&&(gu.hasLoaded?this.onSetTarget(gu,yu):gu.addEventListener("loaded",this.onSetTarget.bind(this,gu,yu))),yu;case"probe":return yu=new Re.LightProbe,this.updateProbeMap(iu,yu),yu;default:pA("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.",fu)}},updateProbeMap:function(iu,eu){iu.envMap?(mA[iu.envMap]===void 0&&(mA[iu.envMap]=new window.Promise(function(tu){ur(iu.envMap,function(su){fA.load(su,function(au){var uu=oi.fromCubeTexture(au);mA[iu.envMap]=uu,tu(uu)})})})),mA[iu.envMap]instanceof window.Promise?mA[iu.envMap].then(function(tu){eu.copy(tu)}):mA[iu.envMap]instanceof Re.LightProbe&&eu.copy(mA[iu.envMap])):eu.copy(new Re.LightProbe)},onSetTarget:function(iu,eu){eu.target=iu.object3D},remove:function(){var iu=this.el;iu.removeObject3D("light"),iu.getObject3D("cameraHelper")&&iu.removeObject3D("cameraHelper")}}),cs("line",{schema:{start:{type:"vec3",default:{x:0,y:0,z:0}},end:{type:"vec3",default:{x:0,y:0,z:0}},color:{type:"color",default:"#74BEC1"},opacity:{type:"number",default:1},visible:{default:!0}},multiple:!0,init:function(){var iu,eu,tu=this.data;eu=this.material=new Re.LineBasicMaterial({color:tu.color,opacity:tu.opacity,transparent:tu.opacity<1,visible:tu.visible}),(iu=this.geometry=new Re.BufferGeometry).setAttribute("position",new Re.BufferAttribute(new Float32Array(6),3)),this.line=new Re.Line(iu,eu),this.el.setObject3D(this.attrName,this.line)},update:function(iu){var eu=this.data,tu=this.geometry,su=!1,au=this.material,uu=tu.attributes.position.array;EA(eu.start,iu.start)||(uu[0]=eu.start.x,uu[1]=eu.start.y,uu[2]=eu.start.z,su=!0),EA(eu.end,iu.end)||(uu[3]=eu.end.x,uu[4]=eu.end.y,uu[5]=eu.end.z,su=!0),su&&(tu.attributes.position.needsUpdate=!0,tu.computeBoundingSphere()),au.color.setStyle(eu.color),au.opacity=eu.opacity,au.transparent=eu.opacity<1,au.visible=eu.visible},remove:function(){this.el.removeObject3D(this.attrName,this.line)}}),cs("link",{schema:{backgroundColor:{default:"red",type:"color"},borderColor:{default:"white",type:"color"},highlighted:{default:!1},highlightedColor:{default:"#24CAFF",type:"color"},href:{default:""},image:{type:"asset"},on:{default:"click"},peekMode:{default:!1},title:{default:""},titleColor:{default:"white",type:"color"},visualAspectEnabled:{default:!1}},init:function(){this.navigate=this.navigate.bind(this),this.previousQuaternion=void 0,this.quaternionClone=new Re.Quaternion,this.hiddenEls=[]},update:function(iu){var eu,tu,su=this.data,au=this.el;if(su.visualAspectEnabled){var uu=this.el.getAttribute("scale");this.previewDistance=15*(uu.x+uu.y)/2,this.initVisualAspect(),eu=su.highlighted?su.highlightedColor:su.backgroundColor,tu=su.highlighted?su.highlightedColor:su.borderColor,au.setAttribute("material","backgroundColor",eu),au.setAttribute("material","strokeColor",tu),su.on!==iu.on&&this.updateEventListener(),iu.peekMode!==void 0&&su.peekMode!==iu.peekMode&&this.updatePeekMode(),su.image&&iu.image!==su.image&&au.setAttribute("material","pano",typeof su.image=="string"?su.image:su.image.src)}},updatePeekMode:function(){var iu=this.el,eu=this.sphereEl;this.data.peekMode?(this.hideAll(),iu.getObject3D("mesh").visible=!1,eu.setAttribute("visible",!0)):(this.showAll(),iu.getObject3D("mesh").visible=!0,eu.setAttribute("visible",!1))},play:function(){this.updateEventListener()},pause:function(){this.removeEventListener()},updateEventListener:function(){var iu=this.el;iu.isPlaying&&(this.removeEventListener(),iu.addEventListener(this.data.on,this.navigate))},removeEventListener:function(){var iu=this.data.on;iu&&this.el.removeEventListener(iu,this.navigate)},initVisualAspect:function(){var iu,eu,tu,su=this.el;this.data.visualAspectEnabled&&!this.visualAspectInitialized&&(tu=this.textEl=this.textEl||document.createElement("a-entity"),eu=this.sphereEl=this.sphereEl||document.createElement("a-entity"),iu=this.semiSphereEl=this.semiSphereEl||document.createElement("a-entity"),su.setAttribute("geometry",{primitive:"circle",radius:1,segments:64}),su.setAttribute("material",{shader:"portal",pano:this.data.image,side:"double",previewDistance:this.previewDistance}),tu.setAttribute("text",{color:this.data.titleColor,align:"center",font:"kelsonsans",value:this.data.title||this.data.href,width:4}),tu.setAttribute("position","0 1.5 0"),su.appendChild(tu),iu.setAttribute("geometry",{primitive:"sphere",radius:1,phiStart:0,segmentsWidth:64,segmentsHeight:64,phiLength:180,thetaStart:0,thetaLength:360}),iu.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back",previewDistance:this.previewDistance}),iu.setAttribute("rotation","0 180 0"),iu.setAttribute("position","0 0 0"),iu.setAttribute("visible",!1),su.appendChild(iu),eu.setAttribute("geometry",{primitive:"sphere",radius:10,segmentsWidth:64,segmentsHeight:64}),eu.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back",previewDistance:this.previewDistance}),eu.setAttribute("visible",!1),su.appendChild(eu),this.visualAspectInitialized=!0)},navigate:function(){window.location=this.data.href},tick:function(){var iu=new Re.Vector3,eu=new Re.Vector3,tu=new Re.Quaternion,su=new Re.Vector3;return function(){var au,uu,du=this.el,fu=du.object3D,gu=du.sceneEl.camera,yu=this.textEl;if(this.data.visualAspectEnabled)if(fu.updateMatrixWorld(),gu.parent.updateMatrixWorld(),gu.updateMatrixWorld(),fu.matrix.decompose(eu,tu,su),eu.setFromMatrixPosition(fu.matrixWorld),iu.setFromMatrixPosition(gu.matrixWorld),(uu=eu.distanceTo(iu))>1.33333*this.previewDistance)this.previousQuaternion||(this.quaternionClone.copy(tu),this.previousQuaternion=this.quaternionClone),fu.lookAt(iu);else{if(au=this.calculateCameraPortalOrientation(),uu<.5){if(this.semiSphereEl.getAttribute("visible")===!0)return;yu.setAttribute("text","width",1.5),au<=0?(yu.setAttribute("position","0 0 0.75"),yu.setAttribute("rotation","0 180 0"),this.semiSphereEl.setAttribute("rotation","0 0 0")):(yu.setAttribute("position","0 0 -0.75"),yu.setAttribute("rotation","0 0 0"),this.semiSphereEl.setAttribute("rotation","0 180 0")),du.getObject3D("mesh").visible=!1,this.semiSphereEl.setAttribute("visible",!0),this.peekCameraPortalOrientation=au}else au<=0?yu.setAttribute("rotation","0 180 0"):yu.setAttribute("rotation","0 0 0"),yu.setAttribute("text","width",5),yu.setAttribute("position","0 1.5 0"),du.getObject3D("mesh").visible=!0,this.semiSphereEl.setAttribute("visible",!1),this.peekCameraPortalOrientation=void 0;this.previousQuaternion&&(fu.quaternion.copy(this.previousQuaternion),this.previousQuaternion=void 0)}}}(),hideAll:function(){var iu=this.el,eu=this.hiddenEls,tu=this;eu.length>0||iu.sceneEl.object3D.traverse(function(su){su&&su.el&&su.el.hasAttribute("link-controls")||su.el&&su!==iu.sceneEl.object3D&&su.el!==iu&&su.el!==tu.sphereEl&&su.el!==iu.sceneEl.cameraEl&&su.el.getAttribute("visible")!==!1&&su.el!==tu.textEl&&su.el!==tu.semiSphereEl&&(su.el.setAttribute("visible",!1),eu.push(su.el))})},showAll:function(){this.hiddenEls.forEach(function(iu){iu.setAttribute("visible",!0)}),this.hiddenEls=[]},calculateCameraPortalOrientation:(cA=new Re.Matrix4,hA=new Re.Vector3,dA=new Re.Vector3(0,0,1),uA=new Re.Vector3(0,0,0),function(){var iu=this.el,eu=iu.sceneEl.camera;return hA.set(0,0,0),dA.set(0,0,1),uA.set(0,0,0),iu.object3D.matrixWorld.extractRotation(cA),dA.applyMatrix4(cA),iu.object3D.updateMatrixWorld(),iu.object3D.localToWorld(uA),eu.parent.parent.updateMatrixWorld(),eu.parent.updateMatrixWorld(),eu.updateMatrixWorld(),eu.localToWorld(hA),hA.sub(uA).normalize(),dA.normalize(),Math.sign(dA.dot(hA))}),remove:function(){this.removeEventListener()}}),ia("portal",{schema:{borderEnabled:{default:1,type:"int",is:"uniform"},backgroundColor:{default:"red",type:"color",is:"uniform"},pano:{type:"map",is:"uniform"},strokeColor:{default:"white",type:"color",is:"uniform"},previewDistance:{default:15,type:"float",is:"uniform"}},vertexShader:["vec3 portalPosition;","varying vec3 vWorldPosition;","varying float vDistanceToCenter;","varying float vDistance;","void main() {","vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);","portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;","vDistance = length(portalPosition - cameraPosition);","vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join(`
`),fragmentShader:["#define RECIPROCAL_PI2 0.15915494","uniform sampler2D pano;","uniform vec3 strokeColor;","uniform vec3 backgroundColor;","uniform float borderEnabled;","uniform float previewDistance;","varying float vDistanceToCenter;","varying float vDistance;","varying vec3 vWorldPosition;","void main() {","vec3 direction = normalize(vWorldPosition - cameraPosition);","vec2 sampleUV;","float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);","sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);","sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;","if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {","gl_FragColor = vec4(strokeColor, 1.0);","} else {","gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / previewDistance), 2.0), 0.0, 1.0));","}","}"].join(`
`)});var CA="logitech-mx-ink",vA=ci+"controllers/logitech/",BA=(cs("logitech-mx-ink-controls",{schema:{hand:{default:"left"},model:{default:!0},orientationOffset:{type:"vec3"}},mapping:{left:{buttons:["front","back","none","none","none","tip"]},right:{buttons:["front","back","none","none","none","tip"]}},init:function(){var iu=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu,iu.data.hand)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu,iu.data.hand)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu,iu.data.hand)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu,iu.data.hand)},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),iu.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),iu.removeEventListener("model-loaded",this.onModelLoaded),iu.sceneEl.removeEventListener("enter-vr",this.onEnterVR),iu.sceneEl.removeEventListener("exit-vr",this.onExitVR),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.controllerObject3D;iu&&(iu.visible=!1),Ur(this,CA,{hand:this.data.hand,iterateControllerProfiles:!0})},injectTrackedControls:function(){var iu=this.el,eu=this.data,tu=CA;iu.setAttribute("tracked-controls",{id:tu,hand:eu.hand,handTrackingEnabled:!1,iterateControllerProfiles:!0,orientationOffset:eu.orientationOffset}),this.loadModel()},loadModel:function(){var iu=this.controllerObject3D;if(this.data.model)return iu?(iu.visible=this.el.sceneEl.is("vr-mode"),void this.el.setObject3D("mesh",iu)):void this.el.setAttribute("gltf-model",vA+"logitech-mx-ink.glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu,tu=this.mapping[this.data.hand].buttons[iu.detail.id];tu&&(tu==="trigger"&&(eu=iu.detail.state.value,console.log("analog value of trigger press: "+eu)),this.el.emit(tu+"changed",iu.detail.state))},onModelLoaded:function(iu){iu.target===this.el&&this.data.model&&(this.el.emit("controllermodelready",{name:"logitech-mx-ink-controls",model:this.data.model,rayOrigin:new Re.Vector3(0,0,0)}),this.controllerObject3D=this.el.getObject3D("mesh"),this.controllerObject3D.visible=this.el.sceneEl.is("vr-mode"))},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)}}),Math.PI/2),bA=(cs("look-controls",{dependencies:["position","rotation"],schema:{enabled:{default:!0},magicWindowTrackingEnabled:{default:!0},pointerLockEnabled:{default:!1},reverseMouseDrag:{default:!1},reverseTouchDrag:{default:!1},touchEnabled:{default:!0},mouseEnabled:{default:!0}},init:function(){this.deltaYaw=0,this.previousHMDPosition=new Re.Vector3,this.hmdQuaternion=new Re.Quaternion,this.magicWindowAbsoluteEuler=new Re.Euler,this.magicWindowDeltaEuler=new Re.Euler,this.position=new Re.Vector3,this.magicWindowObject=new Re.Object3D,this.rotation={},this.deltaRotation={},this.savedPose=null,this.pointerLocked=!1,this.setupMouseControls(),this.bindMethods(),this.previousMouseEvent={},this.setupMagicWindowControls(),this.savedPose={position:new Re.Vector3,rotation:new Re.Euler},(this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode"))&&this.onEnterVR()},setupMagicWindowControls:function(){var iu,eu=this.data;(Si()||Fi())&&(iu=this.magicWindowControls=new ai(this.magicWindowObject),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission&&(iu.enabled=!1,this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted?iu.enabled=eu.magicWindowTrackingEnabled:this.el.sceneEl.addEventListener("deviceorientationpermissiongranted",function(){iu.enabled=eu.magicWindowTrackingEnabled})))},update:function(iu){var eu=this.data;eu.enabled!==iu.enabled&&this.updateGrabCursor(eu.enabled),iu&&!eu.magicWindowTrackingEnabled&&iu.magicWindowTrackingEnabled&&(this.magicWindowAbsoluteEuler.set(0,0,0),this.magicWindowDeltaEuler.set(0,0,0)),this.magicWindowControls&&(this.magicWindowControls.enabled=eu.magicWindowTrackingEnabled),iu&&!eu.pointerLockEnabled!==iu.pointerLockEnabled&&(this.removeEventListeners(),this.addEventListeners(),this.pointerLocked&&this.exitPointerLock())},tick:function(iu){this.data.enabled&&this.updateOrientation()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},remove:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},bindMethods:function(){this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this),this.onPointerLockChange=this.onPointerLockChange.bind(this),this.onPointerLockError=this.onPointerLockError.bind(this)},setupMouseControls:function(){this.mouseDown=!1,this.pitchObject=new Re.Object3D,this.yawObject=new Re.Object3D,this.yawObject.position.y=10,this.yawObject.add(this.pitchObject)},addEventListeners:function(){var iu=this.el.sceneEl,eu=iu.canvas;eu?(eu.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),eu.addEventListener("touchstart",this.onTouchStart,{passive:!0}),window.addEventListener("touchmove",this.onTouchMove,{passive:!0}),window.addEventListener("touchend",this.onTouchEnd,{passive:!0}),iu.addEventListener("enter-vr",this.onEnterVR),iu.addEventListener("exit-vr",this.onExitVR),this.data.pointerLockEnabled&&(document.addEventListener("pointerlockchange",this.onPointerLockChange,!1),document.addEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.addEventListener("pointerlockerror",this.onPointerLockError,!1))):iu.addEventListener("render-target-loaded",this.addEventListeners.bind(this))},removeEventListeners:function(){var iu=this.el.sceneEl,eu=iu&&iu.canvas;eu&&(eu.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),eu.removeEventListener("touchstart",this.onTouchStart),window.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("touchend",this.onTouchEnd),iu.removeEventListener("enter-vr",this.onEnterVR),iu.removeEventListener("exit-vr",this.onExitVR),document.removeEventListener("pointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("pointerlockerror",this.onPointerLockError,!1))},updateOrientation:function(){var iu=this.el.object3D,eu=this.pitchObject,tu=this.yawObject,su=this.el.sceneEl;(su.is("vr-mode")||su.is("ar-mode"))&&su.checkHeadsetConnected()||(this.updateMagicWindowOrientation(),iu.rotation.x=this.magicWindowDeltaEuler.x+eu.rotation.x,iu.rotation.y=this.magicWindowDeltaEuler.y+tu.rotation.y,iu.rotation.z=this.magicWindowDeltaEuler.z)},updateMagicWindowOrientation:function(){var iu=this.magicWindowAbsoluteEuler,eu=this.magicWindowDeltaEuler;this.magicWindowControls&&this.magicWindowControls.enabled&&(this.magicWindowControls.update(),iu.setFromQuaternion(this.magicWindowObject.quaternion,"YXZ"),this.previousMagicWindowYaw||iu.y===0||(this.previousMagicWindowYaw=iu.y),this.previousMagicWindowYaw&&(eu.x=iu.x,eu.y+=iu.y-this.previousMagicWindowYaw,eu.z=iu.z,this.previousMagicWindowYaw=iu.y))},onMouseMove:function(iu){var eu,tu,su,au=this.pitchObject,uu=this.previousMouseEvent,du=this.yawObject;this.data.enabled&&(this.mouseDown||this.pointerLocked)&&(this.pointerLocked?(tu=iu.movementX||iu.mozMovementX||0,su=iu.movementY||iu.mozMovementY||0):(tu=iu.screenX-uu.screenX,su=iu.screenY-uu.screenY),this.previousMouseEvent.screenX=iu.screenX,this.previousMouseEvent.screenY=iu.screenY,eu=this.data.reverseMouseDrag?1:-1,du.rotation.y+=.002*tu*eu,au.rotation.x+=.002*su*eu,au.rotation.x=Math.max(-BA,Math.min(BA,au.rotation.x)))},onMouseDown:function(iu){var eu=this.el.sceneEl;if(this.data.enabled&&this.data.mouseEnabled&&(!eu.is("vr-mode")&&!eu.is("ar-mode")||!eu.checkHeadsetConnected())&&iu.button===0){var tu=eu&&eu.canvas;this.mouseDown=!0,this.previousMouseEvent.screenX=iu.screenX,this.previousMouseEvent.screenY=iu.screenY,this.showGrabbingCursor(),this.data.pointerLockEnabled&&!this.pointerLocked&&(tu.requestPointerLock?tu.requestPointerLock():tu.mozRequestPointerLock&&tu.mozRequestPointerLock())}},showGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor="grabbing"},hideGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor=""},onMouseUp:function(){this.mouseDown=!1,this.hideGrabbingCursor()},onTouchStart:function(iu){iu.touches.length!==1||!this.data.touchEnabled||this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode")||(this.touchStart={x:iu.touches[0].pageX,y:iu.touches[0].pageY},this.touchStarted=!0)},onTouchMove:function(iu){var eu,tu,su=this.el.sceneEl.canvas,au=this.yawObject;this.touchStarted&&this.data.touchEnabled&&(tu=2*Math.PI*(iu.touches[0].pageX-this.touchStart.x)/su.clientWidth,eu=this.data.reverseTouchDrag?1:-1,au.rotation.y-=.5*tu*eu,this.touchStart={x:iu.touches[0].pageX,y:iu.touches[0].pageY})},onTouchEnd:function(){this.touchStarted=!1},onEnterVR:function(){var iu=this.el.sceneEl;iu.checkHeadsetConnected()&&(this.saveCameraPose(),this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),iu.hasWebXR&&(this.el.object3D.matrixAutoUpdate=!1,this.el.object3D.updateMatrix()))},onExitVR:function(){this.el.sceneEl.checkHeadsetConnected()&&(this.restoreCameraPose(),this.previousHMDPosition.set(0,0,0),this.el.object3D.matrixAutoUpdate=!0)},onPointerLockChange:function(){this.pointerLocked=!(!document.pointerLockElement&&!document.mozPointerLockElement)},onPointerLockError:function(){this.pointerLocked=!1},exitPointerLock:function(){document.exitPointerLock(),this.pointerLocked=!1},updateGrabCursor:function(iu){var eu=this.el.sceneEl;function tu(){eu.canvas.classList.add("a-grab-cursor")}function su(){eu.canvas.classList.remove("a-grab-cursor")}eu.canvas?iu?tu():su():iu?eu.addEventListener("render-target-loaded",tu):eu.addEventListener("render-target-loaded",su)},saveCameraPose:function(){var iu=this.el;this.savedPose.position.copy(iu.object3D.position),this.savedPose.rotation.copy(iu.object3D.rotation),this.hasSavedPose=!0},restoreCameraPose:function(){var iu=this.el,eu=this.savedPose;this.hasSavedPose&&(iu.object3D.position.copy(eu.position),iu.object3D.rotation.copy(eu.rotation),this.hasSavedPose=!1)}}),"magicleap-one"),yA=ci+"controllers/magicleap/magicleap-one-controller.glb",IA=(cs("magicleap-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","menu"]},init:function(){var iu=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu)},this.previousButtonValues={},this.bindMethods()},update:function(){var iu=this.data;this.controllerIndex=iu.hand==="right"?0:iu.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),iu.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),iu.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.data;Ur(this,bA,{index:this.controllerIndex,hand:iu.hand})},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{idPrefix:bA,hand:eu.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",yA)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu,tu=this.mapping.buttons[iu.detail.id];tu&&(tu==="trigger"&&(eu=iu.detail.state.value,console.log("analog value of trigger press: "+eu)),this.el.emit(tu+"changed",iu.detail.state))},onModelLoaded:function(iu){iu.detail.model.scale.set(.01,.01,.01)},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)},updateModel:function(iu,eu){},setButtonColor:function(iu,eu){}}),fi("components:material:error"));function wA(iu,eu){iu.dispose(),eu.unregisterMaterial(iu),Object.keys(iu).filter(function(tu){return iu[tu]&&iu[tu].isTexture}).forEach(function(tu){iu[tu].dispose()})}cs("material",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:ea,schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColorsEnabled:{default:!1},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]},dithering:{default:!0},anisotropy:{default:0,min:0}},init:function(){this.material=null},update:function(iu){var eu=this.data;this.shader&&eu.shader===iu.shader||this.updateShader(eu.shader),this.shader.update(this.data),this.updateMaterial(iu)},updateSchema:function(iu){var eu,tu,su,au;tu=iu&&iu.shader,eu=this.oldData&&this.oldData.shader,(su=$s[au=tu||eu]&&$s[au].schema)||IA("Unknown shader schema "+au),eu&&tu===eu||(this.extendSchema(su),this.updateBehavior())},updateBehavior:function(){var iu,eu,tu=this.el.sceneEl,su=this.schema,au=this;function uu(du,fu){var gu;for(gu in eu)eu[gu]=du;au.shader.update(eu)}for(iu in this.tick=void 0,eu={},su)su[iu].type==="time"&&(this.tick=uu,eu[iu]=!0);tu&&(this.tick?tu.addBehavior(this):tu.removeBehavior(this))},updateShader:function(iu){var eu,tu=this.data,su=$s[iu]&&$s[iu].Shader;if(!su)throw new Error("Unknown shader "+iu);(eu=this.shader=new su).el=this.el,eu.init(tu),this.setMaterial(eu.material),this.updateSchema(tu)},updateMaterial:function(iu){var eu,tu=this.data,su=this.material;for(eu in su.alphaTest=tu.alphaTest,su.depthTest=tu.depthTest!==!1,su.depthWrite=tu.depthWrite!==!1,su.opacity=tu.opacity,su.flatShading=tu.flatShading,su.side=function(au){switch(au){case"back":return Re.BackSide;case"double":return Re.DoubleSide;default:return Re.FrontSide}}(tu.side),su.transparent=tu.transparent!==!1||tu.opacity<1,su.vertexColors=tu.vertexColorsEnabled,su.visible=tu.visible,su.blending=function(au){switch(au){case"none":return Re.NoBlending;case"additive":return Re.AdditiveBlending;case"subtractive":return Re.SubtractiveBlending;case"multiply":return Re.MultiplyBlending;default:return Re.NormalBlending}}(tu.blending),su.dithering=tu.dithering,iu)break;!eu||iu.alphaTest===tu.alphaTest&&iu.side===tu.side&&iu.vertexColorsEnabled===tu.vertexColorsEnabled||(su.needsUpdate=!0)},remove:function(){var iu=new Re.MeshBasicMaterial,eu=this.material,tu=this.el.getObject3D("mesh");tu&&(tu.material=iu),wA(eu,this.system)},setMaterial:function(iu){var eu,tu=this.el,su=this.system;this.material&&wA(this.material,su),this.material=iu,su.registerMaterial(iu),(eu=tu.getObject3D("mesh"))?eu.material=iu:tu.addEventListener("object3dset",function au(uu){uu.detail.type==="mesh"&&uu.target===tu&&(tu.getObject3D("mesh").material=iu,tu.removeEventListener("object3dset",au))})}});var xA,QA,LA,MA,SA,DA="oculus-touch",kA=ci+"controllers/oculus/oculus-touch-controller-",TA=ci+"controllers/meta/",RA={left:{modelUrl:kA+"left.gltf",rayOrigin:{origin:{x:.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new Re.Vector3(-.005,.036,-.037),modelPivotRotation:new Re.Euler(Math.PI/4.5,0,0)},right:{modelUrl:kA+"right.gltf",rayOrigin:{origin:{x:-.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new Re.Vector3(.005,.036,-.037),modelPivotRotation:new Re.Euler(Math.PI/4.5,0,0)}},FA="oculus-touch",UA={"oculus-touch":RA,"oculus-touch-v2":{left:{modelUrl:kA+"gen2-left.gltf",rayOrigin:{origin:{x:-.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new Re.Vector3(0,-.007,-.021),modelPivotRotation:new Re.Euler(-Math.PI/4,0,0)},right:{modelUrl:kA+"gen2-right.gltf",rayOrigin:{origin:{x:.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new Re.Vector3(0,-.007,-.021),modelPivotRotation:new Re.Euler(-Math.PI/4,0,0)}},"oculus-touch-v3":{left:{modelUrl:kA+"v3-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new Re.Vector3(0,0,0),modelPivotRotation:new Re.Euler(0,0,0)},right:{modelUrl:kA+"v3-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new Re.Vector3(0,0,0),modelPivotRotation:new Re.Euler(0,0,0)}},"meta-quest-touch-pro":{left:{modelUrl:TA+"quest-touch-pro-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new Re.Vector3(0,0,0),modelPivotRotation:new Re.Euler(0,0,0)},right:{modelUrl:TA+"quest-touch-pro-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new Re.Vector3(0,0,0),modelPivotRotation:new Re.Euler(0,0,0)}},"meta-quest-touch-plus":{left:{modelUrl:TA+"quest-touch-plus-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new Re.Vector3(0,0,0),modelPivotRotation:new Re.Euler(0,0,0)},right:{modelUrl:TA+"quest-touch-plus-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new Re.Vector3(0,0,0),modelPivotRotation:new Re.Euler(0,0,0)}}},OA={schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#999"},buttonTouchColor:{type:"color",default:"#8AB"},buttonHighlightColor:{type:"color",default:"#2DF"},model:{default:!0},controllerType:{default:"auto",oneOf:["auto","oculus-touch","oculus-touch-v2","oculus-touch-v3"]}},after:["tracked-controls"],mapping:{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton","surface"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton","surface"]}},bindMethods:function(){this.onButtonChanged=this.onButtonChanged.bind(this),this.onThumbstickMoved=this.onThumbstickMoved.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var iu=this;this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu,iu.data.hand)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu,iu.data.hand)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu,iu.data.hand)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu,iu.data.hand)},this.controllerPresent=!1,this.previousButtonValues={},this.bindMethods(),this.triggerEuler=new Re.Euler},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),iu.addEventListener("model-loaded",this.onModelLoaded),iu.addEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),iu.removeEventListener("model-loaded",this.onModelLoaded),iu.removeEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.controllerObject3D;iu&&(iu.visible=!1),Ur(this,DA,{hand:this.data.hand,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},loadModel:function(iu){var eu,tu=this.data;if(tu.model){if(this.controllerObject3D)return this.controllerObject3D.visible=!0,void this.el.setObject3D("mesh",this.controllerObject3D);if(this.displayModel=UA[tu.controllerType]||UA[FA],tu.controllerType==="auto"){eu=FA;for(var su=Object.keys(UA),au=0;au<iu.profiles.length;au++)if(su.indexOf(iu.profiles[au])!==-1){eu=iu.profiles[au];break}this.displayModel=UA[eu]}var uu=this.displayModel[tu.hand].modelUrl;this.isTouchV3orPROorPlus=this.displayModel===UA["oculus-touch-v3"]||this.displayModel===UA["meta-quest-touch-pro"]||this.displayModel===UA["meta-quest-touch-plus"],this.el.setAttribute("gltf-model",uu)}},injectTrackedControls:function(iu){var eu=this.data,tu=DA;this.el.setAttribute("tracked-controls",{id:tu,hand:eu.hand,handTrackingEnabled:!1,iterateControllerProfiles:!0}),this.loadModel(iu)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu=this.mapping[this.data.hand].buttons[iu.detail.id];if(eu){if(this.isTouchV3orPROorPlus)this.onButtonChangedV3orPROorPlus(iu);else{var tu,su=this.buttonMeshes;eu!=="trigger"&&eu!=="grip"||(tu=iu.detail.state.value),su&&(eu==="trigger"&&su.trigger&&(su.trigger.rotation.x=this.originalXRotationTrigger-tu*(Math.PI/26)),eu==="grip"&&su.grip&&(tu*=this.data.hand==="left"?-1:1,su.grip.position.x=this.originalXPositionGrip+.004*tu))}this.el.emit(eu+"changed",iu.detail.state)}},onButtonChangedV3orPROorPlus:function(iu){var eu,tu=this.mapping[this.data.hand].buttons[iu.detail.id],su=this.buttonObjects;su&&su[tu]&&(eu=iu.detail.state.value,su[tu].quaternion.slerpQuaternions(this.buttonRanges[tu].min.quaternion,this.buttonRanges[tu].max.quaternion,eu),su[tu].position.lerpVectors(this.buttonRanges[tu].min.position,this.buttonRanges[tu].max.position,eu))},onModelLoaded:function(iu){if(iu.target===this.el&&this.data.model){if(this.isTouchV3orPROorPlus)this.onTouchV3orPROorPlusModelLoaded(iu);else{var eu,tu=this.controllerObject3D=iu.detail.model;(eu=this.buttonMeshes={}).grip=tu.getObjectByName("buttonHand"),this.originalXPositionGrip=eu.grip&&eu.grip.position.x,eu.trigger=tu.getObjectByName("buttonTrigger"),this.originalXRotationTrigger=eu.trigger&&eu.trigger.rotation.x,eu.thumbstick=tu.getObjectByName("stick"),eu.xbutton=tu.getObjectByName("buttonX"),eu.abutton=tu.getObjectByName("buttonA"),eu.ybutton=tu.getObjectByName("buttonY"),eu.bbutton=tu.getObjectByName("buttonB")}for(var su in this.buttonMeshes)this.buttonMeshes[su]&&PA(this.buttonMeshes[su]);this.applyOffset(iu.detail.model),this.el.emit("controllermodelready",{name:"meta-touch-controls",model:this.data.model,rayOrigin:this.displayModel[this.data.hand].rayOrigin})}},applyOffset:function(iu){iu.position.copy(this.displayModel[this.data.hand].modelPivotOffset),iu.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation)},onTouchV3orPROorPlusModelLoaded:function(iu){var eu=this.controllerObject3D=iu.detail.model,tu=this.buttonObjects={},su=this.buttonMeshes={},au=this.buttonRanges={};su.grip=eu.getObjectByName("squeeze"),tu.grip=eu.getObjectByName("xr_standard_squeeze_pressed_value"),au.grip={min:eu.getObjectByName("xr_standard_squeeze_pressed_min"),max:eu.getObjectByName("xr_standard_squeeze_pressed_max")},tu.grip.minX=tu.grip.position.x,su.thumbstick=eu.getObjectByName("thumbstick"),tu.thumbstick=eu.getObjectByName("xr_standard_thumbstick_pressed_value"),au.thumbstick={min:eu.getObjectByName("xr_standard_thumbstick_pressed_min"),max:eu.getObjectByName("xr_standard_thumbstick_pressed_max")},tu.thumbstickXAxis=eu.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"),au.thumbstickXAxis={min:eu.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),max:eu.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")},tu.thumbstickYAxis=eu.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"),au.thumbstickYAxis={min:eu.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),max:eu.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")},su.trigger=eu.getObjectByName("trigger"),tu.trigger=eu.getObjectByName("xr_standard_trigger_pressed_value"),au.trigger={min:eu.getObjectByName("xr_standard_trigger_pressed_min"),max:eu.getObjectByName("xr_standard_trigger_pressed_max")},au.trigger.diff={x:Math.abs(au.trigger.max.rotation.x)-Math.abs(au.trigger.min.rotation.x),y:Math.abs(au.trigger.max.rotation.y)-Math.abs(au.trigger.min.rotation.y),z:Math.abs(au.trigger.max.rotation.z)-Math.abs(au.trigger.min.rotation.z)};var uu=this.data.hand==="left"?"x":"a",du=this.data.hand==="left"?"y":"b",fu=uu+"button",gu=du+"button";su[fu]=eu.getObjectByName(uu+"_button"),tu[fu]=eu.getObjectByName(uu+"_button_pressed_value"),au[fu]={min:eu.getObjectByName(uu+"_button_pressed_min"),max:eu.getObjectByName(uu+"_button_pressed_max")},su[gu]=eu.getObjectByName(du+"_button"),tu[gu]=eu.getObjectByName(du+"_button_pressed_value"),au[gu]={min:eu.getObjectByName(du+"_button_pressed_min"),max:eu.getObjectByName(du+"_button_pressed_max")}},onAxisMoved:function(iu){Gr(this,this.mapping[this.data.hand].axes,iu)},onThumbstickMoved:function(iu){if(this.buttonMeshes&&this.buttonMeshes.thumbstick)if(this.isTouchV3orPROorPlus)this.updateThumbstickTouchV3orPROorPlus(iu);else for(var eu in iu.detail)this.buttonObjects.thumbstick.rotation[this.axisMap[eu]]=this.buttonRanges.thumbstick.originalRotation[this.axisMap[eu]]-Math.PI/8*iu.detail[eu]*(eu==="y"||this.data.hand==="right"?-1:1)},axisMap:{y:"x",x:"z"},updateThumbstickTouchV3orPROorPlus:function(iu){var eu=(iu.detail.x+1)/2;this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion,this.buttonRanges.thumbstickXAxis.max.quaternion,eu);var tu=(iu.detail.y+1)/2;this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion,this.buttonRanges.thumbstickYAxis.max.quaternion,tu)},updateModel:function(iu,eu){this.data.model&&this.updateButtonModel(iu,eu)},updateButtonModel:function(iu,eu){var tu,su=this.buttonMeshes;su&&su[iu]&&(tu=eu==="up"||eu==="touchend"?su[iu].originalColor||this.data.buttonColor:eu==="touchstart"?this.data.buttonTouchColor:this.data.buttonHighlightColor,su[iu].material.color.set(tu))}};function PA(iu){iu.traverse(function(eu){var tu;eu.type==="Mesh"&&(tu=eu.material.clone(),iu.originalColor=eu.material.color,eu.material.dispose(),eu.material=tu)})}cs("oculus-touch-controls",OA),cs("meta-touch-controls",OA),cs("obb-collider",{schema:{size:{default:0},trackedObject3D:{default:""},minimumColliderDimension:{default:.02},centerModel:{default:!1}},init:function(){this.previousScale=new Re.Vector3().copy(this.el.object3D.scale),this.auxEuler=new Re.Euler,this.boundingBox=new Re.Box3,this.boundingBoxSize=new Re.Vector3,this.updateCollider=this.updateCollider.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.updateBoundingBox=this.updateBoundingBox.bind(this),this.el.addEventListener("model-loaded",this.onModelLoaded),this.updateCollider(),this.system.addCollider(this.el)},remove:function(){this.system.removeCollider(this.el)},update:function(){this.data.trackedObject3D&&(this.trackedObject3DPath=this.data.trackedObject3D.split("."))},onModelLoaded:function(){this.data.centerModel&&this.centerModel(),this.updateCollider()},centerModel:function(){var iu,eu=this.el,tu=eu.components["gltf-model"]&&eu.components["gltf-model"].model;tu&&(this.el.removeObject3D("mesh"),iu=new Re.Box3().setFromObject(tu).getCenter(new Re.Vector3),tu.position.x+=tu.position.x-iu.x,tu.position.y+=tu.position.y-iu.y,tu.position.z+=tu.position.z-iu.z,this.el.setObject3D("mesh",tu))},updateCollider:function(){var iu=this.el,eu=this.boundingBoxSize,tu=this.aabb=this.aabb||new _n;this.obb=this.obb||new _n,iu.hasLoaded?(this.updateBoundingBox(),tu.halfSize.copy(eu).multiplyScalar(.5),this.el.sceneEl.systems["obb-collider"].data.showColliders&&this.showCollider()):iu.addEventListener("loaded",this.updateCollider)},showCollider:function(){this.updateColliderMesh(),this.renderColliderMesh.visible=!0},updateColliderMesh:function(){var iu=this.renderColliderMesh,eu=this.boundingBoxSize;iu?(iu.geometry.dispose(),iu.geometry=new Re.BoxGeometry(eu.x,eu.y,eu.z)):this.initColliderMesh()},hideCollider:function(){this.renderColliderMesh&&(this.renderColliderMesh.visible=!1)},initColliderMesh:function(){var iu,eu,tu;iu=this.boundingBoxSize,eu=this.renderColliderGeometry=new Re.BoxGeometry(iu.x,iu.y,iu.z),(tu=this.renderColliderMesh=new Re.Mesh(eu,new Re.MeshLambertMaterial({color:65280,side:Re.DoubleSide}))).matrixAutoUpdate=!1,tu.matrixWorldAutoUpdate=!1,tu.updateMatrixWorld=function(){},this.el.sceneEl.object3D.add(tu)},updateBoundingBox:(xA=new Re.Vector3,QA=new Re.Vector3,LA=new Re.Quaternion,MA=new Re.Quaternion,SA=new Re.Matrix4,function(){var iu=this.auxEuler,eu=this.boundingBox,tu=this.data.size,su=this.trackedObject3D||this.el.object3D,au=this.boundingBoxSize,uu=this.data.minimumColliderDimension;if(tu)return this.boundingBoxSize.x=tu,this.boundingBoxSize.y=tu,void(this.boundingBoxSize.z=tu);iu.copy(su.rotation),su.rotation.set(0,0,0),su.parent.matrixWorld.decompose(xA,LA,QA),SA.compose(xA,MA,QA),su.parent.matrixWorld.copy(SA),eu.setFromObject(su,!0),eu.getSize(au),au.x=au.x<uu?uu:au.x,au.y=au.y<uu?uu:au.y,au.z=au.z<uu?uu:au.z,su.parent.matrixWorld.compose(xA,LA,QA),this.el.object3D.rotation.copy(iu)}),checkTrackedObject:function(){var iu,eu=this.trackedObject3DPath;if(eu&&eu.length&&!this.trackedObject3D){iu=this.el;for(var tu=0;tu<eu.length&&(iu=iu[eu[tu]]);tu++);iu&&(this.trackedObject3D=iu,this.updateCollider())}return this.trackedObject3D},tick:function(){var iu=new Re.Vector3,eu=new Re.Vector3,tu=new Re.Quaternion,su=new Re.Matrix4;return function(){var au=this.obb,uu=this.renderColliderMesh,du=this.checkTrackedObject()||this.el.object3D;du&&(du.updateMatrix(),du.updateMatrixWorld(!0),du.matrixWorld.decompose(iu,tu,eu),(Math.abs(eu.x-this.previousScale.x)>1e-4||Math.abs(eu.y-this.previousScale.y)>1e-4||Math.abs(eu.z-this.previousScale.z)>1e-4)&&this.updateCollider(),this.previousScale.copy(eu),eu.set(1,1,1),su.compose(iu,tu,eu),uu&&uu.matrixWorld.copy(su),au.copy(this.aabb),au.applyMatrix4(su))}}()});var GA=fi("components:obj-model:warn"),NA=(cs("obj-model",{schema:{mtl:{type:"model"},obj:{type:"model"}},init:function(){var iu=this;this.model=null,this.objLoader=new ni,this.mtlLoader=new ii(this.objLoader.manager),this.mtlLoader.crossOrigin="",this.el.addEventListener("componentinitialized",function(eu){iu.model&&eu.detail.name==="material"&&iu.applyMaterial()})},update:function(){var iu=this.data;iu.obj&&(this.resetMesh(),this.loadObj(iu.obj,iu.mtl))},remove:function(){this.resetMesh()},resetMesh:function(){this.model&&this.el.removeObject3D("mesh")},loadObj:function(iu,eu){var tu=this,su=this.el,au=this.mtlLoader,uu=this.objLoader,du=this.el.sceneEl.systems.renderer,fu=eu.substr(0,eu.lastIndexOf("/")+1);if(eu)return su.hasAttribute("material")&&GA("Material component properties are ignored when a .MTL is provided"),au.setResourcePath(fu),void au.load(eu,function(gu){gu.preload(),uu.setMaterials(gu),uu.load(iu,function(yu){tu.model=yu,tu.model.traverse(function(xu){if(xu.isMesh){var vu=xu.material;vu.map&&du.applyColorCorrection(vu.map),vu.emissiveMap&&du.applyColorCorrection(vu.emissiveMap)}}),su.setObject3D("mesh",yu),su.emit("model-loaded",{format:"obj",model:yu})})});uu.load(iu,function(gu){tu.model=gu,tu.applyMaterial(),su.setObject3D("mesh",gu),su.emit("model-loaded",{format:"obj",model:gu})})},applyMaterial:function(){var iu=this.el.components.material;iu&&this.model.traverse(function(eu){eu instanceof Re.Mesh&&(eu.material=iu.material)})}}),ci+"controllers/oculus/go/oculus-go-controller.gltf"),jA="oculus-go",_A=(cs("oculus-go-controls",{schema:{hand:{default:""},buttonColor:{type:"color",default:"#FFFFFF"},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var iu=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu)},this.controllerPresent=!1,this.bindMethods()},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("model-loaded",this.onModelLoaded),iu.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("model-loaded",this.onModelLoaded),iu.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){Ur(this,jA,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{hand:eu.hand,idPrefix:jA}),this.data.model&&this.el.setAttribute("gltf-model",NA)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(iu){var eu,tu=iu.detail.model;iu.target===this.el&&this.data.model&&((eu=this.buttonMeshes={}).trigger=tu.getObjectByName("oculus_go_button_trigger"),eu.trackpad=tu.getObjectByName("oculus_go_touchpad"),eu.touchpad=tu.getObjectByName("oculus_go_touchpad"))},onButtonChanged:function(iu){var eu=this.mapping.buttons[iu.detail.id];eu&&this.el.emit(eu+"changed",iu.detail.state)},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)},updateModel:function(iu,eu){this.data.model&&this.updateButtonModel(iu,eu)},updateButtonModel:function(iu,eu){var tu=this.buttonMeshes;if(tu&&tu[iu]){var su;switch(eu){case"down":su=this.data.buttonHighlightColor;break;case"touchstart":su=this.data.buttonTouchedColor;break;default:su=this.data.buttonColor}tu[iu].material.color.set(su)}}}),"pico-4"),HA=ci+"controllers/pico/pico4/",qA=(cs("pico-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var iu=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu,iu.data.hand)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu,iu.data.hand)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu,iu.data.hand)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu,iu.data.hand)},this.bindMethods()},update:function(){var iu=this.data;this.controllerIndex=iu.hand==="right"?0:iu.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),iu.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),iu.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.data;Ur(this,_A,{index:this.controllerIndex,hand:iu.hand})},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{idPrefix:_A,hand:eu.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",HA+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu,tu=this.mapping[this.data.hand].buttons[iu.detail.id];tu&&(tu==="trigger"&&(eu=iu.detail.state.value,console.log("analog value of trigger press: "+eu)),this.el.emit(tu+"changed",iu.detail.state))},onModelLoaded:function(iu){iu.target===this.el&&this.data.model&&this.el.emit("controllermodelready",{name:"pico-controls",model:this.data.model,rayOrigin:new Re.Vector3(0,0,0)})},onAxisMoved:function(iu){Gr(this,this.mapping[this.data.hand].axes,iu)}}),cs("position",{schema:{type:"vec3"},update:function(){var iu=this.el.object3D,eu=this.data;iu.position.set(eu.x,eu.y,eu.z)},remove:function(){this.el.object3D.position.set(0,0,0)}}),fi("components:raycaster:warn")),VA=/^[\w\s-.,[\]#]*$/,zA={childList:!0,attributes:!0,subtree:!0},YA="raycaster-intersected-cleared",KA="raycaster-intersection-cleared";function WA(iu,eu){var tu;for(iu.length=eu.length,tu=0;tu<eu.length;tu++)iu[tu]=eu[tu]}cs("raycaster",{schema:{autoRefresh:{default:!0},direction:{type:"vec3",default:{x:0,y:0,z:-1}},enabled:{default:!0},far:{default:1e3},interval:{default:0},near:{default:0},objects:{default:""},origin:{type:"vec3"},showLine:{default:!1},lineColor:{default:"white"},lineOpacity:{default:1},useWorldCoordinates:{default:!1}},multiple:!0,init:function(){this.clearedIntersectedEls=[],this.unitLineEndVec3=new Re.Vector3,this.intersectedEls=[],this.intersections=[],this.newIntersectedEls=[],this.newIntersections=[],this.objects=[],this.prevCheckTime=void 0,this.prevIntersectedEls=[],this.rawIntersections=[],this.raycaster=new Re.Raycaster,this.updateOriginDirection(),this.setDirty=this.setDirty.bind(this),this.updateLine=this.updateLine.bind(this),this.observer=new MutationObserver(this.setDirty),this.dirty=!0,this.lineEndVec3=new Re.Vector3,this.otherLineEndVec3=new Re.Vector3,this.lineData={end:this.lineEndVec3},this.getIntersection=this.getIntersection.bind(this),this.intersectedDetail={el:this.el,getIntersection:this.getIntersection},this.intersectedClearedDetail={el:this.el},this.intersectionClearedDetail={clearedEls:this.clearedIntersectedEls},this.intersectionDetail={}},update:function(iu){var eu=this.data,tu=this.el,su=this.raycaster;su.far=eu.far,su.near=eu.near,!eu.showLine||eu.far===iu.far&&eu.origin===iu.origin&&eu.direction===iu.direction&&iu.showLine||(this.unitLineEndVec3.copy(eu.direction).normalize(),this.drawLine()),!eu.showLine&&iu.showLine&&tu.removeAttribute("line"),eu.objects===iu.objects||VA.test(eu.objects)||qA('[raycaster] Selector "'+eu.objects+'" may not update automatically with DOM changes.'),eu.objects||qA('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'),eu.autoRefresh!==iu.autoRefresh&&tu.isPlaying&&(eu.autoRefresh?this.addEventListeners():this.removeEventListeners()),iu.enabled&&!eu.enabled&&this.clearAllIntersections(),eu.objects!==iu.objects&&this.setDirty()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){this.data.showLine&&this.el.removeAttribute("line"),this.clearAllIntersections()},addEventListeners:function(){this.data.autoRefresh&&(this.observer.observe(this.el.sceneEl,zA),this.el.sceneEl.addEventListener("object3dset",this.setDirty),this.el.sceneEl.addEventListener("object3dremove",this.setDirty))},removeEventListeners:function(){this.observer.disconnect(),this.el.sceneEl.removeEventListener("object3dset",this.setDirty),this.el.sceneEl.removeEventListener("object3dremove",this.setDirty)},setDirty:function(){this.dirty=!0},refreshObjects:function(){var iu,eu=this.data;iu=eu.objects?this.el.sceneEl.querySelectorAll(eu.objects):this.el.sceneEl.querySelectorAll("*"),this.objects=this.flattenObject3DMaps(iu),this.dirty=!1},tock:function(iu){var eu=this.data,tu=this.prevCheckTime;eu.enabled&&(tu&&iu-tu<eu.interval||(this.prevCheckTime=iu,this.checkIntersections()))},checkIntersections:function(){var iu,eu,tu=this.clearedIntersectedEls,su=this.el,au=this.data,uu=this.intersectedEls,du=this.intersections,fu=this.newIntersectedEls,gu=this.newIntersections,yu=this.prevIntersectedEls,xu=this.rawIntersections;for(this.dirty&&this.refreshObjects(),WA(this.prevIntersectedEls,this.intersectedEls),this.updateOriginDirection(),xu.length=0,this.raycaster.intersectObjects(this.objects,!0,xu),du.length=0,uu.length=0,iu=0;iu<xu.length;iu++)eu=xu[iu],au.showLine&&eu.object===su.getObject3D("line")||eu.object.el&&(du.push(eu),uu.push(eu.object.el));for(gu.length=0,fu.length=0,iu=0;iu<du.length;iu++)yu.indexOf(du[iu].object.el)===-1&&(gu.push(du[iu]),fu.push(du[iu].object.el));for(tu.length=0,iu=0;iu<yu.length;iu++)uu.indexOf(yu[iu])===-1&&(yu[iu].emit(YA,this.intersectedClearedDetail),tu.push(yu[iu]));for(tu.length&&su.emit(KA,this.intersectionClearedDetail),iu=0;iu<fu.length;iu++)fu[iu].emit("raycaster-intersected",this.intersectedDetail);gu.length&&(this.intersectionDetail.els=fu,this.intersectionDetail.intersections=gu,su.emit("raycaster-intersection",this.intersectionDetail)),(yu.length===0&&du.length>0||yu.length>0&&du.length===0||yu.length&&du.length&&yu[0]!==du[0].object.el)&&(this.intersectionDetail.els=this.intersectedEls,this.intersectionDetail.intersections=du,su.emit("raycaster-closest-entity-changed",this.intersectionDetail)),au.showLine&&setTimeout(this.updateLine)},updateLine:function(){var iu,eu=this.el,tu=this.intersections;tu.length&&(iu=tu[0].object.el===eu&&tu[1]?tu[1].distance:tu[0].distance),this.drawLine(iu)},getIntersection:function(iu){var eu,tu;for(eu=0;eu<this.intersections.length;eu++)if((tu=this.intersections[eu]).object.el===iu)return tu;return null},updateOriginDirection:function(){var iu=new Re.Vector3,eu=new Re.Vector3;return function(){var tu=this.el,su=this.data;su.useWorldCoordinates?this.raycaster.set(su.origin,su.direction):(tu.object3D.updateMatrixWorld(),eu.setFromMatrixPosition(tu.object3D.matrixWorld),su.origin.x===0&&su.origin.y===0&&su.origin.z===0||(eu=tu.object3D.localToWorld(eu.copy(su.origin))),iu.copy(su.direction).transformDirection(tu.object3D.matrixWorld).normalize(),this.raycaster.set(eu,iu))}}(),drawLine:function(iu){var eu,tu=this.data,su=this.el;eu=this.lineData.end===this.lineEndVec3?this.otherLineEndVec3:this.lineEndVec3,iu===void 0&&(iu=tu.far===1/0?1e3:tu.far),this.lineData.start=tu.origin,this.lineData.end=eu.copy(this.unitLineEndVec3).multiplyScalar(iu).add(tu.origin),this.lineData.color=tu.lineColor,this.lineData.opacity=tu.lineOpacity,su.setAttribute("line",this.lineData)},flattenObject3DMaps:function(iu){var eu,tu,su=this.objects,au=this.el.sceneEl.object3D;function uu(fu){return fu.parent?uu(fu.parent):fu===au}for(su.length=0,tu=0;tu<iu.length;tu++){var du=iu[tu];if(du.isEntity&&du.object3D&&uu(du.object3D))for(eu in du.object3DMap)su.push(du.getObject3D(eu))}return su},clearAllIntersections:function(){var iu;for(iu=0;iu<this.intersectedEls.length;iu++)this.intersectedEls[iu].emit(YA,this.intersectedClearedDetail);WA(this.clearedIntersectedEls,this.intersectedEls),this.intersectedEls.length=0,this.intersections.length=0,this.el.emit(KA,this.intersectionClearedDetail)}});var JA,XA,ZA,$A,el=Re.MathUtils.degToRad,tl=(cs("rotation",{schema:{type:"vec3"},update:function(){var iu=this.data;this.el.object3D.rotation.set(el(iu.x),el(iu.y),el(iu.z),"YXZ")},remove:function(){this.el.object3D.rotation.set(0,0,0)}}),cs("scale",{schema:{type:"vec3",default:{x:1,y:1,z:1}},update:function(){var iu=this.data;this.el.object3D.scale.set(iu.x,iu.y,iu.z)},remove:function(){this.el.object3D.scale.set(1,1,1)}}),cs("shadow",{schema:{cast:{default:!0},receive:{default:!0}},init:function(){this.onMeshChanged=this.update.bind(this),this.el.addEventListener("object3dset",this.onMeshChanged),this.system.setShadowMapEnabled(!0)},update:function(){var iu=this.data;this.updateDescendants(iu.cast,iu.receive)},remove:function(){this.el.removeEventListener("object3dset",this.onMeshChanged),this.updateDescendants(!1,!1)},updateDescendants:function(iu,eu){var tu=this.el.sceneEl;this.el.object3D.traverse(function(su){if(su instanceof Re.Mesh&&(su.castShadow=iu,su.receiveShadow=eu,tu.hasLoaded&&su.material))for(var au=Array.isArray(su.material)?su.material:[su.material],uu=0;uu<au.length;uu++)au[uu].needsUpdate=!0})}}),fi("components:sound:warn")),nl=(cs("sound",{schema:{autoplay:{default:!1},distanceModel:{default:"inverse",oneOf:["linear","inverse","exponential"]},loop:{default:!1},loopStart:{default:0},loopEnd:{default:0},maxDistance:{default:1e4},on:{default:""},poolSize:{default:1},positional:{default:!0},refDistance:{default:1},rolloffFactor:{default:1},src:{type:"audio"},volume:{default:1}},multiple:!0,init:function(){var iu=this;this.listener=null,this.audioLoader=new Re.AudioLoader,this.pool=new Re.Group,this.loaded=!1,this.mustPlay=!1,this.playSoundBound=function(){iu.playSound()}},update:function(iu){var eu,tu,su=this.data,au=su.src!==iu.src;if(au){if(!su.src)return;this.setupSound()}for(eu=0;eu<this.pool.children.length;eu++)tu=this.pool.children[eu],su.positional&&(tu.setDistanceModel(su.distanceModel),tu.setMaxDistance(su.maxDistance),tu.setRefDistance(su.refDistance),tu.setRolloffFactor(su.rolloffFactor)),tu.setLoop(su.loop),tu.setLoopStart(su.loopStart),su.loopStart!==0&&su.loopEnd===0?tu.setLoopEnd(tu.buffer.duration):tu.setLoopEnd(su.loopEnd),tu.setVolume(su.volume),tu.isPaused=!1;if(su.on!==iu.on&&this.updateEventListener(iu.on),au){var uu=this;this.loaded=!1,this.audioLoader.load(su.src,function(du){for(eu=0;eu<uu.pool.children.length;eu++)(tu=uu.pool.children[eu]).setBuffer(du);uu.loaded=!0,Re.Cache.remove(su.src),(uu.data.autoplay||uu.mustPlay)&&uu.playSound(uu.processSound),uu.el.emit("sound-loaded",uu.evtDetail,!1)})}},pause:function(){this.stopSound(),this.removeEventListener()},play:function(){this.data.autoplay&&this.playSound(),this.updateEventListener()},remove:function(){var iu;this.removeEventListener(),this.el.getObject3D(this.attrName)&&this.el.removeObject3D(this.attrName);try{for(iu=0;iu<this.pool.children.length;iu++)this.pool.children[iu].disconnect()}catch{tl("Audio source not properly disconnected")}},updateEventListener:function(iu){var eu=this.el;iu&&eu.removeEventListener(iu,this.playSoundBound),eu.addEventListener(this.data.on,this.playSoundBound)},removeEventListener:function(){this.el.removeEventListener(this.data.on,this.playSoundBound)},setupSound:function(){var iu,eu,tu=this.el,su=tu.sceneEl,au=this;this.pool.children.length>0&&(this.stopSound(),tu.removeObject3D("sound"));var uu=this.listener=su.audioListener||new Re.AudioListener;for(su.audioListener=uu,su.camera&&su.camera.add(uu),su.addEventListener("camera-set-active",function(du){du.detail.cameraEl.getObject3D("camera").add(uu)}),this.pool=new Re.Group,iu=0;iu<this.data.poolSize;iu++)eu=this.data.positional?new Re.PositionalAudio(uu):new Re.Audio(uu),this.pool.add(eu);for(tu.setObject3D(this.attrName,this.pool),iu=0;iu<this.pool.children.length;iu++)(eu=this.pool.children[iu]).onEnded=function(){this.isPlaying=!1,au.el.emit("sound-ended",au.evtDetail,!1)}},pauseSound:function(){var iu,eu;for(this.isPlaying=!1,iu=0;iu<this.pool.children.length;iu++)(eu=this.pool.children[iu]).source&&eu.source.buffer&&eu.isPlaying&&!eu.isPaused&&(eu.isPaused=!0,eu.pause())},playSound:function(iu){var eu,tu,su;if(!this.loaded)return tl("Sound not loaded yet. It will be played once it finished loading"),this.mustPlay=!0,void(this.processSound=iu);for(eu=!1,this.isPlaying=!0,tu=0;tu<this.pool.children.length;tu++)(su=this.pool.children[tu]).isPlaying||!su.buffer||eu||(iu&&iu(su),su.play(),su.isPaused=!1,eu=!0);eu?(this.mustPlay=!1,this.processSound=void 0):tl("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.",this.el)},stopSound:function(){var iu,eu;for(this.isPlaying=!1,iu=0;iu<this.pool.children.length;iu++){if(!(eu=this.pool.children[iu]).source||!eu.source.buffer)return;eu.stop()}}}),i$1(4433)),il=i$1.n(nl),rl=i$1(5751),ol=i$1.n(rl),sl=fi("components:text:error"),al=fi("components:text:warn"),Al=ci+"fonts/",ll={aileronsemibold:Al+"Aileron-Semibold.fnt",dejavu:Al+"DejaVu-sdf.fnt",exo2bold:Al+"Exo2Bold.fnt",exo2semibold:Al+"Exo2SemiBold.fnt",kelsonsans:Al+"KelsonSans.fnt",monoid:Al+"Monoid.fnt",mozillavr:Al+"mozillavr.fnt",roboto:Al+"Roboto-msdf.json",sourcecodepro:Al+"SourceCodePro.fnt"},cl=["roboto"],hl="roboto",dl=new function(){var iu=this.cache={};this.get=function(eu,tu){return eu in iu||(iu[eu]=tu()),iu[eu]}},ul={},gl={},pl=/^\w+:/;function fl(iu,eu,tu){return iu||(.5+eu)*tu}cs("text",{multiple:!0,schema:{align:{type:"string",default:"left",oneOf:["left","right","center"]},alphaTest:{default:.5},anchor:{default:"center",oneOf:["left","right","center","align"]},baseline:{default:"center",oneOf:["top","center","bottom"]},color:{type:"color",default:"#FFF"},font:{type:"string",default:hl},fontImage:{type:"string"},height:{type:"number"},letterSpacing:{type:"number",default:0},lineHeight:{type:"number"},negate:{type:"boolean",default:!0},opacity:{type:"number",default:1},shader:{default:"sdf",oneOf:$s},side:{default:"front",oneOf:["front","back","double"]},tabSize:{default:4},transparent:{default:!0},value:{type:"string"},whiteSpace:{default:"normal",oneOf:["normal","pre","nowrap"]},width:{type:"number"},wrapCount:{type:"number",default:40},wrapPixels:{type:"number"},xOffset:{type:"number",default:0},yOffset:{type:"number",default:0},zOffset:{type:"number",default:.001}},init:function(){this.shaderData={},this.geometry=il()(),this.createOrUpdateMaterial(),this.explicitGeoDimensionsChecked=!1},update:function(iu){var eu=this.data,tu=this.currentFont;gl[eu.font]?this.texture=gl[eu.font]:(this.texture=gl[eu.font]=new Re.Texture,this.texture.anisotropy=16),this.createOrUpdateMaterial(),iu.font===eu.font?tu&&(this.updateGeometry(this.geometry,tu),this.updateLayout()):this.updateFont()},remove:function(){this.geometry.dispose(),this.geometry=null,this.el.removeObject3D(this.attrName),this.material.dispose(),this.material=null,this.texture.dispose(),this.texture=null,this.shaderObject&&delete this.shaderObject},createOrUpdateMaterial:function(){var iu,eu,tu,su=this.data,au=this.material,uu=this.shaderData;if(tu=su.shader,cl.indexOf(su.font)!==-1||su.font.indexOf("-msdf.")>=0?tu="msdf":su.font in ll&&cl.indexOf(su.font)===-1&&(tu="sdf"),iu=(this.shaderObject&&this.shaderObject.name)!==tu,uu.alphaTest=su.alphaTest,uu.color=su.color,uu.map=this.texture,uu.opacity=su.opacity,uu.side=function(du){switch(du){case"back":return Re.FrontSide;case"double":return Re.DoubleSide;default:return Re.BackSide}}(su.side),uu.transparent=su.transparent,uu.negate=su.negate,!iu)return this.shaderObject.update(uu),au.transparent=uu.transparent,void(au.side=uu.side);eu=function(du,fu,gu){var yu,xu;return(xu=new $s[fu].Shader).el=du,xu.init(gu),xu.update(gu),(yu=xu.material).transparent=gu.transparent,{material:yu,shader:xu}}(this.el,tu,uu),this.material=eu.material,this.shaderObject=eu.shader,this.material.side=uu.side,this.mesh&&(this.mesh.material=this.material)},updateFont:function(){var iu,eu=this.data,tu=this.el,su=this.geometry,au=this;eu.font||al("No font specified. Using the default font."),this.mesh&&(this.mesh.visible=!1),iu=this.lookupFont(eu.font||hl)||eu.font,dl.get(iu,function(){return function(uu,du){return new Promise(function(fu,gu){ol()(uu,function(yu,xu){if(yu)return sl("Error loading font",uu),void gu(yu);uu.indexOf("/Roboto-msdf.json")>=0&&(du=30),du&&xu.chars.forEach(function(vu){vu.yoffset+=du}),fu(xu)})})}(iu,eu.yOffset)}).then(function(uu){var du;if(uu.pages.length!==1)throw new Error("Currently only single-page bitmap fonts are supported.");ul[iu]||(uu.widthFactor=ul[uu]=function(fu){var gu=0,yu=0,xu=0;return fu.chars.forEach(function(vu){gu+=vu.xadvance,vu.id>=48&&vu.id<=57&&(xu++,yu+=vu.xadvance)}),xu?yu/xu:gu/fu.chars.length}(uu)),au.currentFont=uu,du=au.getFontImageSrc(),dl.get(du,function(){return function(fu){return new Promise(function(gu,yu){new Re.ImageLoader().load(fu,function(xu){gu(xu)},void 0,function(){sl("Error loading font image",fu),yu(null)})})}(du)}).then(function(fu){var gu=au.texture;gu&&(gu.image=fu,gu.needsUpdate=!0,gl[eu.font]=gu,au.texture=gu,au.initMesh(),au.currentFont=uu,au.updateGeometry(su,uu),au.updateLayout(),au.mesh.visible=!0,tu.emit("textfontset",{font:eu.font,fontObj:uu}))}).catch(function(fu){sl(fu.message),sl(fu.stack)})}).catch(function(uu){sl(uu.message),sl(uu.stack)})},initMesh:function(){this.mesh||(this.mesh=new Re.Mesh(this.geometry,this.material),this.el.setObject3D(this.attrName,this.mesh))},getFontImageSrc:function(){if(this.data.fontImage)return this.data.fontImage;var iu=this.lookupFont(this.data.font||hl)||this.data.font,eu=this.currentFont.pages[0];return eu.match(pl)&&eu.indexOf("http")!==0?iu.replace(/(\.fnt)|(\.json)/,".png"):Re.LoaderUtils.extractUrlBase(iu)+eu},updateLayout:function(){var iu,eu,tu,su,au,uu,du,fu,gu,yu=this.el,xu=this.data,vu=this.geometry,Su=this.mesh;if(Su&&vu.layout){if(tu=yu.getAttribute("geometry"),su=(uu=(du=xu.width||tu&&tu.width||1)/fl(xu.wrapPixels,xu.wrapCount,this.currentFont.widthFactor))*((au=vu.layout).height+au.descender),tu&&tu.primitive==="plane"&&(this.explicitGeoDimensionsChecked||(this.explicitGeoDimensionsChecked=!0,this.hasExplicitGeoWidth=!!tu.width,this.hasExplicitGeoHeight=!!tu.height),this.hasExplicitGeoWidth||yu.setAttribute("geometry","width",du),this.hasExplicitGeoHeight||yu.setAttribute("geometry","height",su)),(iu=xu.anchor==="align"?xu.align:xu.anchor)==="left")fu=0;else if(iu==="right")fu=-1*au.width;else{if(iu!=="center")throw new TypeError("Invalid text.anchor property value",iu);fu=-1*au.width/2}if((eu=xu.baseline)==="bottom")gu=0;else if(eu==="top")gu=-1*au.height+au.ascender;else{if(eu!=="center")throw new TypeError("Invalid text.baseline property value",eu);gu=-1*au.height/2}Su.position.x=fu*uu+xu.xOffset,Su.position.y=gu*uu,Su.position.z=xu.zOffset,Su.scale.set(uu,-1*uu,uu)}},lookupFont:function(iu){return ll[iu]},updateGeometry:(JA={},XA={},ZA=/\\n/g,$A=/\\t/g,function(iu,eu){var tu=this.data;XA.font=eu,XA.lineHeight=tu.lineHeight&&isFinite(tu.lineHeight)?tu.lineHeight:eu.common.lineHeight,XA.text=tu.value.toString().replace(ZA,`
`).replace($A,"	"),XA.width=fl(tu.wrapPixels,tu.wrapCount,eu.widthFactor),iu.update(Jr(JA,tu,XA))})});var ml,El,Cl=(cs("tracked-controls",{schema:{id:{type:"string",default:""},controller:{default:-1},autoHide:{default:!0},hand:{type:"string",default:""},handTrackingEnabled:{default:!1},iterateControllerProfiles:{default:!1}},init:function(){this.buttonEventDetails={},this.buttonStates=this.el.components["tracked-controls"].buttonStates={},this.axis=this.el.components["tracked-controls"].axis=[0,0,0],this.changedAxes=[],this.axisMoveEventDetail={axis:this.axis,changed:this.changedAxes},this.updateController=this.updateController.bind(this)},update:function(){this.updateController()},play:function(){var iu=this.el.sceneEl;this.updateController(),iu.addEventListener("controllersupdated",this.updateController)},pause:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.updateController)},isControllerPresent:function(iu){return!(!this.controller||this.controller.gamepad||iu.inputSource.handedness!=="none"&&iu.inputSource.handedness!==this.data.hand)},updateController:function(){this.controller=Pr(this.system.controllers,this.data.id,this.data.hand,this.data.controller,this.data.iterateControllerProfiles,this.data.handTrackingEnabled),this.el.components["tracked-controls"].controller=this.controller},tick:function(){var iu=this.el.sceneEl,eu=this.controller,tu=iu.frame;this.data.autoHide&&(this.el.object3D.visible=!!eu),eu&&iu.frame&&this.system.referenceSpace&&(eu.hand||(this.pose=tu.getPose(eu.gripSpace,this.system.referenceSpace),this.updatePose(),this.updateButtons()))},updatePose:function(){var iu=this.el.object3D,eu=this.pose;eu&&(iu.matrix.elements=eu.transform.matrix,iu.matrix.decompose(iu.position,iu.rotation,iu.scale))},updateButtons:function(){var iu,eu,tu,su=this.controller;if(su&&su.gamepad){for(tu=su.gamepad,eu=0;eu<tu.buttons.length;++eu)this.buttonStates[eu]||(this.buttonStates[eu]={pressed:!1,touched:!1,value:0}),this.buttonEventDetails[eu]||(this.buttonEventDetails[eu]={id:eu,state:this.buttonStates[eu]}),iu=tu.buttons[eu],this.handleButton(eu,iu);this.handleAxes()}},handleButton:function(iu,eu){return!!(this.handlePress(iu,eu)|this.handleTouch(iu,eu)|this.handleValue(iu,eu))&&(this.el.emit("buttonchanged",this.buttonEventDetails[iu],!1),!0)},handleAxes:function(){var iu,eu=!1,tu=this.controller.gamepad.axes,su=this.axis,au=this.changedAxes;for(this.changedAxes.splice(0,this.changedAxes.length),iu=0;iu<tu.length;++iu)au.push(su[iu]!==tu[iu]),au[iu]&&(eu=!0);if(!eu)return!1;for(this.axis.splice(0,this.axis.length),iu=0;iu<tu.length;iu++)this.axis.push(tu[iu]);return this.el.emit("axismove",this.axisMoveEventDetail,!1),!0},handlePress:function(iu,eu){var tu,su=this.buttonStates[iu];return eu.pressed!==su.pressed&&(tu=eu.pressed?"buttondown":"buttonup",this.el.emit(tu,this.buttonEventDetails[iu],!1),su.pressed=eu.pressed,!0)},handleTouch:function(iu,eu){var tu,su=this.buttonStates[iu];return eu.touched!==su.touched&&(tu=eu.touched?"touchstart":"touchend",this.el.emit(tu,this.buttonEventDetails[iu],!1),su.touched=eu.touched,!0)},handleValue:function(iu,eu){var tu=this.buttonStates[iu];return eu.value!==tu.value&&(tu.value=eu.value,!0)}}),cs("visible",{schema:{default:!0},update:function(){this.el.object3D.visible=this.data}}),ci+"controllers/valve/index/valve-index-"),vl={left:Cl+"left.glb",right:Cl+"right.glb"},Bl="valve",bl={left:{x:0,y:-.05,z:.06},right:{x:0,y:-.05,z:.06}},yl={left:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"},right:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"}},Il=(cs("valve-index-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{trackpad:[0,1],thumbstick:[2,3]},buttons:["trigger","grip","trackpad","thumbstick","abutton"]},init:function(){var iu=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu)},this.previousButtonValues={},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("model-loaded",this.onModelLoaded),iu.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("model-loaded",this.onModelLoaded),iu.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.data,eu=iu.hand==="right"?0:iu.hand==="left"?1:2;Ur(this,Bl,{index:eu,iterateControllerProfiles:!0,hand:iu.hand})},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{idPrefix:Bl,controller:eu.hand==="right"?1:eu.hand==="left"?0:2,hand:eu.hand}),this.loadModel()},loadModel:function(){var iu=this.data;iu.model&&this.el.setAttribute("gltf-model",""+vl[iu.hand])},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu,tu=this.mapping.buttons[iu.detail.id],su=this.buttonMeshes;tu&&(tu==="trigger"&&(eu=iu.detail.state.value,su&&su.trigger&&(su.trigger.rotation.x=this.triggerOriginalRotationX-eu*(Math.PI/40))),this.el.emit(tu+"changed",iu.detail.state))},onModelLoaded:function(iu){var eu,tu=iu.detail.model,su=this;iu.target===this.el&&this.data.model&&((eu=this.buttonMeshes={}).grip={left:tu.getObjectByName("leftgrip"),right:tu.getObjectByName("rightgrip")},eu.menu=tu.getObjectByName("menubutton"),eu.system=tu.getObjectByName("systembutton"),eu.trackpad=tu.getObjectByName("touchpad"),eu.trigger=tu.getObjectByName("trigger"),this.triggerOriginalRotationX=eu.trigger.rotation.x,Object.keys(eu).forEach(function(au){su.setButtonColor(au,su.data.buttonColor)}),tu.position.copy(yl[this.data.hand]),tu.rotation.copy(bl[this.data.hand]),this.el.emit("controllermodelready",{name:"valve-index-controls",model:this.data.model,rayOrigin:new Re.Vector3(0,0,0)}))},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)},updateModel:function(iu,eu){var tu;this.data.model&&(eu.indexOf("touch")!==-1||(tu=eu==="up"?this.data.buttonColor:this.data.buttonHighlightColor,this.setButtonColor(iu,tu)))},setButtonColor:function(iu,eu){}}),ci+"controllers/vive/vr_controller_vive.obj"),wl=ci+"controllers/vive/vr_controller_vive.mtl",xl="htc-vive",Ql=(cs("vive-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","none"]},init:function(){var iu=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu)},this.previousButtonValues={},this.bindMethods()},update:function(){var iu=this.data;this.controllerIndex=iu.hand==="right"?0:iu.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("model-loaded",this.onModelLoaded),iu.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("model-loaded",this.onModelLoaded),iu.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var iu=this.data;Ur(this,xl,{index:this.controllerIndex,hand:iu.hand})},injectTrackedControls:function(){var iu=this.el,eu=this.data;iu.setAttribute("tracked-controls",{idPrefix:xl,hand:eu.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("obj-model",{obj:Il,mtl:wl})},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(iu){var eu,tu=this.mapping.buttons[iu.detail.id],su=this.buttonMeshes;tu&&(tu==="trigger"&&(eu=iu.detail.state.value,su&&su.trigger&&(su.trigger.rotation.x=-eu*(Math.PI/12))),this.el.emit(tu+"changed",iu.detail.state))},onModelLoaded:function(iu){var eu,tu=iu.detail.model,su=this;iu.target===this.el&&this.data.model&&((eu=this.buttonMeshes={}).grip={left:tu.getObjectByName("leftgrip"),right:tu.getObjectByName("rightgrip")},eu.menu=tu.getObjectByName("menubutton"),eu.system=tu.getObjectByName("systembutton"),eu.trackpad=tu.getObjectByName("touchpad"),eu.touchpad=tu.getObjectByName("touchpad"),eu.trigger=tu.getObjectByName("trigger"),Object.keys(eu).forEach(function(au){su.setButtonColor(au,su.data.buttonColor)}),tu.position.set(0,-.015,.04))},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)},updateModel:function(iu,eu){var tu;this.data.model&&(eu.indexOf("touch")!==-1||(tu=eu==="up"?this.data.buttonColor:this.data.buttonHighlightColor,this.setButtonColor(iu,tu)))},setButtonColor:function(iu,eu){var tu=this.buttonMeshes;if(tu)return iu==="grip"?(tu.grip.left.material.color.set(eu),void tu.grip.right.material.color.set(eu)):void tu[iu].material.color.set(eu)}}),ci+"controllers/vive/focus-controller/focus-controller.gltf"),Ll="htc-vive-focus",Ml=(cs("vive-focus-controls",{schema:{hand:{default:""},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad","none","menu"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var iu=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(eu){Nr(eu.detail.id,"down",iu)},this.onButtonUp=function(eu){Nr(eu.detail.id,"up",iu)},this.onButtonTouchStart=function(eu){Nr(eu.detail.id,"touchstart",iu)},this.onButtonTouchEnd=function(eu){Nr(eu.detail.id,"touchend",iu)},this.controllerPresent=!1,this.bindMethods()},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("model-loaded",this.onModelLoaded),iu.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0,this.addControllersUpdateListener()},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("model-loaded",this.onModelLoaded),iu.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1,this.removeControllersUpdateListener()},checkIfControllerPresent:function(){Ur(this,Ll,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){this.el.setAttribute("tracked-controls",{idPrefix:Ll}),this.data.model&&this.el.setAttribute("gltf-model",Ql)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(iu){var eu,tu=iu.detail.model;iu.target===this.el&&this.data.model&&((eu=this.buttonMeshes={}).trigger=tu.getObjectByName("BumperKey"),eu.triggerPressed=tu.getObjectByName("BumperKey_Press"),eu.triggerPressed&&(eu.triggerPressed.visible=!1),eu.touchpad=tu.getObjectByName("TouchPad"),eu.touchpadPressed=tu.getObjectByName("TouchPad_Press"),eu.trackpad=tu.getObjectByName("TouchPad"),eu.trackpadPressed=tu.getObjectByName("TouchPad_Press"),eu.trackpadPressed&&(eu.trackpadPressed.visible=!1))},onButtonChanged:function(iu){var eu=this.mapping.buttons[iu.detail.id];eu&&this.el.emit(eu+"changed",iu.detail.state)},onAxisMoved:function(iu){Gr(this,this.mapping.axes,iu)},updateModel:function(iu,eu){this.data.model&&this.updateButtonModel(iu,eu)},updateButtonModel:function(iu,eu){var tu=this.buttonMeshes,su=iu+"Pressed";if(tu&&tu[iu]&&tu[su]){var au;switch(eu){case"down":au=this.data.buttonHighlightColor;break;case"touchstart":au=this.data.buttonTouchedColor}au&&tu[su].material.color.set(au),tu[su].visible=!!au,tu[iu].visible=!au}}}),{38:"ArrowUp",37:"ArrowLeft",40:"ArrowDown",39:"ArrowRight",87:"KeyW",65:"KeyA",83:"KeyS",68:"KeyD"}),Sl=io,Dl=1e-5,kl=["KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowLeft","ArrowRight","ArrowDown"];cs("wasd-controls",{schema:{acceleration:{default:65},adAxis:{default:"x",oneOf:["x","y","z"]},adEnabled:{default:!0},adInverted:{default:!1},enabled:{default:!0},fly:{default:!1},wsAxis:{default:"z",oneOf:["x","y","z"]},wsEnabled:{default:!0},wsInverted:{default:!1}},after:["look-controls"],init:function(){this.keys={},this.easing=1.1,this.velocity=new Re.Vector3,this.onBlur=this.onBlur.bind(this),this.onContextMenu=this.onContextMenu.bind(this),this.onFocus=this.onFocus.bind(this),this.onKeyDown=this.onKeyDown.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onVisibilityChange=this.onVisibilityChange.bind(this),this.attachVisibilityEventListeners()},tick:function(iu,eu){var tu=this.data,su=this.el,au=this.velocity;(au[tu.adAxis]||au[tu.wsAxis]||!function(uu){var du;for(du in uu)return!1;return!0}(this.keys))&&(eu/=1e3,this.updateVelocity(eu),(au[tu.adAxis]||au[tu.wsAxis])&&su.object3D.position.add(this.getMovementVector(eu)))},update:function(iu){iu.adAxis!==this.data.adAxis&&(this.velocity[iu.adAxis]=0),iu.wsAxis!==this.data.wsAxis&&(this.velocity[iu.wsAxis]=0)},remove:function(){this.removeKeyEventListeners(),this.removeVisibilityEventListeners()},play:function(){this.attachKeyEventListeners()},pause:function(){this.keys={},this.removeKeyEventListeners()},updateVelocity:function(iu){var eu,tu,su,au,uu,du=this.data,fu=this.keys,gu=this.velocity;if(tu=du.adAxis,au=du.wsAxis,iu>.2)return gu[tu]=0,void(gu[au]=0);var yu=Math.pow(1/this.easing,60*iu);gu[tu]!==0&&(gu[tu]=gu[tu]*yu),gu[au]!==0&&(gu[au]=gu[au]*yu),Math.abs(gu[tu])<Dl&&(gu[tu]=0),Math.abs(gu[au])<Dl&&(gu[au]=0),du.enabled&&(eu=du.acceleration,du.adEnabled&&(su=du.adInverted?-1:1,(fu.KeyA||fu.ArrowLeft)&&(gu[tu]-=su*eu*iu),(fu.KeyD||fu.ArrowRight)&&(gu[tu]+=su*eu*iu)),du.wsEnabled&&(uu=du.wsInverted?-1:1,(fu.KeyW||fu.ArrowUp)&&(gu[au]-=uu*eu*iu),(fu.KeyS||fu.ArrowDown)&&(gu[au]+=uu*eu*iu)))},getMovementVector:(ml=new Re.Vector3(0,0,0),El=new Re.Euler(0,0,0,"YXZ"),function(iu){var eu,tu=this.el.getAttribute("rotation"),su=this.velocity;return ml.copy(su),ml.multiplyScalar(iu),tu&&(eu=this.data.fly?tu.x:0,El.set(Re.MathUtils.degToRad(eu),Re.MathUtils.degToRad(tu.y),0),ml.applyEuler(El)),ml}),attachVisibilityEventListeners:function(){window.oncontextmenu=this.onContextMenu,window.addEventListener("blur",this.onBlur),window.addEventListener("focus",this.onFocus),document.addEventListener("visibilitychange",this.onVisibilityChange)},removeVisibilityEventListeners:function(){window.removeEventListener("blur",this.onBlur),window.removeEventListener("focus",this.onFocus),document.removeEventListener("visibilitychange",this.onVisibilityChange)},attachKeyEventListeners:function(){window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp)},removeKeyEventListeners:function(){window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp)},onContextMenu:function(){for(var iu=Object.keys(this.keys),eu=0;eu<iu.length;eu++)delete this.keys[iu[eu]]},onBlur:function(){this.pause()},onFocus:function(){this.play()},onVisibilityChange:function(){document.hidden?this.onBlur():this.onFocus()},onKeyDown:function(iu){var eu;Sl(iu)&&(eu=iu.code||Ml[iu.keyCode],kl.indexOf(eu)!==-1&&(this.keys[eu]=!0))},onKeyUp:function(iu){var eu;eu=iu.code||Ml[iu.keyCode],delete this.keys[eu]}});var Tl,Rl,Fl,Ul=fi("components:windows-motion-controls:debug"),Ol=fi("components:windows-motion-controls:warn"),Pl=ci+"controllers/microsoft/",Gl={left:"left.glb",right:"right.glb",default:"universal.glb"},Nl="windows-mixed-reality",jl=(cs("windows-motion-controls",{schema:{hand:{default:"right"},pair:{default:0},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick","menu"],axisMeshNames:["TOUCHPAD_TOUCH_X","TOUCHPAD_TOUCH_X","THUMBSTICK_X","THUMBSTICK_Y"],buttonMeshNames:{trigger:"SELECT",menu:"MENU",squeeze:"GRASP",thumbstick:"THUMBSTICK_PRESS",touchpad:"TOUCHPAD_PRESS"},pointingPoseMeshName:"POINTING_POSE"},bindMethods:function(){this.onModelError=this.onModelError.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var iu=this,eu=this.el;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(tu){Nr(tu.detail.id,"down",iu)},this.onButtonUp=function(tu){Nr(tu.detail.id,"up",iu)},this.onButtonTouchStart=function(tu){Nr(tu.detail.id,"touchstart",iu)},this.onButtonTouchEnd=function(tu){Nr(tu.detail.id,"touchend",iu)},this.onControllerConnected=function(){iu.setModelVisibility(!0)},this.onControllerDisconnected=function(){iu.setModelVisibility(!1)},this.controllerPresent=!1,this.previousButtonValues={},this.bindMethods(),this.loadedMeshInfo={buttonMeshes:null,axisMeshes:null},this.rayOrigin={origin:new Re.Vector3,direction:new Re.Vector3(0,0,-1),createdFromMesh:!1},eu.addEventListener("controllerconnected",this.onControllerConnected),eu.addEventListener("controllerdisconnected",this.onControllerDisconnected)},addEventListeners:function(){var iu=this.el;iu.addEventListener("buttonchanged",this.onButtonChanged),iu.addEventListener("buttondown",this.onButtonDown),iu.addEventListener("buttonup",this.onButtonUp),iu.addEventListener("touchstart",this.onButtonTouchStart),iu.addEventListener("touchend",this.onButtonTouchEnd),iu.addEventListener("axismove",this.onAxisMoved),iu.addEventListener("model-error",this.onModelError),iu.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var iu=this.el;iu.removeEventListener("buttonchanged",this.onButtonChanged),iu.removeEventListener("buttondown",this.onButtonDown),iu.removeEventListener("buttonup",this.onButtonUp),iu.removeEventListener("touchstart",this.onButtonTouchStart),iu.removeEventListener("touchend",this.onButtonTouchEnd),iu.removeEventListener("axismove",this.onAxisMoved),iu.removeEventListener("model-error",this.onModelError),iu.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){Ur(this,Nl,{hand:this.data.hand,index:this.data.pair,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},updateControllerModel:function(){if(this.data.model&&!this.rayOrigin.createdFromMesh){var iu=this.createControllerModelUrl();this.loadModel(iu)}else this.modelReady()},createControllerModelUrl:function(iu){var eu=this.data.hand;return Pl+"default/"+(Gl[eu]||Gl.default)},injectTrackedControls:function(){var iu=this.data;this.el.setAttribute("tracked-controls",{idPrefix:Nl,controller:iu.pair,hand:iu.hand}),this.updateControllerModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelError:function(iu){var eu=this.createControllerModelUrl(!0);iu.detail.src!==eu?(Ol("Failed to load controller model for device, attempting to load default."),this.loadModel(eu)):Ol("Failed to load default controller model.")},loadModel:function(iu){this.el.setAttribute("gltf-model","url("+iu+")")},onModelLoaded:function(iu){var eu,tu,su,au,uu=this.controllerModel=iu.detail.model,du=this.loadedMeshInfo;if(iu.target===this.el){if(Ul("Processing model"),du.buttonMeshes={},du.axisMeshes={},uu){for(eu=0;eu<this.mapping.buttons.length;eu++)(tu=this.mapping.buttonMeshNames[this.mapping.buttons[eu]])?(su=uu.getObjectByName(tu))?(au={index:eu,value:fu(su,"VALUE"),pressed:fu(su,"PRESSED"),unpressed:fu(su,"UNPRESSED")}).value&&au.pressed&&au.unpressed?du.buttonMeshes[this.mapping.buttons[eu]]=au:Ol("Missing button submesh under mesh with name: "+tu+"(VALUE: "+!!au.value+", PRESSED: "+!!au.pressed+", UNPRESSED:"+!!au.unpressed+")"):Ol("Missing button mesh with name: "+tu):Ul("Skipping unknown button at index: "+eu+" with mapped name: "+this.mapping.buttons[eu]);for(eu=0;eu<this.mapping.axisMeshNames.length;eu++)(tu=this.mapping.axisMeshNames[eu])?(su=uu.getObjectByName(tu))?(au={index:eu,value:fu(su,"VALUE"),min:fu(su,"MIN"),max:fu(su,"MAX")}).value&&au.min&&au.max?du.axisMeshes[eu]=au:Ol("Missing axis submesh under mesh with name: "+tu+"(VALUE: "+!!au.value+", MIN: "+!!au.min+", MAX:"+!!au.max+")"):Ol("Missing axis mesh with name: "+tu):Ul("Skipping unknown axis at index: "+eu);this.calculateRayOriginFromMesh(uu),this.setModelVisibility()}Ul("Model load complete.")}function fu(gu,yu){for(var xu=0,vu=gu.children.length;xu<vu;xu++){var Su=gu.children[xu];if(Su&&Su.name===yu)return Su}}},calculateRayOriginFromMesh:function(){var iu=new Re.Quaternion;return function(eu){var tu;if(this.rayOrigin.origin.set(0,0,0),this.rayOrigin.direction.set(0,0,-1),this.rayOrigin.createdFromMesh=!0,tu=eu.getObjectByName(this.mapping.pointingPoseMeshName)){var su=eu.parent;su&&(eu.parent=null,eu.updateMatrixWorld(!0),eu.parent=su),tu.getWorldPosition(this.rayOrigin.origin),tu.getWorldQuaternion(iu),this.rayOrigin.direction.applyQuaternion(iu),su&&eu.updateMatrixWorld(!0)}else Ul("Mesh does not contain pointing origin data, defaulting to none.");this.modelReady()}}(),lerpAxisTransform:function(){var iu=new Re.Quaternion;return function(eu,tu){var su=this.loadedMeshInfo.axisMeshes[eu];if(su){var au=su.min,uu=su.max,du=su.value,fu=.5*tu+.5;du.setRotationFromQuaternion(iu.copy(au.quaternion).slerp(uu.quaternion,fu)),du.position.lerpVectors(au.position,uu.position,fu)}}}(),lerpButtonTransform:function(){var iu=new Re.Quaternion;return function(eu,tu){var su=this.loadedMeshInfo.buttonMeshes[eu];if(su){var au=su.unpressed,uu=su.pressed,du=su.value;du.setRotationFromQuaternion(iu.copy(au.quaternion).slerp(uu.quaternion,tu)),du.position.lerpVectors(au.position,uu.position,tu)}}}(),modelReady:function(){this.el.emit("controllermodelready",{name:"windows-motion-controls",model:this.data.model,rayOrigin:this.rayOrigin})},onButtonChanged:function(iu){var eu=this.mapping.buttons[iu.detail.id];eu&&(this.loadedMeshInfo&&this.loadedMeshInfo.buttonMeshes&&this.lerpButtonTransform(eu,iu.detail.state.value),this.el.emit(eu+"changed",iu.detail.state))},onAxisMoved:function(iu){var eu=this.mapping.axisMeshNames.length;if(this.loadedMeshInfo&&this.loadedMeshInfo.axisMeshes)for(var tu=0;tu<eu;tu++)this.lerpAxisTransform(tu,iu.detail.axis[tu]||0);Gr(this,this.mapping.axes,iu)},setModelVisibility:function(iu){var eu=this.el.getObject3D("mesh");this.controllerPresent&&(iu=iu!==void 0?iu:this.modelVisible,this.modelVisible=iu,eu&&(eu.visible=iu))}}),Tl=new Re.Quaternion,Rl=new Re.Vector3,function(iu,eu,tu){eu.position.copy(iu.transform.position),eu.quaternion.copy(iu.transform.orientation),Rl.copy(tu),Tl.copy(iu.transform.orientation),Rl.applyQuaternion(Tl),eu.position.sub(Rl)});function _l(iu,eu){this.renderer=iu,this.xrHitTestSource=null,iu.xr.addEventListener("sessionend",(function(){this.xrHitTestSource=null}).bind(this)),iu.xr.addEventListener("sessionstart",(function(){this.sessionStart(eu)}).bind(this)),this.renderer.xr.isPresenting&&this.sessionStart(eu)}function Hl(iu){console.warn(iu.message),console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?')}jl.tempFakePose={transform:{orientation:new Re.Quaternion,position:new Re.Vector3}},_l.prototype.previousFrameAnchors=new Set,_l.prototype.anchorToObject3D=new Map,_l.prototype.sessionStart=function(iu){this.session=this.renderer.xr.getSession(),"requestHitTestSource"in this.session?iu.space?this.session.requestHitTestSource(iu).then((function(eu){this.xrHitTestSource=eu}).bind(this)).catch(Hl):iu.profile&&this.session.requestHitTestSourceForTransientInput(iu).then((function(eu){this.xrHitTestSource=eu,this.transient=!0}).bind(this)).catch(Hl):Hl({message:"No requestHitTestSource on the session."})},_l.prototype.anchorFromLastHitTestResult=function(iu,eu){var tu=this.lastHitTest;if(tu){var su={object3D:iu,offset:eu};Array.from(this.anchorToObject3D.entries()).forEach((function(au){var uu=au[1].object3D,du=au[0];uu===iu&&(this.anchorToObject3D.delete(du),du.delete())}).bind(this)),tu.createAnchor&&tu.createAnchor().then((function(au){this.anchorToObject3D.set(au,su)}).bind(this)).catch(function(au){console.warn(au.message),console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?')})}},_l.prototype.doHit=function(iu){if(this.renderer.xr.isPresenting){var eu,tu,su=this.renderer.xr.getReferenceSpace(),au=iu.getViewerPose(su);return this.xrHitTestSource&&au?this.transient?(eu=iu.getHitTestResultsForTransientInput(this.xrHitTestSource)).length>0&&(tu=eu[0].results).length>0&&(this.lastHitTest=tu[0],tu[0].getPose(su)):(eu=iu.getHitTestResults(this.xrHitTestSource)).length>0&&(this.lastHitTest=eu[0],eu[0].getPose(su)):void 0}},_l.updateAnchorPoses=function(iu,eu){var tu=iu.trackedAnchors||_l.prototype.previousFrameAnchors;_l.prototype.previousFrameAnchors.forEach(function(su){tu.has(su)||_l.prototype.anchorToObject3D.delete(su)}),tu.forEach(function(su){var au,uu,du,fu;try{if(au=iu.getPose(su.anchorSpace,eu)){if(!(uu=_l.prototype.anchorToObject3D.get(su)))return;du=uu.offset,fu=uu.object3D,jl(au,fu,du)}}catch(gu){console.error("while updating anchor poses:",gu)}}),_l.prototype.previousFrameAnchors=tu},cs("ar-hit-test",{schema:{target:{type:"selector"},enabled:{default:!0},src:{default:"data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=",type:"map"},type:{default:"footprint",oneOf:["footprint","map"]},footprintDepth:{default:.1},mapSize:{type:"vec2",default:{x:.5,y:.5}}},sceneOnly:!0,init:function(){this.hitTest=null,this.imageDataArray=new Uint8ClampedArray(1048576),this.imageData=new ImageData(this.imageDataArray,512,512),this.textureCache=new Map,this.orthoCam=new Re.OrthographicCamera,this.orthoCam.layers.set(21),this.textureTarget=new Re.WebGLRenderTarget(512,512,{}),this.basicMaterial=new Re.MeshBasicMaterial({color:0,side:Re.DoubleSide}),this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.context.imageSmoothingEnabled=!1,this.canvas.width=512,this.canvas.height=512,this.canvasTexture=new Re.CanvasTexture(this.canvas,{alpha:!0}),this.canvasTexture.flipY=!1;var iu=this.el.getAttribute("webxr"),eu=iu.optionalFeatures;eu.includes("hit-test")&&eu.includes("anchors")||(eu.push("hit-test"),eu.push("anchors"),this.el.setAttribute("webxr",iu)),this.el.sceneEl.renderer.xr.addEventListener("sessionend",(function(){this.hitTest=null}).bind(this)),this.el.sceneEl.addEventListener("enter-vr",(function(){if(this.el.is("ar-mode")){var tu=this.el.sceneEl.renderer,su=this.session=tu.xr.getSession();this.hasPosedOnce=!1,this.bboxMesh.visible=!1,Fl||(Fl=new Map),su.requestReferenceSpace("viewer").then((function(fu){this.viewerHitTest=this.hitTest=new _l(tu,{space:fu}),this.el.emit("ar-hit-test-start")}).bind(this));var au=this;this.el.sceneEl.addEventListener("controllersupdated",function(){var fu=this.xrSession&&this.xrSession.inputSources;if(fu){for(var gu=0;gu<fu.length;++gu)if(fu[gu].targetRayMode==="tracked-pointer"){au.hitTest=new _l(tu,{space:fu[gu].targetRaySpace}),Fl.set(fu[gu],au.hitTest),au.viewerHitTest&&typeof au.viewerHitTest.cancel=="function"&&(au.viewerHitTest.cancel(),au.viewerHitTest=null);break}}});var uu="generic-touchscreen",du=new _l(tu,{profile:uu});su.addEventListener("selectstart",(function(fu){if(this.data.enabled===!0){var gu=fu.inputSource;this.bboxMesh.visible=!0,this.hasPosedOnce===!0&&(this.el.emit("ar-hit-test-select-start",{inputSource:gu,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),gu.profiles[0]===uu?this.hitTest=du:(this.hitTest=Fl.get(gu)||new _l(tu,{space:gu.targetRaySpace}),Fl.set(gu,this.hitTest)))}}).bind(this)),su.addEventListener("selectend",(function(fu){if(this.hitTest&&this.data.enabled===!0){var gu,yu=fu.inputSource;this.hasPosedOnce===!0&&(this.bboxMesh.visible=!1,this.data.target&&(gu=this.data.target.object3D)&&(jl.tempFakePose.transform.position.copy(this.bboxMesh.position),jl.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion),jl(jl.tempFakePose,gu,this.bboxOffset),gu.visible=!0,this.hitTest.anchorFromLastHitTestResult(gu,this.bboxOffset)),this.el.emit("ar-hit-test-select",{inputSource:yu,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),this.hitTest=null)}else this.hitTest=null}).bind(this))}}).bind(this)),this.bboxOffset=new Re.Vector3,this.update=this.update.bind(this),this.makeBBox()},update:function(){this.data.enabled===!1&&(this.hitTest=null,this.bboxMesh.visible=!1),this.data.target&&(this.data.target.object3D?(this.data.target.addEventListener("model-loaded",this.update),this.data.target.object3D.layers.enable(21),this.data.target.object3D.traverse(function(iu){iu.layers.enable(21)})):this.data.target.addEventListener("loaded",this.update,{once:!0})),this.bboxNeedsUpdate=!0},makeBBox:function(){var iu=new Re.PlaneGeometry(1,1),eu=new Re.MeshBasicMaterial({transparent:!0,color:16777215});iu.rotateX(-Math.PI/2),iu.rotateY(-Math.PI/2),this.bbox=new Re.Box3,this.bboxMesh=new Re.Mesh(iu,eu),this.el.setObject3D("ar-hit-test",this.bboxMesh),this.bboxMesh.visible=!1},updateFootprint:function(){var iu,eu,tu,su=this.el.sceneEl.renderer,au=su.xr.enabled;this.bboxMesh.material.map=this.canvasTexture,this.bboxMesh.material.needsUpdate=!0,this.orthoCam.rotation.set(-Math.PI/2,0,-Math.PI/2),this.orthoCam.position.copy(this.bboxMesh.position),this.orthoCam.position.y-=this.bboxMesh.scale.y/2,this.orthoCam.near=.1,this.orthoCam.far=this.orthoCam.near+this.data.footprintDepth*this.bboxMesh.scale.y,this.orthoCam.position.y+=this.orthoCam.far,this.orthoCam.right=this.bboxMesh.scale.z/2,this.orthoCam.left=-this.bboxMesh.scale.z/2,this.orthoCam.top=this.bboxMesh.scale.x/2,this.orthoCam.bottom=-this.bboxMesh.scale.x/2,this.orthoCam.updateProjectionMatrix(),eu=su.getRenderTarget(),su.setRenderTarget(this.textureTarget),su.xr.enabled=!1,tu=this.el.object3D.background,this.el.object3D.overrideMaterial=this.basicMaterial,this.el.object3D.background=null,su.render(this.el.object3D,this.orthoCam),this.el.object3D.background=tu,this.el.object3D.overrideMaterial=null,su.xr.enabled=au,su.setRenderTarget(eu),su.readRenderTargetPixels(this.textureTarget,0,0,512,512,this.imageDataArray),this.context.putImageData(this.imageData,0,0),this.context.shadowColor="white",this.context.shadowBlur=10,this.context.drawImage(this.canvas,0,0),iu=this.context.getImageData(0,0,512,512);for(var uu=0;uu<262144;uu++)iu.data[4*uu+3]!==0&&iu.data[4*uu+3]!==255&&(iu.data[4*uu+3]=128);this.context.putImageData(iu,0,0),this.canvasTexture.needsUpdate=!0},tick:function(){var iu,eu,tu=this.el.sceneEl.frame,su=this.el.sceneEl.renderer;tu&&_l.updateAnchorPoses(tu,su.xr.getReferenceSpace()),this.bboxNeedsUpdate&&(this.bboxNeedsUpdate=!1,this.data.target&&this.data.type!=="map"||(this.textureCache.has(this.data.src)?eu=this.textureCache.get(this.data.src):(eu=new Re.TextureLoader().load(this.data.src),this.textureCache.set(this.data.src,eu)),this.bboxMesh.material.map=eu,this.bboxMesh.material.needsUpdate=!0),this.data.target&&this.data.target.object3D?(this.bbox.setFromObject(this.data.target.object3D),this.bbox.getCenter(this.bboxMesh.position),this.bbox.getSize(this.bboxMesh.scale),this.data.type==="footprint"&&(this.bboxMesh.scale.x*=1.04,this.bboxMesh.scale.z*=1.04,this.updateFootprint()),this.bboxMesh.position.y-=this.bboxMesh.scale.y/2,this.bboxOffset.copy(this.bboxMesh.position),this.bboxOffset.sub(this.data.target.object3D.position)):this.bboxMesh.scale.set(this.data.mapSize.x,1,this.data.mapSize.y)),this.hitTest&&(iu=this.hitTest.doHit(tu))&&(this.hasPosedOnce!==!0&&(this.hasPosedOnce=!0,this.el.emit("ar-hit-test-achieved")),this.bboxMesh.visible=!0,this.bboxMesh.position.copy(iu.transform.position),this.bboxMesh.quaternion.copy(iu.transform.orientation))}}),cs("background",{schema:{color:{type:"color",default:"black"},transparent:{default:!1}},sceneOnly:!0,update:function(){var iu=this.data,eu=this.el.object3D;iu.transparent?eu.background=null:eu.background=new Re.Color(iu.color)},remove:function(){this.el.object3D.background=null}}),cs("debug",{schema:{default:!0},sceneOnly:!0});var ql="a-dialog-buttons-container",Vl="a-dialog-button";function zl(iu,eu){var tu,su,au,uu;return(tu=document.createElement("div")).classList.add("a-modal"),tu.setAttribute(hi,""),(su=document.createElement("div")).className="a-dialog",su.setAttribute(hi,""),tu.appendChild(su),(au=document.createElement("div")).classList.add("a-dialog-text-container"),su.appendChild(au),(uu=document.createElement("div")).classList.add("a-dialog-text"),uu.innerHTML=iu,au.appendChild(uu),su.appendChild(eu),tu}cs("device-orientation-permission-ui",{schema:{enabled:{default:!0},deviceMotionMessage:{default:"This immersive website requires access to your device motion sensors."},httpsMessage:{default:"Access this site over HTTPS to enter VR mode and grant access to the device sensors."},denyButtonText:{default:"Deny"},allowButtonText:{default:"Allow"},cancelButtonText:{default:"Cancel"}},sceneOnly:!0,init:function(){var iu=this;this.data.enabled&&(window.isSecureContext||this.showHTTPAlert(),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission?(this.onDeviceMotionDialogAllowClicked=this.onDeviceMotionDialogAllowClicked.bind(this),this.onDeviceMotionDialogDenyClicked=this.onDeviceMotionDialogDenyClicked.bind(this),DeviceOrientationEvent.requestPermission().then(function(){iu.el.emit("deviceorientationpermissiongranted"),iu.permissionGranted=!0}).catch(function(){var eu,tu,su,au,uu,du,fu,gu;iu.devicePermissionDialogEl=(eu=iu.data.denyButtonText,tu=iu.data.allowButtonText,su=iu.data.deviceMotionMessage,au=iu.onDeviceMotionDialogAllowClicked,uu=iu.onDeviceMotionDialogDenyClicked,(du=document.createElement("div")).classList.add(ql),(fu=document.createElement("button")).classList.add(Vl,"a-dialog-deny-button"),fu.setAttribute(hi,""),fu.innerHTML=eu,du.appendChild(fu),(gu=document.createElement("button")).classList.add(Vl,"a-dialog-allow-button"),gu.setAttribute(hi,""),gu.innerHTML=tu,du.appendChild(gu),gu.addEventListener("click",function(yu){yu.stopPropagation(),au()}),fu.addEventListener("click",function(yu){yu.stopPropagation(),uu()}),zl(su,du)),iu.el.appendChild(iu.devicePermissionDialogEl)})):this.permissionGranted=!0)},remove:function(){this.devicePermissionDialogEl&&this.el.removeChild(this.devicePermissionDialogEl)},onDeviceMotionDialogDenyClicked:function(){this.remove()},showHTTPAlert:function(){var iu,eu,tu,su,au,uu=this,du=(iu=uu.data.cancelButtonText,eu=uu.data.httpsMessage,tu=function(){uu.el.removeChild(du)},(su=document.createElement("div")).classList.add(ql),(au=document.createElement("button")).classList.add(Vl,"a-dialog-ok-button"),au.setAttribute(hi,""),au.innerHTML=iu,su.appendChild(au),au.addEventListener("click",function(fu){fu.stopPropagation(),tu()}),zl(eu,su));this.el.appendChild(du)},onDeviceMotionDialogAllowClicked:function(){var iu=this;this.el.emit("deviceorientationpermissionrequested"),DeviceOrientationEvent.requestPermission().then(function(eu){eu==="granted"?(iu.el.emit("deviceorientationpermissiongranted"),iu.permissionGranted=!0):iu.el.emit("deviceorientationpermissionrejected"),iu.remove()}).catch(console.error)}}),cs("embedded",{dependencies:["xr-mode-ui"],schema:{default:!0},sceneOnly:!0,update:function(){var iu=this.el,eu=iu.querySelector(".a-enter-vr");this.data===!0?(eu&&eu.classList.add("embedded"),iu.removeFullScreenStyles()):(eu&&eu.classList.remove("embedded"),iu.addFullScreenStyles())}});var Yl="https://unpkg.com/aframe-inspector@"+function(){var iu=ca.split(".");return iu[2]="x",iu.join(".")}()+"/dist/aframe-inspector.min.js";cs("inspector",{schema:{url:{default:Yl}},sceneOnly:!0,init:function(){this.firstPlay=!0,this.onKeydown=this.onKeydown.bind(this),this.onMessage=this.onMessage.bind(this),this.initOverlay(),window.addEventListener("keydown",this.onKeydown),window.addEventListener("message",this.onMessage)},play:function(){var iu;this.firstPlay&&(iu=so("inspector"))!=="false"&&iu&&(this.openInspector(),this.firstPlay=!1)},initOverlay:function(){this.loadingMessageEl=document.createElement("div"),this.loadingMessageEl.classList.add("a-inspector-loader"),this.loadingMessageEl.innerHTML='Loading Inspector<span class="dots"><span>.</span><span>.</span><span>.</span></span>'},remove:function(){this.removeEventListeners()},onKeydown:function(iu){iu.keyCode===73&&(iu.ctrlKey&&iu.altKey||iu.getModifierState("AltGraph"))&&this.openInspector()},showLoader:function(){document.body.appendChild(this.loadingMessageEl)},hideLoader:function(){document.body.removeChild(this.loadingMessageEl)},onMessage:function(iu){iu.data==="INJECT_AFRAME_INSPECTOR"&&this.openInspector()},openInspector:function(iu){var eu,tu=this;AFRAME.INSPECTOR||AFRAME.inspectorInjected?AFRAME.INSPECTOR.open(iu):(this.showLoader(),(eu=document.createElement("script")).src=this.data.url,eu.setAttribute("data-name","aframe-inspector"),eu.setAttribute(hi,""),eu.onload=function(){AFRAME.INSPECTOR.open(iu),tu.hideLoader(),tu.removeEventListeners()},eu.onerror=function(){tu.loadingMessageEl.innerHTML="Error loading Inspector"},document.head.appendChild(eu),AFRAME.inspectorInjected=!0)},removeEventListeners:function(){window.removeEventListener("keydown",this.onKeydown),window.removeEventListener("message",this.onMessage)}}),cs("fog",{schema:{color:{type:"color",default:"#000"},density:{default:25e-5},far:{default:1e3,min:0},near:{default:1,min:0},type:{default:"linear",oneOf:["linear","exponential"]}},sceneOnly:!0,update:function(){var iu=this.data,eu=this.el,tu=this.el.object3D.fog;tu&&iu.type===tu.name?Object.keys(this.schema).forEach(function(su){var au=iu[su];su==="color"&&(au=new Re.Color(au)),tu[su]=au}):eu.object3D.fog=function(su){var au;return(au=su.type==="exponential"?new Re.FogExp2(su.color,su.density):new Re.Fog(su.color,su.near,su.far)).name=su.type,au}(iu)},remove:function(){var iu=this.el;this.el.object3D.fog&&(iu.object3D.fog=null)}}),cs("keyboard-shortcuts",{schema:{enterVR:{default:!0},exitVR:{default:!0}},sceneOnly:!0,init:function(){this.onKeyup=this.onKeyup.bind(this)},play:function(){window.addEventListener("keyup",this.onKeyup,!1)},pause:function(){window.removeEventListener("keyup",this.onKeyup)},onKeyup:function(iu){var eu=this.el;io(iu)&&(this.data.enterVR&&iu.keyCode===70&&eu.enterVR(),this.data.exitVR&&iu.keyCode===27&&eu.exitVR())}});var Kl=fi("components:pool:warn");cs("pool",{schema:{container:{default:""},mixin:{default:""},size:{default:0},dynamic:{default:!1}},sceneOnly:!0,multiple:!0,initPool:function(){var iu;for(this.availableEls=[],this.usedEls=[],this.data.mixin||Kl("No mixin provided for pool component."),this.data.container&&(this.container=document.querySelector(this.data.container),this.container||Kl("Container "+this.data.container+" not found.")),this.container=this.container||this.el,iu=0;iu<this.data.size;++iu)this.createEntity()},update:function(iu){var eu=this.data;iu.mixin===eu.mixin&&iu.size===eu.size||this.initPool()},createEntity:function(){var iu;(iu=document.createElement("a-entity")).play=this.wrapPlay(iu.play),iu.setAttribute("mixin",this.data.mixin),iu.object3D.visible=!1,iu.pause(),this.container.appendChild(iu),this.availableEls.push(iu);var eu=this.usedEls;iu.addEventListener("loaded",function(){eu.indexOf(iu)===-1&&(iu.object3DParent=iu.object3D.parent,iu.object3D.parent.remove(iu.object3D))})},wrapPlay:function(iu){var eu=this.usedEls;return function(){eu.indexOf(this)!==-1&&iu.call(this)}},requestEntity:function(){var iu;if(this.availableEls.length===0){if(this.data.dynamic===!1)return void Kl("Requested entity from empty pool: "+this.attrName);Kl("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: "+this.attrName),this.createEntity()}return iu=this.availableEls.shift(),this.usedEls.push(iu),iu.object3DParent&&(iu.object3DParent.add(iu.object3D),this.updateRaycasters()),iu.object3D.visible=!0,iu},returnEntity:function(iu){var eu=this.usedEls.indexOf(iu);if(eu!==-1)return this.usedEls.splice(eu,1),this.availableEls.push(iu),iu.object3DParent=iu.object3D.parent,iu.object3D.parent.remove(iu.object3D),this.updateRaycasters(),iu.object3D.visible=!1,iu.pause(),iu;Kl("The returned entity was not previously pooled from "+this.attrName)},updateRaycasters:function(){document.querySelectorAll("[raycaster]").forEach(function(iu){iu.components.raycaster.setDirty()})}}),cs("real-world-meshing",{schema:{filterLabels:{type:"array"},meshesEnabled:{default:!0},meshMixin:{default:!0},planesEnabled:{default:!0},planeMixin:{default:""}},sceneOnly:!0,init:function(){var iu=this.el.getAttribute("webxr"),eu=iu.requiredFeatures;eu.indexOf("mesh-detection")===-1&&(eu.push("mesh-detection"),this.el.setAttribute("webxr",iu)),eu.indexOf("plane-detection")===-1&&(eu.push("plane-detection"),this.el.setAttribute("webxr",iu)),this.meshEntities=[],this.initWorldMeshEntity=this.initWorldMeshEntity.bind(this)},tick:function(){this.el.is("ar-mode")&&(this.detectMeshes(),this.updateMeshes())},detectMeshes:function(){var iu,eu,tu,su=this.data,au=this.el,uu=this.meshEntities,du=!1,fu=[],gu=this.data.filterLabels;iu=(tu=au.frame).detectedMeshes,eu=tu.detectedPlanes;for(var yu=0;yu<uu.length;yu++)uu[yu].present=!1;if(su.meshesEnabled){for(var xu of iu.values())if(!gu.length||gu.indexOf(xu.semanticLabel)!==-1){for(yu=0;yu<uu.length;yu++)if(xu===uu[yu].mesh){du=!0,uu[yu].present=!0,uu[yu].lastChangedTime<xu.lastChangedTime&&this.updateMeshGeometry(uu[yu].el,xu),uu[yu].lastChangedTime=xu.lastChangedTime;break}du||fu.push(xu),du=!1}}if(su.planesEnabled){for(xu of eu.values())if(!gu.length||gu.indexOf(xu.semanticLabel)!==-1){for(yu=0;yu<uu.length;yu++)if(xu===uu[yu].mesh){du=!0,uu[yu].present=!0,uu[yu].lastChangedTime<xu.lastChangedTime&&this.updateMeshGeometry(uu[yu].el,xu),uu[yu].lastChangedTime=xu.lastChangedTime;break}du||fu.push(xu),du=!1}}this.deleteMeshes(),this.createNewMeshes(fu)},updateMeshes:function(){var iu=new Re.Matrix4;return function(){for(var eu,tu,su,au=this.el,uu=au.frame,du=this.meshEntities,fu=au.renderer.xr.getReferenceSpace(),gu=0;gu<du.length;gu++)su=du[gu].mesh.meshSpace||du[gu].mesh.planeSpace,eu=uu.getPose(su,fu),(tu=du[gu].el).hasLoaded&&(iu.fromArray(eu.transform.matrix),iu.decompose(tu.object3D.position,tu.object3D.quaternion,tu.object3D.scale))}}(),deleteMeshes:function(){for(var iu=this.meshEntities,eu=[],tu=0;tu<iu.length;tu++)iu[tu].present?eu.push(iu[tu]):this.el.removeChild(iu[tu]);this.meshEntities=eu},createNewMeshes:function(iu){for(var eu,tu=0;tu<iu.length;tu++)eu=document.createElement("a-entity"),this.meshEntities.push({mesh:iu[tu],el:eu}),eu.addEventListener("loaded",this.initWorldMeshEntity),this.el.appendChild(eu)},initMeshGeometry:function(iu){var eu,tu,su;if(iu instanceof XRPlane){tu=new Re.Shape,su=iu.polygon;for(var au=0;au<su.length;++au)au===0?tu.moveTo(su[au].x,su[au].z):tu.lineTo(su[au].x,su[au].z);return(eu=new Re.ShapeGeometry(tu)).rotateX(Math.PI/2),eu}return(eu=new Re.BufferGeometry).setAttribute("position",new Re.BufferAttribute(iu.vertices,3)),eu.setIndex(new Re.BufferAttribute(iu.indices,1)),eu},initWorldMeshEntity:function(iu){for(var eu,tu,su,au=iu.target,uu=this.meshEntities,du=0;du<uu.length;du++)if(uu[du].el===au){su=uu[du];break}eu=this.initMeshGeometry(su.mesh),tu=new Re.Mesh(eu,new Re.MeshBasicMaterial({color:16777215*Math.random(),side:Re.DoubleSide})),au.setObject3D("mesh",tu),su.mesh instanceof XRPlane&&this.data.planeMixin?au.setAttribute("mixin",this.data.planeMixin):this.data.meshMixin&&au.setAttribute("mixin",this.data.meshMixin),au.setAttribute("data-world-mesh",su.mesh.semanticLabel)},updateMeshGeometry:function(iu,eu){var tu=iu.getObject3D("mesh");tu.geometry.dispose(),tu.geometry=this.initMeshGeometry(eu)}}),cs("reflection",{schema:{directionalLight:{type:"selector"}},sceneOnly:!0,init:function(){var iu=this;this.cubeRenderTarget=new Re.WebGLCubeRenderTarget(16),this.cubeCamera=new Re.CubeCamera(.1,1e3,this.cubeRenderTarget),this.lightingEstimationTexture=new Re.WebGLCubeRenderTarget(16).texture,this.needsVREnvironmentUpdate=!0;var eu=this.el.getAttribute("webxr"),tu=eu.optionalFeatures;tu.includes("light-estimation")||(tu.push("light-estimation"),this.el.setAttribute("webxr",eu)),this.el.addEventListener("enter-vr",function(){iu.el.is("ar-mode")&&iu.el.renderer.xr.getSession().requestLightProbe&&iu.startLightProbe()}),this.el.addEventListener("exit-vr",function(){iu.xrLightProbe&&iu.stopLightProbe()}),this.el.object3D.environment=this.cubeRenderTarget.texture},stopLightProbe:function(){this.xrLightProbe=null,this.probeLight&&(this.probeLight.components.light.light.intensity=0),this.needsVREnvironmentUpdate=!0,this.el.object3D.environment=this.cubeRenderTarget.texture},startLightProbe:function(){this.needsLightProbeUpdate=!0},setupLightProbe:function(){var iu=this.el.renderer,eu=iu.xr.getSession(),tu=this,su=iu.getContext();if(!this.probeLight){var au=document.createElement("a-light");au.setAttribute("type","probe"),au.setAttribute("intensity",0),this.el.appendChild(au),this.probeLight=au}switch(eu.preferredReflectionFormat){case"srgba8":su.getExtension("EXT_sRGB");break;case"rgba16f":su.getExtension("OES_texture_half_float")}this.glBinding=new XRWebGLBinding(eu,su),su.getExtension("EXT_sRGB"),su.getExtension("OES_texture_half_float"),eu.requestLightProbe().then(function(uu){tu.xrLightProbe=uu,uu.addEventListener("reflectionchange",tu.updateXRCubeMap.bind(tu))}).catch(function(uu){console.warn("Lighting estimation not supported: "+uu.message),console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?')})},updateXRCubeMap:function(){var iu=this.el.renderer,eu=this.glBinding.getReflectionCubeMap(this.xrLightProbe);eu&&(iu.properties.get(this.lightingEstimationTexture).__webglTexture=eu,this.lightingEstimationTexture.needsPMREMUpdate=!0,this.el.object3D.environment=this.lightingEstimationTexture)},tick:function(){var iu=this.el.object3D,eu=this.el.renderer,tu=this.el.frame;if(tu&&this.xrLightProbe){var su=tu.getLightEstimate(this.xrLightProbe);su&&function(au,uu,du,fu){var gu=Math.max(au.primaryLightIntensity.x,Math.max(au.primaryLightIntensity.y,au.primaryLightIntensity.z));uu.sh.fromArray(au.sphericalHarmonicsCoefficients),uu.intensity=3.14,du&&(du.color.setRGB(au.primaryLightIntensity.x/gu,au.primaryLightIntensity.y/gu,au.primaryLightIntensity.z/gu),du.intensity=gu,fu.copy(au.primaryLightDirection))}(su,this.probeLight.components.light.light,this.data.directionalLight&&this.data.directionalLight.components.light.light,this.data.directionalLight&&this.data.directionalLight.object3D.position)}this.needsVREnvironmentUpdate&&(iu.environment=null,this.needsVREnvironmentUpdate=!1,this.cubeCamera.position.set(0,1.6,0),this.cubeCamera.update(eu,iu),iu.environment=this.cubeRenderTarget.texture),this.needsLightProbeUpdate&&tu&&(this.setupLightProbe(),this.needsLightProbeUpdate=!1)},remove:function(){this.el.object3D.environment=null,this.probeLight&&this.el.removeChild(this.probeLight)}});var Wl=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),Jl=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join(`
`),Xl=(cs("screenshot",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"}},sceneOnly:!0,setup:function(){var iu=this.el;if(!this.canvas){var eu=iu.renderer.getContext();eu&&(this.cubeMapSize=eu.getParameter(eu.MAX_CUBE_MAP_TEXTURE_SIZE),this.material=new Re.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:Wl,fragmentShader:Jl,side:Re.DoubleSide}),this.quad=new Re.Mesh(new Re.PlaneGeometry(1,1),this.material),this.quad.visible=!1,this.camera=new Re.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4),this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),iu.object3D.add(this.quad),this.onKeyDown=this.onKeyDown.bind(this))}},getRenderTarget:function(iu,eu){return new Re.WebGLRenderTarget(iu,eu,{colorSpace:this.el.sceneEl.renderer.outputColorSpace,minFilter:Re.LinearFilter,magFilter:Re.LinearFilter,wrapS:Re.ClampToEdgeWrapping,wrapT:Re.ClampToEdgeWrapping,format:Re.RGBAFormat,type:Re.UnsignedByteType})},resize:function(iu,eu){this.quad.scale.set(iu,eu,1),this.camera.left=-1*iu/2,this.camera.right=iu/2,this.camera.top=eu/2,this.camera.bottom=-1*eu/2,this.camera.updateProjectionMatrix(),this.canvas.width=iu,this.canvas.height=eu},play:function(){window.addEventListener("keydown",this.onKeyDown)},onKeyDown:function(iu){var eu=iu.keyCode===83&&iu.ctrlKey&&iu.altKey;if(this.data&&eu){var tu=iu.shiftKey?"equirectangular":"perspective";this.capture(tu)}},setCapture:function(iu){var eu,tu,su,au,uu=this.el;return iu==="perspective"?(this.quad.visible=!1,tu=this.data.camera&&this.data.camera.components.camera.camera||uu.camera,eu={width:this.data.width,height:this.data.height}):(tu=this.camera,au=new Re.WebGLCubeRenderTarget(Math.min(this.cubeMapSize,2048),{format:Re.RGBFormat,generateMipmaps:!0,minFilter:Re.LinearMipmapLinearFilter,colorSpace:Re.SRGBColorSpace}),su=new Re.CubeCamera(uu.camera.near,uu.camera.far,au),uu.camera.getWorldPosition(su.position),uu.camera.getWorldQuaternion(su.quaternion),su.update(uu.renderer,uu.object3D),this.quad.material.uniforms.map.value=su.renderTarget.texture,eu={width:this.data.width,height:this.data.height},this.quad.visible=!0),{camera:tu,size:eu,projection:iu}},capture:function(iu){var eu,tu=this.el.renderer.xr.enabled,su=this.el.renderer;this.setup(),su.xr.enabled=!1,eu=this.setCapture(iu),this.renderCapture(eu.camera,eu.size,eu.projection),this.saveCapture(),su.xr.enabled=tu},getCanvas:function(iu){var eu=this.el.renderer.xr.enabled,tu=this.el.renderer;this.setup();var su=this.setCapture(iu);return tu.xr.enabled=!1,this.renderCapture(su.camera,su.size,su.projection),tu.xr.enabled=eu,this.canvas},renderCapture:function(iu,eu,tu){var su,au,uu,du=this.el.renderer.autoClear,fu=this.el,gu=fu.renderer;au=this.getRenderTarget(eu.width,eu.height),uu=new Uint8Array(4*eu.width*eu.height),this.resize(eu.width,eu.height),gu.autoClear=!0,gu.clear(),gu.setRenderTarget(au),gu.render(fu.object3D,iu),gu.autoClear=du,gu.readRenderTargetPixels(au,0,0,eu.width,eu.height,uu),gu.setRenderTarget(null),tu==="perspective"&&(uu=this.flipPixelsVertically(uu,eu.width,eu.height)),su=new ImageData(new Uint8ClampedArray(uu),eu.width,eu.height),this.quad.visible=!1,this.ctx.putImageData(su,0,0)},flipPixelsVertically:function(iu,eu,tu){for(var su=iu.slice(0),au=0;au<eu;++au)for(var uu=0;uu<tu;++uu)su[4*au+uu*eu*4]=iu[4*au+(tu-uu)*eu*4],su[4*au+1+uu*eu*4]=iu[4*au+1+(tu-uu)*eu*4],su[4*au+2+uu*eu*4]=iu[4*au+2+(tu-uu)*eu*4],su[4*au+3+uu*eu*4]=iu[4*au+3+(tu-uu)*eu*4];return su},saveCapture:function(){this.canvas.toBlob(function(iu){var eu="screenshot-"+document.title.toLowerCase()+"-"+Date.now()+".png",tu=document.createElement("a"),su=URL.createObjectURL(iu);tu.href=su,tu.setAttribute("download",eu),tu.innerHTML="downloading...",tu.style.display="none",document.body.appendChild(tu),setTimeout(function(){tu.click(),document.body.removeChild(tu)},1)},"image/png")}}),i$1(282)),Zl=i$1.n(Xl),$l=(i$1(3729),i$1(8132),window.aframeStats),ec="a-hidden",tc=window.threeStats;cs("stats",{schema:{default:!0},sceneOnly:!0,init:function(){var iu=this.el;so("stats")!=="false"&&(this.stats=function(eu){var tu=new tc(eu.renderer),su=new $l(eu),au=eu.isMobile?[]:[tu,su];return new(Zl())({css:[],values:{fps:{caption:"fps",below:30}},groups:[{caption:"Framerate",values:["fps","raf"]}],plugins:au})}(iu),this.statsEl=document.querySelector(".rs-base"),this.hideBound=this.hide.bind(this),this.showBound=this.show.bind(this),iu.addEventListener("enter-vr",this.hideBound),iu.addEventListener("exit-vr",this.showBound))},update:function(){if(this.stats)return this.data?this.show():this.hide()},remove:function(){this.el.removeEventListener("enter-vr",this.hideBound),this.el.removeEventListener("exit-vr",this.showBound),this.statsEl&&this.statsEl.parentNode.removeChild(this.statsEl)},tick:function(){var iu=this.stats;iu&&(iu("rAF").tick(),iu("FPS").frame(),iu().update())},hide:function(){this.statsEl.classList.add(ec)},show:function(){this.statsEl.classList.remove(ec)}});var nc="a-hidden";function ic(iu){iu.addEventListener("touchstart",function(){iu.classList.remove("resethover")},{passive:!0}),iu.addEventListener("touchend",function(){iu.classList.add("resethover")},{passive:!0})}cs("xr-mode-ui",{dependencies:["canvas"],schema:{enabled:{default:!0},enterVRButton:{default:""},enterVREnabled:{default:!0},enterARButton:{default:""},enterAREnabled:{default:!0},XRMode:{default:"vr",oneOf:["vr","ar","xr"]}},sceneOnly:!0,init:function(){var iu=this,eu=this.el;so("ui")!=="false"&&(this.insideLoader=!1,this.enterVREl=null,this.enterAREl=null,this.orientationModalEl=null,this.bindMethods(),eu.addEventListener("enter-vr",this.updateEnterInterfaces),eu.addEventListener("exit-vr",this.updateEnterInterfaces),eu.addEventListener("update-vr-devices",this.updateEnterInterfaces),window.addEventListener("message",function(tu){tu.data.type==="loaderReady"&&(iu.insideLoader=!0,iu.remove())}),window.addEventListener("orientationchange",this.toggleOrientationModalIfNeeded))},bindMethods:function(){this.onEnterVRButtonClick=this.onEnterVRButtonClick.bind(this),this.onEnterARButtonClick=this.onEnterARButtonClick.bind(this),this.onModalClick=this.onModalClick.bind(this),this.toggleOrientationModalIfNeeded=this.toggleOrientationModalIfNeeded.bind(this),this.updateEnterInterfaces=this.updateEnterInterfaces.bind(this)},onModalClick:function(){this.el.exitVR()},onEnterVRButtonClick:function(){this.el.enterVR()},onEnterARButtonClick:function(){this.el.enterAR()},update:function(){var iu,eu,tu,su=this.data,au=this.el;if(!su.enabled||this.insideLoader||so("ui")==="false")return this.remove();this.enterVREl||this.enterAREl||this.orientationModalEl||(this.enterVREl||!su.enterVREnabled||su.XRMode!=="xr"&&su.XRMode!=="vr"||(su.enterVRButton?(this.enterVREl=document.querySelector(su.enterVRButton),this.enterVREl.addEventListener("click",this.onEnterVRButtonClick)):(this.enterVREl=(iu=this.onEnterVRButtonClick,(tu=document.createElement("div")).classList.add("a-enter-vr"),tu.setAttribute(hi,""),(eu=document.createElement("button")).className="a-enter-vr-button",eu.setAttribute("title","Enter VR mode with a headset or fullscreen without"),eu.setAttribute(hi,""),Si()&&ic(eu),tu.appendChild(eu),eu.addEventListener("click",function(uu){iu(),uu.stopPropagation()}),tu),au.appendChild(this.enterVREl))),this.enterAREl||!su.enterAREnabled||su.XRMode!=="xr"&&su.XRMode!=="ar"||(su.enterARButton?(this.enterAREl=document.querySelector(su.enterARButton),this.enterAREl.addEventListener("click",this.onEnterARButtonClick)):(this.enterAREl=function(uu,du){var fu,gu;return(gu=document.createElement("div")).classList.add("a-enter-ar"),du&&gu.classList.add("xr"),gu.setAttribute(hi,""),(fu=document.createElement("button")).className="a-enter-ar-button",fu.setAttribute("title","Enter AR mode with a headset or handheld device."),fu.setAttribute(hi,""),Si()&&ic(fu),gu.appendChild(fu),fu.addEventListener("click",function(yu){uu(),yu.stopPropagation()}),gu}(this.onEnterARButtonClick,su.XRMode==="xr"),au.appendChild(this.enterAREl))),this.orientationModalEl=function(uu){var du=document.createElement("div");du.className="a-orientation-modal",du.classList.add(nc),du.setAttribute(hi,"");var fu=document.createElement("button");return fu.setAttribute(hi,""),fu.innerHTML="Exit VR",fu.addEventListener("click",uu),du.appendChild(fu),du}(this.onModalClick),au.appendChild(this.orientationModalEl),this.updateEnterInterfaces())},remove:function(){[this.enterVREl,this.enterAREl,this.orientationModalEl].forEach(function(iu){iu&&iu.parentNode&&iu.parentNode.removeChild(iu)}),this.enterVREl=void 0,this.enterAREl=void 0,this.orientationModalEl=void 0},updateEnterInterfaces:function(){this.toggleEnterVRButtonIfNeeded(),this.toggleEnterARButtonIfNeeded(),this.toggleOrientationModalIfNeeded()},toggleEnterVRButtonIfNeeded:function(){var iu=this.el;this.enterVREl&&(iu.is("vr-mode")||(iu.isMobile||Fi())&&!Qi()?this.enterVREl.classList.add(nc):(Qi()||this.enterVREl.classList.add("fullscreen"),this.enterVREl.classList.remove(nc),iu.enterVR(!1,!0)))},toggleEnterARButtonIfNeeded:function(){var iu=this.el;this.enterAREl&&(iu.is("vr-mode")||!xi()?this.enterAREl.classList.add(nc):(this.enterAREl.classList.remove(nc),iu.enterVR(!0,!0)))},toggleOrientationModalIfNeeded:function(){var iu=this.el,eu=this.orientationModalEl;eu&&iu.isMobile&&(!Ni()&&iu.is("vr-mode")?eu.classList.remove(nc):eu.classList.add(nc))}}),qs("box",{schema:{depth:{default:1,min:0},height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"},segmentsDepth:{default:1,min:1,max:20,type:"int"}},init:function(iu){this.geometry=new Re.BoxGeometry(iu.width,iu.height,iu.depth,iu.segmentsWidth,iu.segmentsHeight,iu.segmentsDepth)}});var rc=Re.MathUtils.degToRad;qs("circle",{schema:{radius:{default:1,min:0},segments:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(iu){this.geometry=new Re.CircleGeometry(iu.radius,iu.segments,rc(iu.thetaStart),rc(iu.thetaLength))}});var oc=Re.MathUtils.degToRad;qs("cone",{schema:{height:{default:1,min:0},openEnded:{default:!1},radiusBottom:{default:1,min:0},radiusTop:{default:.01,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(iu){this.geometry=new Re.CylinderGeometry(iu.radiusTop,iu.radiusBottom,iu.height,iu.segmentsRadial,iu.segmentsHeight,iu.openEnded,oc(iu.thetaStart),oc(iu.thetaLength))}});var sc=Re.MathUtils.degToRad;qs("cylinder",{schema:{height:{default:1,min:0},openEnded:{default:!1},radius:{default:1,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(iu){this.geometry=new Re.CylinderGeometry(iu.radius,iu.radius,iu.height,iu.segmentsRadial,iu.segmentsHeight,iu.openEnded,sc(iu.thetaStart),sc(iu.thetaLength))}}),qs("dodecahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(iu){this.geometry=new Re.DodecahedronGeometry(iu.radius,iu.detail)}}),qs("icosahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(iu){this.geometry=new Re.IcosahedronGeometry(iu.radius,iu.detail)}}),qs("octahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(iu){this.geometry=new Re.OctahedronGeometry(iu.radius,iu.detail)}}),qs("plane",{schema:{height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"}},init:function(iu){this.geometry=new Re.PlaneGeometry(iu.width,iu.height,iu.segmentsWidth,iu.segmentsHeight)}});var ac=Re.MathUtils.degToRad;qs("ring",{schema:{radiusInner:{default:.8,min:0},radiusOuter:{default:1.2,min:0},segmentsPhi:{default:10,min:1,type:"int"},segmentsTheta:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(iu){this.geometry=new Re.RingGeometry(iu.radiusInner,iu.radiusOuter,iu.segmentsTheta,iu.segmentsPhi,ac(iu.thetaStart),ac(iu.thetaLength))}});var Ac=Re.MathUtils.degToRad;qs("sphere",{schema:{radius:{default:1,min:0},phiLength:{default:360},phiStart:{default:0,min:0},thetaLength:{default:180,min:0},thetaStart:{default:0},segmentsHeight:{default:18,min:2,type:"int"},segmentsWidth:{default:36,min:3,type:"int"}},init:function(iu){this.geometry=new Re.SphereGeometry(iu.radius,iu.segmentsWidth,iu.segmentsHeight,Ac(iu.phiStart),Ac(iu.phiLength),Ac(iu.thetaStart),Ac(iu.thetaLength))}}),qs("tetrahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(iu){this.geometry=new Re.TetrahedronGeometry(iu.radius,iu.detail)}});var lc=Re.MathUtils.degToRad;qs("torus",{schema:{arc:{default:360},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:36,min:2,type:"int"},segmentsTubular:{default:32,min:3,type:"int"}},init:function(iu){this.geometry=new Re.TorusGeometry(iu.radius,2*iu.radiusTubular,iu.segmentsRadial,iu.segmentsTubular,lc(iu.arc))}}),qs("torusKnot",{schema:{p:{default:2,min:1},q:{default:3,min:1},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:8,min:3,type:"int"},segmentsTubular:{default:100,min:3,type:"int"}},init:function(iu){this.geometry=new Re.TorusKnotGeometry(iu.radius,2*iu.radiusTubular,iu.segmentsTubular,iu.segmentsRadial,iu.p,iu.q)}});var cc=new Re.Quaternion,hc=new Re.Vector3(0,0,1),dc=new Re.Vector2,uc=new Re.Vector2,gc=new Re.Vector2;function pc(iu,eu){return eu.color.set(iu.color),eu.fog=iu.fog,eu.wireframe=iu.wireframe,eu.toneMapped=iu.toneMapped,eu.wireframeLinewidth=iu.wireframeLinewidth,eu}function fc(iu,eu){return eu.color.set(iu.color),eu.emissive.set(iu.emissive),eu.emissiveIntensity=iu.emissiveIntensity,eu.fog=iu.fog,eu.metalness=iu.metalness,eu.roughness=iu.roughness,eu.wireframe=iu.wireframe,eu.wireframeLinewidth=iu.wireframeLinewidth,iu.normalMap&&(eu.normalScale=iu.normalScale),iu.ambientOcclusionMap&&(eu.aoMapIntensity=iu.ambientOcclusionMapIntensity),iu.displacementMap&&(eu.displacementScale=iu.displacementScale,eu.displacementBias=iu.displacementBias),eu}function mc(iu,eu){switch(eu.color.set(iu.color),eu.specular.set(iu.specular),eu.emissive.set(iu.emissive),eu.emissiveIntensity=iu.emissiveIntensity,eu.fog=iu.fog,eu.transparent=iu.transparent,eu.wireframe=iu.wireframe,eu.wireframeLinewidth=iu.wireframeLinewidth,eu.shininess=iu.shininess,eu.flatShading=iu.flatShading,eu.wireframe=iu.wireframe,eu.wireframeLinewidth=iu.wireframeLinewidth,eu.reflectivity=iu.reflectivity,eu.refractionRatio=iu.refractionRatio,iu.combine){case"mix":eu.combine=Re.MixOperation;break;case"multiply":eu.combine=Re.MultiplyOperation;break;case"add":eu.combine=Re.AddOperation}return iu.normalMap&&(eu.normalScale=iu.normalScale),iu.ambientOcclusionMap&&(eu.aoMapIntensity=iu.ambientOcclusionMapIntensity),iu.bumpMap&&(eu.bumpScale=iu.bumpMapScale),iu.displacementMap&&(eu.displacementScale=iu.displacementScale,eu.displacementBias=iu.displacementBias),eu}qs("triangle",{schema:{vertexA:{type:"vec3",default:{x:0,y:.5,z:0}},vertexB:{type:"vec3",default:{x:-.5,y:-.5,z:0}},vertexC:{type:"vec3",default:{x:.5,y:-.5,z:0}}},init:function(iu){var eu,tu,su,au,uu,du,fu,gu,yu;(su=new Re.Triangle).a.set(iu.vertexA.x,iu.vertexA.y,iu.vertexA.z),su.b.set(iu.vertexB.x,iu.vertexB.y,iu.vertexB.z),su.c.set(iu.vertexC.x,iu.vertexC.y,iu.vertexC.z),tu=su.getNormal(new Re.Vector3),cc.setFromUnitVectors(tu,hc),au=su.a.clone().applyQuaternion(cc),uu=su.b.clone().applyQuaternion(cc),du=su.c.clone().applyQuaternion(cc),dc.set(Math.min(au.x,uu.x,du.x),Math.min(au.y,uu.y,du.y)),uc.set(Math.max(au.x,uu.x,du.x),Math.max(au.y,uu.y,du.y)),gc.set(0,0).subVectors(uc,dc),au=new Re.Vector2().subVectors(au,dc).divide(gc),uu=new Re.Vector2().subVectors(uu,dc).divide(gc),du=new Re.Vector2().subVectors(du,dc).divide(gc),eu=this.geometry=new Re.BufferGeometry,fu=[su.a.x,su.a.y,su.a.z,su.b.x,su.b.y,su.b.z,su.c.x,su.c.y,su.c.z],gu=[tu.x,tu.y,tu.z,tu.x,tu.y,tu.z,tu.x,tu.y,tu.z],yu=[au.x,au.y,uu.x,uu.y,du.x,du.y],eu.setAttribute("position",new Re.Float32BufferAttribute(fu,3)),eu.setAttribute("normal",new Re.Float32BufferAttribute(gu,3)),eu.setAttribute("uv",new Re.Float32BufferAttribute(yu,2))}}),ia("flat",{schema:{color:{type:"color"},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},wireframe:{default:!1},wireframeLinewidth:{default:2},toneMapped:{default:!0}},init:function(iu){this.materialData={color:new Re.Color},pc(iu,this.materialData),this.material=new Re.MeshBasicMaterial(this.materialData)},update:function(iu){this.updateMaterial(iu),vr(this,iu)},updateMaterial:function(iu){var eu;for(eu in pc(iu,this.materialData),this.materialData)this.material[eu]=this.materialData[eu]}}),ia("standard",{schema:{ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},ambientOcclusionTextureOffset:{type:"vec2"},ambientOcclusionTextureRepeat:{type:"vec2",default:{x:1,y:1}},color:{type:"color"},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},emissive:{type:"color",default:"#000"},emissiveIntensity:{default:1},envMap:{default:""},fog:{default:!0},metalness:{default:0,min:0,max:1},metalnessMap:{type:"map"},metalnessTextureOffset:{type:"vec2"},metalnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},roughness:{default:.5,min:0,max:1},roughnessMap:{type:"map"},roughnessTextureOffset:{type:"vec2"},roughnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},sphericalEnvMap:{type:"map"},src:{type:"map"},wireframe:{default:!1},wireframeLinewidth:{default:2}},init:function(iu){this.materialData={color:new Re.Color,emissive:new Re.Color},fc(iu,this.materialData),this.material=new Re.MeshStandardMaterial(this.materialData)},update:function(iu){this.updateMaterial(iu),vr(this,iu),Br("normal",this,iu),Br("displacement",this,iu),Br("ambientOcclusion",this,iu),Br("metalness",this,iu),Br("roughness",this,iu),yr(this,iu)},updateMaterial:function(iu){var eu,tu=this.material;for(eu in fc(iu,this.materialData),this.materialData)tu[eu]=this.materialData[eu]}}),ia("phong",{schema:{color:{type:"color"},emissive:{type:"color",default:"black"},emissiveIntensity:{default:1},specular:{type:"color",default:"#111111"},transparent:{default:!1},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},envMap:{default:""},sphericalEnvMap:{type:"map"},shininess:{default:30},flatShading:{default:!1},wireframe:{default:!1},wireframeLinewidth:{default:2},combine:{oneOF:["multiply","mix","add"],default:"mix"},reflectivity:{default:.9},refractionRatio:{default:.98},refract:{default:!1},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},bumpMap:{type:"map"},bumpMapScale:{default:1},bumpTextureOffset:{type:"vec2"},bumpTextureRepeat:{type:"vec2",default:{x:1,y:1}}},init:function(iu){this.materialData={color:new Re.Color,specular:new Re.Color,emissive:new Re.Color},mc(iu,this.materialData),this.material=new Re.MeshPhongMaterial(this.materialData);var eu=this.el.sceneEl;Object.defineProperty(this.material,"envMap",{get:function(){return this._envMap||eu.object3D.environment},set:function(tu){this._envMap=tu}})},update:function(iu){this.updateMaterial(iu),vr(this,iu),Br("normal",this,iu),Br("displacement",this,iu),Br("ambientOcclusion",this,iu),Br("bump",this,iu),yr(this,iu)},updateMaterial:function(iu){var eu;for(eu in mc(iu,this.materialData),this.materialData)this.material[eu]=this.materialData[eu]}}),ia("sdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},opacity:{type:"number",is:"uniform",default:1}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float contour(float width, float value) {","  return smoothstep(0.5 - value, 0.5 + value, width);","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec2 uv = vUV;","  vec4 texColor = texture(map, uv);","  float dist = texColor.a;","  float width = fwidth(dist);","  float alpha = contour(dist, width);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * dist;","  }","  if (isBigEnough <= BIG_ENOUGH) {","    vec4 box = vec4 (uv - duv, uv + duv);","    alpha = (alpha + 0.5 * (","      contour(texture(map, box.xy).a, width)","      + contour(texture(map, box.zw).a, width)","      + contour(texture(map, box.xw).a, width)","      + contour(texture(map, box.zy).a, width)","    )) / 3.0;","  }","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color, opacity * alpha);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join(`
`),init:function(){return this.uniforms=this.initUniforms(),Re.UniformsUtils&&(this.uniforms=Re.UniformsUtils.merge([Re.UniformsLib.fog,this.uniforms])),this.material=new Re.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}}),ia("msdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},negate:{type:"boolean",is:"uniform",default:!0},opacity:{type:"number",is:"uniform",default:1}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform bool negate;","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float median(float r, float g, float b) {","  return max(min(r, g), min(max(r, g), b));","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec3 sampleColor = texture(map, vUV).rgb;","  if (negate) { sampleColor = 1.0 - sampleColor; }","  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;","  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  // Do modified alpha test.","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);","  }","  // Do modified alpha test.","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color.xyz, alpha * opacity);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join(`
`),init:function(){return this.uniforms=this.initUniforms(),Re.UniformsUtils&&(this.uniforms=Re.UniformsUtils.merge([Re.UniformsLib.fog,this.uniforms])),this.material=new Re.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}}),ia("shadow",{schema:{opacity:{default:.5},transparent:{default:!0},alphaToCoverage:{default:!0}},init:function(iu){this.material=new Re.ShadowMaterial},update:function(iu){this.material.opacity=iu.opacity,this.material.alphaToCoverage=iu.alphaToCoverage,this.material.transparent=iu.transparent}});var Ec="data-aframe-default-camera";function Cc(iu){var eu=iu.primitive,tu=js[eu]&&js[eu].Geometry,su=new tu;if(!tu)throw new Error("Unknown geometry `"+eu+"`");return su.init(iu),su.geometry}Es("camera",{init:function(){this.activeCameraEl=null,this.render=this.render.bind(this),this.unwrapRender=this.unwrapRender.bind(this),this.wrapRender=this.wrapRender.bind(this),this.initialCameraFound=!1,this.numUserCameras=0,this.numUserCamerasChecked=0,this.setupInitialCamera()},setupInitialCamera:function(){var iu,eu,tu=this.sceneEl,su=this;if(!tu.camera||tu.camera.el.getAttribute("camera").spectator)if((iu=tu.querySelectorAll("a-camera, :not(a-mixin)[camera]")).length)for(this.numUserCameras=iu.length,eu=0;eu<iu.length;eu++)iu[eu].addEventListener("object3dset",function(au){au.detail.type==="camera"&&su.checkUserCamera(this)}),iu[eu].isANode?iu[eu].load():iu[eu].addEventListener("nodeready",function(){this.load()});else this.createDefaultCamera();else tu.emit("cameraready",{cameraEl:tu.camera.el})},checkUserCamera:function(iu){var eu,tu=this.el.sceneEl;this.numUserCamerasChecked++,this.initialCameraFound||((eu=iu.getAttribute("camera")).active&&!eu.spectator?(this.initialCameraFound=!0,tu.camera=iu.getObject3D("camera"),tu.emit("cameraready",{cameraEl:iu})):this.numUserCamerasChecked===this.numUserCameras&&this.createDefaultCamera())},createDefaultCamera:function(){var iu,eu=this.sceneEl;(iu=document.createElement("a-entity")).setAttribute("camera",{active:!0}),iu.setAttribute("position",{x:0,y:1.6,z:0}),iu.setAttribute("wasd-controls",""),iu.setAttribute("look-controls",""),iu.setAttribute(hi,""),iu.addEventListener("object3dset",function(tu){tu.detail.type==="camera"&&(eu.camera=tu.detail.object,eu.emit("cameraready",{cameraEl:iu}))}),eu.appendChild(iu)},disableActiveCamera:function(){var iu;(iu=this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"))[iu.length-1].setAttribute("camera","active",!0)},setActiveCamera:function(iu){var eu,tu,su,au,uu=this.activeCameraEl,du=this.sceneEl;if((au=iu.getObject3D("camera"))&&iu!==this.activeCameraEl){var fu=du.querySelector("["+Ec+"]");for(iu!==(fu&&fu.querySelector(":not(a-mixin)[camera]"))&&function(gu){var yu;gu.camera&&(yu=gu.querySelector("["+Ec+"]"))&&gu.removeChild(yu)}(du),this.activeCameraEl=iu,this.activeCameraEl.play(),du.camera=au,uu&&uu.setAttribute("camera","active",!1),tu=du.querySelectorAll(":not(a-mixin)[camera]"),su=0;su<tu.length;su++)(eu=tu[su]).isEntity&&iu!==eu&&(eu.setAttribute("camera","active",!1),eu.pause());du.emit("camera-set-active",{cameraEl:iu})}},setSpectatorCamera:function(iu){var eu,tu=this.spectatorCameraEl,su=this.sceneEl;iu.getObject3D("camera")&&iu!==this.spectatorCameraEl&&(tu&&tu.setAttribute("camera","spectator",!1),eu=this.spectatorCameraEl=iu,su.addEventListener("enter-vr",this.wrapRender),su.addEventListener("exit-vr",this.unwrapRender),eu.setAttribute("camera","active",!1),eu.play(),su.emit("camera-set-spectator",{cameraEl:iu}))},disableSpectatorCamera:function(){this.spectatorCameraEl=void 0},wrapRender:function(){this.spectatorCameraEl&&!this.originalRender&&(this.originalRender=this.sceneEl.renderer.render,this.sceneEl.renderer.render=this.render)},unwrapRender:function(){this.originalRender&&(this.sceneEl.renderer.render=this.originalRender,this.originalRender=void 0)},render:function(iu,eu){var tu,su,au=this.sceneEl;tu=au.renderer.xr.enabled,this.originalRender.call(au.renderer,iu,eu),this.spectatorCameraEl&&!au.isMobile&&tu&&(su=this.spectatorCameraEl.components.camera.camera,au.renderer.xr.enabled=!1,this.originalRender.call(au.renderer,iu,su),au.renderer.xr.enabled=tu)}}),Es("geometry",{init:function(){this.cache={},this.cacheCount={}},clearCache:function(){this.cache={},this.cacheCount={}},getOrCreateGeometry:function(iu){var eu,tu,su=this.cache;return iu.skipCache?Cc(iu):(eu=su[tu=this.hash(iu)],function(au,uu){au[uu]=au[uu]===void 0?1:au[uu]+1}(this.cacheCount,tu),eu||(eu=Cc(iu),su[tu]=eu,eu))},unuseGeometry:function(iu){var eu,tu=this.cache,su=this.cacheCount;iu.skipCache||tu[eu=this.hash(iu)]&&(function(au,uu){au[uu]--}(su,eu),su[eu]>0||(tu[eu].dispose(),delete tu[eu],delete su[eu]))},hash:function(iu){return JSON.stringify(iu)}}),Es("gltf-model",{schema:{dracoDecoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.5.7/"},basisTranscoderPath:{default:""},meshoptDecoderPath:{default:""}},init:function(){this.update()},update:function(){var iu=this.data.dracoDecoderPath,eu=this.data.basisTranscoderPath,tu=this.data.meshoptDecoderPath;!this.dracoLoader&&iu&&(this.dracoLoader=new Ue,this.dracoLoader.setDecoderPath(iu)),!this.ktx2Loader&&eu&&(this.ktx2Loader=new Bn,this.ktx2Loader.setTranscoderPath(eu).detectSupport(this.el.renderer)),!this.meshoptDecoder&&tu&&(this.meshoptDecoder=function(su){return new Promise(function(au,uu){var du=document.createElement("script");document.body.appendChild(du),du.onload=au,du.onerror=uu,du.async=!0,du.src=su})}(tu).then(function(){return window.MeshoptDecoder.ready}).then(function(){return window.MeshoptDecoder}))},getDRACOLoader:function(){return this.dracoLoader},getKTX2Loader:function(){return this.ktx2Loader},getMeshoptDecoder:function(){return this.meshoptDecoder}});var vc="data-aframe-default-light",Bc=(Es("light",{schema:{defaultLightsEnabled:{default:!0}},init:function(){this.defaultLights=!1,this.userDefinedLights=!1,this.sceneEl.addEventListener("loaded",this.setupDefaultLights.bind(this))},registerLight:function(iu){iu.hasAttribute(vc)||(this.removeDefaultLights(),this.userDefinedLights=!0)},removeDefaultLights:function(){var iu,eu=this.sceneEl;if(this.defaultLights){iu=document.querySelectorAll("["+vc+"]");for(var tu=0;tu<iu.length;tu++)eu.removeChild(iu[tu]);this.defaultLights=!1}},setupDefaultLights:function(){var iu,eu,tu=this.sceneEl;this.userDefinedLights||this.defaultLights||!this.data.defaultLightsEnabled||((iu=document.createElement("a-entity")).setAttribute("light",{color:"#BBB",type:"ambient"}),iu.setAttribute(vc,""),iu.setAttribute(hi,""),tu.appendChild(iu),(eu=document.createElement("a-entity")).setAttribute("light",{color:"#FFF",intensity:1.884,castShadow:!0}),eu.setAttribute("position",{x:-.5,y:1,z:1}),eu.setAttribute(vc,""),eu.setAttribute(hi,""),tu.appendChild(eu),this.defaultLights=!0)}}),fi),bc=Bc("components:texture:error"),yc=Bc("components:texture:warn"),Ic=new Re.ImageLoader;Es("material",{init:function(){this.materials={},this.sourceCache={}},clearTextureSourceCache:function(){this.sourceCache={}},loadTexture:function(iu,eu,tu){this.loadTextureSource(iu,function(su){var au=xr(su);Er(au,eu),tu(au)})},loadTextureSource:function(iu,eu){var tu=this,su=this.sourceCache,au=this.hash(iu);function uu(du){su[au]=Promise.resolve(du),su[au].then(eu)}su[au]?su[au].then(eu):iu.tagName!=="CANVAS"?uu(new Promise(function(du,fu){hr(iu,function(gu){tu.loadImage(gu,du)},function(gu){tu.loadVideo(gu,du)})})):uu(new Re.Source(iu))},loadCubeMapTexture:function(iu,eu){var tu=this,su=0,au=new Re.CubeTexture;function uu(fu){tu.loadTextureSource(iu[fu],function(gu){au.images[fu]=gu.data,++su==6&&(au.needsUpdate=!0,eu(au))})}if(au.colorSpace=Re.SRGBColorSpace,iu.length===6)for(var du=0;du<iu.length;du++)uu(du);else yc("Cube map texture requires exactly 6 sources, got only %s sources",iu.length)},loadImage:function(iu,eu){eu(typeof iu=="string"?function(tu){return new Promise(function(su,au){Ic.load(tu,function(uu){su(new Re.Source(uu))},function(){},function(uu){bc("`$s` could not be fetched (Error code: %s; Response: %s)",uu.status,uu.statusText)})})}(iu):new Re.Source(iu))},loadVideo:function(iu,eu){var tu;typeof iu!="string"&&function(su){su.autoplay=su.hasAttribute("autoplay")&&su.getAttribute("autoplay")!=="false",su.controls=su.hasAttribute("controls")&&su.getAttribute("controls")!=="false",su.getAttribute("loop")==="false"&&su.removeAttribute("loop"),su.getAttribute("preload")==="false"&&(su.preload="none"),su.crossOrigin=su.crossOrigin||"anonymous",su.setAttribute("playsinline",""),su.setAttribute("webkit-playsinline","")}(tu=iu),tu=tu||function(su){var au=document.createElement("video");return au.setAttribute("playsinline",""),au.setAttribute("webkit-playsinline",""),au.autoplay=!0,au.loop=!0,au.crossOrigin="anonymous",au.addEventListener("error",function(){yc("`%s` is not a valid video",su)},!0),au.src=su,au}(iu),eu(new Re.Source(tu))},hash:function(iu){return iu.tagName&&(iu.id||iu.src)||iu},registerMaterial:function(iu){this.materials[iu.uuid]=iu},unregisterMaterial:function(iu){delete this.materials[iu.uuid]}}),Es("obb-collider",{schema:{showColliders:{default:!1}},init:function(){this.collisions=[],this.colliderEls=[]},addCollider:function(iu){this.colliderEls.push(iu),this.data.showColliders?iu.components["obb-collider"].showCollider():iu.components["obb-collider"].hideCollider(),this.tick=this.detectCollisions},removeCollider:function(iu){var eu=this.colliderEls,tu=eu.indexOf(iu);iu.components["obb-collider"].hideCollider(),tu>-1&&eu.splice(tu,1),eu.length===0&&(this.tick=void 0)},registerCollision:function(iu,eu){var tu=this.collisions,su=!1,au=iu.obb,uu=eu.obb,du=iu.renderColliderMesh,fu=eu.renderColliderMesh;du&&du.material.color.set(16711680),fu&&fu.material.color.set(16711680);for(var gu=0;gu<tu.length;gu++)if(tu[gu].componentA.obb===au&&tu[gu].componentB.obb===uu||tu[gu].componentA.obb===uu&&tu[gu].componentB.obb===au){su=!0,tu[gu].detected=!0;break}su||(tu.push({componentA:iu,componentB:eu,detected:!0}),iu.el.emit("obbcollisionstarted",{trackedObject3D:iu.trackedObject3D,withEl:eu.el}),eu.el.emit("obbcollisionstarted",{trackedObject3D:eu.trackedObject3D,withEl:iu.el}))},resetCollisions:function(){for(var iu=this.collisions,eu=0;eu<iu.length;eu++)iu[eu].detected=!1},clearCollisions:function(){for(var iu,eu,tu,su,au=this.collisions,uu=[],du=0;du<au.length;du++)au[du].detected?uu.push(au[du]):(iu=au[du].componentA,eu=au[du].componentB,tu=iu.renderColliderMesh,su=eu.renderColliderMesh,tu&&tu.material.color.set(65280),iu.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:eu.el}),su&&su.material.color.set(65280),eu.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:iu.el}));this.collisions=uu},detectCollisions:function(){var iu,eu,tu,su,au=this.colliderEls;if(!(au.length<2)){this.resetCollisions();for(var uu=0;uu<au.length;uu++)if(tu=au[uu].components["obb-collider"],(iu=au[uu].components["obb-collider"].obb).halfSize.x!==0&&iu.halfSize.y!==0&&iu.halfSize.z!==0)for(var du=uu+1;du<au.length;du++)(eu=(su=au[du].components["obb-collider"]).obb).halfSize.x!==0&&eu.halfSize.y!==0&&eu.halfSize.z!==0&&iu.intersectsOBB(eu)&&this.registerCollision(tu,su);this.clearCollisions()}}});var wc=fi("components:renderer:warn");function xc(iu,eu){return iu.groupOrder!==eu.groupOrder?iu.groupOrder-eu.groupOrder:iu.renderOrder!==eu.renderOrder?iu.renderOrder-eu.renderOrder:iu.z-eu.z}function Qc(iu,eu){return iu.groupOrder!==eu.groupOrder?iu.groupOrder-eu.groupOrder:iu.renderOrder-eu.renderOrder}function Lc(iu,eu){return iu.groupOrder!==eu.groupOrder?iu.groupOrder-eu.groupOrder:iu.renderOrder!==eu.renderOrder?iu.renderOrder-eu.renderOrder:eu.z-iu.z}Es("renderer",{schema:{antialias:{default:"auto",oneOf:["true","false","auto"]},highRefreshRate:{default:Ui()},logarithmicDepthBuffer:{default:"auto",oneOf:["true","false","auto"]},maxCanvasWidth:{default:-1},maxCanvasHeight:{default:-1},multiviewStereo:{default:!1},exposure:{default:1,if:{toneMapping:["ACESFilmic","linear","reinhard","cineon","AgX","neutral"]}},toneMapping:{default:"no",oneOf:["no","ACESFilmic","linear","reinhard","cineon","AgX","neutral"]},precision:{default:"high",oneOf:["high","medium","low"]},anisotropy:{default:1},sortTransparentObjects:{default:!1},colorManagement:{default:!0},alpha:{default:!0},stencil:{default:!1},foveationLevel:{default:1}},init:function(){var iu=this.data,eu=this.el,tu=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1),su=eu.renderer;su.toneMapping=Re[tu+"ToneMapping"],Re.Texture.DEFAULT_ANISOTROPY=iu.anisotropy,Re.ColorManagement.enabled=iu.colorManagement,su.outputColorSpace=iu.colorManagement?Re.SRGBColorSpace:Re.LinearSRGBColorSpace,eu.hasAttribute("antialias")&&wc('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'),eu.hasAttribute("logarithmicDepthBuffer")&&wc('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'),su.sortObjects=!0,su.setOpaqueSort(xc)},update:function(){var iu=this.data,eu=this.el.renderer,tu=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1);eu.toneMapping=Re[tu+"ToneMapping"],eu.toneMappingExposure=iu.exposure,eu.xr.setFoveation(iu.foveationLevel),iu.sortObjects&&wc('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'),iu.sortTransparentObjects?eu.setTransparentSort(Lc):eu.setTransparentSort(Qc)},applyColorCorrection:function(iu){this.data.colorManagement&&iu&&iu.isTexture&&iu.colorSpace!==Re.SRGBColorSpace&&(iu.colorSpace=Re.SRGBColorSpace,iu.needsUpdate=!0)},setWebXRFrameRate:function(iu){var eu,tu=this.data,su=iu.supportedFrameRates;su&&iu.updateTargetFrameRate&&(eu=su.includes(90)?tu.highRefreshRate?90:72:tu.highRefreshRate?72:60,iu.updateTargetFrameRate(eu).catch(function(au){console.warn("failed to set target frame rate of "+eu+". Error info: "+au)}))}});var Mc={basic:Re.BasicShadowMap,pcf:Re.PCFShadowMap,pcfsoft:Re.PCFSoftShadowMap};Es("shadow",{schema:{enabled:{default:!0},autoUpdate:{default:!0},type:{default:"pcf",oneOf:["basic","pcf","pcfsoft"]}},init:function(){var iu=this.sceneEl,eu=this.data;this.shadowMapEnabled=!1,iu.renderer.shadowMap.type=Mc[eu.type],iu.renderer.shadowMap.autoUpdate=eu.autoUpdate},update:function(iu){iu.enabled!==this.data.enabled&&this.setShadowMapEnabled(this.shadowMapEnabled)},setShadowMapEnabled:function(iu){var eu=this.sceneEl,tu=this.sceneEl.renderer;this.shadowMapEnabled=iu;var su=this.data.enabled&&this.shadowMapEnabled;tu&&su!==tu.shadowMap.enabled&&(tu.shadowMap.enabled=su,function(au){au.hasLoaded&&au.object3D.traverse(function(uu){if(uu.material)for(var du=Array.isArray(uu.material)?uu.material:[uu.material],fu=0;fu<du.length;fu++)du[fu].needsUpdate=!0})}(eu))}}),Es("tracked-controls",{init:function(){this.controllers=[],this.onInputSourcesChange=this.onInputSourcesChange.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.el.addEventListener("enter-vr",this.onEnterVR),this.onExitVR=this.onExitVR.bind(this),this.el.addEventListener("exit-vr",this.onExitVR)},onEnterVR:function(){this.el.xrSession&&this.el.xrSession.addEventListener("inputsourceschange",this.onInputSourcesChange)},onExitVR:function(){this.referenceSpace=void 0,this.controllers=[],this.el.emit("controllersupdated",void 0,!1)},onInputSourcesChange:function(){var iu=this,eu=this.el.xrSession,tu=this.el.sceneEl.systems.webxr.sessionReferenceSpaceType;eu.requestReferenceSpace(tu).then(function(su){iu.referenceSpace=su}).catch(function(su){throw iu.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(tu,'tracked-controls uses reference space "'+tu+'".'),su}),this.controllers=eu.inputSources,this.el.emit("controllersupdated",void 0,!1)}});var Sc=fi("systems:webxr:warn"),Dc=(Es("webxr",{schema:{referenceSpaceType:{type:"string",default:"local-floor"},requiredFeatures:{type:"array",default:["local-floor"]},optionalFeatures:{type:"array",default:["bounded-floor"]},overlayElement:{type:"selector"}},update:function(){var iu=this.data;this.sessionConfiguration={requiredFeatures:iu.requiredFeatures,optionalFeatures:iu.optionalFeatures},this.sessionReferenceSpaceType=iu.referenceSpaceType,iu.overlayElement&&(iu.overlayElement.classList.remove("a-dom-overlay"),iu.optionalFeatures.includes("dom-overlay")||(iu.optionalFeatures.push("dom-overlay"),this.el.setAttribute("webxr",iu)),this.warnIfFeatureNotRequested("dom-overlay"),this.sessionConfiguration.domOverlay={root:iu.overlayElement},iu.overlayElement.classList.add("a-dom-overlay"))},wasFeatureRequested:function(iu){return iu==="viewer"||iu==="local"||!(!this.sessionConfiguration.requiredFeatures.includes(iu)&&!this.sessionConfiguration.optionalFeatures.includes(iu))},warnIfFeatureNotRequested:function(iu,eu){this.wasFeatureRequested(iu)||Sc((eu?eu+" ":"")+'Please add the feature "'+iu+`" to a-scene's webxr system options in requiredFeatures/optionalFeatures.`)}}),{});function kc(iu){var eu=iu.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();iu==="fog"&&(eu="material-fog"),iu==="visible"&&(eu="material-visible"),Dc[eu]="material."+iu}function Tc(){return{defaultComponents:{material:{}},mappings:Jr({},Dc)}}Object.keys(Ko.material.schema).forEach(kc),Object.keys($s.standard.schema).forEach(kc);var Rc=new Re.Vector3,Fc=new Re.Vector3;cs("pivot",{dependencies:["position"],schema:{type:"vec3"},init:function(){var iu=this.data,eu=this.el,tu=eu.object3D.parent,su=eu.object3D,au=new Re.Group;Rc.copy(su.position),Fc.copy(su.rotation),tu.remove(su),au.add(su),tu.add(au),eu.object3D=au,su.position.set(-1*iu.x,-1*iu.y,-1*iu.z),au.position.set(iu.x+Rc.x,iu.y+Rc.y,iu.z+Rc.z),au.rotation.copy(su.rotation),su.rotation.set(0,0,0)}}),Xs("a-camera",{defaultComponents:{camera:{},"look-controls":{},"wasd-controls":{},position:{x:0,y:1.6,z:0}},mappings:{active:"camera.active",far:"camera.far",fov:"camera.fov","look-controls-enabled":"look-controls.enabled",near:"camera.near","pointer-lock-enabled":"look-controls.pointerLockEnabled","wasd-controls-enabled":"wasd-controls.enabled","reverse-mouse-drag":"look-controls.reverseMouseDrag",zoom:"camera.zoom"}}),Xs("a-cursor",Xr({},Tc(),{defaultComponents:{cursor:{},geometry:{primitive:"ring",radiusOuter:.016,radiusInner:.01,segmentsTheta:32},material:{color:"#000",shader:"flat",opacity:.8},position:{x:0,y:0,z:-1}},mappings:{far:"raycaster.far",fuse:"cursor.fuse","fuse-timeout":"cursor.fuseTimeout",interval:"raycaster.interval",objects:"raycaster.objects"}})),Xs("a-curvedimage",Xr({},Tc(),{defaultComponents:{geometry:{height:1,primitive:"cylinder",radius:2,segmentsRadial:48,thetaLength:270,openEnded:!0,thetaStart:0},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0,repeat:"-1 1"}},mappings:{height:"geometry.height","open-ended":"geometry.openEnded",radius:"geometry.radius",segments:"geometry.segmentsRadial",start:"geometry.thetaStart","theta-length":"geometry.thetaLength","theta-start":"geometry.thetaStart",width:"geometry.thetaLength"}})),Xs("a-gltf-model",{mappings:{src:"gltf-model"}}),Xs("a-image",Xr({},Tc(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}})),Xs("a-light",{defaultComponents:{light:{}},mappings:{angle:"light.angle",color:"light.color","ground-color":"light.groundColor",decay:"light.decay",distance:"light.distance",intensity:"light.intensity",penumbra:"light.penumbra",type:"light.type",target:"light.target",envmap:"light.envMap","shadow-camera-automatic":"light.shadowCameraAutomatic"}}),Xs("a-link",{defaultComponents:{link:{visualAspectEnabled:!0}},mappings:{href:"link.href",image:"link.image",title:"link.title"}}),Xs("a-obj-model",Xr({},Tc(),{defaultComponents:{"obj-model":{}},mappings:{src:"obj-model.obj",mtl:"obj-model.mtl"}}));const Uc={},Oc=Uc;function Pc(iu){return iu.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}var Gc,Nc;_s.forEach(function(iu){var eu=js[iu],tu=Pc(iu),su={};Object.keys(eu.schema).forEach(function(du){su[Pc(du)]="geometry."+du});var au="a-"+tu,uu=Xs(au,Xr({},Tc(),{defaultComponents:{geometry:{primitive:iu}},mappings:su}));Uc[au]=uu}),Xs("a-sky",Xr({},Tc(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",side:"back",shader:"flat",npot:!0},scale:"-1 1 1"},mappings:Xr({},Oc["a-sphere"].mappings)})),Xs("a-sound",{defaultComponents:{sound:{}},mappings:{src:"sound.src",on:"sound.on",autoplay:"sound.autoplay",loop:"sound.loop",volume:"sound.volume"}}),Gc={text:{anchor:"align",width:5}},Nc=Nc||{},Object.keys(Gc).forEach(function(iu){(function(eu,tu){var su=Ko[eu].schema;Object.keys(su).forEach(function(au){var uu=au.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();tu[uu]!==void 0&&(uu=eu+"-"+au),tu[uu]=eu+"."+au})})(iu,Nc)}),Xs("a-text",Xr({},null,{defaultComponents:Gc,mappings:Nc})),Xs("a-video",Xr({},Tc(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}})),Xs("a-videosphere",Xr({},Tc(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",shader:"flat",side:"back",npot:!0},scale:"-1 1 1"},mappings:{radius:"geometry.radius","segments-height":"geometry.segmentsHeight","segments-width":"geometry.segmentsWidth"}}));var jc=fi,_c=jc("A-Frame:error"),Hc=jc("A-Frame:warn");window.document.currentScript&&window.document.currentScript.parentNode!==window.document.head&&!window.debug&&Hc("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."),window.cordova||window.location.protocol!=="file:"||_c("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."),ji&&(window.logs=jc,i$1(7180),i$1(9379)),console.log("A-Frame Version: 1.7.0 (Date 2025-03-12, Commit #1b9650f1)"),console.log("THREE Version (https://github.com/supermedium/three.js):",li.REVISION),window.AFRAME_ASYNC||(document.readyState!=="complete"?document.addEventListener("readystatechange",function iu(){document.readyState==="complete"&&(document.removeEventListener("readystatechange",iu),gs())}):gs());const qc=globalThis.AFRAME={AComponent:As,AEntity:Ls,ANode:bs,ANIME:Te,AScene:Us,components:Ko,coreComponents:Object.keys(Ko),geometries:js,registerComponent:cs,registerGeometry:qs,registerPrimitive:Xs,registerShader:ia,registerSystem:Es,primitives:{getMeshMixin:Tc,primitives:Js},scenes:bo,schema:p,shaders:$s,systems:fs,emitReady:gs,THREE:li,utils:g,version:ca};r.A;var buffer={},base64Js={};base64Js.byteLength=byteLength;base64Js.toByteArray=toByteArray;base64Js.fromByteArray=fromByteArray;var lookup=[],revLookup=[],Arr=typeof Uint8Array<"u"?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var i=0,len=code.length;i<len;++i)lookup[i]=code[i],revLookup[code.charCodeAt(i)]=i;revLookup[45]=62;revLookup[95]=63;function getLens(iu){var eu=iu.length;if(eu%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var tu=iu.indexOf("=");tu===-1&&(tu=eu);var su=tu===eu?0:4-tu%4;return[tu,su]}function byteLength(iu){var eu=getLens(iu),tu=eu[0],su=eu[1];return(tu+su)*3/4-su}function _byteLength(iu,eu,tu){return(eu+tu)*3/4-tu}function toByteArray(iu){var eu,tu=getLens(iu),su=tu[0],au=tu[1],uu=new Arr(_byteLength(iu,su,au)),du=0,fu=au>0?su-4:su,gu;for(gu=0;gu<fu;gu+=4)eu=revLookup[iu.charCodeAt(gu)]<<18|revLookup[iu.charCodeAt(gu+1)]<<12|revLookup[iu.charCodeAt(gu+2)]<<6|revLookup[iu.charCodeAt(gu+3)],uu[du++]=eu>>16&255,uu[du++]=eu>>8&255,uu[du++]=eu&255;return au===2&&(eu=revLookup[iu.charCodeAt(gu)]<<2|revLookup[iu.charCodeAt(gu+1)]>>4,uu[du++]=eu&255),au===1&&(eu=revLookup[iu.charCodeAt(gu)]<<10|revLookup[iu.charCodeAt(gu+1)]<<4|revLookup[iu.charCodeAt(gu+2)]>>2,uu[du++]=eu>>8&255,uu[du++]=eu&255),uu}function tripletToBase64(iu){return lookup[iu>>18&63]+lookup[iu>>12&63]+lookup[iu>>6&63]+lookup[iu&63]}function encodeChunk(iu,eu,tu){for(var su,au=[],uu=eu;uu<tu;uu+=3)su=(iu[uu]<<16&16711680)+(iu[uu+1]<<8&65280)+(iu[uu+2]&255),au.push(tripletToBase64(su));return au.join("")}function fromByteArray(iu){for(var eu,tu=iu.length,su=tu%3,au=[],uu=16383,du=0,fu=tu-su;du<fu;du+=uu)au.push(encodeChunk(iu,du,du+uu>fu?fu:du+uu));return su===1?(eu=iu[tu-1],au.push(lookup[eu>>2]+lookup[eu<<4&63]+"==")):su===2&&(eu=(iu[tu-2]<<8)+iu[tu-1],au.push(lookup[eu>>10]+lookup[eu>>4&63]+lookup[eu<<2&63]+"=")),au.join("")}var ieee754={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ieee754.read=function(iu,eu,tu,su,au){var uu,du,fu=au*8-su-1,gu=(1<<fu)-1,yu=gu>>1,xu=-7,vu=tu?au-1:0,Su=tu?-1:1,Iu=iu[eu+vu];for(vu+=Su,uu=Iu&(1<<-xu)-1,Iu>>=-xu,xu+=fu;xu>0;uu=uu*256+iu[eu+vu],vu+=Su,xu-=8);for(du=uu&(1<<-xu)-1,uu>>=-xu,xu+=su;xu>0;du=du*256+iu[eu+vu],vu+=Su,xu-=8);if(uu===0)uu=1-yu;else{if(uu===gu)return du?NaN:(Iu?-1:1)*(1/0);du=du+Math.pow(2,su),uu=uu-yu}return(Iu?-1:1)*du*Math.pow(2,uu-su)};ieee754.write=function(iu,eu,tu,su,au,uu){var du,fu,gu,yu=uu*8-au-1,xu=(1<<yu)-1,vu=xu>>1,Su=au===23?Math.pow(2,-24)-Math.pow(2,-77):0,Iu=su?0:uu-1,Mu=su?1:-1,ku=eu<0||eu===0&&1/eu<0?1:0;for(eu=Math.abs(eu),isNaN(eu)||eu===1/0?(fu=isNaN(eu)?1:0,du=xu):(du=Math.floor(Math.log(eu)/Math.LN2),eu*(gu=Math.pow(2,-du))<1&&(du--,gu*=2),du+vu>=1?eu+=Su/gu:eu+=Su*Math.pow(2,1-vu),eu*gu>=2&&(du++,gu/=2),du+vu>=xu?(fu=0,du=xu):du+vu>=1?(fu=(eu*gu-1)*Math.pow(2,au),du=du+vu):(fu=eu*Math.pow(2,vu-1)*Math.pow(2,au),du=0));au>=8;iu[tu+Iu]=fu&255,Iu+=Mu,fu/=256,au-=8);for(du=du<<au|fu,yu+=au;yu>0;iu[tu+Iu]=du&255,Iu+=Mu,du/=256,yu-=8);iu[tu+Iu-Mu]|=ku*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(iu){const eu=base64Js,tu=ieee754,su=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;iu.Buffer=xu,iu.SlowBuffer=Wu,iu.INSPECT_MAX_BYTES=50;const au=2147483647;iu.kMaxLength=au;const{Uint8Array:uu,ArrayBuffer:du,SharedArrayBuffer:fu}=globalThis;xu.TYPED_ARRAY_SUPPORT=gu(),!xu.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function gu(){try{const qu=new uu(1),Uu={foo:function(){return 42}};return Object.setPrototypeOf(Uu,uu.prototype),Object.setPrototypeOf(qu,Uu),qu.foo()===42}catch{return!1}}Object.defineProperty(xu.prototype,"parent",{enumerable:!0,get:function(){if(xu.isBuffer(this))return this.buffer}}),Object.defineProperty(xu.prototype,"offset",{enumerable:!0,get:function(){if(xu.isBuffer(this))return this.byteOffset}});function yu(qu){if(qu>au)throw new RangeError('The value "'+qu+'" is invalid for option "size"');const Uu=new uu(qu);return Object.setPrototypeOf(Uu,xu.prototype),Uu}function xu(qu,Uu,zu){if(typeof qu=="number"){if(typeof Uu=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return Mu(qu)}return vu(qu,Uu,zu)}xu.poolSize=8192;function vu(qu,Uu,zu){if(typeof qu=="string")return ku(qu,Uu);if(du.isView(qu))return _u(qu);if(qu==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof qu);if(vm(qu,du)||qu&&vm(qu.buffer,du)||typeof fu<"u"&&(vm(qu,fu)||qu&&vm(qu.buffer,fu)))return Lu(qu,Uu,zu);if(typeof qu=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const ep=qu.valueOf&&qu.valueOf();if(ep!=null&&ep!==qu)return xu.from(ep,Uu,zu);const up=Du(qu);if(up)return up;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof qu[Symbol.toPrimitive]=="function")return xu.from(qu[Symbol.toPrimitive]("string"),Uu,zu);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof qu)}xu.from=function(qu,Uu,zu){return vu(qu,Uu,zu)},Object.setPrototypeOf(xu.prototype,uu.prototype),Object.setPrototypeOf(xu,uu);function Su(qu){if(typeof qu!="number")throw new TypeError('"size" argument must be of type number');if(qu<0)throw new RangeError('The value "'+qu+'" is invalid for option "size"')}function Iu(qu,Uu,zu){return Su(qu),qu<=0?yu(qu):Uu!==void 0?typeof zu=="string"?yu(qu).fill(Uu,zu):yu(qu).fill(Uu):yu(qu)}xu.alloc=function(qu,Uu,zu){return Iu(qu,Uu,zu)};function Mu(qu){return Su(qu),yu(qu<0?0:Ou(qu)|0)}xu.allocUnsafe=function(qu){return Mu(qu)},xu.allocUnsafeSlow=function(qu){return Mu(qu)};function ku(qu,Uu){if((typeof Uu!="string"||Uu==="")&&(Uu="utf8"),!xu.isEncoding(Uu))throw new TypeError("Unknown encoding: "+Uu);const zu=Zu(qu,Uu)|0;let ep=yu(zu);const up=ep.write(qu,Uu);return up!==zu&&(ep=ep.slice(0,up)),ep}function Bu(qu){const Uu=qu.length<0?0:Ou(qu.length)|0,zu=yu(Uu);for(let ep=0;ep<Uu;ep+=1)zu[ep]=qu[ep]&255;return zu}function _u(qu){if(vm(qu,uu)){const Uu=new uu(qu);return Lu(Uu.buffer,Uu.byteOffset,Uu.byteLength)}return Bu(qu)}function Lu(qu,Uu,zu){if(Uu<0||qu.byteLength<Uu)throw new RangeError('"offset" is outside of buffer bounds');if(qu.byteLength<Uu+(zu||0))throw new RangeError('"length" is outside of buffer bounds');let ep;return Uu===void 0&&zu===void 0?ep=new uu(qu):zu===void 0?ep=new uu(qu,Uu):ep=new uu(qu,Uu,zu),Object.setPrototypeOf(ep,xu.prototype),ep}function Du(qu){if(xu.isBuffer(qu)){const Uu=Ou(qu.length)|0,zu=yu(Uu);return zu.length===0||qu.copy(zu,0,0,Uu),zu}if(qu.length!==void 0)return typeof qu.length!="number"||sp(qu.length)?yu(0):Bu(qu);if(qu.type==="Buffer"&&Array.isArray(qu.data))return Bu(qu.data)}function Ou(qu){if(qu>=au)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+au.toString(16)+" bytes");return qu|0}function Wu(qu){return+qu!=qu&&(qu=0),xu.alloc(+qu)}xu.isBuffer=function(Uu){return Uu!=null&&Uu._isBuffer===!0&&Uu!==xu.prototype},xu.compare=function(Uu,zu){if(vm(Uu,uu)&&(Uu=xu.from(Uu,Uu.offset,Uu.byteLength)),vm(zu,uu)&&(zu=xu.from(zu,zu.offset,zu.byteLength)),!xu.isBuffer(Uu)||!xu.isBuffer(zu))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Uu===zu)return 0;let ep=Uu.length,up=zu.length;for(let Mp=0,Ip=Math.min(ep,up);Mp<Ip;++Mp)if(Uu[Mp]!==zu[Mp]){ep=Uu[Mp],up=zu[Mp];break}return ep<up?-1:up<ep?1:0},xu.isEncoding=function(Uu){switch(String(Uu).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},xu.concat=function(Uu,zu){if(!Array.isArray(Uu))throw new TypeError('"list" argument must be an Array of Buffers');if(Uu.length===0)return xu.alloc(0);let ep;if(zu===void 0)for(zu=0,ep=0;ep<Uu.length;++ep)zu+=Uu[ep].length;const up=xu.allocUnsafe(zu);let Mp=0;for(ep=0;ep<Uu.length;++ep){let Ip=Uu[ep];if(vm(Ip,uu))Mp+Ip.length>up.length?(xu.isBuffer(Ip)||(Ip=xu.from(Ip)),Ip.copy(up,Mp)):uu.prototype.set.call(up,Ip,Mp);else if(xu.isBuffer(Ip))Ip.copy(up,Mp);else throw new TypeError('"list" argument must be an Array of Buffers');Mp+=Ip.length}return up};function Zu(qu,Uu){if(xu.isBuffer(qu))return qu.length;if(du.isView(qu)||vm(qu,du))return qu.byteLength;if(typeof qu!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof qu);const zu=qu.length,ep=arguments.length>2&&arguments[2]===!0;if(!ep&&zu===0)return 0;let up=!1;for(;;)switch(Uu){case"ascii":case"latin1":case"binary":return zu;case"utf8":case"utf-8":return _h(qu).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return zu*2;case"hex":return zu>>>1;case"base64":return Lp(qu).length;default:if(up)return ep?-1:_h(qu).length;Uu=(""+Uu).toLowerCase(),up=!0}}xu.byteLength=Zu;function Hu(qu,Uu,zu){let ep=!1;if((Uu===void 0||Uu<0)&&(Uu=0),Uu>this.length||((zu===void 0||zu>this.length)&&(zu=this.length),zu<=0)||(zu>>>=0,Uu>>>=0,zu<=Uu))return"";for(qu||(qu="utf8");;)switch(qu){case"hex":return lm(this,Uu,zu);case"utf8":case"utf-8":return Dp(this,Uu,zu);case"ascii":return xp(this,Uu,zu);case"latin1":case"binary":return cm(this,Uu,zu);case"base64":return wp(this,Uu,zu);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return vp(this,Uu,zu);default:if(ep)throw new TypeError("Unknown encoding: "+qu);qu=(qu+"").toLowerCase(),ep=!0}}xu.prototype._isBuffer=!0;function Yu(qu,Uu,zu){const ep=qu[Uu];qu[Uu]=qu[zu],qu[zu]=ep}xu.prototype.swap16=function(){const Uu=this.length;if(Uu%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let zu=0;zu<Uu;zu+=2)Yu(this,zu,zu+1);return this},xu.prototype.swap32=function(){const Uu=this.length;if(Uu%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let zu=0;zu<Uu;zu+=4)Yu(this,zu,zu+3),Yu(this,zu+1,zu+2);return this},xu.prototype.swap64=function(){const Uu=this.length;if(Uu%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let zu=0;zu<Uu;zu+=8)Yu(this,zu,zu+7),Yu(this,zu+1,zu+6),Yu(this,zu+2,zu+5),Yu(this,zu+3,zu+4);return this},xu.prototype.toString=function(){const Uu=this.length;return Uu===0?"":arguments.length===0?Dp(this,0,Uu):Hu.apply(this,arguments)},xu.prototype.toLocaleString=xu.prototype.toString,xu.prototype.equals=function(Uu){if(!xu.isBuffer(Uu))throw new TypeError("Argument must be a Buffer");return this===Uu?!0:xu.compare(this,Uu)===0},xu.prototype.inspect=function(){let Uu="";const zu=iu.INSPECT_MAX_BYTES;return Uu=this.toString("hex",0,zu).replace(/(.{2})/g,"$1 ").trim(),this.length>zu&&(Uu+=" ... "),"<Buffer "+Uu+">"},su&&(xu.prototype[su]=xu.prototype.inspect),xu.prototype.compare=function(Uu,zu,ep,up,Mp){if(vm(Uu,uu)&&(Uu=xu.from(Uu,Uu.offset,Uu.byteLength)),!xu.isBuffer(Uu))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Uu);if(zu===void 0&&(zu=0),ep===void 0&&(ep=Uu?Uu.length:0),up===void 0&&(up=0),Mp===void 0&&(Mp=this.length),zu<0||ep>Uu.length||up<0||Mp>this.length)throw new RangeError("out of range index");if(up>=Mp&&zu>=ep)return 0;if(up>=Mp)return-1;if(zu>=ep)return 1;if(zu>>>=0,ep>>>=0,up>>>=0,Mp>>>=0,this===Uu)return 0;let Ip=Mp-up,fm=ep-zu;const Gm=Math.min(Ip,fm),pp=this.slice(up,Mp),Zp=Uu.slice(zu,ep);for(let om=0;om<Gm;++om)if(pp[om]!==Zp[om]){Ip=pp[om],fm=Zp[om];break}return Ip<fm?-1:fm<Ip?1:0};function Ku(qu,Uu,zu,ep,up){if(qu.length===0)return-1;if(typeof zu=="string"?(ep=zu,zu=0):zu>2147483647?zu=2147483647:zu<-2147483648&&(zu=-2147483648),zu=+zu,sp(zu)&&(zu=up?0:qu.length-1),zu<0&&(zu=qu.length+zu),zu>=qu.length){if(up)return-1;zu=qu.length-1}else if(zu<0)if(up)zu=0;else return-1;if(typeof Uu=="string"&&(Uu=xu.from(Uu,ep)),xu.isBuffer(Uu))return Uu.length===0?-1:ju(qu,Uu,zu,ep,up);if(typeof Uu=="number")return Uu=Uu&255,typeof uu.prototype.indexOf=="function"?up?uu.prototype.indexOf.call(qu,Uu,zu):uu.prototype.lastIndexOf.call(qu,Uu,zu):ju(qu,[Uu],zu,ep,up);throw new TypeError("val must be string, number or Buffer")}function ju(qu,Uu,zu,ep,up){let Mp=1,Ip=qu.length,fm=Uu.length;if(ep!==void 0&&(ep=String(ep).toLowerCase(),ep==="ucs2"||ep==="ucs-2"||ep==="utf16le"||ep==="utf-16le")){if(qu.length<2||Uu.length<2)return-1;Mp=2,Ip/=2,fm/=2,zu/=2}function Gm(Zp,om){return Mp===1?Zp[om]:Zp.readUInt16BE(om*Mp)}let pp;if(up){let Zp=-1;for(pp=zu;pp<Ip;pp++)if(Gm(qu,pp)===Gm(Uu,Zp===-1?0:pp-Zp)){if(Zp===-1&&(Zp=pp),pp-Zp+1===fm)return Zp*Mp}else Zp!==-1&&(pp-=pp-Zp),Zp=-1}else for(zu+fm>Ip&&(zu=Ip-fm),pp=zu;pp>=0;pp--){let Zp=!0;for(let om=0;om<fm;om++)if(Gm(qu,pp+om)!==Gm(Uu,om)){Zp=!1;break}if(Zp)return pp}return-1}xu.prototype.includes=function(Uu,zu,ep){return this.indexOf(Uu,zu,ep)!==-1},xu.prototype.indexOf=function(Uu,zu,ep){return Ku(this,Uu,zu,ep,!0)},xu.prototype.lastIndexOf=function(Uu,zu,ep){return Ku(this,Uu,zu,ep,!1)};function tp(qu,Uu,zu,ep){zu=Number(zu)||0;const up=qu.length-zu;ep?(ep=Number(ep),ep>up&&(ep=up)):ep=up;const Mp=Uu.length;ep>Mp/2&&(ep=Mp/2);let Ip;for(Ip=0;Ip<ep;++Ip){const fm=parseInt(Uu.substr(Ip*2,2),16);if(sp(fm))return Ip;qu[zu+Ip]=fm}return Ip}function gp(qu,Uu,zu,ep){return Kp(_h(Uu,qu.length-zu),qu,zu,ep)}function yp(qu,Uu,zu,ep){return Kp(ap(Uu),qu,zu,ep)}function Cp(qu,Uu,zu,ep){return Kp(Lp(Uu),qu,zu,ep)}function Hp(qu,Uu,zu,ep){return Kp(mp(Uu,qu.length-zu),qu,zu,ep)}xu.prototype.write=function(Uu,zu,ep,up){if(zu===void 0)up="utf8",ep=this.length,zu=0;else if(ep===void 0&&typeof zu=="string")up=zu,ep=this.length,zu=0;else if(isFinite(zu))zu=zu>>>0,isFinite(ep)?(ep=ep>>>0,up===void 0&&(up="utf8")):(up=ep,ep=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const Mp=this.length-zu;if((ep===void 0||ep>Mp)&&(ep=Mp),Uu.length>0&&(ep<0||zu<0)||zu>this.length)throw new RangeError("Attempt to write outside buffer bounds");up||(up="utf8");let Ip=!1;for(;;)switch(up){case"hex":return tp(this,Uu,zu,ep);case"utf8":case"utf-8":return gp(this,Uu,zu,ep);case"ascii":case"latin1":case"binary":return yp(this,Uu,zu,ep);case"base64":return Cp(this,Uu,zu,ep);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Hp(this,Uu,zu,ep);default:if(Ip)throw new TypeError("Unknown encoding: "+up);up=(""+up).toLowerCase(),Ip=!0}},xu.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function wp(qu,Uu,zu){return Uu===0&&zu===qu.length?eu.fromByteArray(qu):eu.fromByteArray(qu.slice(Uu,zu))}function Dp(qu,Uu,zu){zu=Math.min(qu.length,zu);const ep=[];let up=Uu;for(;up<zu;){const Mp=qu[up];let Ip=null,fm=Mp>239?4:Mp>223?3:Mp>191?2:1;if(up+fm<=zu){let Gm,pp,Zp,om;switch(fm){case 1:Mp<128&&(Ip=Mp);break;case 2:Gm=qu[up+1],(Gm&192)===128&&(om=(Mp&31)<<6|Gm&63,om>127&&(Ip=om));break;case 3:Gm=qu[up+1],pp=qu[up+2],(Gm&192)===128&&(pp&192)===128&&(om=(Mp&15)<<12|(Gm&63)<<6|pp&63,om>2047&&(om<55296||om>57343)&&(Ip=om));break;case 4:Gm=qu[up+1],pp=qu[up+2],Zp=qu[up+3],(Gm&192)===128&&(pp&192)===128&&(Zp&192)===128&&(om=(Mp&15)<<18|(Gm&63)<<12|(pp&63)<<6|Zp&63,om>65535&&om<1114112&&(Ip=om))}}Ip===null?(Ip=65533,fm=1):Ip>65535&&(Ip-=65536,ep.push(Ip>>>10&1023|55296),Ip=56320|Ip&1023),ep.push(Ip),up+=fm}return Rp(ep)}const dp=4096;function Rp(qu){const Uu=qu.length;if(Uu<=dp)return String.fromCharCode.apply(String,qu);let zu="",ep=0;for(;ep<Uu;)zu+=String.fromCharCode.apply(String,qu.slice(ep,ep+=dp));return zu}function xp(qu,Uu,zu){let ep="";zu=Math.min(qu.length,zu);for(let up=Uu;up<zu;++up)ep+=String.fromCharCode(qu[up]&127);return ep}function cm(qu,Uu,zu){let ep="";zu=Math.min(qu.length,zu);for(let up=Uu;up<zu;++up)ep+=String.fromCharCode(qu[up]);return ep}function lm(qu,Uu,zu){const ep=qu.length;(!Uu||Uu<0)&&(Uu=0),(!zu||zu<0||zu>ep)&&(zu=ep);let up="";for(let Mp=Uu;Mp<zu;++Mp)up+=_d[qu[Mp]];return up}function vp(qu,Uu,zu){const ep=qu.slice(Uu,zu);let up="";for(let Mp=0;Mp<ep.length-1;Mp+=2)up+=String.fromCharCode(ep[Mp]+ep[Mp+1]*256);return up}xu.prototype.slice=function(Uu,zu){const ep=this.length;Uu=~~Uu,zu=zu===void 0?ep:~~zu,Uu<0?(Uu+=ep,Uu<0&&(Uu=0)):Uu>ep&&(Uu=ep),zu<0?(zu+=ep,zu<0&&(zu=0)):zu>ep&&(zu=ep),zu<Uu&&(zu=Uu);const up=this.subarray(Uu,zu);return Object.setPrototypeOf(up,xu.prototype),up};function bp(qu,Uu,zu){if(qu%1!==0||qu<0)throw new RangeError("offset is not uint");if(qu+Uu>zu)throw new RangeError("Trying to access beyond buffer length")}xu.prototype.readUintLE=xu.prototype.readUIntLE=function(Uu,zu,ep){Uu=Uu>>>0,zu=zu>>>0,ep||bp(Uu,zu,this.length);let up=this[Uu],Mp=1,Ip=0;for(;++Ip<zu&&(Mp*=256);)up+=this[Uu+Ip]*Mp;return up},xu.prototype.readUintBE=xu.prototype.readUIntBE=function(Uu,zu,ep){Uu=Uu>>>0,zu=zu>>>0,ep||bp(Uu,zu,this.length);let up=this[Uu+--zu],Mp=1;for(;zu>0&&(Mp*=256);)up+=this[Uu+--zu]*Mp;return up},xu.prototype.readUint8=xu.prototype.readUInt8=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,1,this.length),this[Uu]},xu.prototype.readUint16LE=xu.prototype.readUInt16LE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,2,this.length),this[Uu]|this[Uu+1]<<8},xu.prototype.readUint16BE=xu.prototype.readUInt16BE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,2,this.length),this[Uu]<<8|this[Uu+1]},xu.prototype.readUint32LE=xu.prototype.readUInt32LE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,4,this.length),(this[Uu]|this[Uu+1]<<8|this[Uu+2]<<16)+this[Uu+3]*16777216},xu.prototype.readUint32BE=xu.prototype.readUInt32BE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,4,this.length),this[Uu]*16777216+(this[Uu+1]<<16|this[Uu+2]<<8|this[Uu+3])},xu.prototype.readBigUInt64LE=Sp(function(Uu){Uu=Uu>>>0,cp(Uu,"offset");const zu=this[Uu],ep=this[Uu+7];(zu===void 0||ep===void 0)&&mm(Uu,this.length-8);const up=zu+this[++Uu]*2**8+this[++Uu]*2**16+this[++Uu]*2**24,Mp=this[++Uu]+this[++Uu]*2**8+this[++Uu]*2**16+ep*2**24;return BigInt(up)+(BigInt(Mp)<<BigInt(32))}),xu.prototype.readBigUInt64BE=Sp(function(Uu){Uu=Uu>>>0,cp(Uu,"offset");const zu=this[Uu],ep=this[Uu+7];(zu===void 0||ep===void 0)&&mm(Uu,this.length-8);const up=zu*2**24+this[++Uu]*2**16+this[++Uu]*2**8+this[++Uu],Mp=this[++Uu]*2**24+this[++Uu]*2**16+this[++Uu]*2**8+ep;return(BigInt(up)<<BigInt(32))+BigInt(Mp)}),xu.prototype.readIntLE=function(Uu,zu,ep){Uu=Uu>>>0,zu=zu>>>0,ep||bp(Uu,zu,this.length);let up=this[Uu],Mp=1,Ip=0;for(;++Ip<zu&&(Mp*=256);)up+=this[Uu+Ip]*Mp;return Mp*=128,up>=Mp&&(up-=Math.pow(2,8*zu)),up},xu.prototype.readIntBE=function(Uu,zu,ep){Uu=Uu>>>0,zu=zu>>>0,ep||bp(Uu,zu,this.length);let up=zu,Mp=1,Ip=this[Uu+--up];for(;up>0&&(Mp*=256);)Ip+=this[Uu+--up]*Mp;return Mp*=128,Ip>=Mp&&(Ip-=Math.pow(2,8*zu)),Ip},xu.prototype.readInt8=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,1,this.length),this[Uu]&128?(255-this[Uu]+1)*-1:this[Uu]},xu.prototype.readInt16LE=function(Uu,zu){Uu=Uu>>>0,zu||bp(Uu,2,this.length);const ep=this[Uu]|this[Uu+1]<<8;return ep&32768?ep|4294901760:ep},xu.prototype.readInt16BE=function(Uu,zu){Uu=Uu>>>0,zu||bp(Uu,2,this.length);const ep=this[Uu+1]|this[Uu]<<8;return ep&32768?ep|4294901760:ep},xu.prototype.readInt32LE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,4,this.length),this[Uu]|this[Uu+1]<<8|this[Uu+2]<<16|this[Uu+3]<<24},xu.prototype.readInt32BE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,4,this.length),this[Uu]<<24|this[Uu+1]<<16|this[Uu+2]<<8|this[Uu+3]},xu.prototype.readBigInt64LE=Sp(function(Uu){Uu=Uu>>>0,cp(Uu,"offset");const zu=this[Uu],ep=this[Uu+7];(zu===void 0||ep===void 0)&&mm(Uu,this.length-8);const up=this[Uu+4]+this[Uu+5]*2**8+this[Uu+6]*2**16+(ep<<24);return(BigInt(up)<<BigInt(32))+BigInt(zu+this[++Uu]*2**8+this[++Uu]*2**16+this[++Uu]*2**24)}),xu.prototype.readBigInt64BE=Sp(function(Uu){Uu=Uu>>>0,cp(Uu,"offset");const zu=this[Uu],ep=this[Uu+7];(zu===void 0||ep===void 0)&&mm(Uu,this.length-8);const up=(zu<<24)+this[++Uu]*2**16+this[++Uu]*2**8+this[++Uu];return(BigInt(up)<<BigInt(32))+BigInt(this[++Uu]*2**24+this[++Uu]*2**16+this[++Uu]*2**8+ep)}),xu.prototype.readFloatLE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,4,this.length),tu.read(this,Uu,!0,23,4)},xu.prototype.readFloatBE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,4,this.length),tu.read(this,Uu,!1,23,4)},xu.prototype.readDoubleLE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,8,this.length),tu.read(this,Uu,!0,52,8)},xu.prototype.readDoubleBE=function(Uu,zu){return Uu=Uu>>>0,zu||bp(Uu,8,this.length),tu.read(this,Uu,!1,52,8)};function kp(qu,Uu,zu,ep,up,Mp){if(!xu.isBuffer(qu))throw new TypeError('"buffer" argument must be a Buffer instance');if(Uu>up||Uu<Mp)throw new RangeError('"value" argument is out of bounds');if(zu+ep>qu.length)throw new RangeError("Index out of range")}xu.prototype.writeUintLE=xu.prototype.writeUIntLE=function(Uu,zu,ep,up){if(Uu=+Uu,zu=zu>>>0,ep=ep>>>0,!up){const fm=Math.pow(2,8*ep)-1;kp(this,Uu,zu,ep,fm,0)}let Mp=1,Ip=0;for(this[zu]=Uu&255;++Ip<ep&&(Mp*=256);)this[zu+Ip]=Uu/Mp&255;return zu+ep},xu.prototype.writeUintBE=xu.prototype.writeUIntBE=function(Uu,zu,ep,up){if(Uu=+Uu,zu=zu>>>0,ep=ep>>>0,!up){const fm=Math.pow(2,8*ep)-1;kp(this,Uu,zu,ep,fm,0)}let Mp=ep-1,Ip=1;for(this[zu+Mp]=Uu&255;--Mp>=0&&(Ip*=256);)this[zu+Mp]=Uu/Ip&255;return zu+ep},xu.prototype.writeUint8=xu.prototype.writeUInt8=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,1,255,0),this[zu]=Uu&255,zu+1},xu.prototype.writeUint16LE=xu.prototype.writeUInt16LE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,2,65535,0),this[zu]=Uu&255,this[zu+1]=Uu>>>8,zu+2},xu.prototype.writeUint16BE=xu.prototype.writeUInt16BE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,2,65535,0),this[zu]=Uu>>>8,this[zu+1]=Uu&255,zu+2},xu.prototype.writeUint32LE=xu.prototype.writeUInt32LE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,4,4294967295,0),this[zu+3]=Uu>>>24,this[zu+2]=Uu>>>16,this[zu+1]=Uu>>>8,this[zu]=Uu&255,zu+4},xu.prototype.writeUint32BE=xu.prototype.writeUInt32BE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,4,4294967295,0),this[zu]=Uu>>>24,this[zu+1]=Uu>>>16,this[zu+2]=Uu>>>8,this[zu+3]=Uu&255,zu+4};function dm(qu,Uu,zu,ep,up){lp(Uu,ep,up,qu,zu,7);let Mp=Number(Uu&BigInt(4294967295));qu[zu++]=Mp,Mp=Mp>>8,qu[zu++]=Mp,Mp=Mp>>8,qu[zu++]=Mp,Mp=Mp>>8,qu[zu++]=Mp;let Ip=Number(Uu>>BigInt(32)&BigInt(4294967295));return qu[zu++]=Ip,Ip=Ip>>8,qu[zu++]=Ip,Ip=Ip>>8,qu[zu++]=Ip,Ip=Ip>>8,qu[zu++]=Ip,zu}function nm(qu,Uu,zu,ep,up){lp(Uu,ep,up,qu,zu,7);let Mp=Number(Uu&BigInt(4294967295));qu[zu+7]=Mp,Mp=Mp>>8,qu[zu+6]=Mp,Mp=Mp>>8,qu[zu+5]=Mp,Mp=Mp>>8,qu[zu+4]=Mp;let Ip=Number(Uu>>BigInt(32)&BigInt(4294967295));return qu[zu+3]=Ip,Ip=Ip>>8,qu[zu+2]=Ip,Ip=Ip>>8,qu[zu+1]=Ip,Ip=Ip>>8,qu[zu]=Ip,zu+8}xu.prototype.writeBigUInt64LE=Sp(function(Uu,zu=0){return dm(this,Uu,zu,BigInt(0),BigInt("0xffffffffffffffff"))}),xu.prototype.writeBigUInt64BE=Sp(function(Uu,zu=0){return nm(this,Uu,zu,BigInt(0),BigInt("0xffffffffffffffff"))}),xu.prototype.writeIntLE=function(Uu,zu,ep,up){if(Uu=+Uu,zu=zu>>>0,!up){const Gm=Math.pow(2,8*ep-1);kp(this,Uu,zu,ep,Gm-1,-Gm)}let Mp=0,Ip=1,fm=0;for(this[zu]=Uu&255;++Mp<ep&&(Ip*=256);)Uu<0&&fm===0&&this[zu+Mp-1]!==0&&(fm=1),this[zu+Mp]=(Uu/Ip>>0)-fm&255;return zu+ep},xu.prototype.writeIntBE=function(Uu,zu,ep,up){if(Uu=+Uu,zu=zu>>>0,!up){const Gm=Math.pow(2,8*ep-1);kp(this,Uu,zu,ep,Gm-1,-Gm)}let Mp=ep-1,Ip=1,fm=0;for(this[zu+Mp]=Uu&255;--Mp>=0&&(Ip*=256);)Uu<0&&fm===0&&this[zu+Mp+1]!==0&&(fm=1),this[zu+Mp]=(Uu/Ip>>0)-fm&255;return zu+ep},xu.prototype.writeInt8=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,1,127,-128),Uu<0&&(Uu=255+Uu+1),this[zu]=Uu&255,zu+1},xu.prototype.writeInt16LE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,2,32767,-32768),this[zu]=Uu&255,this[zu+1]=Uu>>>8,zu+2},xu.prototype.writeInt16BE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,2,32767,-32768),this[zu]=Uu>>>8,this[zu+1]=Uu&255,zu+2},xu.prototype.writeInt32LE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,4,2147483647,-2147483648),this[zu]=Uu&255,this[zu+1]=Uu>>>8,this[zu+2]=Uu>>>16,this[zu+3]=Uu>>>24,zu+4},xu.prototype.writeInt32BE=function(Uu,zu,ep){return Uu=+Uu,zu=zu>>>0,ep||kp(this,Uu,zu,4,2147483647,-2147483648),Uu<0&&(Uu=4294967295+Uu+1),this[zu]=Uu>>>24,this[zu+1]=Uu>>>16,this[zu+2]=Uu>>>8,this[zu+3]=Uu&255,zu+4},xu.prototype.writeBigInt64LE=Sp(function(Uu,zu=0){return dm(this,Uu,zu,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),xu.prototype.writeBigInt64BE=Sp(function(Uu,zu=0){return nm(this,Uu,zu,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Bp(qu,Uu,zu,ep,up,Mp){if(zu+ep>qu.length)throw new RangeError("Index out of range");if(zu<0)throw new RangeError("Index out of range")}function Qp(qu,Uu,zu,ep,up){return Uu=+Uu,zu=zu>>>0,up||Bp(qu,Uu,zu,4),tu.write(qu,Uu,zu,ep,23,4),zu+4}xu.prototype.writeFloatLE=function(Uu,zu,ep){return Qp(this,Uu,zu,!0,ep)},xu.prototype.writeFloatBE=function(Uu,zu,ep){return Qp(this,Uu,zu,!1,ep)};function Xp(qu,Uu,zu,ep,up){return Uu=+Uu,zu=zu>>>0,up||Bp(qu,Uu,zu,8),tu.write(qu,Uu,zu,ep,52,8),zu+8}xu.prototype.writeDoubleLE=function(Uu,zu,ep){return Xp(this,Uu,zu,!0,ep)},xu.prototype.writeDoubleBE=function(Uu,zu,ep){return Xp(this,Uu,zu,!1,ep)},xu.prototype.copy=function(Uu,zu,ep,up){if(!xu.isBuffer(Uu))throw new TypeError("argument should be a Buffer");if(ep||(ep=0),!up&&up!==0&&(up=this.length),zu>=Uu.length&&(zu=Uu.length),zu||(zu=0),up>0&&up<ep&&(up=ep),up===ep||Uu.length===0||this.length===0)return 0;if(zu<0)throw new RangeError("targetStart out of bounds");if(ep<0||ep>=this.length)throw new RangeError("Index out of range");if(up<0)throw new RangeError("sourceEnd out of bounds");up>this.length&&(up=this.length),Uu.length-zu<up-ep&&(up=Uu.length-zu+ep);const Mp=up-ep;return this===Uu&&typeof uu.prototype.copyWithin=="function"?this.copyWithin(zu,ep,up):uu.prototype.set.call(Uu,this.subarray(ep,up),zu),Mp},xu.prototype.fill=function(Uu,zu,ep,up){if(typeof Uu=="string"){if(typeof zu=="string"?(up=zu,zu=0,ep=this.length):typeof ep=="string"&&(up=ep,ep=this.length),up!==void 0&&typeof up!="string")throw new TypeError("encoding must be a string");if(typeof up=="string"&&!xu.isEncoding(up))throw new TypeError("Unknown encoding: "+up);if(Uu.length===1){const Ip=Uu.charCodeAt(0);(up==="utf8"&&Ip<128||up==="latin1")&&(Uu=Ip)}}else typeof Uu=="number"?Uu=Uu&255:typeof Uu=="boolean"&&(Uu=Number(Uu));if(zu<0||this.length<zu||this.length<ep)throw new RangeError("Out of range index");if(ep<=zu)return this;zu=zu>>>0,ep=ep===void 0?this.length:ep>>>0,Uu||(Uu=0);let Mp;if(typeof Uu=="number")for(Mp=zu;Mp<ep;++Mp)this[Mp]=Uu;else{const Ip=xu.isBuffer(Uu)?Uu:xu.from(Uu,up),fm=Ip.length;if(fm===0)throw new TypeError('The value "'+Uu+'" is invalid for argument "value"');for(Mp=0;Mp<ep-zu;++Mp)this[Mp+zu]=Ip[Mp%fm]}return this};const sm={};function $p(qu,Uu,zu){sm[qu]=class extends zu{constructor(){super(),Object.defineProperty(this,"message",{value:Uu.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${qu}]`,this.stack,delete this.name}get code(){return qu}set code(up){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:up,writable:!0})}toString(){return`${this.name} [${qu}]: ${this.message}`}}}$p("ERR_BUFFER_OUT_OF_BOUNDS",function(qu){return qu?`${qu} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),$p("ERR_INVALID_ARG_TYPE",function(qu,Uu){return`The "${qu}" argument must be of type number. Received type ${typeof Uu}`},TypeError),$p("ERR_OUT_OF_RANGE",function(qu,Uu,zu){let ep=`The value of "${qu}" is out of range.`,up=zu;return Number.isInteger(zu)&&Math.abs(zu)>2**32?up=_f(String(zu)):typeof zu=="bigint"&&(up=String(zu),(zu>BigInt(2)**BigInt(32)||zu<-(BigInt(2)**BigInt(32)))&&(up=_f(up)),up+="n"),ep+=` It must be ${Uu}. Received ${up}`,ep},RangeError);function _f(qu){let Uu="",zu=qu.length;const ep=qu[0]==="-"?1:0;for(;zu>=ep+4;zu-=3)Uu=`_${qu.slice(zu-3,zu)}${Uu}`;return`${qu.slice(0,zu)}${Uu}`}function rm(qu,Uu,zu){cp(Uu,"offset"),(qu[Uu]===void 0||qu[Uu+zu]===void 0)&&mm(Uu,qu.length-(zu+1))}function lp(qu,Uu,zu,ep,up,Mp){if(qu>zu||qu<Uu){const Ip=typeof Uu=="bigint"?"n":"";let fm;throw Uu===0||Uu===BigInt(0)?fm=`>= 0${Ip} and < 2${Ip} ** ${(Mp+1)*8}${Ip}`:fm=`>= -(2${Ip} ** ${(Mp+1)*8-1}${Ip}) and < 2 ** ${(Mp+1)*8-1}${Ip}`,new sm.ERR_OUT_OF_RANGE("value",fm,qu)}rm(ep,up,Mp)}function cp(qu,Uu){if(typeof qu!="number")throw new sm.ERR_INVALID_ARG_TYPE(Uu,"number",qu)}function mm(qu,Uu,zu){throw Math.floor(qu)!==qu?(cp(qu,zu),new sm.ERR_OUT_OF_RANGE("offset","an integer",qu)):Uu<0?new sm.ERR_BUFFER_OUT_OF_BOUNDS:new sm.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${Uu}`,qu)}const $u=/[^+/0-9A-Za-z-_]/g;function Vu(qu){if(qu=qu.split("=")[0],qu=qu.trim().replace($u,""),qu.length<2)return"";for(;qu.length%4!==0;)qu=qu+"=";return qu}function _h(qu,Uu){Uu=Uu||1/0;let zu;const ep=qu.length;let up=null;const Mp=[];for(let Ip=0;Ip<ep;++Ip){if(zu=qu.charCodeAt(Ip),zu>55295&&zu<57344){if(!up){if(zu>56319){(Uu-=3)>-1&&Mp.push(239,191,189);continue}else if(Ip+1===ep){(Uu-=3)>-1&&Mp.push(239,191,189);continue}up=zu;continue}if(zu<56320){(Uu-=3)>-1&&Mp.push(239,191,189),up=zu;continue}zu=(up-55296<<10|zu-56320)+65536}else up&&(Uu-=3)>-1&&Mp.push(239,191,189);if(up=null,zu<128){if((Uu-=1)<0)break;Mp.push(zu)}else if(zu<2048){if((Uu-=2)<0)break;Mp.push(zu>>6|192,zu&63|128)}else if(zu<65536){if((Uu-=3)<0)break;Mp.push(zu>>12|224,zu>>6&63|128,zu&63|128)}else if(zu<1114112){if((Uu-=4)<0)break;Mp.push(zu>>18|240,zu>>12&63|128,zu>>6&63|128,zu&63|128)}else throw new Error("Invalid code point")}return Mp}function ap(qu){const Uu=[];for(let zu=0;zu<qu.length;++zu)Uu.push(qu.charCodeAt(zu)&255);return Uu}function mp(qu,Uu){let zu,ep,up;const Mp=[];for(let Ip=0;Ip<qu.length&&!((Uu-=2)<0);++Ip)zu=qu.charCodeAt(Ip),ep=zu>>8,up=zu%256,Mp.push(up),Mp.push(ep);return Mp}function Lp(qu){return eu.toByteArray(Vu(qu))}function Kp(qu,Uu,zu,ep){let up;for(up=0;up<ep&&!(up+zu>=Uu.length||up>=qu.length);++up)Uu[up+zu]=qu[up];return up}function vm(qu,Uu){return qu instanceof Uu||qu!=null&&qu.constructor!=null&&qu.constructor.name!=null&&qu.constructor.name===Uu.name}function sp(qu){return qu!==qu}const _d=function(){const qu="0123456789abcdef",Uu=new Array(256);for(let zu=0;zu<16;++zu){const ep=zu*16;for(let up=0;up<16;++up)Uu[ep+up]=qu[zu]+qu[up]}return Uu}();function Sp(qu){return typeof BigInt>"u"?tm:qu}function tm(){throw new Error("BigInt not supported")}})(buffer);const Buffer=buffer.Buffer;var browser={exports:{}},hasRequiredBrowser;function requireBrowser(){return hasRequiredBrowser||(hasRequiredBrowser=1,function(iu,eu){var tu=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof commonjsGlobal<"u")return commonjsGlobal;throw new Error("unable to locate global object")},su=tu();iu.exports=eu=su.fetch,su.fetch&&(eu.default=su.fetch.bind(su)),eu.Headers=su.Headers,eu.Request=su.Request,eu.Response=su.Response}(browser,browser.exports)),browser.exports}var util={},types={},shams$1,hasRequiredShams$1;function requireShams$1(){return hasRequiredShams$1||(hasRequiredShams$1=1,shams$1=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var eu={},tu=Symbol("test"),su=Object(tu);if(typeof tu=="string"||Object.prototype.toString.call(tu)!=="[object Symbol]"||Object.prototype.toString.call(su)!=="[object Symbol]")return!1;var au=42;eu[tu]=au;for(var uu in eu)return!1;if(typeof Object.keys=="function"&&Object.keys(eu).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(eu).length!==0)return!1;var du=Object.getOwnPropertySymbols(eu);if(du.length!==1||du[0]!==tu||!Object.prototype.propertyIsEnumerable.call(eu,tu))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var fu=Object.getOwnPropertyDescriptor(eu,tu);if(fu.value!==au||fu.enumerable!==!0)return!1}return!0}),shams$1}var shams,hasRequiredShams;function requireShams(){if(hasRequiredShams)return shams;hasRequiredShams=1;var iu=requireShams$1();return shams=function(){return iu()&&!!Symbol.toStringTag},shams}var esObjectAtoms,hasRequiredEsObjectAtoms;function requireEsObjectAtoms(){return hasRequiredEsObjectAtoms||(hasRequiredEsObjectAtoms=1,esObjectAtoms=Object),esObjectAtoms}var esErrors,hasRequiredEsErrors;function requireEsErrors(){return hasRequiredEsErrors||(hasRequiredEsErrors=1,esErrors=Error),esErrors}var _eval,hasRequired_eval;function require_eval(){return hasRequired_eval||(hasRequired_eval=1,_eval=EvalError),_eval}var range,hasRequiredRange;function requireRange(){return hasRequiredRange||(hasRequiredRange=1,range=RangeError),range}var ref,hasRequiredRef;function requireRef(){return hasRequiredRef||(hasRequiredRef=1,ref=ReferenceError),ref}var syntax,hasRequiredSyntax;function requireSyntax(){return hasRequiredSyntax||(hasRequiredSyntax=1,syntax=SyntaxError),syntax}var type,hasRequiredType;function requireType(){return hasRequiredType||(hasRequiredType=1,type=TypeError),type}var uri,hasRequiredUri;function requireUri(){return hasRequiredUri||(hasRequiredUri=1,uri=URIError),uri}var abs,hasRequiredAbs;function requireAbs(){return hasRequiredAbs||(hasRequiredAbs=1,abs=Math.abs),abs}var floor,hasRequiredFloor;function requireFloor(){return hasRequiredFloor||(hasRequiredFloor=1,floor=Math.floor),floor}var max,hasRequiredMax;function requireMax(){return hasRequiredMax||(hasRequiredMax=1,max=Math.max),max}var min,hasRequiredMin;function requireMin(){return hasRequiredMin||(hasRequiredMin=1,min=Math.min),min}var pow,hasRequiredPow;function requirePow(){return hasRequiredPow||(hasRequiredPow=1,pow=Math.pow),pow}var round,hasRequiredRound;function requireRound(){return hasRequiredRound||(hasRequiredRound=1,round=Math.round),round}var _isNaN,hasRequired_isNaN;function require_isNaN(){return hasRequired_isNaN||(hasRequired_isNaN=1,_isNaN=Number.isNaN||function(eu){return eu!==eu}),_isNaN}var sign,hasRequiredSign;function requireSign(){if(hasRequiredSign)return sign;hasRequiredSign=1;var iu=require_isNaN();return sign=function(tu){return iu(tu)||tu===0?tu:tu<0?-1:1},sign}var gOPD,hasRequiredGOPD;function requireGOPD(){return hasRequiredGOPD||(hasRequiredGOPD=1,gOPD=Object.getOwnPropertyDescriptor),gOPD}var gopd,hasRequiredGopd;function requireGopd(){if(hasRequiredGopd)return gopd;hasRequiredGopd=1;var iu=requireGOPD();if(iu)try{iu([],"length")}catch{iu=null}return gopd=iu,gopd}var esDefineProperty,hasRequiredEsDefineProperty;function requireEsDefineProperty(){if(hasRequiredEsDefineProperty)return esDefineProperty;hasRequiredEsDefineProperty=1;var iu=Object.defineProperty||!1;if(iu)try{iu({},"a",{value:1})}catch{iu=!1}return esDefineProperty=iu,esDefineProperty}var hasSymbols,hasRequiredHasSymbols;function requireHasSymbols(){if(hasRequiredHasSymbols)return hasSymbols;hasRequiredHasSymbols=1;var iu=typeof Symbol<"u"&&Symbol,eu=requireShams$1();return hasSymbols=function(){return typeof iu!="function"||typeof Symbol!="function"||typeof iu("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:eu()},hasSymbols}var Reflect_getPrototypeOf,hasRequiredReflect_getPrototypeOf;function requireReflect_getPrototypeOf(){return hasRequiredReflect_getPrototypeOf||(hasRequiredReflect_getPrototypeOf=1,Reflect_getPrototypeOf=typeof Reflect<"u"&&Reflect.getPrototypeOf||null),Reflect_getPrototypeOf}var Object_getPrototypeOf,hasRequiredObject_getPrototypeOf;function requireObject_getPrototypeOf(){if(hasRequiredObject_getPrototypeOf)return Object_getPrototypeOf;hasRequiredObject_getPrototypeOf=1;var iu=requireEsObjectAtoms();return Object_getPrototypeOf=iu.getPrototypeOf||null,Object_getPrototypeOf}var implementation,hasRequiredImplementation;function requireImplementation(){if(hasRequiredImplementation)return implementation;hasRequiredImplementation=1;var iu="Function.prototype.bind called on incompatible ",eu=Object.prototype.toString,tu=Math.max,su="[object Function]",au=function(gu,yu){for(var xu=[],vu=0;vu<gu.length;vu+=1)xu[vu]=gu[vu];for(var Su=0;Su<yu.length;Su+=1)xu[Su+gu.length]=yu[Su];return xu},uu=function(gu,yu){for(var xu=[],vu=yu,Su=0;vu<gu.length;vu+=1,Su+=1)xu[Su]=gu[vu];return xu},du=function(fu,gu){for(var yu="",xu=0;xu<fu.length;xu+=1)yu+=fu[xu],xu+1<fu.length&&(yu+=gu);return yu};return implementation=function(gu){var yu=this;if(typeof yu!="function"||eu.apply(yu)!==su)throw new TypeError(iu+yu);for(var xu=uu(arguments,1),vu,Su=function(){if(this instanceof vu){var _u=yu.apply(this,au(xu,arguments));return Object(_u)===_u?_u:this}return yu.apply(gu,au(xu,arguments))},Iu=tu(0,yu.length-xu.length),Mu=[],ku=0;ku<Iu;ku++)Mu[ku]="$"+ku;if(vu=Function("binder","return function ("+du(Mu,",")+"){ return binder.apply(this,arguments); }")(Su),yu.prototype){var Bu=function(){};Bu.prototype=yu.prototype,vu.prototype=new Bu,Bu.prototype=null}return vu},implementation}var functionBind,hasRequiredFunctionBind;function requireFunctionBind(){if(hasRequiredFunctionBind)return functionBind;hasRequiredFunctionBind=1;var iu=requireImplementation();return functionBind=Function.prototype.bind||iu,functionBind}var functionCall,hasRequiredFunctionCall;function requireFunctionCall(){return hasRequiredFunctionCall||(hasRequiredFunctionCall=1,functionCall=Function.prototype.call),functionCall}var functionApply,hasRequiredFunctionApply;function requireFunctionApply(){return hasRequiredFunctionApply||(hasRequiredFunctionApply=1,functionApply=Function.prototype.apply),functionApply}var reflectApply,hasRequiredReflectApply;function requireReflectApply(){return hasRequiredReflectApply||(hasRequiredReflectApply=1,reflectApply=typeof Reflect<"u"&&Reflect&&Reflect.apply),reflectApply}var actualApply,hasRequiredActualApply;function requireActualApply(){if(hasRequiredActualApply)return actualApply;hasRequiredActualApply=1;var iu=requireFunctionBind(),eu=requireFunctionApply(),tu=requireFunctionCall(),su=requireReflectApply();return actualApply=su||iu.call(tu,eu),actualApply}var callBindApplyHelpers,hasRequiredCallBindApplyHelpers;function requireCallBindApplyHelpers(){if(hasRequiredCallBindApplyHelpers)return callBindApplyHelpers;hasRequiredCallBindApplyHelpers=1;var iu=requireFunctionBind(),eu=requireType(),tu=requireFunctionCall(),su=requireActualApply();return callBindApplyHelpers=function(uu){if(uu.length<1||typeof uu[0]!="function")throw new eu("a function is required");return su(iu,tu,uu)},callBindApplyHelpers}var get,hasRequiredGet;function requireGet(){if(hasRequiredGet)return get;hasRequiredGet=1;var iu=requireCallBindApplyHelpers(),eu=requireGopd(),tu;try{tu=[].__proto__===Array.prototype}catch(du){if(!du||typeof du!="object"||!("code"in du)||du.code!=="ERR_PROTO_ACCESS")throw du}var su=!!tu&&eu&&eu(Object.prototype,"__proto__"),au=Object,uu=au.getPrototypeOf;return get=su&&typeof su.get=="function"?iu([su.get]):typeof uu=="function"?function(fu){return uu(fu==null?fu:au(fu))}:!1,get}var getProto,hasRequiredGetProto;function requireGetProto(){if(hasRequiredGetProto)return getProto;hasRequiredGetProto=1;var iu=requireReflect_getPrototypeOf(),eu=requireObject_getPrototypeOf(),tu=requireGet();return getProto=iu?function(au){return iu(au)}:eu?function(au){if(!au||typeof au!="object"&&typeof au!="function")throw new TypeError("getProto: not an object");return eu(au)}:tu?function(au){return tu(au)}:null,getProto}var hasown,hasRequiredHasown;function requireHasown(){if(hasRequiredHasown)return hasown;hasRequiredHasown=1;var iu=Function.prototype.call,eu=Object.prototype.hasOwnProperty,tu=requireFunctionBind();return hasown=tu.call(iu,eu),hasown}var getIntrinsic,hasRequiredGetIntrinsic;function requireGetIntrinsic(){if(hasRequiredGetIntrinsic)return getIntrinsic;hasRequiredGetIntrinsic=1;var iu,eu=requireEsObjectAtoms(),tu=requireEsErrors(),su=require_eval(),au=requireRange(),uu=requireRef(),du=requireSyntax(),fu=requireType(),gu=requireUri(),yu=requireAbs(),xu=requireFloor(),vu=requireMax(),Su=requireMin(),Iu=requirePow(),Mu=requireRound(),ku=requireSign(),Bu=Function,_u=function(Qp){try{return Bu('"use strict"; return ('+Qp+").constructor;")()}catch{}},Lu=requireGopd(),Du=requireEsDefineProperty(),Ou=function(){throw new fu},Wu=Lu?function(){try{return arguments.callee,Ou}catch{try{return Lu(arguments,"callee").get}catch{return Ou}}}():Ou,Zu=requireHasSymbols()(),Hu=requireGetProto(),Yu=requireObject_getPrototypeOf(),Ku=requireReflect_getPrototypeOf(),ju=requireFunctionApply(),tp=requireFunctionCall(),gp={},yp=typeof Uint8Array>"u"||!Hu?iu:Hu(Uint8Array),Cp={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?iu:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?iu:ArrayBuffer,"%ArrayIteratorPrototype%":Zu&&Hu?Hu([][Symbol.iterator]()):iu,"%AsyncFromSyncIteratorPrototype%":iu,"%AsyncFunction%":gp,"%AsyncGenerator%":gp,"%AsyncGeneratorFunction%":gp,"%AsyncIteratorPrototype%":gp,"%Atomics%":typeof Atomics>"u"?iu:Atomics,"%BigInt%":typeof BigInt>"u"?iu:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?iu:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?iu:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?iu:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":tu,"%eval%":eval,"%EvalError%":su,"%Float16Array%":typeof Float16Array>"u"?iu:Float16Array,"%Float32Array%":typeof Float32Array>"u"?iu:Float32Array,"%Float64Array%":typeof Float64Array>"u"?iu:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?iu:FinalizationRegistry,"%Function%":Bu,"%GeneratorFunction%":gp,"%Int8Array%":typeof Int8Array>"u"?iu:Int8Array,"%Int16Array%":typeof Int16Array>"u"?iu:Int16Array,"%Int32Array%":typeof Int32Array>"u"?iu:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":Zu&&Hu?Hu(Hu([][Symbol.iterator]())):iu,"%JSON%":typeof JSON=="object"?JSON:iu,"%Map%":typeof Map>"u"?iu:Map,"%MapIteratorPrototype%":typeof Map>"u"||!Zu||!Hu?iu:Hu(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":eu,"%Object.getOwnPropertyDescriptor%":Lu,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?iu:Promise,"%Proxy%":typeof Proxy>"u"?iu:Proxy,"%RangeError%":au,"%ReferenceError%":uu,"%Reflect%":typeof Reflect>"u"?iu:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?iu:Set,"%SetIteratorPrototype%":typeof Set>"u"||!Zu||!Hu?iu:Hu(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?iu:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":Zu&&Hu?Hu(""[Symbol.iterator]()):iu,"%Symbol%":Zu?Symbol:iu,"%SyntaxError%":du,"%ThrowTypeError%":Wu,"%TypedArray%":yp,"%TypeError%":fu,"%Uint8Array%":typeof Uint8Array>"u"?iu:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?iu:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?iu:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?iu:Uint32Array,"%URIError%":gu,"%WeakMap%":typeof WeakMap>"u"?iu:WeakMap,"%WeakRef%":typeof WeakRef>"u"?iu:WeakRef,"%WeakSet%":typeof WeakSet>"u"?iu:WeakSet,"%Function.prototype.call%":tp,"%Function.prototype.apply%":ju,"%Object.defineProperty%":Du,"%Object.getPrototypeOf%":Yu,"%Math.abs%":yu,"%Math.floor%":xu,"%Math.max%":vu,"%Math.min%":Su,"%Math.pow%":Iu,"%Math.round%":Mu,"%Math.sign%":ku,"%Reflect.getPrototypeOf%":Ku};if(Hu)try{null.error}catch(Qp){var Hp=Hu(Hu(Qp));Cp["%Error.prototype%"]=Hp}var wp=function Qp(Xp){var sm;if(Xp==="%AsyncFunction%")sm=_u("async function () {}");else if(Xp==="%GeneratorFunction%")sm=_u("function* () {}");else if(Xp==="%AsyncGeneratorFunction%")sm=_u("async function* () {}");else if(Xp==="%AsyncGenerator%"){var $p=Qp("%AsyncGeneratorFunction%");$p&&(sm=$p.prototype)}else if(Xp==="%AsyncIteratorPrototype%"){var _f=Qp("%AsyncGenerator%");_f&&Hu&&(sm=Hu(_f.prototype))}return Cp[Xp]=sm,sm},Dp={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},dp=requireFunctionBind(),Rp=requireHasown(),xp=dp.call(tp,Array.prototype.concat),cm=dp.call(ju,Array.prototype.splice),lm=dp.call(tp,String.prototype.replace),vp=dp.call(tp,String.prototype.slice),bp=dp.call(tp,RegExp.prototype.exec),kp=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,dm=/\\(\\)?/g,nm=function(Xp){var sm=vp(Xp,0,1),$p=vp(Xp,-1);if(sm==="%"&&$p!=="%")throw new du("invalid intrinsic syntax, expected closing `%`");if($p==="%"&&sm!=="%")throw new du("invalid intrinsic syntax, expected opening `%`");var _f=[];return lm(Xp,kp,function(rm,lp,cp,mm){_f[_f.length]=cp?lm(mm,dm,"$1"):lp||rm}),_f},Bp=function(Xp,sm){var $p=Xp,_f;if(Rp(Dp,$p)&&(_f=Dp[$p],$p="%"+_f[0]+"%"),Rp(Cp,$p)){var rm=Cp[$p];if(rm===gp&&(rm=wp($p)),typeof rm>"u"&&!sm)throw new fu("intrinsic "+Xp+" exists, but is not available. Please file an issue!");return{alias:_f,name:$p,value:rm}}throw new du("intrinsic "+Xp+" does not exist!")};return getIntrinsic=function(Xp,sm){if(typeof Xp!="string"||Xp.length===0)throw new fu("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof sm!="boolean")throw new fu('"allowMissing" argument must be a boolean');if(bp(/^%?[^%]*%?$/,Xp)===null)throw new du("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var $p=nm(Xp),_f=$p.length>0?$p[0]:"",rm=Bp("%"+_f+"%",sm),lp=rm.name,cp=rm.value,mm=!1,$u=rm.alias;$u&&(_f=$u[0],cm($p,xp([0,1],$u)));for(var Vu=1,_h=!0;Vu<$p.length;Vu+=1){var ap=$p[Vu],mp=vp(ap,0,1),Lp=vp(ap,-1);if((mp==='"'||mp==="'"||mp==="`"||Lp==='"'||Lp==="'"||Lp==="`")&&mp!==Lp)throw new du("property names with quotes must have matching quotes");if((ap==="constructor"||!_h)&&(mm=!0),_f+="."+ap,lp="%"+_f+"%",Rp(Cp,lp))cp=Cp[lp];else if(cp!=null){if(!(ap in cp)){if(!sm)throw new fu("base intrinsic for "+Xp+" exists, but the property is not available.");return}if(Lu&&Vu+1>=$p.length){var Kp=Lu(cp,ap);_h=!!Kp,_h&&"get"in Kp&&!("originalValue"in Kp.get)?cp=Kp.get:cp=cp[ap]}else _h=Rp(cp,ap),cp=cp[ap];_h&&!mm&&(Cp[lp]=cp)}}return cp},getIntrinsic}var callBound,hasRequiredCallBound;function requireCallBound(){if(hasRequiredCallBound)return callBound;hasRequiredCallBound=1;var iu=requireGetIntrinsic(),eu=requireCallBindApplyHelpers(),tu=eu([iu("%String.prototype.indexOf%")]);return callBound=function(au,uu){var du=iu(au,!!uu);return typeof du=="function"&&tu(au,".prototype.")>-1?eu([du]):du},callBound}var isArguments,hasRequiredIsArguments;function requireIsArguments(){if(hasRequiredIsArguments)return isArguments;hasRequiredIsArguments=1;var iu=requireShams()(),eu=requireCallBound(),tu=eu("Object.prototype.toString"),su=function(fu){return iu&&fu&&typeof fu=="object"&&Symbol.toStringTag in fu?!1:tu(fu)==="[object Arguments]"},au=function(fu){return su(fu)?!0:fu!==null&&typeof fu=="object"&&"length"in fu&&typeof fu.length=="number"&&fu.length>=0&&tu(fu)!=="[object Array]"&&"callee"in fu&&tu(fu.callee)==="[object Function]"},uu=function(){return su(arguments)}();return su.isLegacyArguments=au,isArguments=uu?su:au,isArguments}var isRegex,hasRequiredIsRegex;function requireIsRegex(){if(hasRequiredIsRegex)return isRegex;hasRequiredIsRegex=1;var iu=requireCallBound(),eu=requireShams()(),tu=requireHasown(),su=requireGopd(),au;if(eu){var uu=iu("RegExp.prototype.exec"),du={},fu=function(){throw du},gu={toString:fu,valueOf:fu};typeof Symbol.toPrimitive=="symbol"&&(gu[Symbol.toPrimitive]=fu),au=function(Su){if(!Su||typeof Su!="object")return!1;var Iu=su(Su,"lastIndex"),Mu=Iu&&tu(Iu,"value");if(!Mu)return!1;try{uu(Su,gu)}catch(ku){return ku===du}}}else{var yu=iu("Object.prototype.toString"),xu="[object RegExp]";au=function(Su){return!Su||typeof Su!="object"&&typeof Su!="function"?!1:yu(Su)===xu}}return isRegex=au,isRegex}var safeRegexTest,hasRequiredSafeRegexTest;function requireSafeRegexTest(){if(hasRequiredSafeRegexTest)return safeRegexTest;hasRequiredSafeRegexTest=1;var iu=requireCallBound(),eu=requireIsRegex(),tu=iu("RegExp.prototype.exec"),su=requireType();return safeRegexTest=function(uu){if(!eu(uu))throw new su("`regex` must be a RegExp");return function(fu){return tu(uu,fu)!==null}},safeRegexTest}var generatorFunction,hasRequiredGeneratorFunction;function requireGeneratorFunction(){if(hasRequiredGeneratorFunction)return generatorFunction;hasRequiredGeneratorFunction=1;const iu=(function*(){}).constructor;return generatorFunction=()=>iu,generatorFunction}var isGeneratorFunction,hasRequiredIsGeneratorFunction;function requireIsGeneratorFunction(){if(hasRequiredIsGeneratorFunction)return isGeneratorFunction;hasRequiredIsGeneratorFunction=1;var iu=requireCallBound(),eu=requireSafeRegexTest(),tu=eu(/^\s*(?:function)?\*/),su=requireShams()(),au=requireGetProto(),uu=iu("Object.prototype.toString"),du=iu("Function.prototype.toString"),fu=requireGeneratorFunction();return isGeneratorFunction=function(yu){if(typeof yu!="function")return!1;if(tu(du(yu)))return!0;if(!su){var xu=uu(yu);return xu==="[object GeneratorFunction]"}if(!au)return!1;var vu=fu();return vu&&au(yu)===vu.prototype},isGeneratorFunction}var isCallable,hasRequiredIsCallable;function requireIsCallable(){if(hasRequiredIsCallable)return isCallable;hasRequiredIsCallable=1;var iu=Function.prototype.toString,eu=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,tu,su;if(typeof eu=="function"&&typeof Object.defineProperty=="function")try{tu=Object.defineProperty({},"length",{get:function(){throw su}}),su={},eu(function(){throw 42},null,tu)}catch(Lu){Lu!==su&&(eu=null)}else eu=null;var au=/^\s*class\b/,uu=function(Du){try{var Ou=iu.call(Du);return au.test(Ou)}catch{return!1}},du=function(Du){try{return uu(Du)?!1:(iu.call(Du),!0)}catch{return!1}},fu=Object.prototype.toString,gu="[object Object]",yu="[object Function]",xu="[object GeneratorFunction]",vu="[object HTMLAllCollection]",Su="[object HTML document.all class]",Iu="[object HTMLCollection]",Mu=typeof Symbol=="function"&&!!Symbol.toStringTag,ku=!(0 in[,]),Bu=function(){return!1};if(typeof document=="object"){var _u=document.all;fu.call(_u)===fu.call(document.all)&&(Bu=function(Du){if((ku||!Du)&&(typeof Du>"u"||typeof Du=="object"))try{var Ou=fu.call(Du);return(Ou===vu||Ou===Su||Ou===Iu||Ou===gu)&&Du("")==null}catch{}return!1})}return isCallable=eu?function(Du){if(Bu(Du))return!0;if(!Du||typeof Du!="function"&&typeof Du!="object")return!1;try{eu(Du,null,tu)}catch(Ou){if(Ou!==su)return!1}return!uu(Du)&&du(Du)}:function(Du){if(Bu(Du))return!0;if(!Du||typeof Du!="function"&&typeof Du!="object")return!1;if(Mu)return du(Du);if(uu(Du))return!1;var Ou=fu.call(Du);return Ou!==yu&&Ou!==xu&&!/^\[object HTML/.test(Ou)?!1:du(Du)},isCallable}var forEach,hasRequiredForEach;function requireForEach(){if(hasRequiredForEach)return forEach;hasRequiredForEach=1;var iu=requireIsCallable(),eu=Object.prototype.toString,tu=Object.prototype.hasOwnProperty,su=function(gu,yu,xu){for(var vu=0,Su=gu.length;vu<Su;vu++)tu.call(gu,vu)&&(xu==null?yu(gu[vu],vu,gu):yu.call(xu,gu[vu],vu,gu))},au=function(gu,yu,xu){for(var vu=0,Su=gu.length;vu<Su;vu++)xu==null?yu(gu.charAt(vu),vu,gu):yu.call(xu,gu.charAt(vu),vu,gu)},uu=function(gu,yu,xu){for(var vu in gu)tu.call(gu,vu)&&(xu==null?yu(gu[vu],vu,gu):yu.call(xu,gu[vu],vu,gu))};function du(fu){return eu.call(fu)==="[object Array]"}return forEach=function(gu,yu,xu){if(!iu(yu))throw new TypeError("iterator must be a function");var vu;arguments.length>=3&&(vu=xu),du(gu)?su(gu,yu,vu):typeof gu=="string"?au(gu,yu,vu):uu(gu,yu,vu)},forEach}var possibleTypedArrayNames,hasRequiredPossibleTypedArrayNames;function requirePossibleTypedArrayNames(){return hasRequiredPossibleTypedArrayNames||(hasRequiredPossibleTypedArrayNames=1,possibleTypedArrayNames=["Float16Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]),possibleTypedArrayNames}var availableTypedArrays,hasRequiredAvailableTypedArrays;function requireAvailableTypedArrays(){if(hasRequiredAvailableTypedArrays)return availableTypedArrays;hasRequiredAvailableTypedArrays=1;var iu=requirePossibleTypedArrayNames(),eu=typeof globalThis>"u"?commonjsGlobal:globalThis;return availableTypedArrays=function(){for(var su=[],au=0;au<iu.length;au++)typeof eu[iu[au]]=="function"&&(su[su.length]=iu[au]);return su},availableTypedArrays}var callBind={exports:{}},defineDataProperty,hasRequiredDefineDataProperty;function requireDefineDataProperty(){if(hasRequiredDefineDataProperty)return defineDataProperty;hasRequiredDefineDataProperty=1;var iu=requireEsDefineProperty(),eu=requireSyntax(),tu=requireType(),su=requireGopd();return defineDataProperty=function(uu,du,fu){if(!uu||typeof uu!="object"&&typeof uu!="function")throw new tu("`obj` must be an object or a function`");if(typeof du!="string"&&typeof du!="symbol")throw new tu("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new tu("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new tu("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new tu("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new tu("`loose`, if provided, must be a boolean");var gu=arguments.length>3?arguments[3]:null,yu=arguments.length>4?arguments[4]:null,xu=arguments.length>5?arguments[5]:null,vu=arguments.length>6?arguments[6]:!1,Su=!!su&&su(uu,du);if(iu)iu(uu,du,{configurable:xu===null&&Su?Su.configurable:!xu,enumerable:gu===null&&Su?Su.enumerable:!gu,value:fu,writable:yu===null&&Su?Su.writable:!yu});else if(vu||!gu&&!yu&&!xu)uu[du]=fu;else throw new eu("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")},defineDataProperty}var hasPropertyDescriptors_1,hasRequiredHasPropertyDescriptors;function requireHasPropertyDescriptors(){if(hasRequiredHasPropertyDescriptors)return hasPropertyDescriptors_1;hasRequiredHasPropertyDescriptors=1;var iu=requireEsDefineProperty(),eu=function(){return!!iu};return eu.hasArrayLengthDefineBug=function(){if(!iu)return null;try{return iu([],"length",{value:1}).length!==1}catch{return!0}},hasPropertyDescriptors_1=eu,hasPropertyDescriptors_1}var setFunctionLength,hasRequiredSetFunctionLength;function requireSetFunctionLength(){if(hasRequiredSetFunctionLength)return setFunctionLength;hasRequiredSetFunctionLength=1;var iu=requireGetIntrinsic(),eu=requireDefineDataProperty(),tu=requireHasPropertyDescriptors()(),su=requireGopd(),au=requireType(),uu=iu("%Math.floor%");return setFunctionLength=function(fu,gu){if(typeof fu!="function")throw new au("`fn` is not a function");if(typeof gu!="number"||gu<0||gu>4294967295||uu(gu)!==gu)throw new au("`length` must be a positive 32-bit integer");var yu=arguments.length>2&&!!arguments[2],xu=!0,vu=!0;if("length"in fu&&su){var Su=su(fu,"length");Su&&!Su.configurable&&(xu=!1),Su&&!Su.writable&&(vu=!1)}return(xu||vu||!yu)&&(tu?eu(fu,"length",gu,!0,!0):eu(fu,"length",gu)),fu},setFunctionLength}var applyBind,hasRequiredApplyBind;function requireApplyBind(){if(hasRequiredApplyBind)return applyBind;hasRequiredApplyBind=1;var iu=requireFunctionBind(),eu=requireFunctionApply(),tu=requireActualApply();return applyBind=function(){return tu(iu,eu,arguments)},applyBind}var hasRequiredCallBind;function requireCallBind(){return hasRequiredCallBind||(hasRequiredCallBind=1,function(iu){var eu=requireSetFunctionLength(),tu=requireEsDefineProperty(),su=requireCallBindApplyHelpers(),au=requireApplyBind();iu.exports=function(du){var fu=su(arguments),gu=du.length-(arguments.length-1);return eu(fu,1+(gu>0?gu:0),!0)},tu?tu(iu.exports,"apply",{value:au}):iu.exports.apply=au}(callBind)),callBind.exports}var whichTypedArray,hasRequiredWhichTypedArray;function requireWhichTypedArray(){if(hasRequiredWhichTypedArray)return whichTypedArray;hasRequiredWhichTypedArray=1;var iu=requireForEach(),eu=requireAvailableTypedArrays(),tu=requireCallBind(),su=requireCallBound(),au=requireGopd(),uu=requireGetProto(),du=su("Object.prototype.toString"),fu=requireShams()(),gu=typeof globalThis>"u"?commonjsGlobal:globalThis,yu=eu(),xu=su("String.prototype.slice"),vu=su("Array.prototype.indexOf",!0)||function(Bu,_u){for(var Lu=0;Lu<Bu.length;Lu+=1)if(Bu[Lu]===_u)return Lu;return-1},Su={__proto__:null};fu&&au&&uu?iu(yu,function(ku){var Bu=new gu[ku];if(Symbol.toStringTag in Bu&&uu){var _u=uu(Bu),Lu=au(_u,Symbol.toStringTag);if(!Lu&&_u){var Du=uu(_u);Lu=au(Du,Symbol.toStringTag)}Su["$"+ku]=tu(Lu.get)}}):iu(yu,function(ku){var Bu=new gu[ku],_u=Bu.slice||Bu.set;_u&&(Su["$"+ku]=tu(_u))});var Iu=function(Bu){var _u=!1;return iu(Su,function(Lu,Du){if(!_u)try{"$"+Lu(Bu)===Du&&(_u=xu(Du,1))}catch{}}),_u},Mu=function(Bu){var _u=!1;return iu(Su,function(Lu,Du){if(!_u)try{Lu(Bu),_u=xu(Du,1)}catch{}}),_u};return whichTypedArray=function(Bu){if(!Bu||typeof Bu!="object")return!1;if(!fu){var _u=xu(du(Bu),8,-1);return vu(yu,_u)>-1?_u:_u!=="Object"?!1:Mu(Bu)}return au?Iu(Bu):null},whichTypedArray}var isTypedArray,hasRequiredIsTypedArray;function requireIsTypedArray(){if(hasRequiredIsTypedArray)return isTypedArray;hasRequiredIsTypedArray=1;var iu=requireWhichTypedArray();return isTypedArray=function(tu){return!!iu(tu)},isTypedArray}var hasRequiredTypes;function requireTypes(){return hasRequiredTypes||(hasRequiredTypes=1,function(iu){var eu=requireIsArguments(),tu=requireIsGeneratorFunction(),su=requireWhichTypedArray(),au=requireIsTypedArray();function uu(Vu){return Vu.call.bind(Vu)}var du=typeof BigInt<"u",fu=typeof Symbol<"u",gu=uu(Object.prototype.toString),yu=uu(Number.prototype.valueOf),xu=uu(String.prototype.valueOf),vu=uu(Boolean.prototype.valueOf);if(du)var Su=uu(BigInt.prototype.valueOf);if(fu)var Iu=uu(Symbol.prototype.valueOf);function Mu(Vu,_h){if(typeof Vu!="object")return!1;try{return _h(Vu),!0}catch{return!1}}iu.isArgumentsObject=eu,iu.isGeneratorFunction=tu,iu.isTypedArray=au;function ku(Vu){return typeof Promise<"u"&&Vu instanceof Promise||Vu!==null&&typeof Vu=="object"&&typeof Vu.then=="function"&&typeof Vu.catch=="function"}iu.isPromise=ku;function Bu(Vu){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(Vu):au(Vu)||vp(Vu)}iu.isArrayBufferView=Bu;function _u(Vu){return su(Vu)==="Uint8Array"}iu.isUint8Array=_u;function Lu(Vu){return su(Vu)==="Uint8ClampedArray"}iu.isUint8ClampedArray=Lu;function Du(Vu){return su(Vu)==="Uint16Array"}iu.isUint16Array=Du;function Ou(Vu){return su(Vu)==="Uint32Array"}iu.isUint32Array=Ou;function Wu(Vu){return su(Vu)==="Int8Array"}iu.isInt8Array=Wu;function Zu(Vu){return su(Vu)==="Int16Array"}iu.isInt16Array=Zu;function Hu(Vu){return su(Vu)==="Int32Array"}iu.isInt32Array=Hu;function Yu(Vu){return su(Vu)==="Float32Array"}iu.isFloat32Array=Yu;function Ku(Vu){return su(Vu)==="Float64Array"}iu.isFloat64Array=Ku;function ju(Vu){return su(Vu)==="BigInt64Array"}iu.isBigInt64Array=ju;function tp(Vu){return su(Vu)==="BigUint64Array"}iu.isBigUint64Array=tp;function gp(Vu){return gu(Vu)==="[object Map]"}gp.working=typeof Map<"u"&&gp(new Map);function yp(Vu){return typeof Map>"u"?!1:gp.working?gp(Vu):Vu instanceof Map}iu.isMap=yp;function Cp(Vu){return gu(Vu)==="[object Set]"}Cp.working=typeof Set<"u"&&Cp(new Set);function Hp(Vu){return typeof Set>"u"?!1:Cp.working?Cp(Vu):Vu instanceof Set}iu.isSet=Hp;function wp(Vu){return gu(Vu)==="[object WeakMap]"}wp.working=typeof WeakMap<"u"&&wp(new WeakMap);function Dp(Vu){return typeof WeakMap>"u"?!1:wp.working?wp(Vu):Vu instanceof WeakMap}iu.isWeakMap=Dp;function dp(Vu){return gu(Vu)==="[object WeakSet]"}dp.working=typeof WeakSet<"u"&&dp(new WeakSet);function Rp(Vu){return dp(Vu)}iu.isWeakSet=Rp;function xp(Vu){return gu(Vu)==="[object ArrayBuffer]"}xp.working=typeof ArrayBuffer<"u"&&xp(new ArrayBuffer);function cm(Vu){return typeof ArrayBuffer>"u"?!1:xp.working?xp(Vu):Vu instanceof ArrayBuffer}iu.isArrayBuffer=cm;function lm(Vu){return gu(Vu)==="[object DataView]"}lm.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&lm(new DataView(new ArrayBuffer(1),0,1));function vp(Vu){return typeof DataView>"u"?!1:lm.working?lm(Vu):Vu instanceof DataView}iu.isDataView=vp;var bp=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function kp(Vu){return gu(Vu)==="[object SharedArrayBuffer]"}function dm(Vu){return typeof bp>"u"?!1:(typeof kp.working>"u"&&(kp.working=kp(new bp)),kp.working?kp(Vu):Vu instanceof bp)}iu.isSharedArrayBuffer=dm;function nm(Vu){return gu(Vu)==="[object AsyncFunction]"}iu.isAsyncFunction=nm;function Bp(Vu){return gu(Vu)==="[object Map Iterator]"}iu.isMapIterator=Bp;function Qp(Vu){return gu(Vu)==="[object Set Iterator]"}iu.isSetIterator=Qp;function Xp(Vu){return gu(Vu)==="[object Generator]"}iu.isGeneratorObject=Xp;function sm(Vu){return gu(Vu)==="[object WebAssembly.Module]"}iu.isWebAssemblyCompiledModule=sm;function $p(Vu){return Mu(Vu,yu)}iu.isNumberObject=$p;function _f(Vu){return Mu(Vu,xu)}iu.isStringObject=_f;function rm(Vu){return Mu(Vu,vu)}iu.isBooleanObject=rm;function lp(Vu){return du&&Mu(Vu,Su)}iu.isBigIntObject=lp;function cp(Vu){return fu&&Mu(Vu,Iu)}iu.isSymbolObject=cp;function mm(Vu){return $p(Vu)||_f(Vu)||rm(Vu)||lp(Vu)||cp(Vu)}iu.isBoxedPrimitive=mm;function $u(Vu){return typeof Uint8Array<"u"&&(cm(Vu)||dm(Vu))}iu.isAnyArrayBuffer=$u,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(Vu){Object.defineProperty(iu,Vu,{enumerable:!1,value:function(){throw new Error(Vu+" is not supported in userland")}})})}(types)),types}var isBufferBrowser,hasRequiredIsBufferBrowser;function requireIsBufferBrowser(){return hasRequiredIsBufferBrowser||(hasRequiredIsBufferBrowser=1,isBufferBrowser=function(eu){return eu&&typeof eu=="object"&&typeof eu.copy=="function"&&typeof eu.fill=="function"&&typeof eu.readUInt8=="function"}),isBufferBrowser}var inherits_browser={exports:{}},hasRequiredInherits_browser;function requireInherits_browser(){return hasRequiredInherits_browser||(hasRequiredInherits_browser=1,typeof Object.create=="function"?inherits_browser.exports=function(eu,tu){tu&&(eu.super_=tu,eu.prototype=Object.create(tu.prototype,{constructor:{value:eu,enumerable:!1,writable:!0,configurable:!0}}))}:inherits_browser.exports=function(eu,tu){if(tu){eu.super_=tu;var su=function(){};su.prototype=tu.prototype,eu.prototype=new su,eu.prototype.constructor=eu}}),inherits_browser.exports}var hasRequiredUtil;function requireUtil(){return hasRequiredUtil||(hasRequiredUtil=1,function(iu){var eu={},tu=Object.getOwnPropertyDescriptors||function(bp){for(var kp=Object.keys(bp),dm={},nm=0;nm<kp.length;nm++)dm[kp[nm]]=Object.getOwnPropertyDescriptor(bp,kp[nm]);return dm},su=/%[sdj%]/g;iu.format=function(vp){if(!Zu(vp)){for(var bp=[],kp=0;kp<arguments.length;kp++)bp.push(fu(arguments[kp]));return bp.join(" ")}for(var kp=1,dm=arguments,nm=dm.length,Bp=String(vp).replace(su,function(Xp){if(Xp==="%%")return"%";if(kp>=nm)return Xp;switch(Xp){case"%s":return String(dm[kp++]);case"%d":return Number(dm[kp++]);case"%j":try{return JSON.stringify(dm[kp++])}catch{return"[Circular]"}default:return Xp}}),Qp=dm[kp];kp<nm;Qp=dm[++kp])Du(Qp)||!ju(Qp)?Bp+=" "+Qp:Bp+=" "+fu(Qp);return Bp},iu.deprecate=function(vp,bp){if(typeof process$1<"u"&&process$1.noDeprecation===!0)return vp;if(typeof process$1>"u")return function(){return iu.deprecate(vp,bp).apply(this,arguments)};var kp=!1;function dm(){if(!kp){if(process$1.throwDeprecation)throw new Error(bp);process$1.traceDeprecation?console.trace(bp):console.error(bp),kp=!0}return vp.apply(this,arguments)}return dm};var au={},uu=/^$/;if(eu.NODE_DEBUG){var du=eu.NODE_DEBUG;du=du.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),uu=new RegExp("^"+du+"$","i")}iu.debuglog=function(vp){if(vp=vp.toUpperCase(),!au[vp])if(uu.test(vp)){var bp=process$1.pid;au[vp]=function(){var kp=iu.format.apply(iu,arguments);console.error("%s %d: %s",vp,bp,kp)}}else au[vp]=function(){};return au[vp]};function fu(vp,bp){var kp={seen:[],stylize:yu};return arguments.length>=3&&(kp.depth=arguments[2]),arguments.length>=4&&(kp.colors=arguments[3]),Lu(bp)?kp.showHidden=bp:bp&&iu._extend(kp,bp),Yu(kp.showHidden)&&(kp.showHidden=!1),Yu(kp.depth)&&(kp.depth=2),Yu(kp.colors)&&(kp.colors=!1),Yu(kp.customInspect)&&(kp.customInspect=!0),kp.colors&&(kp.stylize=gu),vu(kp,vp,kp.depth)}iu.inspect=fu,fu.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},fu.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function gu(vp,bp){var kp=fu.styles[bp];return kp?"\x1B["+fu.colors[kp][0]+"m"+vp+"\x1B["+fu.colors[kp][1]+"m":vp}function yu(vp,bp){return vp}function xu(vp){var bp={};return vp.forEach(function(kp,dm){bp[kp]=!0}),bp}function vu(vp,bp,kp){if(vp.customInspect&&bp&&yp(bp.inspect)&&bp.inspect!==iu.inspect&&!(bp.constructor&&bp.constructor.prototype===bp)){var dm=bp.inspect(kp,vp);return Zu(dm)||(dm=vu(vp,dm,kp)),dm}var nm=Su(vp,bp);if(nm)return nm;var Bp=Object.keys(bp),Qp=xu(Bp);if(vp.showHidden&&(Bp=Object.getOwnPropertyNames(bp)),gp(bp)&&(Bp.indexOf("message")>=0||Bp.indexOf("description")>=0))return Iu(bp);if(Bp.length===0){if(yp(bp)){var Xp=bp.name?": "+bp.name:"";return vp.stylize("[Function"+Xp+"]","special")}if(Ku(bp))return vp.stylize(RegExp.prototype.toString.call(bp),"regexp");if(tp(bp))return vp.stylize(Date.prototype.toString.call(bp),"date");if(gp(bp))return Iu(bp)}var sm="",$p=!1,_f=["{","}"];if(_u(bp)&&($p=!0,_f=["[","]"]),yp(bp)){var rm=bp.name?": "+bp.name:"";sm=" [Function"+rm+"]"}if(Ku(bp)&&(sm=" "+RegExp.prototype.toString.call(bp)),tp(bp)&&(sm=" "+Date.prototype.toUTCString.call(bp)),gp(bp)&&(sm=" "+Iu(bp)),Bp.length===0&&(!$p||bp.length==0))return _f[0]+sm+_f[1];if(kp<0)return Ku(bp)?vp.stylize(RegExp.prototype.toString.call(bp),"regexp"):vp.stylize("[Object]","special");vp.seen.push(bp);var lp;return $p?lp=Mu(vp,bp,kp,Qp,Bp):lp=Bp.map(function(cp){return ku(vp,bp,kp,Qp,cp,$p)}),vp.seen.pop(),Bu(lp,sm,_f)}function Su(vp,bp){if(Yu(bp))return vp.stylize("undefined","undefined");if(Zu(bp)){var kp="'"+JSON.stringify(bp).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return vp.stylize(kp,"string")}if(Wu(bp))return vp.stylize(""+bp,"number");if(Lu(bp))return vp.stylize(""+bp,"boolean");if(Du(bp))return vp.stylize("null","null")}function Iu(vp){return"["+Error.prototype.toString.call(vp)+"]"}function Mu(vp,bp,kp,dm,nm){for(var Bp=[],Qp=0,Xp=bp.length;Qp<Xp;++Qp)Rp(bp,String(Qp))?Bp.push(ku(vp,bp,kp,dm,String(Qp),!0)):Bp.push("");return nm.forEach(function(sm){sm.match(/^\d+$/)||Bp.push(ku(vp,bp,kp,dm,sm,!0))}),Bp}function ku(vp,bp,kp,dm,nm,Bp){var Qp,Xp,sm;if(sm=Object.getOwnPropertyDescriptor(bp,nm)||{value:bp[nm]},sm.get?sm.set?Xp=vp.stylize("[Getter/Setter]","special"):Xp=vp.stylize("[Getter]","special"):sm.set&&(Xp=vp.stylize("[Setter]","special")),Rp(dm,nm)||(Qp="["+nm+"]"),Xp||(vp.seen.indexOf(sm.value)<0?(Du(kp)?Xp=vu(vp,sm.value,null):Xp=vu(vp,sm.value,kp-1),Xp.indexOf(`
`)>-1&&(Bp?Xp=Xp.split(`
`).map(function($p){return"  "+$p}).join(`
`).slice(2):Xp=`
`+Xp.split(`
`).map(function($p){return"   "+$p}).join(`
`))):Xp=vp.stylize("[Circular]","special")),Yu(Qp)){if(Bp&&nm.match(/^\d+$/))return Xp;Qp=JSON.stringify(""+nm),Qp.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(Qp=Qp.slice(1,-1),Qp=vp.stylize(Qp,"name")):(Qp=Qp.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),Qp=vp.stylize(Qp,"string"))}return Qp+": "+Xp}function Bu(vp,bp,kp){var dm=vp.reduce(function(nm,Bp){return Bp.indexOf(`
`)>=0,nm+Bp.replace(/\u001b\[\d\d?m/g,"").length+1},0);return dm>60?kp[0]+(bp===""?"":bp+`
 `)+" "+vp.join(`,
  `)+" "+kp[1]:kp[0]+bp+" "+vp.join(", ")+" "+kp[1]}iu.types=requireTypes();function _u(vp){return Array.isArray(vp)}iu.isArray=_u;function Lu(vp){return typeof vp=="boolean"}iu.isBoolean=Lu;function Du(vp){return vp===null}iu.isNull=Du;function Ou(vp){return vp==null}iu.isNullOrUndefined=Ou;function Wu(vp){return typeof vp=="number"}iu.isNumber=Wu;function Zu(vp){return typeof vp=="string"}iu.isString=Zu;function Hu(vp){return typeof vp=="symbol"}iu.isSymbol=Hu;function Yu(vp){return vp===void 0}iu.isUndefined=Yu;function Ku(vp){return ju(vp)&&Hp(vp)==="[object RegExp]"}iu.isRegExp=Ku,iu.types.isRegExp=Ku;function ju(vp){return typeof vp=="object"&&vp!==null}iu.isObject=ju;function tp(vp){return ju(vp)&&Hp(vp)==="[object Date]"}iu.isDate=tp,iu.types.isDate=tp;function gp(vp){return ju(vp)&&(Hp(vp)==="[object Error]"||vp instanceof Error)}iu.isError=gp,iu.types.isNativeError=gp;function yp(vp){return typeof vp=="function"}iu.isFunction=yp;function Cp(vp){return vp===null||typeof vp=="boolean"||typeof vp=="number"||typeof vp=="string"||typeof vp=="symbol"||typeof vp>"u"}iu.isPrimitive=Cp,iu.isBuffer=requireIsBufferBrowser();function Hp(vp){return Object.prototype.toString.call(vp)}function wp(vp){return vp<10?"0"+vp.toString(10):vp.toString(10)}var Dp=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function dp(){var vp=new Date,bp=[wp(vp.getHours()),wp(vp.getMinutes()),wp(vp.getSeconds())].join(":");return[vp.getDate(),Dp[vp.getMonth()],bp].join(" ")}iu.log=function(){console.log("%s - %s",dp(),iu.format.apply(iu,arguments))},iu.inherits=requireInherits_browser(),iu._extend=function(vp,bp){if(!bp||!ju(bp))return vp;for(var kp=Object.keys(bp),dm=kp.length;dm--;)vp[kp[dm]]=bp[kp[dm]];return vp};function Rp(vp,bp){return Object.prototype.hasOwnProperty.call(vp,bp)}var xp=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;iu.promisify=function(bp){if(typeof bp!="function")throw new TypeError('The "original" argument must be of type Function');if(xp&&bp[xp]){var kp=bp[xp];if(typeof kp!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(kp,xp,{value:kp,enumerable:!1,writable:!1,configurable:!0}),kp}function kp(){for(var dm,nm,Bp=new Promise(function(sm,$p){dm=sm,nm=$p}),Qp=[],Xp=0;Xp<arguments.length;Xp++)Qp.push(arguments[Xp]);Qp.push(function(sm,$p){sm?nm(sm):dm($p)});try{bp.apply(this,Qp)}catch(sm){nm(sm)}return Bp}return Object.setPrototypeOf(kp,Object.getPrototypeOf(bp)),xp&&Object.defineProperty(kp,xp,{value:kp,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(kp,tu(bp))},iu.promisify.custom=xp;function cm(vp,bp){if(!vp){var kp=new Error("Promise was rejected with a falsy value");kp.reason=vp,vp=kp}return bp(vp)}function lm(vp){if(typeof vp!="function")throw new TypeError('The "original" argument must be of type Function');function bp(){for(var kp=[],dm=0;dm<arguments.length;dm++)kp.push(arguments[dm]);var nm=kp.pop();if(typeof nm!="function")throw new TypeError("The last argument must be of type Function");var Bp=this,Qp=function(){return nm.apply(Bp,arguments)};vp.apply(this,kp).then(function(Xp){process$1.nextTick(Qp.bind(null,null,Xp))},function(Xp){process$1.nextTick(cm.bind(null,Xp,Qp))})}return Object.setPrototypeOf(bp,Object.getPrototypeOf(vp)),Object.defineProperties(bp,tu(vp)),bp}iu.callbackify=lm}(util)),util}var define_process_env_default={};(function(){function iu(ou,nu){for(var ru=0;ru<nu.length;ru++){const lu=nu[ru];if(typeof lu!="string"&&!Array.isArray(lu)){for(const cu in lu)if(cu!=="default"&&!(cu in ou)){const hu=Object.getOwnPropertyDescriptor(lu,cu);hu&&Object.defineProperty(ou,cu,hu.get?hu:{enumerable:!0,get:()=>lu[cu]})}}}return Object.freeze(Object.defineProperty(ou,Symbol.toStringTag,{value:"Module"}))}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eu=1e-7,tu=1e-4;class su{constructor(nu,ru){this.backend=nu,this.dataMover=ru,this.data=new WeakMap,this.dataIdsCount=0}get(nu){return this.data.has(nu)||this.dataMover.moveData(this.backend,nu),this.data.get(nu)}set(nu,ru){this.dataIdsCount++,this.data.set(nu,ru)}has(nu){return this.data.has(nu)}delete(nu){return this.dataIdsCount--,this.data.delete(nu)}numDataIds(){return this.dataIdsCount}}class au{refCount(nu){return uu("refCount")}incRef(nu){return uu("incRef")}timerAvailable(){return!0}time(nu){return uu("time")}read(nu){return uu("read")}readSync(nu){return uu("readSync")}readToGPU(nu,ru){return uu("readToGPU")}numDataIds(){return uu("numDataIds")}disposeData(nu,ru){return uu("disposeData")}write(nu,ru,lu){return uu("write")}move(nu,ru,lu,cu,hu){return uu("move")}createTensorFromGPUData(nu,ru,lu){return uu("createTensorFromGPUData")}memory(){return uu("memory")}floatPrecision(){return uu("floatPrecision")}epsilon(){return this.floatPrecision()===32?eu:tu}dispose(){return uu("dispose")}}function uu(ou){throw new Error(`'${ou}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function du(ou){let nu=ou.length,ru=0;for(;nu>0;)ru=Math.random()*nu|0,nu--,yu(ou,nu,ru)}function fu(ou,nu,ru){return Math.max(ou,Math.min(nu,ru))}function gu(ou){return ou%2===0?ou:ou+1}function yu(ou,nu,ru){const lu=ou[nu];ou[nu]=ou[ru],ou[ru]=lu}function xu(ou){let nu=0;for(let ru=0;ru<ou.length;ru++)nu+=ou[ru];return nu}function vu(ou,nu){if(!ou)throw new Error(typeof nu=="string"?nu:nu())}function Su(ou,nu,ru=""){vu(ku(ou,nu),()=>ru+` Shapes ${ou} and ${nu} must match`)}function Iu(ou){vu(ou!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Mu(ou){if(ou.length===0)return 1;let nu=ou[0];for(let ru=1;ru<ou.length;ru++)nu*=ou[ru];return nu}function ku(ou,nu){if(ou===nu)return!0;if(ou==null||nu==null||ou.length!==nu.length)return!1;for(let ru=0;ru<ou.length;ru++)if(ou[ru]!==nu[ru])return!1;return!0}function Bu(ou){return ou%1===0}function _u(ou){const nu=Math.ceil(Math.sqrt(ou));return[nu,Math.ceil(ou/nu)]}function Lu(ou,nu){return nu<=ou.length?ou:ou+" ".repeat(nu-ou.length)}function Du(ou,nu=cu=>0,ru,lu){return new Promise((cu,hu)=>{let pu=0;const mu=()=>{if(ou()){cu();return}pu++;const Au=nu(pu);if(ru!=null&&pu>=ru){hu();return}lu!=null?lu(mu,Au):setTimeout(mu,Au)};mu()})}function Ou(ou,nu){let ru=1,lu=-1;for(let hu=0;hu<ou.length;++hu)if(ou[hu]>=0)ru*=ou[hu];else if(ou[hu]===-1){if(lu!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${lu} and dim ${hu}`);lu=hu}else if(ou[hu]<0)throw Error(`Shapes can not be < 0. Found ${ou[hu]} at dim ${hu}`);if(lu===-1){if(nu>0&&nu!==ru)throw Error(`Size(${nu}) must match the product of shape ${ou}`);return ou}if(ru===0)throw Error(`Cannot infer the missing size in [${ou}] when there are 0 elements`);if(nu%ru!==0)throw Error(`The implicit shape can't be a fractional number. Got ${nu} / ${ru}`);const cu=ou.slice();return cu[lu]=nu/ru,cu}function Wu(ou,nu){const ru=nu.length;return ou=ou==null?nu.map((lu,cu)=>cu):[].concat(ou),vu(ou.every(lu=>lu>=-ru&&lu<ru),()=>`All values in axis param must be in range [-${ru}, ${ru}) but got axis ${ou}`),vu(ou.every(lu=>Bu(lu)),()=>`All values in axis param must be integers but got axis ${ou}`),ou.map(lu=>lu<0?ru+lu:lu)}function Zu(ou,nu){const ru=[],lu=[],cu=nu!=null&&Array.isArray(nu)&&nu.length===0,hu=nu==null||cu?null:Wu(nu,ou).sort();let pu=0;for(let mu=0;mu<ou.length;++mu){if(hu!=null){if(hu[pu]===mu&&ou[mu]!==1)throw new Error(`Can't squeeze axis ${mu} since its dim '${ou[mu]}' is not 1`);(hu[pu]==null||hu[pu]>mu)&&ou[mu]===1&&(ru.push(ou[mu]),lu.push(mu)),hu[pu]<=mu&&pu++}ou[mu]!==1&&(ru.push(ou[mu]),lu.push(mu))}return{newShape:ru,keptDims:lu}}function Hu(ou,nu){return Yu(ou,nu)}function Yu(ou,nu){let ru=null;if(ou==null||ou==="float32")ru=new Float32Array(nu);else if(ou==="int32")ru=new Int32Array(nu);else if(ou==="bool")ru=new Uint8Array(nu);else if(ou==="string")ru=new Array(nu);else throw new Error(`Unknown data type ${ou}`);return ru}function Ku(ou,nu){for(let ru=0;ru<ou.length;ru++){const lu=ou[ru];if(isNaN(lu)||!isFinite(lu))throw Error(`A tensor of type ${nu} being uploaded contains ${lu}.`)}}function ju(ou){return ou==="bool"||ou==="complex64"||ou==="float32"||ou==="int32"||ou==="string"}function tp(ou,nu){return!(nu==="complex64"||nu==="float32"&&ou!=="complex64"||nu==="int32"&&ou!=="float32"&&ou!=="complex64"||nu==="bool"&&ou==="bool")}function gp(ou){if(ou==="float32"||ou==="int32")return 4;if(ou==="complex64")return 8;if(ou==="bool")return 1;throw new Error(`Unknown dtype ${ou}`)}function yp(ou){if(ou==null)return 0;let nu=0;return ou.forEach(ru=>nu+=ru.length),nu}function Cp(ou){return typeof ou=="string"||ou instanceof String}function Hp(ou){return typeof ou=="boolean"}function wp(ou){return typeof ou=="number"}function Dp(ou){return Array.isArray(ou)?Dp(ou[0]):ou instanceof Float32Array?"float32":ou instanceof Int32Array||ou instanceof Uint8Array||ou instanceof Uint8ClampedArray?"int32":wp(ou)?"float32":Cp(ou)?"string":Hp(ou)?"bool":"float32"}function dp(ou){return!!(ou&&ou.constructor&&ou.call&&ou.apply)}function Rp(ou,nu){for(let ru=nu;ru<ou;++ru)if(ou%ru===0)return ru;return ou}function xp(ou){const nu=ou.length;if(nu<2)return[];const ru=new Array(nu-1);ru[nu-2]=ou[nu-1];for(let lu=nu-3;lu>=0;--lu)ru[lu]=ru[lu+1]*ou[lu+1];return ru}function cm(ou,nu,ru,lu=!1){const cu=new Array;if(nu.length===1){const hu=nu[0]*(lu?2:1);for(let pu=0;pu<hu;pu++)cu[pu]=ru[ou+pu]}else{const hu=nu[0],pu=nu.slice(1),mu=pu.reduce((Au,bu)=>Au*bu)*(lu?2:1);for(let Au=0;Au<hu;Au++)cu[Au]=cm(ou+Au*mu,pu,ru,lu)}return cu}function lm(ou,nu,ru=!1){if(ou.length===0)return nu[0];const lu=ou.reduce((cu,hu)=>cu*hu)*(ru?2:1);if(lu===0)return[];if(lu!==nu.length)throw new Error(`[${ou}] does not match the input size ${nu.length}${ru?" for a complex tensor":""}.`);return cm(0,ou,nu,ru)}function vp(ou,nu){if(Array.isArray(ou))return ou;if(nu==="float32")return ou instanceof Float32Array?ou:new Float32Array(ou);if(nu==="int32")return ou instanceof Int32Array?ou:new Int32Array(ou);if(nu==="bool"||nu==="string")return Uint8Array.from(new Int32Array(ou));throw new Error(`Unknown dtype ${nu}`)}function bp(ou,nu){const ru=kp(ou,nu);for(let lu=0;lu<ru.length;lu++)ru[lu]=1;return ru}function kp(ou,nu){if(nu==null||nu==="float32"||nu==="complex64")return new Float32Array(ou);if(nu==="int32")return new Int32Array(ou);if(nu==="bool")return new Uint8Array(ou);throw new Error(`Unknown data type ${nu}`)}function dm(ou,nu){const ru=ou.reduce((lu,cu)=>lu*cu,1);if(nu==null||nu==="float32")return lm(ou,new Float32Array(ru));if(nu==="int32")return lm(ou,new Int32Array(ru));if(nu==="bool")return lm(ou,new Uint8Array(ru));throw new Error(`Unknown data type ${nu}`)}function nm(ou){ou.forEach(nu=>{vu(Number.isInteger(nu)&&nu>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${ou}].`)})}function Bp(ou,nu,ru){if(nu===0)return 0;if(nu===1)return ou[0];let lu=ou[ou.length-1];for(let cu=0;cu<ou.length-1;++cu)lu+=ru[cu]*ou[cu];return lu}function Qp(ou,nu,ru){if(nu===0)return[];if(nu===1)return[ou];const lu=new Array(nu);for(let cu=0;cu<lu.length-1;++cu)lu[cu]=Math.floor(ou/ru[cu]),ou-=lu[cu]*ru[cu];return lu[lu.length-1]=ou,lu}function Xp(ou){return ou&&ou.then&&typeof ou.then=="function"}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sm="tfjsflags";class $p{constructor(nu){this.global=nu,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=_f,this.populateURLFlags()}setPlatform(nu,ru){this.platform!=null&&(cp().getBool("IS_TEST")||cp().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${nu}.`)),this.platformName=nu,this.platform=ru}registerFlag(nu,ru,lu){if(this.flagRegistry[nu]={evaluationFn:ru,setHook:lu},this.urlFlags[nu]!=null){const cu=this.urlFlags[nu];cp().getBool("IS_TEST")||cp().getBool("PROD")||console.warn(`Setting feature override from URL ${nu}: ${cu}.`),this.set(nu,cu)}}async getAsync(nu){return nu in this.flags?this.flags[nu]:(this.flags[nu]=await this.evaluateFlag(nu),this.flags[nu])}get(nu){if(nu in this.flags)return this.flags[nu];const ru=this.evaluateFlag(nu);if(Xp(ru))throw new Error(`Flag ${nu} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[nu]=ru,this.flags[nu]}getNumber(nu){return this.get(nu)}getBool(nu){return this.get(nu)}getString(nu){return this.get(nu)}getFlags(){return this.flags}get features(){return this.flags}set(nu,ru){if(this.flagRegistry[nu]==null)throw new Error(`Cannot set flag ${nu} as it has not been registered.`);this.flags[nu]=ru,this.flagRegistry[nu].setHook!=null&&this.flagRegistry[nu].setHook(ru)}evaluateFlag(nu){if(this.flagRegistry[nu]==null)throw new Error(`Cannot evaluate flag '${nu}': no evaluation function found.`);return this.flagRegistry[nu].evaluationFn()}setFlags(nu){this.flags=Object.assign({},nu)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const nu=this.getQueryParams(this.global.location.search);sm in nu&&nu[sm].split(",").forEach(ru=>{const[lu,cu]=ru.split(":");this.urlFlags[lu]=lp(lu,cu)})}}function _f(ou){const nu={};return ou.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(ru,...lu)=>(rm(nu,lu[0],lu[1]),lu.join("="))),nu}function rm(ou,nu,ru){ou[decodeURIComponent(nu)]=decodeURIComponent(ru||"")}function lp(ou,nu){const ru=nu.toLowerCase();return ru==="true"||ru==="false"?ru==="true":`${+ru}`===ru?+ru:nu}function cp(){return mm}let mm=null;function $u(ou){mm=ou}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Vu;function _h(){if(Vu==null){let ou;if(typeof window<"u")ou=window;else if(typeof commonjsGlobal<"u")ou=commonjsGlobal;else if(typeof process$1<"u")ou=process$1;else if(typeof self<"u")ou=self;else throw new Error("Could not find a global object");Vu=ou}return Vu}function ap(){const ou=_h();return ou._tfGlobals==null&&(ou._tfGlobals=new Map),ou._tfGlobals}function mp(ou,nu){const ru=ap();if(ru.has(ou))return ru.get(ou);{const lu=nu();return ru.set(ou,lu),ru.get(ou)}}const Lp="Abs",Kp="Acos",vm="Acosh",sp="Add",_d="AddN",Sp="All",tm="Any",qu="ArgMax",Uu="ArgMin",zu="Asin",ep="Asinh",up="Atan",Mp="Atanh",Ip="Atan2",fm="AvgPool",Gm="AvgPoolGrad",pp="AvgPool3D",Zp="AvgPool3DGrad",om="BatchMatMul",Mm="BatchToSpaceND",Tm="Bincount",Lm="BitwiseAnd",Ym="BroadcastTo",Rm="BroadcastArgs",Sm="Cast",Fm="Ceil",i0="ClipByValue",$0="Complex",pv="ComplexAbs",L1="Concat",zv="Conv2D",N1="Conv2DBackpropFilter",tx="Conv2DBackpropInput",fv="Conv3D",Wv="Conv3DBackpropFilterV2",D1="Conv3DBackpropInputV2",Lx="Cos",mv="Cosh",gv="Cumprod",Hv="Cumsum",F1="CropAndResize",CC="DenseBincount",wC="DepthToSpace",P1="DepthwiseConv2dNative",EC="DepthwiseConv2dNativeBackpropFilter",SC="DepthwiseConv2dNativeBackpropInput",jw="Diag",np="Dilation2D",Np="Dilation2DBackpropInput",Wp="Dilation2DBackpropFilter",jp="Draw",Gp="RealDiv",gm="Einsum",_m="Elu",Nm="EluGrad",Dm="Erf",Km="Equal",Zm="Exp",Vm="ExpandDims",r0="Expm1",h0="FFT",P0="Fill",N0="FlipLeftRight",s0="Floor",z0="FloorDiv",Um="FusedBatchNorm",Nx="GatherV2",d0="GatherNd",cy="Greater",yy="GreaterEqual",Hy="Identity",Dx="IFFT",m0="Imag",V0="IsFinite",Py="IsInf",_0="IsNan",Ax="LeakyRelu",yx="Less",Xv="LessEqual",T_="LinSpace",IC="Log",TC="Log1p",Yw="LogicalAnd",qw="LogicalNot",Jw="LogicalOr",oP="LogSoftmax",eE="LRN",J2="LRNGrad",tE="Max",_C="Maximum",nE="MaxPool",eS="MaxPoolGrad",iE="MaxPool3D",tS="MaxPool3DGrad",__="MaxPoolWithArgmax",rE="Mean",sE="Min",MC="Minimum",oE="MirrorPad",RC="Mod",M_="Multinomial",kC="Multiply",aE="Neg",lE="NotEqual",nS="NonMaxSuppressionV3",iS="NonMaxSuppressionV4",rS="NonMaxSuppressionV5",cE="OnesLike",uE="OneHot",hE="Pack",dE="PadV2",BC="Pow",pE="Prelu",fE="Prod",R_="RaggedGather",k_="RaggedRange",B_="RaggedTensorToTensor",sS="Range",oS="Real",LC="Reciprocal",NC="Relu",mE="Reshape",gE="ResizeNearestNeighbor",aS="ResizeNearestNeighborGrad",AE="ResizeBilinear",lS="ResizeBilinearGrad",DC="Relu6",yE="Reverse",FC="Round",PC="Rsqrt",L_="ScatterNd",N_="TensorScatterUpdate",D_="SearchSorted",bE="Select",GC="Selu",xE="Slice",OC="Sin",UC="Sinh",$C="Sign",VC="Sigmoid",zC="Softplus",WC="Sqrt",vE="Sum",CE="SpaceToBatchND",wE="SplitV",EE="Softmax",F_="SparseFillEmptyRows",P_="SparseReshape",G_="SparseSegmentMean",O_="SparseSegmentSum",U_="SparseToDense",HC="SquaredDifference",cS="Square",uS="StaticRegexReplace",hS="StridedSlice",$_="StringNGrams",V_="StringSplit",z_="StringToHashBucketFast",XC="Sub",QC="Tan",KC="Tanh",ZC="Tile",dS="TopK",pS="Transform",G1="Transpose",fS="Unique",SE="Unpack",IE="UnsortedSegmentSum",TE="ZerosLike",jC="Step",mS="FromPixels",gS="RotateWithOffset",_E="_FusedMatMul",ME="FusedConv2D",W_="FusedDepthwiseConv2D";/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xy(...ou){cp().getBool("IS_TEST")||cp().getBool("PROD")||console.warn(...ou)}function aP(...ou){cp().getBool("IS_TEST")||cp().getBool("PROD")||console.log(...ou)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RE=mp("kernelRegistry",()=>new Map),AS=mp("gradRegistry",()=>new Map);function yS(ou,nu){const ru=Q_(ou,nu);return RE.get(ru)}function H_(ou){return AS.get(ou)}function X_(ou){const nu=RE.entries(),ru=[];for(;;){const{done:lu,value:cu}=nu.next();if(lu)break;const[hu,pu]=cu,[mu]=hu.split("_");mu===ou&&ru.push(pu)}return ru}function Qy(ou){const{kernelName:nu,backendName:ru}=ou,lu=Q_(nu,ru);RE.has(lu)&&Xy(`The kernel '${nu}' for backend '${ru}' is already registered`),RE.set(lu,ou)}function lP(ou){const{kernelName:nu}=ou;AS.has(nu)&&cp().getBool("DEBUG")&&Xy(`Overriding the gradient for '${nu}'`),AS.set(nu,ou)}function Q_(ou,nu){return`${nu}_${ou}`}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function K_(ou){return ou instanceof Float32Array||ou instanceof Int32Array||ou instanceof Uint8Array||ou instanceof Uint8ClampedArray}var Qv=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof commonjsGlobal<"u"?commonjsGlobal:typeof self<"u"?self:{};function cP(ou){return ou&&ou.__esModule&&Object.prototype.hasOwnProperty.call(ou,"default")?ou.default:ou}function uP(ou){if(ou.__esModule)return ou;var nu=ou.default;if(typeof nu=="function"){var ru=function lu(){return this instanceof lu?Reflect.construct(nu,arguments,this.constructor):nu.apply(this,arguments)};ru.prototype=nu.prototype}else ru={};return Object.defineProperty(ru,"__esModule",{value:!0}),Object.keys(ou).forEach(function(lu){var cu=Object.getOwnPropertyDescriptor(ou,lu);Object.defineProperty(ru,lu,cu.get?cu:{enumerable:!0,get:function(){return ou[lu]}})}),ru}var Z_=M0,nx=null;try{nx=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function M0(ou,nu,ru){this.low=ou|0,this.high=nu|0,this.unsigned=!!ru}M0.prototype.__isLong__,Object.defineProperty(M0.prototype,"__isLong__",{value:!0});function Gy(ou){return(ou&&ou.__isLong__)===!0}M0.isLong=Gy;var j_={},Y_={};function Kv(ou,nu){var ru,lu,cu;return nu?(ou>>>=0,(cu=0<=ou&&ou<256)&&(lu=Y_[ou],lu)?lu:(ru=R0(ou,(ou|0)<0?-1:0,!0),cu&&(Y_[ou]=ru),ru)):(ou|=0,(cu=-128<=ou&&ou<128)&&(lu=j_[ou],lu)?lu:(ru=R0(ou,ou<0?-1:0,!1),cu&&(j_[ou]=ru),ru))}M0.fromInt=Kv;function ix(ou,nu){if(isNaN(ou))return nu?Zv:rx;if(nu){if(ou<0)return Zv;if(ou>=J_)return rM}else{if(ou<=-eM)return Oy;if(ou+1>=eM)return iM}return ou<0?ix(-ou,nu).neg():R0(ou%O1|0,ou/O1|0,nu)}M0.fromNumber=ix;function R0(ou,nu,ru){return new M0(ou,nu,ru)}M0.fromBits=R0;var kE=Math.pow;function bS(ou,nu,ru){if(ou.length===0)throw Error("empty string");if(ou==="NaN"||ou==="Infinity"||ou==="+Infinity"||ou==="-Infinity")return rx;if(typeof nu=="number"?(ru=nu,nu=!1):nu=!!nu,ru=ru||10,ru<2||36<ru)throw RangeError("radix");var lu;if((lu=ou.indexOf("-"))>0)throw Error("interior hyphen");if(lu===0)return bS(ou.substring(1),nu,ru).neg();for(var cu=ix(kE(ru,8)),hu=rx,pu=0;pu<ou.length;pu+=8){var mu=Math.min(8,ou.length-pu),Au=parseInt(ou.substring(pu,pu+mu),ru);if(mu<8){var bu=ix(kE(ru,mu));hu=hu.mul(bu).add(ix(Au))}else hu=hu.mul(cu),hu=hu.add(ix(Au))}return hu.unsigned=nu,hu}M0.fromString=bS;function bx(ou,nu){return typeof ou=="number"?ix(ou,nu):typeof ou=="string"?bS(ou,nu):R0(ou.low,ou.high,typeof nu=="boolean"?nu:ou.unsigned)}M0.fromValue=bx;var q_=65536,hP=1<<24,O1=q_*q_,J_=O1*O1,eM=J_/2,tM=Kv(hP),rx=Kv(0);M0.ZERO=rx;var Zv=Kv(0,!0);M0.UZERO=Zv;var U1=Kv(1);M0.ONE=U1;var nM=Kv(1,!0);M0.UONE=nM;var xS=Kv(-1);M0.NEG_ONE=xS;var iM=R0(-1,2147483647,!1);M0.MAX_VALUE=iM;var rM=R0(-1,-1,!0);M0.MAX_UNSIGNED_VALUE=rM;var Oy=R0(0,-2147483648,!1);M0.MIN_VALUE=Oy;var Em=M0.prototype;Em.toInt=function(){return this.unsigned?this.low>>>0:this.low},Em.toNumber=function(){return this.unsigned?(this.high>>>0)*O1+(this.low>>>0):this.high*O1+(this.low>>>0)},Em.toString=function(ou){if(ou=ou||10,ou<2||36<ou)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Oy)){var nu=ix(ou),ru=this.div(nu),lu=ru.mul(nu).sub(this);return ru.toString(ou)+lu.toInt().toString(ou)}else return"-"+this.neg().toString(ou);for(var cu=ix(kE(ou,6),this.unsigned),hu=this,pu="";;){var mu=hu.div(cu),Au=hu.sub(mu.mul(cu)).toInt()>>>0,bu=Au.toString(ou);if(hu=mu,hu.isZero())return bu+pu;for(;bu.length<6;)bu="0"+bu;pu=""+bu+pu}},Em.getHighBits=function(){return this.high},Em.getHighBitsUnsigned=function(){return this.high>>>0},Em.getLowBits=function(){return this.low},Em.getLowBitsUnsigned=function(){return this.low>>>0},Em.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Oy)?64:this.neg().getNumBitsAbs();for(var ou=this.high!=0?this.high:this.low,nu=31;nu>0&&!(ou&1<<nu);nu--);return this.high!=0?nu+33:nu+1},Em.isZero=function(){return this.high===0&&this.low===0},Em.eqz=Em.isZero,Em.isNegative=function(){return!this.unsigned&&this.high<0},Em.isPositive=function(){return this.unsigned||this.high>=0},Em.isOdd=function(){return(this.low&1)===1},Em.isEven=function(){return(this.low&1)===0},Em.equals=function(ou){return Gy(ou)||(ou=bx(ou)),this.unsigned!==ou.unsigned&&this.high>>>31===1&&ou.high>>>31===1?!1:this.high===ou.high&&this.low===ou.low},Em.eq=Em.equals,Em.notEquals=function(ou){return!this.eq(ou)},Em.neq=Em.notEquals,Em.ne=Em.notEquals,Em.lessThan=function(ou){return this.comp(ou)<0},Em.lt=Em.lessThan,Em.lessThanOrEqual=function(ou){return this.comp(ou)<=0},Em.lte=Em.lessThanOrEqual,Em.le=Em.lessThanOrEqual,Em.greaterThan=function(ou){return this.comp(ou)>0},Em.gt=Em.greaterThan,Em.greaterThanOrEqual=function(ou){return this.comp(ou)>=0},Em.gte=Em.greaterThanOrEqual,Em.ge=Em.greaterThanOrEqual,Em.compare=function(ou){if(Gy(ou)||(ou=bx(ou)),this.eq(ou))return 0;var nu=this.isNegative(),ru=ou.isNegative();return nu&&!ru?-1:!nu&&ru?1:this.unsigned?ou.high>>>0>this.high>>>0||ou.high===this.high&&ou.low>>>0>this.low>>>0?-1:1:this.sub(ou).isNegative()?-1:1},Em.comp=Em.compare,Em.negate=function(){return!this.unsigned&&this.eq(Oy)?Oy:this.not().add(U1)},Em.neg=Em.negate,Em.add=function(ou){Gy(ou)||(ou=bx(ou));var nu=this.high>>>16,ru=this.high&65535,lu=this.low>>>16,cu=this.low&65535,hu=ou.high>>>16,pu=ou.high&65535,mu=ou.low>>>16,Au=ou.low&65535,bu=0,Cu=0,wu=0,Eu=0;return Eu+=cu+Au,wu+=Eu>>>16,Eu&=65535,wu+=lu+mu,Cu+=wu>>>16,wu&=65535,Cu+=ru+pu,bu+=Cu>>>16,Cu&=65535,bu+=nu+hu,bu&=65535,R0(wu<<16|Eu,bu<<16|Cu,this.unsigned)},Em.subtract=function(ou){return Gy(ou)||(ou=bx(ou)),this.add(ou.neg())},Em.sub=Em.subtract,Em.multiply=function(ou){if(this.isZero())return rx;if(Gy(ou)||(ou=bx(ou)),nx){var nu=nx.mul(this.low,this.high,ou.low,ou.high);return R0(nu,nx.get_high(),this.unsigned)}if(ou.isZero())return rx;if(this.eq(Oy))return ou.isOdd()?Oy:rx;if(ou.eq(Oy))return this.isOdd()?Oy:rx;if(this.isNegative())return ou.isNegative()?this.neg().mul(ou.neg()):this.neg().mul(ou).neg();if(ou.isNegative())return this.mul(ou.neg()).neg();if(this.lt(tM)&&ou.lt(tM))return ix(this.toNumber()*ou.toNumber(),this.unsigned);var ru=this.high>>>16,lu=this.high&65535,cu=this.low>>>16,hu=this.low&65535,pu=ou.high>>>16,mu=ou.high&65535,Au=ou.low>>>16,bu=ou.low&65535,Cu=0,wu=0,Eu=0,Tu=0;return Tu+=hu*bu,Eu+=Tu>>>16,Tu&=65535,Eu+=cu*bu,wu+=Eu>>>16,Eu&=65535,Eu+=hu*Au,wu+=Eu>>>16,Eu&=65535,wu+=lu*bu,Cu+=wu>>>16,wu&=65535,wu+=cu*Au,Cu+=wu>>>16,wu&=65535,wu+=hu*mu,Cu+=wu>>>16,wu&=65535,Cu+=ru*bu+lu*Au+cu*mu+hu*pu,Cu&=65535,R0(Eu<<16|Tu,Cu<<16|wu,this.unsigned)},Em.mul=Em.multiply,Em.divide=function(ou){if(Gy(ou)||(ou=bx(ou)),ou.isZero())throw Error("division by zero");if(nx){if(!this.unsigned&&this.high===-2147483648&&ou.low===-1&&ou.high===-1)return this;var nu=(this.unsigned?nx.div_u:nx.div_s)(this.low,this.high,ou.low,ou.high);return R0(nu,nx.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Zv:rx;var ru,lu,cu;if(this.unsigned){if(ou.unsigned||(ou=ou.toUnsigned()),ou.gt(this))return Zv;if(ou.gt(this.shru(1)))return nM;cu=Zv}else{if(this.eq(Oy)){if(ou.eq(U1)||ou.eq(xS))return Oy;if(ou.eq(Oy))return U1;var hu=this.shr(1);return ru=hu.div(ou).shl(1),ru.eq(rx)?ou.isNegative()?U1:xS:(lu=this.sub(ou.mul(ru)),cu=ru.add(lu.div(ou)),cu)}else if(ou.eq(Oy))return this.unsigned?Zv:rx;if(this.isNegative())return ou.isNegative()?this.neg().div(ou.neg()):this.neg().div(ou).neg();if(ou.isNegative())return this.div(ou.neg()).neg();cu=rx}for(lu=this;lu.gte(ou);){ru=Math.max(1,Math.floor(lu.toNumber()/ou.toNumber()));for(var pu=Math.ceil(Math.log(ru)/Math.LN2),mu=pu<=48?1:kE(2,pu-48),Au=ix(ru),bu=Au.mul(ou);bu.isNegative()||bu.gt(lu);)ru-=mu,Au=ix(ru,this.unsigned),bu=Au.mul(ou);Au.isZero()&&(Au=U1),cu=cu.add(Au),lu=lu.sub(bu)}return cu},Em.div=Em.divide,Em.modulo=function(ou){if(Gy(ou)||(ou=bx(ou)),nx){var nu=(this.unsigned?nx.rem_u:nx.rem_s)(this.low,this.high,ou.low,ou.high);return R0(nu,nx.get_high(),this.unsigned)}return this.sub(this.div(ou).mul(ou))},Em.mod=Em.modulo,Em.rem=Em.modulo,Em.not=function(){return R0(~this.low,~this.high,this.unsigned)},Em.and=function(ou){return Gy(ou)||(ou=bx(ou)),R0(this.low&ou.low,this.high&ou.high,this.unsigned)},Em.or=function(ou){return Gy(ou)||(ou=bx(ou)),R0(this.low|ou.low,this.high|ou.high,this.unsigned)},Em.xor=function(ou){return Gy(ou)||(ou=bx(ou)),R0(this.low^ou.low,this.high^ou.high,this.unsigned)},Em.shiftLeft=function(ou){return Gy(ou)&&(ou=ou.toInt()),(ou&=63)===0?this:ou<32?R0(this.low<<ou,this.high<<ou|this.low>>>32-ou,this.unsigned):R0(0,this.low<<ou-32,this.unsigned)},Em.shl=Em.shiftLeft,Em.shiftRight=function(ou){return Gy(ou)&&(ou=ou.toInt()),(ou&=63)===0?this:ou<32?R0(this.low>>>ou|this.high<<32-ou,this.high>>ou,this.unsigned):R0(this.high>>ou-32,this.high>=0?0:-1,this.unsigned)},Em.shr=Em.shiftRight,Em.shiftRightUnsigned=function(ou){if(Gy(ou)&&(ou=ou.toInt()),ou&=63,ou===0)return this;var nu=this.high;if(ou<32){var ru=this.low;return R0(ru>>>ou|nu<<32-ou,nu>>>ou,this.unsigned)}else return ou===32?R0(nu,0,this.unsigned):R0(nu>>>ou-32,0,this.unsigned)},Em.shru=Em.shiftRightUnsigned,Em.shr_u=Em.shiftRightUnsigned,Em.toSigned=function(){return this.unsigned?R0(this.low,this.high,!1):this},Em.toUnsigned=function(){return this.unsigned?this:R0(this.low,this.high,!0)},Em.toBytes=function(ou){return ou?this.toBytesLE():this.toBytesBE()},Em.toBytesLE=function(){var ou=this.high,nu=this.low;return[nu&255,nu>>>8&255,nu>>>16&255,nu>>>24,ou&255,ou>>>8&255,ou>>>16&255,ou>>>24]},Em.toBytesBE=function(){var ou=this.high,nu=this.low;return[ou>>>24,ou>>>16&255,ou>>>8&255,ou&255,nu>>>24,nu>>>16&255,nu>>>8&255,nu&255]},M0.fromBytes=function(ou,nu,ru){return ru?M0.fromBytesLE(ou,nu):M0.fromBytesBE(ou,nu)},M0.fromBytesLE=function(ou,nu){return new M0(ou[0]|ou[1]<<8|ou[2]<<16|ou[3]<<24,ou[4]|ou[5]<<8|ou[6]<<16|ou[7]<<24,nu)},M0.fromBytesBE=function(ou,nu){return new M0(ou[4]<<24|ou[5]<<16|ou[6]<<8|ou[7],ou[0]<<24|ou[1]<<16|ou[2]<<8|ou[3],nu)};const sM=cP(Z_),dP=iu({__proto__:null,default:sM},[Z_]);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jv=sM||dP;function BE(ou){return jv.fromString(ou,!0,16)}const oM=BE("c3a5c85c97cb3127"),Yv=BE("b492b66fbe98f273"),by=BE("9ae16a3b2f90404f");function vS(ou){return ou.xor(ou.shru(47))}function aM(ou,nu,ru){const lu=ou.slice(nu,nu+ru);return jv.fromBytes(Array.from(lu),!0,!0)}function C0(ou,nu){return aM(ou,nu,8)}function lM(ou,nu){return aM(ou,nu,4)}function sy(ou,nu){return nu===0?ou:ou.shru(nu).or(ou.shl(64-nu))}function Av(ou,nu,ru=BE("9ddfea08eb382d69")){let lu=ou.xor(nu).mul(ru);lu=lu.xor(lu.shru(47));let cu=nu.xor(lu).mul(ru);return cu=cu.xor(cu.shru(47)),cu=cu.mul(ru),cu}function pP(ou,nu,ru,lu,cu,hu){cu=cu.add(ou),hu=sy(hu.add(cu).add(lu),21);const pu=cu;return cu=cu.add(nu),cu=cu.add(ru),hu=hu.add(sy(cu,44)),[cu.add(lu),hu.add(pu)]}function LE(ou,nu,ru,lu){return pP(C0(ou,nu),C0(ou,nu+8),C0(ou,nu+16),C0(ou,nu+24),ru,lu)}function fP(ou,nu=ou.length){if(nu>=8){const ru=by.add(nu*2),lu=C0(ou,0).add(by),cu=C0(ou,nu-8),hu=sy(cu,37).mul(ru).add(lu),pu=sy(lu,25).add(cu).mul(ru);return Av(hu,pu,ru)}if(nu>=4){const ru=by.add(nu*2),lu=lM(ou,0);return Av(lu.shl(3).add(nu),lM(ou,nu-4),ru)}if(nu>0){const ru=ou[0],lu=ou[nu>>1],cu=ou[nu-1],hu=ru+(lu<<8),pu=nu+(cu<<2);return vS(by.mul(hu).xor(oM.mul(pu))).mul(by)}return by}function mP(ou,nu=ou.length){const ru=by.add(nu*2),lu=C0(ou,0).mul(Yv),cu=C0(ou,8),hu=C0(ou,nu-8).mul(ru),pu=C0(ou,nu-16).mul(by);return Av(sy(lu.add(cu),43).add(sy(hu,30)).add(pu),lu.add(sy(cu.add(by),18)).add(hu),ru)}function gP(ou,nu=ou.length){const ru=by.add(nu*2),lu=C0(ou,0).mul(by),cu=C0(ou,8),hu=C0(ou,nu-8).mul(ru),pu=C0(ou,nu-16).mul(by),mu=sy(lu.add(cu),43).add(sy(hu,30)).add(pu),Au=Av(mu,lu.add(sy(cu.add(by),18)).add(hu),ru),bu=C0(ou,16).mul(ru),Cu=C0(ou,24),wu=mu.add(C0(ou,nu-32)).mul(ru),Eu=Au.add(C0(ou,nu-24)).mul(ru);return Av(sy(bu.add(Cu),43).add(sy(wu,30)).add(Eu),bu.add(sy(Cu.add(lu),18)).add(wu),ru)}function AP(ou,nu=ou.length){const ru=jv.fromNumber(81,!0);if(nu<=32)return nu<=16?fP(ou,nu):mP(ou,nu);if(nu<=64)return gP(ou,nu);let lu=ru,cu=ru.mul(Yv).add(113),hu=vS(cu.mul(by).add(113)).mul(by),pu=[jv.UZERO,jv.UZERO],mu=[jv.UZERO,jv.UZERO];lu=lu.mul(by).add(C0(ou,0));let Au=0;const bu=(nu-1>>6)*64,Cu=bu+(nu-1&63)-63;do lu=sy(lu.add(cu).add(pu[0]).add(C0(ou,Au+8)),37).mul(Yv),cu=sy(cu.add(pu[1]).add(C0(ou,Au+48)),42).mul(Yv),lu=lu.xor(mu[1]),cu=cu.add(pu[0]).add(C0(ou,Au+40)),hu=sy(hu.add(mu[0]),33).mul(Yv),pu=LE(ou,Au,pu[1].mul(Yv),lu.add(mu[0])),mu=LE(ou,Au+32,hu.add(mu[1]),cu.add(C0(ou,Au+16))),[hu,lu]=[lu,hu],Au+=64;while(Au!==bu);const wu=Yv.add(hu.and(255).shl(1));return Au=Cu,mu[0]=mu[0].add(nu-1&63),pu[0]=pu[0].add(mu[0]),mu[0]=mu[0].add(pu[0]),lu=sy(lu.add(cu).add(pu[0]).add(C0(ou,Au+8)),37).mul(wu),cu=sy(cu.add(pu[1]).add(C0(ou,Au+48)),42).mul(wu),lu=lu.xor(mu[1].mul(9)),cu=cu.add(pu[0].mul(9).add(C0(ou,Au+40))),hu=sy(hu.add(mu[0]),33).mul(wu),pu=LE(ou,Au,pu[1].mul(wu),lu.add(mu[0])),mu=LE(ou,Au+32,hu.add(mu[1]),cu.add(C0(ou,Au+16))),[hu,lu]=[lu,hu],Av(Av(pu[0],mu[0],wu).add(vS(cu).mul(oM)).add(hu),Av(pu[1],mu[1],wu).add(lu),wu)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yv(ou,nu){return nu==="string"?bv(ou):qv([ou],nu)}function yP(ou,nu){return ou instanceof Float32Array&&nu==="float32"||ou instanceof Int32Array&&nu==="int32"||ou instanceof Uint8Array&&nu==="bool"}function qv(ou,nu){if(nu==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(ou)&&(ou=Jv(ou)),cp().getBool("DEBUG")&&Ku(ou,nu),yP(ou,nu))return ou;if(nu==null||nu==="float32"||nu==="complex64")return new Float32Array(ou);if(nu==="int32")return new Int32Array(ou);if(nu==="bool"){const ru=new Uint8Array(ou.length);for(let lu=0;lu<ru.length;++lu)Math.round(ou[lu])!==0&&(ru[lu]=1);return ru}else throw new Error(`Unknown data type ${nu}`)}function My(){return cp().platform.now()}function bv(ou,nu="utf-8"){return nu=nu||"utf-8",cp().platform.encode(ou,nu)}function xv(ou,nu="utf-8"){return nu=nu||"utf-8",cp().platform.decode(ou,nu)}function sx(ou){return cp().platform.isTypedArray!=null?cp().platform.isTypedArray(ou):K_(ou)}function Jv(ou,nu=[],ru=!1){if(nu==null&&(nu=[]),typeof ou=="boolean"||typeof ou=="number"||typeof ou=="string"||Xp(ou)||ou==null||sx(ou)&&ru)nu.push(ou);else if(Array.isArray(ou)||sx(ou))for(let lu=0;lu<ou.length;++lu)Jv(ou[lu],nu,ru);else{let lu=-1;for(const cu of Object.keys(ou))/^([1-9]+[0-9]*|0)$/.test(cu)&&(lu=Math.max(lu,Number(cu)));for(let cu=0;cu<=lu;cu++)Jv(ou[cu],nu,ru)}return nu}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class bP{constructor(nu,ru){this.backendTimer=nu,this.logger=ru,ru==null&&(this.logger=new vP)}profileKernel(nu,ru,lu){let cu;const hu=()=>{cu=lu()};let pu;const mu=My();if(this.backendTimer.timerAvailable())pu=this.backendTimer.time(hu);else{hu();for(const Au of cu)Au.dataSync();pu=Promise.resolve({kernelMs:My()-mu})}if(cp().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let Au=0;Au<cu.length;Au++){const bu=cu[Au];bu.data().then(Cu=>{xP(Cu,bu.dtype,nu)})}return{kernelName:nu,outputs:cu,inputs:ru,timeMs:pu.then(Au=>Au.kernelMs),extraInfo:pu.then(Au=>Au.getExtraProfileInfo!=null?Au.getExtraProfileInfo():"")}}logKernelProfile(nu){const{kernelName:ru,outputs:lu,timeMs:cu,inputs:hu,extraInfo:pu}=nu;lu.forEach(mu=>{Promise.all([mu.data(),cu,pu]).then(Au=>{this.logger.logKernelProfile(ru,mu,Au[0],Au[1],hu,Au[2])})})}}function xP(ou,nu,ru){if(nu!=="float32")return!1;for(let lu=0;lu<ou.length;lu++){const cu=ou[lu];if(isNaN(cu)||!isFinite(cu))return console.warn(`Found ${cu} in the result of '${ru}'`),!0}return!1}class vP{logKernelProfile(nu,ru,lu,cu,hu,pu){const mu=typeof cu=="number"?Lu(`${cu}ms`,9):cu.error,Au=Lu(nu,25),bu=ru.rank,Cu=ru.size,wu=Lu(ru.shape.toString(),14);let Eu="";for(const Tu in hu){const Ru=hu[Tu];if(Ru!=null){const Nu=Ru.shape||ru.shape,Pu=Nu.length;Eu+=`${Tu}: ${Pu}D ${Pu>0?Nu:""} `}}console.log(`%c${Au}	%c${mu}	%c${bu}D ${wu}	%c${Cu}	%c${Eu}	%c${pu}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CP(ou,nu,ru){const lu={},cu={};for(let Au=0;Au<nu.length;Au++)lu[nu[Au].id]=!0;for(let Au=0;Au<ou.length;Au++){const bu=ou[Au],Cu=bu.inputs;for(const wu in Cu){const Eu=Cu[wu];let Tu=!1;for(let Ru=0;Ru<nu.length;Ru++)if(lu[Eu.id]){bu.outputs.forEach(Nu=>lu[Nu.id]=!0),Tu=!0,cu[bu.id]=!0;break}if(Tu)break}}const hu={};hu[ru.id]=!0;const pu={};for(let Au=ou.length-1;Au>=0;Au--){const bu=ou[Au],Cu=bu.inputs;for(let wu=0;wu<bu.outputs.length;wu++)if(hu[bu.outputs[wu].id]){for(const Eu in Cu)hu[Cu[Eu].id]=!0,pu[bu.id]=!0;break}}const mu=[];for(let Au=0;Au<ou.length;Au++){const bu=ou[Au];if(cu[bu.id]&&pu[bu.id]){const Cu={};for(const Eu in bu.inputs){const Tu=bu.inputs[Eu];lu[Tu.id]&&(Cu[Eu]=Tu)}const wu=Object.assign({},bu);wu.inputs=Cu,wu.outputs=bu.outputs,mu.push(wu)}}return mu}function wP(ou,nu,ru,lu){for(let cu=nu.length-1;cu>=0;cu--){const hu=nu[cu],pu=[];if(hu.outputs.forEach(Au=>{const bu=ou[Au.id];bu!=null?pu.push(bu):pu.push(null)}),hu.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${hu.kernelName}.`);const mu=hu.gradient(pu);for(const Au in hu.inputs){if(!(Au in mu))throw new Error(`Cannot backprop through input ${Au}. Available gradients found: ${Object.keys(mu)}.`);const bu=ru(()=>mu[Au]());if(bu.dtype!=="float32")throw new Error(`Error in gradient for op ${hu.kernelName}. The gradient of input ${Au} must have 'float32' dtype, but has '${bu.dtype}'`);const Cu=hu.inputs[Au];if(!ku(bu.shape,Cu.shape))throw new Error(`Error in gradient for op ${hu.kernelName}. The gradient of input '${Au}' has shape '${bu.shape}', which does not match the shape of the input '${Cu.shape}'`);if(ou[Cu.id]==null)ou[Cu.id]=bu;else{const wu=ou[Cu.id];ou[Cu.id]=lu(wu,bu),wu.dispose()}}}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cM=20,YC=3,CS=7;function EP(ou,nu,ru,lu){const cu=xp(nu),hu=SP(ou,nu,ru,cu),pu=nu.length,mu=NE(ou,nu,ru,cu,hu),Au=["Tensor"];return lu&&(Au.push(`  dtype: ${ru}`),Au.push(`  rank: ${pu}`),Au.push(`  shape: [${nu}]`),Au.push("  values:")),Au.push(mu.map(bu=>"    "+bu).join(`
`)),Au.join(`
`)}function SP(ou,nu,ru,lu){const cu=Mu(nu),hu=lu[lu.length-1],pu=new Array(hu).fill(0),mu=nu.length,Au=ru==="complex64"?JC(ou):ou;if(mu>1)for(let bu=0;bu<cu/hu;bu++){const Cu=bu*hu;for(let wu=0;wu<hu;wu++)pu[wu]=Math.max(pu[wu],qC(Au[Cu+wu],0,ru).length)}return pu}function qC(ou,nu,ru){let lu;return Array.isArray(ou)?lu=`${parseFloat(ou[0].toFixed(CS))} + ${parseFloat(ou[1].toFixed(CS))}j`:Cp(ou)?lu=`'${ou}'`:ru==="bool"?lu=uM(ou):lu=parseFloat(ou.toFixed(CS)).toString(),Lu(lu,nu)}function uM(ou){return ou===0?"false":"true"}function NE(ou,nu,ru,lu,cu,hu=!0){const pu=ru==="complex64"?2:1,mu=nu[0],Au=nu.length;if(Au===0){if(ru==="complex64"){const Nu=JC(ou);return[qC(Nu[0],0,ru)]}return ru==="bool"?[uM(ou[0])]:[ou[0].toString()]}if(Au===1){if(mu>cM){const Nu=YC*pu;let Pu=Array.from(ou.slice(0,Nu)),Fu=Array.from(ou.slice((mu-YC)*pu,mu*pu));return ru==="complex64"&&(Pu=JC(Pu),Fu=JC(Fu)),["["+Pu.map((Gu,Xu)=>qC(Gu,cu[Xu],ru)).join(", ")+", ..., "+Fu.map((Gu,Xu)=>qC(Gu,cu[mu-YC+Xu],ru)).join(", ")+"]"]}return["["+(ru==="complex64"?JC(ou):Array.from(ou)).map((Nu,Pu)=>qC(Nu,cu[Pu],ru)).join(", ")+"]"]}const bu=nu.slice(1),Cu=lu.slice(1),wu=lu[0]*pu,Eu=[];if(mu>cM){for(let Nu=0;Nu<YC;Nu++){const Pu=Nu*wu,Fu=Pu+wu;Eu.push(...NE(ou.slice(Pu,Fu),bu,ru,Cu,cu,!1))}Eu.push("...");for(let Nu=mu-YC;Nu<mu;Nu++){const Pu=Nu*wu,Fu=Pu+wu;Eu.push(...NE(ou.slice(Pu,Fu),bu,ru,Cu,cu,Nu===mu-1))}}else for(let Nu=0;Nu<mu;Nu++){const Pu=Nu*wu,Fu=Pu+wu;Eu.push(...NE(ou.slice(Pu,Fu),bu,ru,Cu,cu,Nu===mu-1))}const Tu=Au===2?",":"";Eu[0]="["+(mu>0?Eu[0]+Tu:"");for(let Nu=1;Nu<Eu.length-1;Nu++)Eu[Nu]=" "+Eu[Nu]+Tu;let Ru=`,
`;for(let Nu=2;Nu<Au;Nu++)Ru+=`
`;return Eu[Eu.length-1]=" "+Eu[Eu.length-1]+"]"+(hu?"":Ru),Eu}function JC(ou){const nu=[];for(let ru=0;ru<ou.length;ru+=2)nu.push([ou[ru],ou[ru+1]]);return nu}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class uy{constructor(nu,ru,lu){if(this.dtype=ru,this.shape=nu.slice(),this.size=Mu(nu),lu!=null){const cu=lu.length;vu(cu===this.size,()=>`Length of values '${cu}' does not match the size inferred by the shape '${this.size}'.`)}if(ru==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=lu||Yu(ru,this.size),this.strides=xp(nu)}set(nu,...ru){ru.length===0&&(ru=[0]),vu(ru.length===this.rank,()=>`The number of provided coordinates (${ru.length}) must match the rank (${this.rank})`);const lu=this.locToIndex(ru);this.values[lu]=nu}get(...nu){nu.length===0&&(nu=[0]);let ru=0;for(const cu of nu){if(cu<0||cu>=this.shape[ru]){const hu=`Requested out of range element at ${nu}.   Buffer shape=${this.shape}`;throw new Error(hu)}ru++}let lu=nu[nu.length-1];for(let cu=0;cu<nu.length-1;++cu)lu+=this.strides[cu]*nu[cu];return this.values[lu]}locToIndex(nu){if(this.rank===0)return 0;if(this.rank===1)return nu[0];let ru=nu[nu.length-1];for(let lu=0;lu<nu.length-1;++lu)ru+=this.strides[lu]*nu[lu];return ru}indexToLoc(nu){if(this.rank===0)return[];if(this.rank===1)return[nu];const ru=new Array(this.shape.length);for(let lu=0;lu<ru.length-1;++lu)ru[lu]=Math.floor(nu/this.strides[lu]),nu-=ru[lu]*this.strides[lu];return ru[ru.length-1]=nu,ru}get rank(){return this.shape.length}toTensor(){return xx().makeTensor(this.values,this.shape,this.dtype)}}let xx=null,$1=null;function IP(ou){xx=ou}function TP(ou){$1=ou}class q0{constructor(nu,ru,lu,cu){this.kept=!1,this.isDisposedInternal=!1,this.shape=nu.slice(),this.dtype=ru||"float32",this.size=Mu(nu),this.strides=xp(nu),this.dataId=lu,this.id=cu,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const nu=await this.data();return $1.buffer(this.shape,this.dtype,nu)}bufferSync(){return $1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const nu=await this.data();return lm(this.shape,nu,this.dtype==="complex64")}arraySync(){return lm(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const nu=xx().read(this.dataId);if(this.dtype==="string"){const ru=await nu;try{return ru.map(lu=>xv(lu))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return nu}dataToGPU(nu){return this.throwIfDisposed(),xx().readToGPU(this.dataId,nu)}dataSync(){this.throwIfDisposed();const nu=xx().readSync(this.dataId);if(this.dtype==="string")try{return nu.map(ru=>xv(ru))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return nu}async bytes(){this.throwIfDisposed();const nu=await xx().read(this.dataId);return this.dtype==="string"?nu:new Uint8Array(nu.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),xx().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(nu=!1){return $1.print(this,nu)}clone(){return this.throwIfDisposed(),$1.clone(this)}toString(nu=!1){const ru=this.dataSync();return EP(ru,this.shape,this.dtype,nu)}cast(nu){return this.throwIfDisposed(),$1.cast(this,nu)}variable(nu=!0,ru,lu){return this.throwIfDisposed(),xx().makeVariable(this,nu,ru,lu)}}Object.defineProperty(q0,Symbol.hasInstance,{value:ou=>!!ou&&ou.data!=null&&ou.dataSync!=null&&ou.throwIfDisposed!=null});function Jp(){return mp("Tensor",()=>q0)}Jp();class DE extends q0{constructor(nu,ru,lu,cu){super(nu.shape,nu.dtype,nu.dataId,cu),this.trainable=ru,this.name=lu}assign(nu){if(nu.dtype!==this.dtype)throw new Error(`dtype of the new value (${nu.dtype}) and previous value (${this.dtype}) must match`);if(!ku(nu.shape,this.shape))throw new Error(`shape of the new value (${nu.shape}) and previous value (${this.shape}) must match`);xx().disposeTensor(this),this.dataId=nu.dataId,xx().incRef(this,null)}dispose(){xx().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(DE,Symbol.hasInstance,{value:ou=>ou instanceof q0&&ou.assign!=null&&ou.assign instanceof Function});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var hM;(function(ou){ou.R0="R0",ou.R1="R1",ou.R2="R2",ou.R3="R3",ou.R4="R4",ou.R5="R5",ou.R6="R6"})(hM||(hM={}));var wS;(function(ou){ou.float32="float32",ou.int32="int32",ou.bool="int32",ou.complex64="complex64"})(wS||(wS={}));var ES;(function(ou){ou.float32="float32",ou.int32="int32",ou.bool="bool",ou.complex64="complex64"})(ES||(ES={}));var SS;(function(ou){ou.float32="float32",ou.int32="float32",ou.bool="float32",ou.complex64="complex64"})(SS||(SS={}));var IS;(function(ou){ou.float32="complex64",ou.int32="complex64",ou.bool="complex64",ou.complex64="complex64"})(IS||(IS={}));const _P={float32:SS,int32:wS,bool:ES,complex64:IS};function Uy(ou,nu){if(ou==="string"||nu==="string"){if(ou==="string"&&nu==="string")return"string";throw new Error(`Can not upcast ${ou} with ${nu}`)}return _P[ou][nu]}function TS(ou){return Uy(ou,"int32")}function dM(ou){return ou!=null&&typeof ou=="object"&&"texture"in ou&&ou.texture instanceof WebGLTexture}function pM(ou){return typeof GPUBuffer<"u"&&ou!=null&&typeof ou=="object"&&"buffer"in ou&&ou.buffer instanceof GPUBuffer}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function W0(ou,nu){if(ou.dtype===nu.dtype)return[ou,nu];const ru=Uy(ou.dtype,nu.dtype);return[ou.cast(ru),nu.cast(ru)]}function fM(ou){const nu=[];return mM(ou,nu,new Set),nu}function mM(ou,nu,ru){if(ou==null)return;if(ou instanceof q0){nu.push(ou);return}if(!MP(ou))return;const lu=ou;for(const cu in lu){const hu=lu[cu];ru.has(hu)||(ru.add(hu),mM(hu,nu,ru))}}function MP(ou){return Array.isArray(ou)||typeof ou=="object"}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _S(ou){return ou.kernelName!=null}class gM{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(nu=>nu.name)))}}}dispose(){for(const nu in this.registeredVariables)this.registeredVariables[nu].dispose()}}class V1{constructor(nu){this.ENV=nu,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new gM}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const nu=this.getSortedBackends();for(let ru=0;ru<nu.length;ru++){const lu=nu[ru];if(await this.initializeBackend(lu).success){await this.setBackend(lu);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:nu,asyncInit:ru}=this.initializeBackendsAndReturnBest();if(ru)throw new Error(`The highest priority backend '${nu}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(nu)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(nu){if(!(nu in this.registry))if(nu in this.registryFactory){const{asyncInit:ru}=this.initializeBackend(nu);if(ru)return null}else return null;return this.registry[nu]}findBackendFactory(nu){return nu in this.registryFactory?this.registryFactory[nu].factory:null}registerBackend(nu,ru,lu=1){return nu in this.registryFactory?(Xy(`${nu} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[nu]={factory:ru,priority:lu},!0)}async setBackend(nu){if(this.registryFactory[nu]==null)throw new Error(`Backend name '${nu}' not found in registry`);if(this.backendName=nu,this.registry[nu]==null){this.backendInstance=null;const{success:ru,asyncInit:lu}=this.initializeBackend(nu);if(!(lu?await ru:ru))return!1}return this.backendInstance=this.registry[nu],this.setupRegisteredKernels(),this.profiler=new bP(this.backendInstance),!0}setupRegisteredKernels(){X_(this.backendName).forEach(nu=>{nu.setupFunc!=null&&nu.setupFunc(this.backendInstance)})}disposeRegisteredKernels(nu){X_(nu).forEach(ru=>{ru.disposeFunc!=null&&ru.disposeFunc(this.registry[nu])})}initializeBackend(nu){const ru=this.registryFactory[nu];if(ru==null)throw new Error(`Cannot initialize backend ${nu}, no registration found.`);try{const lu=ru.factory();if(lu&&!(lu instanceof au)&&typeof lu.then=="function"){const cu=++this.pendingBackendInitId,hu=lu.then(pu=>cu<this.pendingBackendInitId?!1:(this.registry[nu]=pu,this.pendingBackendInit=null,!0)).catch(pu=>(cu<this.pendingBackendInitId||(this.pendingBackendInit=null,Xy(`Initialization of backend ${nu} failed`),Xy(pu.stack||pu.message)),!1));return this.pendingBackendInit=hu,{success:hu,asyncInit:!0}}else return this.registry[nu]=lu,{success:!0,asyncInit:!1}}catch(lu){return Xy(`Initialization of backend ${nu} failed`),Xy(lu.stack||lu.message),{success:!1,asyncInit:!1}}}removeBackend(nu){if(!(nu in this.registryFactory))throw new Error(`${nu} backend not found in registry`);this.backendName===nu&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,nu in this.registry&&(this.disposeRegisteredKernels(nu),this.registry[nu].dispose(),delete this.registry[nu]),delete this.registryFactory[nu],this.backendName===nu&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((nu,ru)=>this.registryFactory[ru].priority-this.registryFactory[nu].priority)}initializeBackendsAndReturnBest(){const nu=this.getSortedBackends();for(let ru=0;ru<nu.length;ru++){const lu=nu[ru],{success:cu,asyncInit:hu}=this.initializeBackend(lu);if(hu||cu)return{name:lu,asyncInit:hu}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(nu,ru){const lu=this.state.tensorInfo.get(ru),cu=lu.backend,hu=this.readSync(ru),pu=cu.refCount(ru);cu.disposeData(ru,!0),lu.backend=nu,nu.move(ru,hu,lu.shape,lu.dtype,pu),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(nu,ru){let lu=null;if(ru==null){if(typeof nu!="function")throw new Error("Please provide a function to tidy()");ru=nu}else{if(typeof nu!="string"&&!(nu instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof ru!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");lu=nu}let cu;return this.scopedRun(()=>this.startScope(lu),()=>this.endScope(cu),()=>(cu=ru(),cu instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),cu))}scopedRun(nu,ru,lu){nu();try{const cu=lu();return ru(),cu}catch(cu){throw ru(),cu}}nextTensorId(){return V1.nextTensorId++}nextVariableId(){return V1.nextVariableId++}clone(nu){const ru=Tp.runKernel(Hy,{x:nu}),lu={x:nu},cu=pu=>({x:()=>{const mu="float32",Au={x:pu},bu={dtype:mu};return Tp.runKernel(Sm,Au,bu)}}),hu=[];return this.addTapeNode(this.state.activeScope.name,lu,[ru],cu,hu,{}),ru}runKernel(nu,ru,lu){if(this.backendName==null&&this.backend,yS(nu,this.backendName)==null)throw new Error(`Kernel '${nu}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:nu,inputs:ru,attrs:lu})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(nu,ru,lu){const cu=this.backend.numDataIds();let hu=0;lu.forEach(Au=>{hu+=Au.dtype==="complex64"?3:1});const pu=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],mu=cu-ru-hu-pu;if(mu>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${mu} data ids) after running '${nu}'`)}runKernelFunc(nu){let ru,lu=[];const cu=this.isTapeOn(),hu=this.state.numBytes,pu=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let mu;this.backendName==null&&this.backend;let Au;const bu=_S(nu)?nu.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(_S(nu)){const{kernelName:Ru,inputs:Nu,attrs:Pu}=nu;this.backendName==null&&this.backend;const Fu=yS(Ru,this.backendName);vu(Fu!=null,()=>`Cannot find registered kernel '${Ru}' for backend '${this.backendName}'`),mu=()=>{const Gu=this.backend.numDataIds();Au=Fu.kernelFunc({inputs:Nu,attrs:Pu,backend:this.backend});const Xu=Array.isArray(Au)?Au:[Au];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Ru,Gu,Xu);const Qu=Xu.map(Ju=>Ju.rank!=null?Ju:this.makeTensorFromTensorInfo(Ju));if(cu){const Ju=this.getTensorsForGradient(Ru,Nu,Qu);lu=this.saveTensorsForBackwardMode(Ju)}return Qu}}else{const{forwardFunc:Ru}=nu,Nu=Pu=>{cu&&(lu=Pu.map(Fu=>this.keep(this.clone(Fu))))};mu=()=>{const Pu=this.backend.numDataIds();Au=this.tidy(()=>Ru(this.backend,Nu));const Fu=Array.isArray(Au)?Au:[Au];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(bu,Pu,Fu),Fu}}const{inputs:Cu,attrs:wu}=nu,Eu=_S(nu)?null:nu.backwardsFunc;let Tu;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?ru=mu():(Tu=this.profiler.profileKernel(bu,Cu,()=>mu()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Tu),ru=Tu.outputs)}),cu&&this.addTapeNode(bu,Cu,ru,Eu,lu,wu),this.state.profiling&&this.state.activeProfile.kernels.push({name:bu,bytesAdded:this.state.numBytes-hu,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-pu,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Cu).map(Ru=>Cu[Ru]!=null?Cu[Ru].shape:null),outputShapes:ru.map(Ru=>Ru.shape),kernelTimeMs:Tu.timeMs,extraInfo:Tu.extraInfo}),Array.isArray(Au)?ru:ru[0]}saveTensorsForBackwardMode(nu){return nu.map(ru=>this.keep(this.clone(ru)))}getTensorsForGradient(nu,ru,lu){const cu=H_(nu);if(cu!=null){const hu=cu.inputsToSave||[],pu=cu.outputsToSave||[];let mu;cu.saveAllInputs?(vu(Array.isArray(ru),()=>"saveAllInputs is true, expected inputs to be an array."),mu=Object.keys(ru).map(bu=>ru[bu])):mu=hu.map(bu=>ru[bu]);const Au=lu.filter((bu,Cu)=>pu[Cu]);return mu.concat(Au)}return[]}makeTensor(nu,ru,lu,cu){if(nu==null)throw new Error("Values passed to engine.makeTensor() are null");lu=lu||"float32",cu=cu||this.backend;let hu=nu;lu==="string"&&Cp(nu[0])&&(hu=nu.map(Au=>bv(Au)));const pu=cu.write(hu,ru,lu),mu=new q0(ru,lu,pu,this.nextTensorId());if(this.trackTensor(mu,cu),lu==="string"){const Au=this.state.tensorInfo.get(pu),bu=yp(hu);this.state.numBytes+=bu-Au.bytes,Au.bytes=bu}return mu}makeTensorFromDataId(nu,ru,lu,cu){lu=lu||"float32";const hu={dataId:nu,shape:ru,dtype:lu};return this.makeTensorFromTensorInfo(hu,cu)}makeTensorFromTensorInfo(nu,ru){const{dataId:lu,shape:cu,dtype:hu}=nu,pu=new q0(cu,hu,lu,this.nextTensorId());return this.trackTensor(pu,ru),pu}makeVariable(nu,ru=!0,lu,cu){lu=lu||this.nextVariableId().toString(),cu!=null&&cu!==nu.dtype&&(nu=nu.cast(cu));const hu=new DE(nu,ru,lu,this.nextTensorId());if(this.state.registeredVariables[hu.name]!=null)throw new Error(`Variable with name ${hu.name} was already registered`);return this.state.registeredVariables[hu.name]=hu,this.incRef(hu,this.backend),hu}trackTensor(nu,ru){this.state.numTensors++,nu.dtype==="string"&&this.state.numStringTensors++;let lu=0;nu.dtype!=="complex64"&&nu.dtype!=="string"&&(lu=nu.size*gp(nu.dtype)),this.state.numBytes+=lu,this.state.tensorInfo.has(nu.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(nu.dataId,{backend:ru||this.backend,dtype:nu.dtype,shape:nu.shape,bytes:lu})),nu instanceof DE||this.track(nu)}incRef(nu,ru){this.trackTensor(nu,ru),this.backend.incRef(nu.dataId)}removeDataId(nu,ru){this.state.tensorInfo.has(nu)&&this.state.tensorInfo.get(nu).backend===ru&&(this.state.tensorInfo.delete(nu),this.state.numDataBuffers--)}disposeTensor(nu){if(!this.state.tensorInfo.has(nu.dataId))return;const ru=this.state.tensorInfo.get(nu.dataId);if(this.state.numTensors--,nu.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=ru.bytes),nu.dtype!=="complex64"&&nu.dtype!=="string"){const lu=nu.size*gp(nu.dtype);this.state.numBytes-=lu}ru.backend.disposeData(nu.dataId)&&this.removeDataId(nu.dataId,ru.backend)}disposeVariables(){for(const nu in this.state.registeredVariables){const ru=this.state.registeredVariables[nu];this.disposeVariable(ru)}}disposeVariable(nu){this.disposeTensor(nu),this.state.registeredVariables[nu.name]!=null&&delete this.state.registeredVariables[nu.name]}memory(){const nu=this.backend.memory();return nu.numTensors=this.state.numTensors,nu.numDataBuffers=this.state.numDataBuffers,nu.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(nu.unreliable=!0,nu.reasons==null&&(nu.reasons=[]),nu.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),nu}async profile(nu){this.state.profiling=!0;const ru=this.state.numBytes,lu=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await nu(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(cu=>cu.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-ru,this.state.activeProfile.newTensors=this.state.numTensors-lu;for(const cu of this.state.activeProfile.kernels)cu.kernelTimeMs=await cu.kernelTimeMs,cu.extraInfo=await cu.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(nu,ru,lu,cu,hu,pu){const mu={id:this.state.nextTapeNodeId++,kernelName:nu,inputs:ru,outputs:lu,saved:hu},Au=H_(nu);Au!=null&&(cu=Au.gradFunc),cu!=null&&(mu.gradient=bu=>(bu=bu.map((Cu,wu)=>{if(Cu==null){const Eu=lu[wu],Tu=kp(Eu.size,Eu.dtype);return this.makeTensor(Tu,Eu.shape,Eu.dtype)}return Cu}),cu(bu.length>1?bu:bu[0],hu,pu))),this.state.activeTape.push(mu)}keep(nu){return nu.kept=!0,nu}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(nu){const ru={track:[],name:"unnamed scope",id:this.state.nextScopeId++};nu&&(ru.name=nu),this.state.scopeStack.push(ru),this.state.activeScope=ru}endScope(nu){const ru=fM(nu),lu=new Set(ru.map(hu=>hu.id));for(let hu=0;hu<this.state.activeScope.track.length;hu++){const pu=this.state.activeScope.track[hu];!pu.kept&&!lu.has(pu.id)&&pu.dispose()}const cu=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],ru.forEach(hu=>{!hu.kept&&hu.scopeId===cu.id&&this.track(hu)})}gradients(nu,ru,lu,cu=!1){if(vu(ru.length>0,()=>"gradients() received an empty list of xs."),lu!=null&&lu.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${lu.dtype}'`);const hu=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",nu));vu(hu instanceof q0,()=>"The result y returned by f() must be a tensor.");const pu=CP(this.state.activeTape,ru,hu);if(!cu&&pu.length===0&&ru.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const mu={};mu[hu.id]=lu??RP(hu.shape),wP(mu,pu,bu=>this.tidy(bu),kP);const Au=ru.map(bu=>mu[bu.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(bu=>{for(const Cu of bu.saved)Cu.dispose()}),this.state.activeTape=null),{value:hu,grads:Au}})}customGrad(nu){return vu(dp(nu),()=>"The f passed in customGrad(f) must be a function."),(...ru)=>{vu(ru.every(mu=>mu instanceof q0),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let lu;const cu={};ru.forEach((mu,Au)=>{cu[Au]=mu});const hu=(mu,Au)=>(lu=nu(...ru,Au),vu(lu.value instanceof q0,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),vu(dp(lu.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),lu.value),pu=(mu,Au)=>{const bu=lu.gradFunc(mu,Au),Cu=Array.isArray(bu)?bu:[bu];vu(Cu.length===ru.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),vu(Cu.every(Eu=>Eu instanceof q0),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const wu={};return Cu.forEach((Eu,Tu)=>{wu[Tu]=()=>Eu}),wu};return this.runKernelFunc({forwardFunc:hu,backwardsFunc:pu,inputs:cu})}}readSync(nu){return this.state.tensorInfo.get(nu).backend.readSync(nu)}read(nu){return this.state.tensorInfo.get(nu).backend.read(nu)}readToGPU(nu,ru){return this.state.tensorInfo.get(nu).backend.readToGPU(nu,ru)}async time(nu){const ru=My(),lu=await this.backend.time(nu);return lu.wallMs=My()-ru,lu}track(nu){return this.state.activeScope!=null&&(nu.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(nu)),nu}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new gM;for(const nu in this.registry)this.disposeRegisteredKernels(nu),this.registry[nu].dispose(),delete this.registry[nu];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}V1.nextTensorId=0,V1.nextVariableId=0;function RP(ou){const nu=bp(Mu(ou),"float32");return Tp.makeTensor(nu,ou,"float32")}function AM(){const ou=_h();if(ou._tfengine==null){const nu=new $p(ou);ou._tfengine=new V1(nu)}return $u(ou._tfengine.ENV),IP(()=>ou._tfengine),ou._tfengine}const Tp=AM();function kP(ou,nu){const ru={a:ou,b:nu};return Tp.runKernel(sp,ru)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BP(){return typeof navigator<"u"&&navigator!=null}function yM(ou){if(ou||BP()){if(ou||(ou=navigator),ou.product==="ReactNative")return!0;const nu=ou.userAgent||ou.vendor||(typeof window<"u"?window.opera:"");if(!nu){const ru=ou;return ru.userAgentData&&ru.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(nu)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(nu.substr(0,4))}return!1}function bM(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ry=cp();Ry.registerFlag("DEBUG",()=>!1,ou=>{ou&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ry.registerFlag("IS_BROWSER",()=>bM()),Ry.registerFlag("IS_NODE",()=>typeof process$1<"u"&&typeof process$1.versions<"u"&&typeof process$1.versions.node<"u"),Ry.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ry.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Ry.registerFlag("PROD",()=>!1),Ry.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ry.getBool("DEBUG")),Ry.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ry.registerFlag("IS_TEST",()=>!1),Ry.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ry.getBool("DEBUG")),Ry.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ry.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ry.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ew(ou,nu){let ru=ou;if(sx(ou))return nu==="string"?[]:[ou.length];if(dM(ou)){const cu=ou.channels||"RGBA";return[ou.height,ou.width*cu.length]}else if(pM(ou))return[ou.buffer.size/(nu==null?4:gp(nu))];if(!Array.isArray(ou))return[];const lu=[];for(;Array.isArray(ru)||sx(ru)&&nu!=="string";)lu.push(ru.length),ru=ru[0];return Array.isArray(ou)&&cp().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&xM(ou,lu,[]),lu}function xM(ou,nu,ru){if(ru=ru||[],!Array.isArray(ou)&&!sx(ou)){vu(nu.length===0,()=>`Element arr[${ru.join("][")}] is a primitive, but should be an array/TypedArray of ${nu[0]} elements`);return}vu(nu.length>0,()=>`Element arr[${ru.join("][")}] should be a primitive, but is an array of ${ou.length} elements`),vu(ou.length===nu[0],()=>`Element arr[${ru.join("][")}] should have ${nu[0]} elements, but has ${ou.length} elements`);const lu=nu.slice(1);for(let cu=0;cu<ou.length;++cu)xM(ou[cu],lu,ru.concat(cu))}function vM(ou,nu,ru,lu){if(ou!=="string_or_numeric"){if(ou==null)throw new Error("Expected dtype cannot be null.");if(ou!=="numeric"&&ou!==nu||ou==="numeric"&&nu==="string")throw new Error(`Argument '${ru}' passed to '${lu}' must be ${ou} tensor, but got ${nu} tensor`)}}function fp(ou,nu,ru,lu="numeric"){if(ou instanceof Jp())return vM(lu,ou.dtype,nu,ru),ou;let cu=Dp(ou);if(cu!=="string"&&["bool","int32","float32"].indexOf(lu)>=0&&(cu=lu),vM(lu,cu,nu,ru),ou==null||!sx(ou)&&!Array.isArray(ou)&&typeof ou!="number"&&typeof ou!="boolean"&&typeof ou!="string"){const mu=ou==null?"null":ou.constructor.name;throw new Error(`Argument '${nu}' passed to '${ru}' must be a Tensor or TensorLike, but got '${mu}'`)}const hu=ew(ou,cu);!sx(ou)&&!Array.isArray(ou)&&(ou=[ou]);const pu=cu!=="string"?qv(ou,cu):Jv(ou,[],!0);return Tp.makeTensor(pu,hu,cu)}function CM(ou,nu,ru,lu="numeric"){if(!Array.isArray(ou))throw new Error(`Argument ${nu} passed to ${ru} must be a \`Tensor[]\` or \`TensorLike[]\``);return ou.map((cu,hu)=>fp(cu,`${nu}[${hu}]`,ru,lu))}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const LP="__op";function Fp(ou){const nu=Object.keys(ou);if(nu.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${nu.length} keys.`);let ru=nu[0];const lu=ou[ru];ru.endsWith("_")&&(ru=ru.substring(0,ru.length-1)),ru=ru+LP;const cu=(...hu)=>{Tp.startScope(ru);try{const pu=lu(...hu);return Xp(pu)&&console.error("Cannot return a Promise inside of tidy."),Tp.endScope(pu),pu}catch(pu){throw Tp.endScope(null),pu}};return Object.defineProperty(cu,"name",{value:ru,configurable:!0}),cu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NP(ou,nu){const ru=fp(ou,"real","complex"),lu=fp(nu,"imag","complex");Su(ru.shape,lu.shape,`real and imag shapes, ${ru.shape} and ${lu.shape}, must match in call to tf.complex().`);const cu={real:ru,imag:lu};return Tp.runKernel($0,cu)}const z1=Fp({complex_:NP});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tw(ou,nu,ru,lu){if(lu==null)lu=Dp(ou);else if(lu==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(pM(ou)||dM(ou)){if(lu!=="float32"&&lu!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${lu}.`);return Tp.backend.createTensorFromGPUData(ou,nu||ru,lu)}if(!sx(ou)&&!Array.isArray(ou)&&typeof ou!="number"&&typeof ou!="boolean"&&typeof ou!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(nu!=null){nm(nu);const cu=Mu(nu),hu=Mu(ru);vu(cu===hu,()=>`Based on the provided shape, [${nu}], the tensor should have ${cu} values but has ${hu}`);for(let pu=0;pu<ru.length;++pu){const mu=ru[pu],Au=pu===ru.length-1?mu!==Mu(nu.slice(pu)):!0;vu(ru[pu]===nu[pu]||!Au,()=>`Error creating a new Tensor. Inferred shape (${ru}) does not match the provided shape (${nu}). `)}}return!sx(ou)&&!Array.isArray(ou)&&(ou=[ou]),nu=nu||ru,ou=lu!=="string"?qv(ou,lu):Jv(ou,[],!0),Tp.makeTensor(ou,nu,lu)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ky(ou,nu,ru){const lu=ew(ou,ru);return tw(ou,nu,lu,ru)}class W1{static join(nu){return new W1(nu).slice()}constructor(nu){if(this.shards=[],this.previousShardIndex=0,nu==null||(nu instanceof Array||(nu=[nu]),nu=nu.map(lu=>sx(lu)?lu.buffer:lu),nu.length===0))return;this.bufferUniformSize=nu[0].byteLength;let ru=0;for(let lu=0;lu<nu.length;lu++){const cu=nu[lu];lu!==nu.length-1&&cu.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const hu=ru+cu.byteLength;this.shards.push({buffer:cu,start:ru,end:hu}),ru=hu}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(nu=0,ru=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(nu=isNaN(Number(nu))?0:nu,ru=isNaN(Number(ru))?0:ru,nu=Math.max(0,nu),ru=Math.min(this.byteLength,ru),ru<=nu)return new ArrayBuffer(0);const lu=this.findShardForByte(nu);if(lu===-1)throw new Error(`Could not find start shard for byte ${nu}`);const cu=ru-nu,hu=new ArrayBuffer(cu),pu=new Uint8Array(hu);let mu=0;for(let Au=lu;Au<this.shards.length;Au++){const bu=this.shards[Au],Cu=nu+mu-bu.start,wu=mu,Eu=Math.min(ru,bu.end)-bu.start,Tu=new Uint8Array(bu.buffer,Cu,Eu-Cu);if(pu.set(Tu,wu),mu+=Tu.length,ru<bu.end)break}return hu}findShardForByte(nu){if(this.shards.length===0||nu<0||nu>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(nu/this.bufferUniformSize),this.previousShardIndex;function ru(cu){return nu<cu.start?-1:nu>=cu.end?1:0}if(ru(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const lu=DP(this.shards,ru);return lu===-1?-1:(this.previousShardIndex=lu,this.previousShardIndex)}}function DP(ou,nu){let ru=0,lu=ou.length;for(;ru<=lu;){const cu=Math.floor((lu-ru)/2)+ru,hu=nu(ou[cu]);if(hu===0)return cu;hu<0?lu=cu:ru=cu+1}return-1}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w0(){return Tp}function MS(){return Tp.memory()}function Op(ou,nu){return Tp.tidy(ou,nu)}function o0(ou){fM(ou).forEach(nu=>nu.dispose())}function Zy(ou){return Tp.keep(ou)}function wM(ou,nu,ru=1){return Tp.registerBackend(ou,nu,ru)}function vv(){return Tp.backend}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EM=4;async function SM(ou,nu){const ru=[],lu=[],cu=Array.isArray(ou)?ou.map(pu=>pu.name):Object.keys(ou);for(let pu=0;pu<cu.length;++pu){const mu=cu[pu],Au=Array.isArray(ou)?ou[pu].tensor:ou[mu];if(Au.dtype!=="float32"&&Au.dtype!=="int32"&&Au.dtype!=="bool"&&Au.dtype!=="string"&&Au.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${mu}': ${Au.dtype}`);const bu={name:mu,shape:Au.shape,dtype:Au.dtype};if(Au.dtype==="string"){const Cu=new Promise(async wu=>{const Eu=await Au.bytes(),Tu=Eu.reduce((Pu,Fu)=>Pu+Fu.length,0)+EM*Eu.length,Ru=new Uint8Array(Tu);let Nu=0;for(let Pu=0;Pu<Eu.length;Pu++){const Fu=Eu[Pu],Gu=new Uint8Array(new Uint32Array([Fu.length]).buffer);Ru.set(Gu,Nu),Nu+=EM,Ru.set(Fu,Nu),Nu+=Fu.length}wu(Ru)});lu.push(Cu)}else lu.push(Au.data());nu!=null&&(bu.group=nu),ru.push(bu)}const hu=await Promise.all(lu);return{data:FP(hu),specs:ru}}function FP(ou){if(ou===null)throw new Error(`Invalid input value: ${JSON.stringify(ou)}`);let nu=0;const ru=[];ou.forEach(hu=>{if(nu+=hu.byteLength,ru.push(hu.byteLength===hu.buffer.byteLength?hu:new hu.constructor(hu)),!(hu instanceof Float32Array||hu instanceof Int32Array||hu instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${hu.constructor.name}`)});const lu=new Uint8Array(nu);let cu=0;return ru.forEach(hu=>{lu.set(new Uint8Array(hu.buffer),cu),cu+=hu.byteLength}),lu.buffer}const RS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function IM(ou){return RS?Buffer.byteLength(ou,"utf8"):new Blob([ou]).size}function PP(ou){if(RS)return Buffer.from(ou).toString("base64");const nu=new Uint8Array(ou);let ru="";for(let lu=0,cu=nu.length;lu<cu;lu++)ru+=String.fromCharCode(nu[lu]);return btoa(ru)}function GP(ou){if(RS){const lu=Buffer.from(ou,"base64");return lu.buffer.slice(lu.byteOffset,lu.byteOffset+lu.byteLength)}const nu=atob(ou),ru=new Uint8Array(nu.length);for(let lu=0;lu<nu.length;++lu)ru.set([nu.charCodeAt(lu)],lu);return ru.buffer}function OP(ou){return W1.join(ou)}function TM(ou){if(ou.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:ou.modelTopology==null?0:IM(JSON.stringify(ou.modelTopology)),weightSpecsBytes:ou.weightSpecs==null?0:IM(JSON.stringify(ou.weightSpecs)),weightDataBytes:ou.weightData==null?0:new W1(ou.weightData).byteLength}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class xy{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return xy.instance==null&&(xy.instance=new xy),xy.instance}static registerSaveRouter(nu){xy.getInstance().saveRouters.push(nu)}static registerLoadRouter(nu){xy.getInstance().loadRouters.push(nu)}static getSaveHandlers(nu){return xy.getHandlers(nu,"save")}static getLoadHandlers(nu,ru){return xy.getHandlers(nu,"load",ru)}static getHandlers(nu,ru,lu){const cu=[];return(ru==="load"?xy.getInstance().loadRouters:xy.getInstance().saveRouters).forEach(hu=>{const pu=hu(nu,lu);pu!==null&&cu.push(pu)}),cu}}const UP=ou=>xy.getSaveHandlers(ou);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kS="tensorflowjs",BS=1,e1="models_store",Cv="model_info_store";function _M(){if(!cp().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const ou=typeof window>"u"?self:window,nu=ou.indexedDB||ou.mozIndexedDB||ou.webkitIndexedDB||ou.msIndexedDB||ou.shimIndexedDB;if(nu==null)throw new Error("The current browser does not appear to support IndexedDB.");return nu}function LS(ou){const nu=ou.result;nu.createObjectStore(e1,{keyPath:"modelPath"}),nu.createObjectStore(Cv,{keyPath:"modelPath"})}class t1{constructor(nu){if(this.indexedDB=_M(),nu==null||!nu)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=nu}async save(nu){if(nu.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,nu)}async load(){return this.databaseAction(this.modelPath)}databaseAction(nu,ru){return new Promise((lu,cu)=>{const hu=this.indexedDB.open(kS,BS);hu.onupgradeneeded=()=>LS(hu),hu.onsuccess=()=>{const pu=hu.result;if(ru==null){const mu=pu.transaction(e1,"readonly"),Au=mu.objectStore(e1).get(this.modelPath);Au.onsuccess=()=>{if(Au.result==null)return pu.close(),cu(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));lu(Au.result.modelArtifacts)},Au.onerror=bu=>(pu.close(),cu(Au.error)),mu.oncomplete=()=>pu.close()}else{ru.weightData=W1.join(ru.weightData);const mu=TM(ru),Au=pu.transaction(Cv,"readwrite");let bu=Au.objectStore(Cv),Cu;try{Cu=bu.put({modelPath:this.modelPath,modelArtifactsInfo:mu})}catch(Eu){return cu(Eu)}let wu;Cu.onsuccess=()=>{wu=pu.transaction(e1,"readwrite");const Eu=wu.objectStore(e1);let Tu;try{Tu=Eu.put({modelPath:this.modelPath,modelArtifacts:ru,modelArtifactsInfo:mu})}catch(Ru){return cu(Ru)}Tu.onsuccess=()=>lu({modelArtifactsInfo:mu}),Tu.onerror=Ru=>{bu=Au.objectStore(Cv);const Nu=bu.delete(this.modelPath);Nu.onsuccess=()=>(pu.close(),cu(Tu.error)),Nu.onerror=Pu=>(pu.close(),cu(Tu.error))}},Cu.onerror=Eu=>(pu.close(),cu(Cu.error)),Au.oncomplete=()=>{wu==null?pu.close():wu.oncomplete=()=>pu.close()}}},hu.onerror=pu=>cu(hu.error)})}}t1.URL_SCHEME="indexeddb://";const MM=ou=>cp().getBool("IS_BROWSER")&&!Array.isArray(ou)&&ou.startsWith(t1.URL_SCHEME)?$P(ou.slice(t1.URL_SCHEME.length)):null;xy.registerSaveRouter(MM),xy.registerLoadRouter(MM);function $P(ou){return new t1(ou)}function VP(ou){return ou.startsWith(t1.URL_SCHEME)?ou.slice(t1.URL_SCHEME.length):ou}class zP{constructor(){this.indexedDB=_M()}async listModels(){return new Promise((nu,ru)=>{const lu=this.indexedDB.open(kS,BS);lu.onupgradeneeded=()=>LS(lu),lu.onsuccess=()=>{const cu=lu.result,hu=cu.transaction(Cv,"readonly"),pu=hu.objectStore(Cv).getAll();pu.onsuccess=()=>{const mu={};for(const Au of pu.result)mu[Au.modelPath]=Au.modelArtifactsInfo;nu(mu)},pu.onerror=mu=>(cu.close(),ru(pu.error)),hu.oncomplete=()=>cu.close()},lu.onerror=cu=>ru(lu.error)})}async removeModel(nu){return nu=VP(nu),new Promise((ru,lu)=>{const cu=this.indexedDB.open(kS,BS);cu.onupgradeneeded=()=>LS(cu),cu.onsuccess=()=>{const hu=cu.result,pu=hu.transaction(Cv,"readwrite"),mu=pu.objectStore(Cv),Au=mu.get(nu);let bu;Au.onsuccess=()=>{if(Au.result==null)return hu.close(),lu(new Error(`Cannot find model with path '${nu}' in IndexedDB.`));{const Cu=mu.delete(nu),wu=()=>{bu=hu.transaction(e1,"readwrite");const Eu=bu.objectStore(e1).delete(nu);Eu.onsuccess=()=>ru(Au.result.modelArtifactsInfo),Eu.onerror=Tu=>lu(Au.error)};Cu.onsuccess=wu,Cu.onerror=Eu=>(wu(),hu.close(),lu(Au.error))}},Au.onerror=Cu=>(hu.close(),lu(Au.error)),pu.oncomplete=()=>{bu==null?hu.close():bu.oncomplete=()=>hu.close()}},cu.onerror=hu=>lu(cu.error)})}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ev="/",H1="tensorflowjs_models",RM="info",WP="model_topology",HP="weight_specs",XP="weight_data",QP="model_metadata";function kM(ou){return{info:[H1,ou,RM].join(ev),topology:[H1,ou,WP].join(ev),weightSpecs:[H1,ou,HP].join(ev),weightData:[H1,ou,XP].join(ev),modelMetadata:[H1,ou,QP].join(ev)}}function BM(ou){for(const nu of Object.values(ou))window.localStorage.removeItem(nu)}function KP(ou){const nu=ou.split(ev);if(nu.length<3)throw new Error(`Invalid key format: ${ou}`);return nu.slice(1,nu.length-1).join(ev)}function ZP(ou){return ou.startsWith(n1.URL_SCHEME)?ou.slice(n1.URL_SCHEME.length):ou}class n1{constructor(nu){if(!cp().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,nu==null||!nu)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=nu,this.keys=kM(this.modelPath)}async save(nu){if(nu.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const ru=JSON.stringify(nu.modelTopology),lu=JSON.stringify(nu.weightSpecs),cu=TM(nu),hu=W1.join(nu.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(cu)),this.LS.setItem(this.keys.topology,ru),this.LS.setItem(this.keys.weightSpecs,lu),this.LS.setItem(this.keys.weightData,PP(hu));const pu={format:nu.format,generatedBy:nu.generatedBy,convertedBy:nu.convertedBy,signature:nu.signature!=null?nu.signature:void 0,userDefinedMetadata:nu.userDefinedMetadata!=null?nu.userDefinedMetadata:void 0,modelInitializer:nu.modelInitializer!=null?nu.modelInitializer:void 0,initializerSignature:nu.initializerSignature!=null?nu.initializerSignature:void 0,trainingConfig:nu.trainingConfig!=null?nu.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(pu)),{modelArtifactsInfo:cu}}catch{throw BM(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${cu.modelTopologyBytes}, weightSpecsBytes=${cu.weightSpecsBytes}, weightDataBytes=${cu.weightDataBytes}.`)}}}async load(){const nu=JSON.parse(this.LS.getItem(this.keys.info));if(nu==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(nu.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const ru={},lu=JSON.parse(this.LS.getItem(this.keys.topology));if(lu==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);ru.modelTopology=lu;const cu=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(cu==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);ru.weightSpecs=cu;const hu=this.LS.getItem(this.keys.modelMetadata);if(hu!=null){const mu=JSON.parse(hu);ru.format=mu.format,ru.generatedBy=mu.generatedBy,ru.convertedBy=mu.convertedBy,mu.signature!=null&&(ru.signature=mu.signature),mu.userDefinedMetadata!=null&&(ru.userDefinedMetadata=mu.userDefinedMetadata),mu.modelInitializer!=null&&(ru.modelInitializer=mu.modelInitializer),mu.initializerSignature!=null&&(ru.initializerSignature=mu.initializerSignature),mu.trainingConfig!=null&&(ru.trainingConfig=mu.trainingConfig)}const pu=this.LS.getItem(this.keys.weightData);if(pu==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return ru.weightData=GP(pu),ru}}n1.URL_SCHEME="localstorage://";const LM=ou=>cp().getBool("IS_BROWSER")&&!Array.isArray(ou)&&ou.startsWith(n1.URL_SCHEME)?jP(ou.slice(n1.URL_SCHEME.length)):null;xy.registerSaveRouter(LM),xy.registerLoadRouter(LM);function jP(ou){return new n1(ou)}class YP{constructor(){vu(cp().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),vu(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const nu={},ru=H1+ev,lu=ev+RM;for(let cu=0;cu<this.LS.length;++cu){const hu=this.LS.key(cu);if(hu.startsWith(ru)&&hu.endsWith(lu)){const pu=KP(hu);nu[pu]=JSON.parse(this.LS.getItem(hu))}}return nu}async removeModel(nu){nu=ZP(nu);const ru=kM(nu);if(this.LS.getItem(ru.info)==null)throw new Error(`Cannot find model at path '${nu}'`);const lu=JSON.parse(this.LS.getItem(ru.info));return BM(ru),lu}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NM="://";class Fx{constructor(){this.managers={}}static getInstance(){return Fx.instance==null&&(Fx.instance=new Fx),Fx.instance}static registerManager(nu,ru){vu(nu!=null,()=>"scheme must not be undefined or null."),nu.endsWith(NM)&&(nu=nu.slice(0,nu.indexOf(NM))),vu(nu.length>0,()=>"scheme must not be an empty string.");const lu=Fx.getInstance();vu(lu.managers[nu]==null,()=>`A model store manager is already registered for scheme '${nu}'.`),lu.managers[nu]=ru}static getManager(nu){const ru=Fx.getInstance().managers[nu];if(ru==null)throw new Error(`Cannot find model manager for scheme '${nu}'`);return ru}static getSchemes(){return Object.keys(Fx.getInstance().managers)}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class qP{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(nu,ru){return fetch(nu,ru)}now(){return performance.now()}encode(nu,ru){if(ru!=="utf-8"&&ru!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${ru}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(nu)}decode(nu,ru){return new TextDecoder(ru).decode(nu)}setTimeoutCustom(nu,ru){if(typeof window>"u"||!cp().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(nu,ru);return}this.functionRefs.push(nu),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},ru),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",lu=>{if(lu.source===window&&lu.data.name===this.messageName){lu.stopPropagation();const cu=this.functionRefs[lu.data.index];cu(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(nu){return K_(nu)}}if(cp().get("IS_BROWSER")){cp().setPlatform("browser",new qP);try{Fx.registerManager(n1.URL_SCHEME,new YP)}catch{}try{Fx.registerManager(t1.URL_SCHEME,new zP)}catch{}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const JP={importFetch:()=>requireBrowser()};let NS;class eG{constructor(){this.util=requireUtil(),this.textEncoder=new this.util.TextEncoder}fetch(nu,ru){return cp().global.fetch!=null?cp().global.fetch(nu,ru):(NS==null&&(NS=JP.importFetch()),NS(nu,ru))}now(){const nu=process$1.hrtime();return nu[0]*1e3+nu[1]/1e6}encode(nu,ru){if(ru!=="utf-8"&&ru!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${ru}`);return this.textEncoder.encode(nu)}decode(nu,ru){return nu.length===0?"":new this.util.TextDecoder(ru).decode(nu)}isTypedArray(nu){return this.util.types.isFloat32Array(nu)||this.util.types.isInt32Array(nu)||this.util.types.isUint8Array(nu)||this.util.types.isUint8ClampedArray(nu)}}cp().get("IS_NODE")&&!cp().get("IS_BROWSER")&&cp().setPlatform("node",new eG);/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t0(ou,nu="float32",ru){return nu=nu||"float32",nm(ou),new uy(ou,nu,ru)}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tG(ou,nu){const ru=fp(ou,"x","cast");if(!ju(nu))throw new Error(`Failed to cast to unknown dtype ${nu}`);if(nu==="string"&&ru.dtype!=="string"||nu!=="string"&&ru.dtype==="string")throw new Error("Only strings can be casted to strings");const lu={x:ru},cu={dtype:nu};return Tp.runKernel(Sm,lu,cu)}const km=Fp({cast_:tG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nG(ou){const nu={x:fp(ou,"x","clone","string_or_numeric")};return Tp.runKernel(Hy,nu)}const i1=Fp({clone_:nG});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iG(ou,nu=!1){console.log(ou.toString(nu))}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/AM(),TP({buffer:t0,cast:km,clone:i1,print:iG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rG(ou,nu){let ru=fp(ou,"a","add"),lu=fp(nu,"b","add");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(sp,cu)}const Am=Fp({add_:rG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sG(ou,nu){let ru=fp(ou,"a","floorDiv"),lu=fp(nu,"b","floorDiv");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(z0,cu)}const DM=Fp({floorDiv_:sG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oG(ou,nu){let ru=fp(ou,"a","div"),lu=fp(nu,"b","div");if([ru,lu]=W0(ru,lu),ru.dtype==="int32"&&lu.dtype==="int32")return DM(ru,lu);const cu={a:ru,b:lu},hu={};return Tp.runKernel(Gp,cu,hu)}const Xm=Fp({div_:oG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aG(ou,nu){let ru=fp(ou,"a","mul"),lu=fp(nu,"b","mul");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(kC,cu)}const _p=Fp({mul_:aG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lG(ou){const nu=fp(ou,"x","abs");if(nu.dtype==="complex64"){const ru={x:nu};return Tp.runKernel(pv,ru)}else{const ru={x:nu};return Tp.runKernel(Lp,ru)}}const vy=Fp({abs_:lG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cG(ou){const nu={x:fp(ou,"x","acos")};return Tp.runKernel(Kp,nu)}const uG=Fp({acos_:cG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hG(ou){const nu={x:fp(ou,"x","acosh")};return Tp.runKernel(vm,nu)}const dG=Fp({acosh_:hG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pG(ou,nu=null,ru=!1){const lu={x:fp(ou,"x","all","bool")},cu={axis:nu,keepDims:ru};return Tp.runKernel(Sp,lu,cu)}const FM=Fp({all_:pG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fG(ou,nu=null,ru=!1){const lu={x:fp(ou,"x","any","bool")},cu={axis:nu,keepDims:ru};return Tp.runKernel(tm,lu,cu)}const DS=Fp({any_:fG});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mG(ou,nu=0){const ru={x:fp(ou,"x","argMax")},lu={axis:nu};return Tp.runKernel(qu,ru,lu)}const nw=Fp({argMax_:mG});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gG(ou,nu=0){const ru={x:fp(ou,"x","argMin")},lu={axis:nu};return Tp.runKernel(Uu,ru,lu)}const AG=Fp({argMin_:gG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yG(ou){const nu={x:fp(ou,"x","asin")};return Tp.runKernel(zu,nu)}const bG=Fp({asin_:yG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xG(ou){const nu={x:fp(ou,"x","asinh")};return Tp.runKernel(ep,nu)}const vG=Fp({asinh_:xG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CG(ou){const nu={x:fp(ou,"x","atan")};return Tp.runKernel(up,nu)}const wG=Fp({atan_:CG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EG(ou,nu){let ru=fp(ou,"a","atan2"),lu=fp(nu,"b","atan2");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(Ip,cu)}const SG=Fp({atan2_:EG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IG(ou){const nu={x:fp(ou,"x","atanh")};return Tp.runKernel(Mp,nu)}const TG=Fp({atanh_:IG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iw(ou,nu,ru,lu,cu="NHWC",hu){const pu=ou[3],mu=[...nu,pu],Au=nv(cu);return hy(ou,mu,ru,hu,lu,null,null,Au)}function ox(ou,nu,ru,lu,cu,hu,pu="channelsLast"){const[mu,Au]=rw(nu);let bu;if(pu==="channelsLast")bu=[mu,Au,ou[3],ou[3]];else if(pu==="channelsFirst")bu=[mu,Au,ou[1],ou[1]];else throw new Error(`Unknown dataFormat ${pu}`);return hy(ou,bu,ru,lu,cu,hu,!1,pu)}function tv(ou,nu,ru,lu,cu,hu,pu="NDHWC"){const[mu,Au,bu]=PS(nu);let Cu,wu;if(pu==="NDHWC")wu="channelsLast",Cu=[mu,Au,bu,ou[4],ou[4]];else if(pu==="NCDHW")wu="channelsFirst",Cu=[mu,Au,bu,ou[1],ou[1]];else throw new Error(`Unknown dataFormat ${pu}`);return wv(ou,Cu,ru,lu,cu,!1,wu,hu)}function hy(ou,nu,ru,lu,cu,hu,pu=!1,mu="channelsLast"){let[Au,bu,Cu,wu]=[-1,-1,-1,-1];if(mu==="channelsLast")[Au,bu,Cu,wu]=ou;else if(mu==="channelsFirst")[Au,wu,bu,Cu]=ou;else throw new Error(`Unknown dataFormat ${mu}`);const[Eu,Tu,,Ru]=nu,[Nu,Pu]=rw(ru),[Fu,Gu]=rw(lu),Xu=X1(Eu,Fu),Qu=X1(Tu,Gu),{padInfo:Ju,outHeight:ip,outWidth:rp}=RG(cu,bu,Cu,Nu,Pu,Xu,Qu,hu,mu),op=pu?Ru*wu:Ru;let hp;return mu==="channelsFirst"?hp=[Au,op,ip,rp]:mu==="channelsLast"&&(hp=[Au,ip,rp,op]),{batchSize:Au,dataFormat:mu,inHeight:bu,inWidth:Cu,inChannels:wu,outHeight:ip,outWidth:rp,outChannels:op,padInfo:Ju,strideHeight:Nu,strideWidth:Pu,filterHeight:Eu,filterWidth:Tu,effectiveFilterHeight:Xu,effectiveFilterWidth:Qu,dilationHeight:Fu,dilationWidth:Gu,inShape:ou,outShape:hp,filterShape:nu}}function wv(ou,nu,ru,lu,cu,hu=!1,pu="channelsLast",mu){let[Au,bu,Cu,wu,Eu]=[-1,-1,-1,-1,-1];if(pu==="channelsLast")[Au,bu,Cu,wu,Eu]=ou;else if(pu==="channelsFirst")[Au,Eu,bu,Cu,wu]=ou;else throw new Error(`Unknown dataFormat ${pu}`);const[Tu,Ru,Nu,,Pu]=nu,[Fu,Gu,Xu]=PS(ru),[Qu,Ju,ip]=PS(lu),rp=X1(Tu,Qu),op=X1(Ru,Ju),hp=X1(Nu,ip),{padInfo:Ap,outDepth:Up,outHeight:Vp,outWidth:zp}=kG(cu,bu,Cu,wu,Fu,Gu,Xu,rp,op,hp,mu),qp=hu?Pu*Eu:Pu;let Yp;return pu==="channelsFirst"?Yp=[Au,qp,Up,Vp,zp]:pu==="channelsLast"&&(Yp=[Au,Up,Vp,zp,qp]),{batchSize:Au,dataFormat:pu,inDepth:bu,inHeight:Cu,inWidth:wu,inChannels:Eu,outDepth:Up,outHeight:Vp,outWidth:zp,outChannels:qp,padInfo:Ap,strideDepth:Fu,strideHeight:Gu,strideWidth:Xu,filterDepth:Tu,filterHeight:Ru,filterWidth:Nu,effectiveFilterDepth:rp,effectiveFilterHeight:op,effectiveFilterWidth:hp,dilationDepth:Qu,dilationHeight:Ju,dilationWidth:ip,inShape:ou,outShape:Yp,filterShape:nu}}function _G(ou,nu,ru,lu,cu){lu==null&&(lu=FS(ou,nu,ru));const hu=ou[0],pu=ou[1],mu=sw((hu-nu+2*lu)/ru+1,cu),Au=sw((pu-nu+2*lu)/ru+1,cu);return[mu,Au]}function MG(ou,nu,ru,lu,cu,hu){cu==null&&(cu=FS(ou,nu[0],lu[0]));const pu=[0,0,0,ru];for(let mu=0;mu<3;mu++)ou[mu]+2*cu>=nu[mu]&&(pu[mu]=sw((ou[mu]-nu[mu]+2*cu)/lu[mu]+1,hu));return pu}function FS(ou,nu,ru,lu=1){const cu=X1(nu,lu);return Math.floor((ou[0]*(ru-1)-ru+cu)/2)}function rw(ou){return typeof ou=="number"?[ou,ou,ou]:ou.length===2?[ou[0],ou[1],1]:ou}function PS(ou){return typeof ou=="number"?[ou,ou,ou]:ou}function X1(ou,nu){return nu<=1?ou:ou+(ou-1)*(nu-1)}function RG(ou,nu,ru,lu,cu,hu,pu,mu,Au){let bu,Cu,wu;if(typeof ou=="number"){bu={top:ou,bottom:ou,left:ou,right:ou,type:ou===0?"VALID":"NUMBER"};const Eu=_G([nu,ru],hu,lu,ou,mu);Cu=Eu[0],wu=Eu[1]}else if(ou==="same"){Cu=Math.ceil(nu/lu),wu=Math.ceil(ru/cu);const Eu=Math.max(0,(Cu-1)*lu+hu-nu),Tu=Math.max(0,(wu-1)*cu+pu-ru),Ru=Math.floor(Eu/2),Nu=Eu-Ru,Pu=Math.floor(Tu/2),Fu=Tu-Pu;bu={top:Ru,bottom:Nu,left:Pu,right:Fu,type:"SAME"}}else if(ou==="valid")bu={top:0,bottom:0,left:0,right:0,type:"VALID"},Cu=Math.ceil((nu-hu+1)/lu),wu=Math.ceil((ru-pu+1)/cu);else if(typeof ou=="object"){const Eu=Au==="channelsLast"?ou[1][0]:ou[2][0],Tu=Au==="channelsLast"?ou[1][1]:ou[2][1],Ru=Au==="channelsLast"?ou[2][0]:ou[3][0],Nu=Au==="channelsLast"?ou[2][1]:ou[3][1];bu={top:Eu,bottom:Tu,left:Ru,right:Nu,type:Eu===0&&Tu===0&&Ru===0&&Nu===0?"VALID":"EXPLICIT"},Cu=sw((nu-hu+Eu+Tu)/lu+1,mu),wu=sw((ru-pu+Ru+Nu)/cu+1,mu)}else throw Error(`Unknown padding parameter: ${ou}`);return{padInfo:bu,outHeight:Cu,outWidth:wu}}function kG(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu,Cu){let wu,Eu,Tu,Ru;if(ou==="valid"&&(ou=0),typeof ou=="number"){wu={top:ou,bottom:ou,left:ou,right:ou,front:ou,back:ou,type:ou===0?"VALID":"NUMBER"};const Nu=MG([nu,ru,lu,1],[mu,Au,bu],1,[cu,hu,pu],ou,Cu);Eu=Nu[0],Tu=Nu[1],Ru=Nu[2]}else if(ou==="same"){Eu=Math.ceil(nu/cu),Tu=Math.ceil(ru/hu),Ru=Math.ceil(lu/pu);const Nu=(Eu-1)*cu+mu-nu,Pu=(Tu-1)*hu+Au-ru,Fu=(Ru-1)*pu+bu-lu,Gu=Math.floor(Nu/2),Xu=Nu-Gu,Qu=Math.floor(Pu/2),Ju=Pu-Qu,ip=Math.floor(Fu/2),rp=Fu-ip;wu={top:Qu,bottom:Ju,left:ip,right:rp,front:Gu,back:Xu,type:"SAME"}}else throw Error(`Unknown padding parameter: ${ou}`);return{padInfo:wu,outDepth:Eu,outHeight:Tu,outWidth:Ru}}function sw(ou,nu){if(!nu)return Math.trunc(ou);switch(nu){case"round":return Math.round(ou);case"ceil":return Math.ceil(ou);case"floor":return Math.floor(ou);default:throw new Error(`Unknown roundingMode ${nu}`)}}function r1(ou){const[nu,ru,lu]=rw(ou);return nu===1&&ru===1&&lu===1}function gy(ou,nu){return r1(ou)||r1(nu)}function s1(ou){return rw(ou).every(nu=>nu>0)}function nv(ou){if(ou==="NHWC")return"channelsLast";if(ou==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${ou}`)}function ky(ou,nu,ru){if(ru!=null){if(typeof nu=="string")throw Error(`Error in ${ou}: pad must be an integer when using dimRoundingMode ${ru} but got pad ${nu}.`);if(typeof nu=="number")vu(Bu(nu),()=>`Error in ${ou}: pad must be an integer when using dimRoundingMode ${ru} but got pad ${nu}.`);else if(typeof nu=="object")nu.forEach(lu=>{lu.forEach(cu=>{vu(Bu(cu),()=>`Error in ${ou}: pad must be an integer when using dimRoundingMode ${ru} but got pad ${cu}.`)})});else throw Error(`Error in ${ou}: Unknown padding parameter: ${nu}`)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BG(ou,nu){const ru={x:fp(ou,"x","reshape","string_or_numeric")},lu={shape:nu};return Tp.runKernel(mE,ru,lu)}const Pp=Fp({reshape_:BG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LG(ou,nu,ru,lu,cu){const hu=fp(ou,"x","avgPool","float32"),pu=1;vu(gy(ru,pu),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${ru} and dilations '${pu}'`);let mu=hu,Au=!1;hu.rank===3&&(Au=!0,mu=Pp(hu,[1,hu.shape[0],hu.shape[1],hu.shape[2]])),vu(mu.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${mu.rank}.`),ky("avgPool",lu,cu);const bu={x:mu},Cu={filterSize:nu,strides:ru,pad:lu,dimRoundingMode:cu};let wu=Tp.runKernel(fm,bu,Cu);return wu=km(wu,hu.dtype),Au?Pp(wu,[wu.shape[1],wu.shape[2],wu.shape[3]]):wu}const GS=Fp({avgPool_:LG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NG(ou,nu,ru,lu,cu,hu="NDHWC"){const pu=fp(ou,"x","avgPool3d","float32");let mu=pu,Au=!1;pu.rank===4&&(Au=!0,mu=Pp(pu,[1,pu.shape[0],pu.shape[1],pu.shape[2],pu.shape[3]])),vu(mu.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${mu.rank}.`),vu(hu==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${hu}`),vu(typeof ru=="number"&&ru>0||Array.isArray(ru)&&ru[0]>0&&ru[1]>0&&ru[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${ru}'`),ky("avgPool3d",lu,cu);const bu={x:mu},Cu={filterSize:nu,strides:ru,pad:lu,dimRoundingMode:cu,dataFormat:hu};let wu=Tp.runKernel(pp,bu,Cu);return wu=km(wu,mu.dtype),Au?Pp(wu,[wu.shape[1],wu.shape[2],wu.shape[3],wu.shape[4]]):wu}const DG=Fp({avgPool3d_:NG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FG(ou,nu=0){vu(ou.length>=1,()=>"Pass at least one tensor to concat");const ru=CM(ou,"tensors","concat","string_or_numeric");if(ru[0].dtype==="complex64"&&ru.forEach(hu=>{if(hu.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${hu.dtype}. `)}),ru.length===1)return i1(ru[0]);const lu=ru,cu={axis:nu};return Tp.runKernel(L1,lu,cu)}const By=Fp({concat_:FG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PG(ou,nu,ru=!1,lu=!1){let cu=fp(ou,"a","matMul"),hu=fp(nu,"b","matMul");[cu,hu]=W0(cu,hu);const pu={a:cu,b:hu},mu={transposeA:ru,transposeB:lu};return Tp.runKernel(om,pu,mu)}const g0=Fp({matMul_:PG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GG(ou){const nu={x:fp(ou,"x","sigmoid","float32")};return Tp.runKernel(VC,nu)}const Q1=Fp({sigmoid_:GG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OG(ou,nu,ru){const lu=fp(ou,"x","slice","string_or_numeric");if(lu.rank===0)throw new Error("Slicing scalar is not possible");const cu={x:lu},hu={begin:nu,size:ru};return Tp.runKernel(xE,cu,hu)}const E0=Fp({slice_:OG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UG(ou){const nu={x:fp(ou,"x","tanh","float32")};return Tp.runKernel(KC,nu)}const OS=Fp({tanh_:UG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $G(ou,nu,ru){const lu=fp(ou,"x","batchToSpaceND"),cu=nu.reduce((mu,Au)=>mu*Au);vu(lu.rank>=1+nu.length,()=>`input rank is ${lu.rank} but should be > than blockShape.length ${nu.length}`),vu(ru.length===nu.length,()=>`crops.length is ${ru.length} but should be equal to blockShape.length  ${nu.length}`),vu(lu.shape[0]%cu===0,()=>`input tensor batch is ${lu.shape[0]} but is not divisible by the product of the elements of blockShape ${nu.join(" * ")} === ${cu}`);const hu={x:lu},pu={blockShape:nu,crops:ru};return Tp.runKernel(Mm,hu,pu)}const US=Fp({batchToSpaceND_:$G});function VG(ou){let nu;return ou.rank===0||ou.rank===1?nu=Pp(ou,[1,1,1,ou.size]):ou.rank===2?nu=Pp(ou,[1,1,ou.shape[0],ou.shape[1]]):ou.rank===3?nu=Pp(ou,[1,ou.shape[0],ou.shape[1],ou.shape[2]]):nu=ou,nu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zG(ou,nu,ru,lu,cu,hu){hu==null&&(hu=.001);const pu=fp(ou,"x","batchNorm"),mu=fp(nu,"mean","batchNorm"),Au=fp(ru,"variance","batchNorm");let bu;cu!=null&&(bu=fp(cu,"scale","batchNorm"));let Cu;lu!=null&&(Cu=fp(lu,"offset","batchNorm")),vu(mu.rank===Au.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),vu(Cu==null||mu.rank===Cu.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),vu(bu==null||mu.rank===bu.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const wu={x:VG(pu),scale:bu,offset:Cu,mean:mu,variance:Au},Eu={varianceEpsilon:hu},Tu=Tp.runKernel(Um,wu,Eu);return Pp(Tu,pu.shape)}const FE=Fp({batchNorm_:zG});function WG(ou,nu,ru,lu,cu,hu){const pu=fp(ou,"x","batchNorm"),mu=fp(nu,"mean","batchNorm"),Au=fp(ru,"variance","batchNorm");let bu;cu!=null&&(bu=fp(cu,"scale","batchNorm"));let Cu;return lu!=null&&(Cu=fp(lu,"offset","batchNorm")),vu(pu.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${pu.rank}.`),vu(mu.rank===2||mu.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${mu.rank}.`),vu(Au.rank===2||Au.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${Au.rank}.`),bu!=null&&vu(bu.rank===2||bu.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${bu.rank}.`),Cu!=null&&vu(Cu.rank===2||Cu.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${Cu.rank}.`),FE(pu,mu,Au,Cu,bu,hu)}const HG=Fp({batchNorm2d_:WG});function XG(ou,nu,ru,lu,cu,hu){const pu=fp(ou,"x","batchNorm"),mu=fp(nu,"mean","batchNorm"),Au=fp(ru,"variance","batchNorm");let bu;cu!=null&&(bu=fp(cu,"scale","batchNorm"));let Cu;return lu!=null&&(Cu=fp(lu,"offset","batchNorm")),vu(pu.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${pu.rank}.`),vu(mu.rank===3||mu.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${mu.rank}.`),vu(Au.rank===3||Au.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${Au.rank}.`),bu!=null&&vu(bu.rank===3||bu.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${bu.rank}.`),Cu!=null&&vu(Cu.rank===3||Cu.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${Cu.rank}.`),FE(pu,mu,Au,Cu,bu,hu)}const QG=Fp({batchNorm3d_:XG});function KG(ou,nu,ru,lu,cu,hu){const pu=fp(ou,"x","batchNorm"),mu=fp(nu,"mean","batchNorm"),Au=fp(ru,"variance","batchNorm");let bu;cu!=null&&(bu=fp(cu,"scale","batchNorm"));let Cu;return lu!=null&&(Cu=fp(lu,"offset","batchNorm")),vu(pu.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${pu.rank}.`),vu(mu.rank===4||mu.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${mu.rank}.`),vu(Au.rank===4||Au.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${Au.rank}.`),bu!=null&&vu(bu.rank===4||bu.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${bu.rank}.`),Cu!=null&&vu(Cu.rank===4||Cu.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${Cu.rank}.`),FE(pu,mu,Au,Cu,bu,hu)}const ZG=Fp({batchNorm4d_:KG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jG(ou,nu,ru){const lu=fp(ou,"x","bincount"),cu=fp(nu,"weights","bincount");vu(lu.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${lu.dtype}`),vu(ru>=0,()=>`size must be non-negative, but got ${ru}.`),vu(cu.size===lu.size||cu.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${lu.shape}, weights shape: ${cu.shape}.`);const hu={x:lu,weights:cu},pu={size:ru};return Tp.runKernel(Tm,hu,pu)}const YG=Fp({bincount_:jG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qG(ou,nu){let ru=fp(ou,"broadcastTo","x");const lu=ru.shape;if(nm(nu),nu.length<ru.rank)throw new Error(`broadcastTo(): shape.length=${nu.length} < input.rank=${ru.rank}.`);if(nu.length>ru.rank){const Au=ru.shape.slice();for(;Au.length<nu.length;)Au.unshift(1);ru=Pp(ru,Au)}const cu=ru.shape,hu=Array.from(nu);for(let Au=nu.length-1;Au>=0;Au--)if(cu[Au]===nu[Au])hu[Au]=1;else if(ru.shape[Au]!==1)throw new Error(`broadcastTo(): [${lu}] cannot be broadcast to [${nu}].`);if(hu.map((Au,bu)=>Au>1?bu:-1).filter(Au=>Au>=0).length===0)return i1(ru);const pu={x:ru},mu={reps:hu};return Tp.runKernel(ZC,pu,mu)}const ow=Fp({broadcastTo_:qG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JG(ou){const nu={x:fp(ou,"x","ceil","float32")};return Tp.runKernel(Fm,nu)}const eO=Fp({ceil_:JG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PE(ou,nu,ru){nm(ou),ru=ru||Dp(nu);const lu={shape:ou,value:nu,dtype:ru};return Tp.runKernel(P0,{},lu)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tO(ou,nu,ru){const lu=fp(ou,"x","clipByValue");if(vu(nu<=ru,()=>`Error in clip: min (${nu}) must be less than or equal to max (${ru}).`),nu===ru)return PE(lu.shape,nu,lu.dtype);const cu={x:lu},hu={clipValueMin:nu,clipValueMax:ru};return Tp.runKernel(i0,cu,hu)}const jy=Fp({clipByValue_:tO});function nO(ou){return By(ou,0)}const iO=Fp({concat1d_:nO});function rO(ou,nu){return By(ou,nu)}const sO=Fp({concat2d_:rO});function oO(ou,nu){return By(ou,nu)}const aO=Fp({concat3d_:oO});function lO(ou,nu){return By(ou,nu)}const cO=Fp({concat4d_:lO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uO(ou,nu,ru,lu,cu="NHWC",hu=[1,1],pu){const mu=fp(ou,"x","conv2d","float32"),Au=fp(nu,"filter","conv2d","float32");let bu=mu,Cu=!1;mu.rank===3&&(Cu=!0,bu=Pp(mu,[1,mu.shape[0],mu.shape[1],mu.shape[2]])),vu(bu.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${bu.rank}.`),vu(Au.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${Au.rank}.`),ky("conv2d",lu,pu);const wu=cu==="NHWC"?bu.shape[3]:bu.shape[1];vu(wu===Au.shape[2],()=>`Error in conv2d: depth of input (${wu}) must match input depth for filter ${Au.shape[2]}.`),vu(gy(ru,hu),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${ru} and dilations '${hu}'`),vu(s1(hu),()=>"Error in conv2D: Dilated rates should be larger than 0."),vu(s1(ru),()=>"Error in conv2D: Strides should be larger than 0.");const Eu={x:bu,filter:Au},Tu={strides:ru,pad:lu,dataFormat:cu,dilations:hu,dimRoundingMode:pu},Ru=Tp.runKernel(zv,Eu,Tu);return Cu?Pp(Ru,[Ru.shape[1],Ru.shape[2],Ru.shape[3]]):Ru}const o1=Fp({conv2d_:uO});function hO(ou,nu,ru,lu,cu="NWC",hu=1,pu){const mu=fp(ou,"x","conv1d"),Au=fp(nu,"filter","conv1d");let bu=mu,Cu=!1;mu.rank===2&&(Cu=!0,bu=Pp(mu,[1,mu.shape[0],mu.shape[1]])),vu(bu.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${bu.rank}.`),vu(Au.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${Au.rank}.`),ky("conv1d",lu,pu),vu(bu.shape[2]===Au.shape[1],()=>`Error in conv1d: depth of input (${bu.shape[2]}) must match input depth for filter ${Au.shape[1]}.`),vu(gy(ru,hu),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${ru} and dilation '${hu}'`),vu(s1(hu),()=>"Error in conv1D: Dilated rates should be larger than 0."),vu(s1(ru),()=>"Error in conv1D: Stride should be larger than 0."),vu(cu==="NWC",()=>`Error in conv1d: got dataFormat of ${cu} but only NWC is currently supported.`);const wu=Pp(Au,[1,Au.shape[0],Au.shape[1],Au.shape[2]]),Eu=Pp(bu,[bu.shape[0],1,bu.shape[1],bu.shape[2]]),Tu=o1(Eu,wu,[1,ru],lu,"NHWC",[1,hu],pu);return Cu?Pp(Tu,[Tu.shape[2],Tu.shape[3]]):Pp(Tu,[Tu.shape[0],Tu.shape[2],Tu.shape[3]])}const PM=Fp({conv1d_:hO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dO(ou,nu,ru,lu,cu,hu="NHWC",pu){vu(ou.length===nu.rank,()=>`Length of inShape (${ou.length}) and rank of dy (${nu.rank}) must match`);let mu=ou,Au=nu,bu=!1;nu.rank===3&&(bu=!0,Au=Pp(nu,[1,nu.shape[0],nu.shape[1],nu.shape[2]]),mu=[1,ou[0],ou[1],ou[2]]),vu(mu.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${mu.length}.`),vu(Au.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${Au.rank}`),vu(ru.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${ru.rank}`);const Cu=hu==="NHWC"?mu[3]:mu[1],wu=hu==="NHWC"?Au.shape[3]:Au.shape[1];vu(Cu===ru.shape[2],()=>`Error in conv2dDerInput: depth of input (${Cu}) must match input depth for filter ${ru.shape[2]}.`),vu(wu===ru.shape[3],()=>`Error in conv2dDerInput: depth of output (${wu}) must match output depth for filter ${ru.shape[3]}.`),ky("conv2dDerInput",cu,pu);const Eu={dy:Au,filter:ru},Tu={strides:lu,pad:cu,dataFormat:hu,dimRoundingMode:pu,inputShape:mu},Ru=Tp.runKernel(tx,Eu,Tu);return bu?Pp(Ru,[Ru.shape[1],Ru.shape[2],Ru.shape[3]]):Ru}const $S=Fp({conv2DBackpropInput_:dO});function pO(ou,nu,ru,lu,cu,hu){const pu=fp(ou,"x","conv2dTranspose"),mu=fp(nu,"filter","conv2dTranspose");return $S(ru,pu,mu,lu,cu,"NHWC",hu)}const GM=Fp({conv2dTranspose_:pO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fO(ou,nu,ru,lu,cu="NDHWC",hu=[1,1,1]){const pu=fp(ou,"x","conv3d"),mu=fp(nu,"filter","conv3d");let Au=pu,bu=!1;pu.rank===4&&(bu=!0,Au=Pp(pu,[1,pu.shape[0],pu.shape[1],pu.shape[2],pu.shape[3]])),vu(Au.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${Au.rank}.`),vu(mu.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${mu.rank}.`),vu(Au.shape[4]===mu.shape[3],()=>`Error in conv3d: depth of input (${Au.shape[4]}) must match input depth for filter ${mu.shape[3]}.`),vu(gy(ru,hu),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${ru} and dilations '${hu}'`),vu(cu==="NDHWC",()=>`Error in conv3d: got dataFormat of ${cu} but only NDHWC is currently supported.`),vu(s1(hu),()=>"Error in conv3D: Dilated rates should be larger than 0."),vu(s1(ru),()=>"Error in conv3D: Strides should be larger than 0.");const Cu={x:Au,filter:mu},wu={strides:ru,pad:lu,dataFormat:cu,dilations:hu},Eu=Tp.runKernel(fv,Cu,wu);return bu?Pp(Eu,[Eu.shape[1],Eu.shape[2],Eu.shape[3],Eu.shape[4]]):Eu}const mO=Fp({conv3d_:fO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gO(ou,nu,ru,lu,cu){vu(ou.length===nu.rank,()=>`Length of inShape (${ou.length}) and rank of dy (${nu.rank}) must match`);let hu=ou,pu=nu,mu=!1;nu.rank===4&&(mu=!0,pu=Pp(nu,[1,nu.shape[0],nu.shape[1],nu.shape[2],nu.shape[3]]),hu=[1,ou[0],ou[1],ou[2],ou[3]]);const Au=hu[4],bu=pu.shape[4];vu(hu.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${hu.length}.`),vu(pu.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${pu.rank}`),vu(ru.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${ru.rank}`),vu(Au===ru.shape[3],()=>`Error in conv3dDerInput: depth of input (${Au}) must match input depth for filter ${ru.shape[3]}.`),vu(bu===ru.shape[4],()=>`Error in conv3dDerInput: depth of output (${bu}) must match output depth for filter ${ru.shape[4]}.`);const Cu={dy:pu,filter:ru},wu={pad:cu,strides:lu,inputShape:hu},Eu=Tp.runKernel(D1,Cu,wu);return mu?Pp(Eu,[Eu.shape[1],Eu.shape[2],Eu.shape[3],Eu.shape[4]]):Eu}const OM=Fp({conv3DBackpropInput_:gO});function AO(ou,nu,ru,lu,cu){const hu=fp(ou,"x","conv3dTranspose"),pu=fp(nu,"filter","conv3dTranspose");return OM(ru,hu,pu,lu,cu)}const yO=Fp({conv3dTranspose_:AO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bO(ou){const nu={x:fp(ou,"x","cos","float32")};return Tp.runKernel(Lx,nu)}const VS=Fp({cos_:bO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xO(ou){const nu={x:fp(ou,"x","cosh","float32")};return Tp.runKernel(mv,nu)}const UM=Fp({cosh_:xO});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vO(ou,nu=0,ru=!1,lu=!1){const cu={x:fp(ou,"x","cumprod")},hu={axis:nu,exclusive:ru,reverse:lu};return Tp.runKernel(gv,cu,hu)}const zS=Fp({cumprod_:vO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CO(ou,nu=0,ru=!1,lu=!1){const cu={x:fp(ou,"x","cumsum")},hu={axis:nu,exclusive:ru,reverse:lu};return Tp.runKernel(Hv,cu,hu)}const $M=Fp({cumsum_:CO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wO(ou,nu,ru,lu=!1){const cu=fp(ou,"x","denseBincount"),hu=fp(nu,"weights","denseBincount");vu(cu.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${cu.dtype}`),vu(cu.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${cu.rank}.`),vu(ru>=0,()=>`size must be non-negative, but got ${ru}.`),vu(hu.size===cu.size||hu.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${cu.shape}, weights shape: ${hu.shape}.`);const pu={x:cu,weights:hu},mu={size:ru,binaryOutput:lu};return Tp.runKernel(CC,pu,mu)}const VM=Fp({denseBincount_:wO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EO(ou,nu,ru="NHWC"){const lu=fp(ou,"x","depthToSpace","float32"),cu=ru==="NHWC"?lu.shape[1]:lu.shape[2],hu=ru==="NHWC"?lu.shape[2]:lu.shape[3],pu=ru==="NHWC"?lu.shape[3]:lu.shape[1];vu(nu>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${nu}`),vu(cu*nu>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${cu} and ${nu}  for depthToSpace with input shape
    ${lu.shape}`),vu(hu*nu>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${hu} and ${nu} for depthToSpace with input shape
        ${lu.shape}`),vu(pu%(nu*nu)===0,()=>`Dimension size must be evenly divisible by ${nu*nu} but is ${pu} for depthToSpace with input shape ${lu.shape}`);const mu={x:lu},Au={blockSize:nu,dataFormat:ru};return Tp.runKernel(wC,mu,Au)}const SO=Fp({depthToSpace_:EO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IO(ou,nu,ru,lu,cu="NHWC",hu=[1,1],pu){const mu=fp(ou,"x","depthwiseConv2d","float32"),Au=fp(nu,"filter","depthwiseConv2d","float32");let bu=mu,Cu=!1;mu.rank===3&&(Cu=!0,bu=Pp(mu,[1,mu.shape[0],mu.shape[1],mu.shape[2]])),vu(bu.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${bu.rank}.`),vu(Au.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${Au.rank}.`);const wu=cu==="NHWC"?bu.shape[3]:bu.shape[1];vu(wu===Au.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${wu}) must match the inChannels dimension in filter ${Au.shape[2]}.`),ky("depthwiseConv2d",lu,pu);const Eu={x:bu,filter:Au},Tu={strides:ru,pad:lu,dataFormat:cu,dilations:hu,dimRoundingMode:pu},Ru=Tp.runKernel(P1,Eu,Tu);return Cu?Pp(Ru,[Ru.shape[1],Ru.shape[2],Ru.shape[3]]):Ru}const WS=Fp({depthwiseConv2d_:IO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TO(ou,nu,ru,lu,cu=[1,1],hu="NHWC"){const pu=fp(ou,"x","dilation2d"),mu=fp(nu,"filter","dilation2d");vu(pu.rank===3||pu.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${pu.rank}.`),vu(mu.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${mu.rank}.`),vu(hu==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${hu}`);let Au=pu,bu=!1;pu.rank===3&&(Au=Pp(pu,[1,pu.shape[0],pu.shape[1],pu.shape[2]]),bu=!0),vu(Au.shape[3]===mu.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${Au.shape[3]} vs ${mu.shape[2]}`);const Cu={x:Au,filter:mu},wu={strides:ru,pad:lu,dilations:cu},Eu=Tp.runKernel(np,Cu,wu);return bu?Pp(Eu,[Eu.shape[1],Eu.shape[2],Eu.shape[3]]):Eu}const _O=Fp({dilation2d_:TO});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function K1(ou,nu){const ru=ou.length,lu=[];for(let cu=0;cu<ru;cu++){const hu=ru-1-cu,pu=ou[hu]||1;(nu[nu.length-1-cu]||1)>1&&pu===1&&lu.unshift(hu)}return lu}function J0(ou,nu){const ru=[];for(let lu=0;lu<nu.length;lu++){const cu=ou[ou.length-lu-1],hu=nu.length-lu-1,pu=nu[hu];(cu==null||cu===1&&pu>1)&&ru.unshift(hu)}return ru}function _g(ou,nu){const ru=Math.max(ou.length,nu.length),lu=new Array(ru);for(let cu=0;cu<ru;cu++){let hu=ou[ou.length-cu-1];hu==null&&(hu=1);let pu=nu[nu.length-cu-1];if(pu==null&&(pu=1),hu===1)lu[ru-cu-1]=pu;else if(pu===1)lu[ru-cu-1]=hu;else if(hu!==pu){const mu=`Operands could not be broadcast together with shapes ${ou} and ${nu}.`;throw Error(mu)}else lu[ru-cu-1]=hu}return lu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MO(ou,nu){let ru=fp(ou,"a","equal","string_or_numeric"),lu=fp(nu,"b","equal","string_or_numeric");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(Km,cu)}const Px=Fp({equal_:MO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RO(ou,nu,ru){const lu=fp(nu,"a","where"),cu=fp(ru,"b","where"),hu=fp(ou,"condition","where","bool"),pu=_g(_g(hu.shape,lu.shape),cu.shape),mu=ow(hu,pu),Au=ow(lu,pu),bu=ow(cu,pu),Cu={condition:mu,t:Au,e:bu};return Tp.runKernel(bE,Cu)}const Cy=Fp({where_:RO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kO(ou){const nu={x:fp(ou,"x","zerosLike")};return Tp.runKernel(TE,nu)}const l0=Fp({zerosLike_:kO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BO(ou,nu){let ru=fp(ou,"a","div"),lu=fp(nu,"b","div");[ru,lu]=W0(ru,lu);const cu=Xm(ru,lu),hu=l0(cu),pu=Px(lu,hu);return Cy(pu,hu,cu)}const LO=Fp({divNoNan_:BO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NO(ou,nu){const ru=fp(ou,"t1","dot"),lu=fp(nu,"t2","dot");vu((ru.rank===1||ru.rank===2)&&(lu.rank===1||lu.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${ru.rank} and ${lu.rank}.`);const cu=ru.rank===1?ru.size:ru.shape[1],hu=lu.rank===1?lu.size:lu.shape[0];if(vu(cu===hu,()=>`Error in dot: inner dimensions of inputs must match, but got ${cu} and ${hu}.`),ru.rank===1&&lu.rank===1){const pu=Pp(ru,[1,-1]),mu=Pp(lu,[-1,1]),Au=g0(pu,mu);return Pp(Au,[])}else if(ru.rank===1&&lu.rank===2){const pu=Pp(ru,[1,-1]),mu=Pp(lu,[lu.shape[0],lu.shape[1]]),Au=g0(pu,mu);return Pp(Au,[Au.size])}else if(ru.rank===2&&lu.rank===1){const pu=Pp(lu,[-1,1]),mu=g0(ru,pu);return Pp(mu,[mu.size])}else{const pu=Pp(lu,[lu.shape[0],lu.shape[1]]);return g0(ru,pu)}}const DO=Fp({dot_:NO});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FO(ou,...nu){const ru=nu.map((cu,hu)=>fp(cu,`tensors${hu}`,"einsum")),lu={equation:ou};return Tp.runKernel(gm,ru,lu)}const aw=Fp({einsum_:FO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PO(ou){const nu={x:fp(ou,"x","elu","float32")};return Tp.runKernel(_m,nu)}const GE=Fp({elu_:PO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GO(ou){let nu=fp(ou,"x","erf");vu(nu.dtype==="int32"||nu.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),nu.dtype==="int32"&&(nu=km(nu,"float32"));const ru={x:nu};return Tp.runKernel(Dm,ru)}const OO=Fp({erf_:GO});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HS(ou,nu){for(let ru=0;ru<ou.length;++ru)if(ou[ou.length-ru-1]!==nu-1-ru)return!1;return!0}function zM(ou,nu,ru){const lu=ou.length+nu.length,cu=[];let hu=0,pu=0;for(let mu=0;mu<lu;mu++)ru.indexOf(mu)===-1?cu.push(ou[hu++]):cu.push(nu[pu++]);return cu}function oy(ou,nu){const ru=[],lu=ou.length;for(let hu=0;hu<lu;hu++)nu.indexOf(hu)===-1&&ru.push(ou[hu]);const cu=nu.map(hu=>ou[hu]);return[ru,cu]}function j0(ou,nu){const ru=nu.map(lu=>1);return zM(ou,ru,nu)}function dy(ou,nu,ru){vu(HS(nu,ru),()=>`${ou} supports only inner-most axes for now. Got axes ${nu} and rank-${ru} input.`)}function G0(ou,nu){if(HS(ou,nu))return null;const ru=[];for(let lu=0;lu<nu;++lu)ou.indexOf(lu)===-1&&ru.push(lu);return ou.forEach(lu=>ru.push(lu)),ru}function Ev(ou){return ou.map((nu,ru)=>[ru,nu]).sort((nu,ru)=>nu[1]-ru[1]).map(nu=>nu[0])}function H0(ou,nu){const ru=[];for(let lu=nu-ou;lu<nu;++lu)ru.push(lu);return ru}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UO(ou,nu=null,ru=!1){const lu={x:fp(ou,"x","max")},cu={reductionIndices:nu,keepDims:ru};return Tp.runKernel(tE,lu,cu)}const vx=Fp({max_:UO});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $O(ou,nu=null,ru=!1){const lu={x:fp(ou,"x","min")},cu={axis:nu,keepDims:ru};return Tp.runKernel(sE,lu,cu)}const OE=Fp({min_:$O});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VO(ou,nu){let ru=fp(ou,"base","pow"),lu=fp(nu,"exp","pow");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(BC,cu)}const Z1=Fp({pow_:VO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function A0(ou,nu){if((sx(ou)&&nu!=="string"||Array.isArray(ou))&&nu!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(nu==="string"&&sx(ou)&&!(ou instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return tw(ou,[],[],nu)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zO(ou){const nu={x:fp(ou,"x","sqrt","float32")};return Tp.runKernel(WC,nu)}const wy=Fp({sqrt_:zO});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WO(ou){const nu=fp(ou,"x","square"),ru={};return Tp.runKernel("Square",{x:nu},ru)}const k0=Fp({square_:WO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HO(ou,nu=null,ru=!1){let lu=fp(ou,"x","sum");lu.dtype==="bool"&&(lu=km(lu,"int32"));const cu={x:lu},hu={axis:nu,keepDims:ru};return Tp.runKernel(vE,cu,hu)}const zm=Fp({sum_:HO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XO(ou,nu="euclidean",ru=null,lu=!1){ou=fp(ou,"x","norm");const cu=WM(ou,nu,ru);let hu=cu.shape;if(lu){const pu=Wu(ru,ou.shape);hu=j0(cu.shape,pu)}return Pp(cu,hu)}function WM(ou,nu,ru=null){if(ou.rank===0)return vy(ou);if(ou.rank!==1&&ru===null)return WM(Pp(ou,[-1]),nu,ru);if(ou.rank===1||typeof ru=="number"||Array.isArray(ru)&&ru.length===1){if(nu===1)return zm(vy(ou),ru);if(nu===1/0)return vx(vy(ou),ru);if(nu===-1/0)return OE(vy(ou),ru);if(nu==="euclidean"||nu===2)return wy(zm(Z1(vy(ou),A0(2,"int32")),ru));throw new Error(`Error in norm: invalid ord value: ${nu}`)}if(Array.isArray(ru)&&ru.length===2){if(nu===1)return vx(zm(vy(ou),ru[0]),ru[1]-1);if(nu===1/0)return vx(zm(vy(ou),ru[1]),ru[0]);if(nu===-1/0)return OE(zm(vy(ou),ru[1]),ru[0]);if(nu==="fro"||nu==="euclidean")return wy(zm(k0(ou),ru));throw new Error(`Error in norm: invalid ord value: ${nu}`)}throw new Error(`Error in norm: invalid axis: ${ru}`)}const UE=Fp({norm_:XO});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QO(ou,nu=null,ru=!1){return UE(ou,"euclidean",nu,ru)}const KO=Fp({euclideanNorm_:QO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZO(ou){const nu={x:fp(ou,"x","exp")};return Tp.runKernel(Zm,nu)}const Gx=Fp({exp_:ZO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jO(ou,nu=0){const ru=fp(ou,"x","expandDims","string_or_numeric");vu(nu<=ru.rank,()=>"Axis must be <= rank of the tensor");const lu={input:ru},cu={dim:nu};return Tp.runKernel(Vm,lu,cu)}const Ly=Fp({expandDims_:jO});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YO(ou){const nu={x:fp(ou,"x","expm1")};return Tp.runKernel(r0,nu)}const qO=Fp({expm1_:YO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JO(ou,nu){const ru=fp(ou,"x","tile","string_or_numeric");vu(ru.rank===nu.length,()=>`Error in transpose: rank of input ${ru.rank} must match length of reps ${nu}.`);const lu={x:ru},cu={reps:nu};return Tp.runKernel(ZC,lu,cu)}const Cx=Fp({tile_:JO});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eU(ou,nu,ru,lu="float32"){nu==null&&(nu=ou);const cu=t0([ou,nu],lu),hu=ou<=nu?ou:nu;for(let mu=0;mu<hu;++mu)cu.set(1,mu,mu);const pu=Pp(cu.toTensor(),[ou,nu]);if(ru==null)return pu;if(ru.length===1)return Cx(Ly(pu,0),[ru[0],1,1]);if(ru.length===2)return Cx(Ly(Ly(pu,0),0),[ru[0],ru[1],1,1]);if(ru.length===3)return Cx(Ly(Ly(Ly(pu,0),0),0),[ru[0],ru[1],ru[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${ru.length}D.`)}const HM=Fp({eye_:eU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tU(ou){const nu={x:fp(ou,"x","floor","float32")};return Tp.runKernel(s0,nu)}const $E=Fp({floor_:tU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nU(ou,nu,ru=0,lu=0){const cu=fp(ou,"x","gather"),hu=fp(nu,"indices","gather","int32"),pu={x:cu,indices:hu},mu={axis:ru,batchDims:lu};return Tp.runKernel(Nx,pu,mu)}const XS=Fp({gather_:nU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iU(ou,nu){let ru=fp(ou,"a","greater","string_or_numeric"),lu=fp(nu,"b","greater","string_or_numeric");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(cy,cu)}const Yy=Fp({greater_:iU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rU(ou,nu){let ru=fp(ou,"a","greaterEqual","string_or_numeric"),lu=fp(nu,"b","greaterEqual","string_or_numeric");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(yy,cu)}const a1=Fp({greaterEqual_:rU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sU(ou){const nu={input:fp(ou,"input","imag")};return Tp.runKernel(m0,nu)}const QS=Fp({imag_:sU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oU(ou){const nu={x:fp(ou,"x","isFinite")};return Tp.runKernel(V0,nu)}const aU=Fp({isFinite_:oU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lU(ou){const nu={x:fp(ou,"x","isInf")};return Tp.runKernel(Py,nu)}const cU=Fp({isInf_:lU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uU(ou){const nu={x:fp(ou,"x","isNaN")};return Tp.runKernel(_0,nu)}const hU=Fp({isNaN_:uU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dU(ou,nu=.2){const ru={x:fp(ou,"x","leakyRelu")},lu={alpha:nu};return Tp.runKernel(Ax,ru,lu)}const KS=Fp({leakyRelu_:dU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pU(ou,nu){let ru=fp(ou,"a","less","string_or_numeric"),lu=fp(nu,"b","less","string_or_numeric");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(yx,cu)}const VE=Fp({less_:pU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fU(ou,nu){let ru=fp(ou,"a","lessEqual","string_or_numeric"),lu=fp(nu,"b","lessEqual","string_or_numeric");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(Xv,cu)}const j1=Fp({lessEqual_:fU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mU(ou,nu=5,ru=1,lu=1,cu=.5){const hu=fp(ou,"x","localResponseNormalization");vu(hu.rank===4||hu.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${hu.rank}.`),vu(Bu(nu),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${nu}.`);let pu=hu,mu=!1;hu.rank===3&&(mu=!0,pu=Pp(hu,[1,hu.shape[0],hu.shape[1],hu.shape[2]]));const Au={x:pu},bu={depthRadius:nu,bias:ru,alpha:lu,beta:cu},Cu=Tp.runKernel(eE,Au,bu);return mu?Pp(Cu,[Cu.shape[1],Cu.shape[2],Cu.shape[3]]):Cu}const gU=Fp({localResponseNormalization_:mU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AU(ou){const nu={x:fp(ou,"x","log","float32")};return Tp.runKernel(IC,nu)}const Ox=Fp({log_:AU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yU(ou){const nu={x:fp(ou,"x","log1p")};return Tp.runKernel(TC,nu)}const XM=Fp({log1p_:yU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bU(ou,nu){vu(dp(ou),()=>"The f passed in variableGrads(f) must be a function"),vu(nu==null||Array.isArray(nu)&&nu.every(bu=>bu instanceof DE),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const ru=nu!=null;if(!ru){nu=[];for(const bu in Tp.registeredVariables)nu.push(Tp.registeredVariables[bu])}const lu=ru?nu.filter(bu=>!bu.trainable):null,cu=nu.length;nu=nu.filter(bu=>bu.trainable),vu(nu.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${cu} variables is trainable.`);const hu=!0,{value:pu,grads:mu}=Tp.gradients(ou,nu,null,hu);vu(mu.some(bu=>bu!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),vu(pu.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${pu.rank} tensor`);const Au={};return nu.forEach((bu,Cu)=>{mu[Cu]!=null&&(Au[bu.name]=mu[Cu])}),lu!=null&&lu.forEach(bu=>Au[bu.name]=null),{value:pu,grads:Au}}function Y1(ou){return Tp.customGrad(ou)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xU(ou){const nu={x:fp(ou,"x","neg")};return Tp.runKernel(aE,nu)}const X0=Fp({neg_:xU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vU(ou){const nu={x:fp(ou,"x","softplus")};return Tp.runKernel(zC,nu)}const lw=Fp({softplus_:vU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CU(ou){const nu=fp(ou,"x","logSigmoid");return Y1(ru=>({value:X0(lw(X0(ru))),gradFunc:lu=>_p(lu,Q1(X0(ru)))}))(nu)}const wU=Fp({logSigmoid_:CU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EU(ou,nu){let ru=fp(ou,"a","sub"),lu=fp(nu,"b","sub");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(XC,cu)}const Qm=Fp({sub_:EU});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SU(ou,nu=-1){const ru=fp(ou,"logits","logSoftmax");if(nu===-1&&(nu=ru.rank-1),nu!==ru.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${ru.rank} and axis was ${nu}`);return Y1((lu,cu)=>{const hu=vx(lu,nu,!0),pu=Qm(lu,hu),mu=Qm(km(pu,"float32"),Ox(zm(Gx(pu),nu,!0)));return cu([mu]),{value:mu,gradFunc:(Au,bu)=>{const[Cu]=bu,wu=!0,Eu=Gx(Cu);return Qm(Au,_p(zm(Au,nu,wu),Eu))}}})(ru)}const QM=Fp({logSoftmax_:SU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IU(ou,nu=null,ru=!1){const lu=fp(ou,"x","logSumExp"),cu=Wu(nu,lu.shape),hu=vx(lu,cu,!0),pu=Qm(lu,hu),mu=Gx(pu),Au=zm(mu,cu),bu=Ox(Au),Cu=Am(Pp(hu,bu.shape),bu);if(ru){const wu=j0(Cu.shape,cu);return Pp(Cu,wu)}return Cu}const KM=Fp({logSumExp_:IU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TU(ou,nu){const ru=fp(ou,"a","logicalAnd","bool"),lu=fp(nu,"b","logicalAnd","bool");_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(Yw,cu)}const iv=Fp({logicalAnd_:TU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _U(ou){const nu={x:fp(ou,"x","logicalNot","bool")};return Tp.runKernel(qw,nu)}const ZS=Fp({logicalNot_:_U});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MU(ou,nu){const ru=fp(ou,"a","logicalOr","bool"),lu=fp(nu,"b","logicalOr","bool");_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(Jw,cu)}const ZM=Fp({logicalOr_:MU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RU(ou,nu){const ru=fp(ou,"a","logicalXor","bool"),lu=fp(nu,"b","logicalXor","bool");return _g(ru.shape,lu.shape),iv(ZM(ou,nu),ZS(iv(ou,nu)))}const kU=Fp({logicalXor_:RU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BU(ou,nu,ru,lu,cu){const hu=fp(ou,"x","maxPool"),pu=1;let mu=hu,Au=!1;hu.rank===3&&(Au=!0,mu=Pp(hu,[1,hu.shape[0],hu.shape[1],hu.shape[2]])),vu(mu.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${mu.rank}.`),vu(gy(ru,pu),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${ru} and dilations '${pu}'`),ky("maxPool",lu,cu);const bu={x:mu},Cu={filterSize:nu,strides:ru,pad:lu,dimRoundingMode:cu},wu=Tp.runKernel(nE,bu,Cu);return Au?Pp(wu,[wu.shape[1],wu.shape[2],wu.shape[3]]):wu}const jS=Fp({maxPool_:BU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LU(ou,nu=[1,1,1],ru,lu,cu,hu="NDHWC"){const pu=fp(ou,"x","maxPool3d");let mu=pu,Au=!1;pu.rank===4&&(Au=!0,mu=Pp(pu,[1,pu.shape[0],pu.shape[1],pu.shape[2],pu.shape[3]])),vu(mu.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${mu.rank}.`),vu(hu==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${hu}`),ky("maxPool3d",lu,cu);const bu={x:mu},Cu={filterSize:nu,strides:ru,pad:lu,dimRoundingMode:cu,dataFormat:hu},wu=Tp.runKernel(iE,bu,Cu);return Au?Pp(wu,[wu.shape[1],wu.shape[2],wu.shape[3],wu.shape[4]]):wu}const NU=Fp({maxPool3d_:LU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DU(ou,nu){let ru=fp(ou,"a","maximum"),lu=fp(nu,"b","maximum");[ru,lu]=W0(ru,lu),ru.dtype==="bool"&&(ru=km(ru,"int32"),lu=km(lu,"int32")),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(_C,cu)}const Sv=Fp({maximum_:DU});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FU(ou,nu=null,ru=!1){const lu={x:fp(ou,"x","mean")},cu={axis:nu,keepDims:ru};return Tp.runKernel(rE,lu,cu)}const Y0=Fp({mean_:FU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ay(ou,nu="float32"){if(nm(ou),nu==="complex64"){const lu=ay(ou,"float32"),cu=ay(ou,"float32");return z1(lu,cu)}const ru=kp(Mu(ou),nu);return Tp.makeTensor(ru,ou,nu)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Iv(ou,nu="float32"){if(nm(ou),nu==="complex64"){const lu=Iv(ou,"float32"),cu=ay(ou,"float32");return z1(lu,cu)}const ru=bp(Mu(ou),nu);return Tp.makeTensor(ru,ou,nu)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PU(ou,nu){let ru=fp(ou,"a","minimum"),lu=fp(nu,"b","minimum");[ru,lu]=W0(ru,lu),ru.dtype==="bool"&&(ru=km(ru,"int32"),lu=km(lu,"int32")),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(MC,cu)}const cw=Fp({minimum_:PU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GU(ou,nu,ru){vu(ru==="reflect"||ru==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${ru}.`);const lu=fp(ou,"x","mirrorPad");if(lu.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");vu(nu.length===lu.rank,()=>`Padding doesn't match input. Must be ${lu.rank}. Got ${nu.length}.`);const cu=ru==="reflect"?1:0;for(let mu=0;mu<lu.rank;mu++)vu(nu[mu].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(nu[mu][0]>=0&&nu[mu][0]<=lu.shape[mu]-cu&&nu[mu][1]>=0&&nu[mu][1]<=lu.shape[mu]-cu,()=>`Padding in dimension ${mu} cannot be greater than or equal to ${lu.shape[mu]-cu} or less than 0 for input of shape ${lu.shape}`);const hu={paddings:nu,mode:ru},pu={x:lu};return Tp.runKernel(oE,pu,hu)}const OU=Fp({mirrorPad_:GU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UU(ou,nu){let ru=fp(ou,"a","mod"),lu=fp(nu,"b","mod");[ru,lu]=W0(ru,lu);const cu={a:ru,b:lu};return Tp.runKernel(RC,cu)}const $U=Fp({mod_:UU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VU(ou,nu=null,ru=!1){ou=fp(ou,"x","moments");const lu=Wu(nu,ou.shape),cu=Y0(ou,lu,ru);let hu=cu.shape;ru||(hu=j0(cu.shape,lu));const pu=k0(Qm(km(ou,"float32"),Pp(cu,hu))),mu=Y0(pu,lu,ru);return{mean:cu,variance:mu}}const YS=Fp({moments_:VU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zU(ou,nu){let ru=fp(ou,"a","notEqual","string_or_numeric"),lu=fp(nu,"b","notEqual","string_or_numeric");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu};return Tp.runKernel(lE,cu)}const zE=Fp({notEqual_:zU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WU(ou,nu,ru=1,lu=0,cu="int32"){if(nu<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${nu}`);const hu={indices:fp(ou,"indices","oneHot","int32")},pu={dtype:cu,depth:nu,onValue:ru,offValue:lu};return Tp.runKernel(uE,hu,pu)}const jM=Fp({oneHot_:WU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HU(ou){const nu={x:fp(ou,"x","onesLike")};return Tp.runKernel(cE,nu)}const ax=Fp({onesLike_:HU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XU(ou,nu,ru=0){const lu=fp(ou,"x","pad");if(lu.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const cu={paddings:nu,constantValue:ru},hu={x:lu};return Tp.runKernel(dE,hu,cu)}const qS=Fp({pad_:XU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QU(ou,nu,ru){const lu=fp(ou,"x","spaceToBatchND");vu(lu.rank>=1+nu.length,()=>`input rank ${lu.rank} should be > than [blockShape] ${nu.length}`),vu(ru.length===nu.length,()=>`paddings.shape[0] ${ru.length} must be equal to [blockShape] ${nu.length}`),vu(lu.shape.reduce((pu,mu,Au)=>Au>0&&Au<=nu.length?pu&&(mu+ru[Au-1][0]+ru[Au-1][1])%nu[Au-1]===0:pu,!0),()=>`input spatial dimensions ${lu.shape.slice(1)} with paddings ${ru.toString()} must be divisible by blockShapes ${nu.toString()}`);const cu={x:lu},hu={blockShape:nu,paddings:ru};return Tp.runKernel(CE,cu,hu)}const JS=Fp({spaceToBatchND_:QU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KU(ou,nu,ru,lu,cu,hu,pu){cu==null&&(cu=[1,1]),hu==null&&(hu=1),lu===0&&(lu="valid");const mu=fp(ou,"x","maxPool");let Au=mu,bu=!1;mu.rank===3&&(bu=!0,Au=Pp(mu,[1,mu.shape[0],mu.shape[1],mu.shape[2]])),vu(gy(hu,cu),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${hu} and dilations '${cu}'`);const Cu=ox(Au.shape,nu,hu,cu,lu),wu=[Cu.dilationHeight,Cu.dilationWidth];let Eu;lu==="same"?Eu=jU([Cu.filterHeight,Cu.filterWidth],wu):Eu=[[0,0],[0,0]];const Tu=wu[0]===1&&wu[1]===1,[Ru,Nu]=ZU([Cu.inHeight,Cu.inWidth],wu,Eu),Pu=Tu?lu:"valid",Fu=Tu?Au:JS(Au,wu,Ru),Gu=(ru==="avg"?()=>GS(Fu,nu,hu,Pu,pu):()=>jS(Fu,nu,hu,Pu,pu))(),Xu=Tu?Gu:US(Gu,wu,Nu);return bu?Pp(Xu,[Xu.shape[1],Xu.shape[2],Xu.shape[3]]):Xu}function ZU(ou,nu,ru){const lu=ru.map(Cu=>Cu[0]),cu=ru.map(Cu=>Cu[1]),hu=ou.concat(lu,cu),pu=nu.map((Cu,wu)=>(Cu-hu[wu]%Cu)%Cu),mu=cu.map((Cu,wu)=>Cu+pu[wu]),Au=nu.map((Cu,wu)=>[lu[wu],mu[wu]]),bu=nu.map((Cu,wu)=>[0,pu[wu]]);return[Au,bu]}function jU(ou,nu){const ru=ou.map((hu,pu)=>hu+(hu-1)*(nu[pu]-1)).map(hu=>hu-1),lu=ru.map(hu=>Math.floor(hu/2)),cu=ru.map((hu,pu)=>hu-lu[pu]);return ru.map((hu,pu)=>[lu[pu],cu[pu]])}const YU=Fp({pool_:KU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qU(ou,nu){const ru=fp(ou,"x","prelu"),lu=fp(nu,"alpha","prelu"),cu={x:ru,alpha:lu};return Tp.runKernel(pE,cu)}const eI=Fp({prelu_:qU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JU(ou,nu=null,ru=!1){let lu=fp(ou,"x","prod");lu.dtype==="bool"&&(lu=km(lu,"int32"));const cu={x:lu},hu={axis:nu,keepDims:ru};return Tp.runKernel(fE,cu,hu)}const e$=Fp({prod_:JU});var YM={exports:{}};(function(ou){(function(nu,ru,lu){function cu(Au){var bu=this,Cu=mu();bu.next=function(){var wu=2091639*bu.s0+bu.c*23283064365386963e-26;return bu.s0=bu.s1,bu.s1=bu.s2,bu.s2=wu-(bu.c=wu|0)},bu.c=1,bu.s0=Cu(" "),bu.s1=Cu(" "),bu.s2=Cu(" "),bu.s0-=Cu(Au),bu.s0<0&&(bu.s0+=1),bu.s1-=Cu(Au),bu.s1<0&&(bu.s1+=1),bu.s2-=Cu(Au),bu.s2<0&&(bu.s2+=1),Cu=null}function hu(Au,bu){return bu.c=Au.c,bu.s0=Au.s0,bu.s1=Au.s1,bu.s2=Au.s2,bu}function pu(Au,bu){var Cu=new cu(Au),wu=bu&&bu.state,Eu=Cu.next;return Eu.int32=function(){return Cu.next()*4294967296|0},Eu.double=function(){return Eu()+(Eu()*2097152|0)*11102230246251565e-32},Eu.quick=Eu,wu&&(typeof wu=="object"&&hu(wu,Cu),Eu.state=function(){return hu(Cu,{})}),Eu}function mu(){var Au=4022871197,bu=function(Cu){Cu=String(Cu);for(var wu=0;wu<Cu.length;wu++){Au+=Cu.charCodeAt(wu);var Eu=.02519603282416938*Au;Au=Eu>>>0,Eu-=Au,Eu*=Au,Au=Eu>>>0,Eu-=Au,Au+=Eu*4294967296}return(Au>>>0)*23283064365386963e-26};return bu}ru&&ru.exports?ru.exports=pu:this.alea=pu})(Qv,ou)})(YM);var t$=YM.exports,qM={exports:{}};(function(ou){(function(nu,ru,lu){function cu(mu){var Au=this,bu="";Au.x=0,Au.y=0,Au.z=0,Au.w=0,Au.next=function(){var wu=Au.x^Au.x<<11;return Au.x=Au.y,Au.y=Au.z,Au.z=Au.w,Au.w^=Au.w>>>19^wu^wu>>>8},mu===(mu|0)?Au.x=mu:bu+=mu;for(var Cu=0;Cu<bu.length+64;Cu++)Au.x^=bu.charCodeAt(Cu)|0,Au.next()}function hu(mu,Au){return Au.x=mu.x,Au.y=mu.y,Au.z=mu.z,Au.w=mu.w,Au}function pu(mu,Au){var bu=new cu(mu),Cu=Au&&Au.state,wu=function(){return(bu.next()>>>0)/4294967296};return wu.double=function(){do var Eu=bu.next()>>>11,Tu=(bu.next()>>>0)/4294967296,Ru=(Eu+Tu)/(1<<21);while(Ru===0);return Ru},wu.int32=bu.next,wu.quick=wu,Cu&&(typeof Cu=="object"&&hu(Cu,bu),wu.state=function(){return hu(bu,{})}),wu}ru&&ru.exports?ru.exports=pu:this.xor128=pu})(Qv,ou)})(qM);var n$=qM.exports,JM={exports:{}};(function(ou){(function(nu,ru,lu){function cu(mu){var Au=this,bu="";Au.next=function(){var wu=Au.x^Au.x>>>2;return Au.x=Au.y,Au.y=Au.z,Au.z=Au.w,Au.w=Au.v,(Au.d=Au.d+362437|0)+(Au.v=Au.v^Au.v<<4^(wu^wu<<1))|0},Au.x=0,Au.y=0,Au.z=0,Au.w=0,Au.v=0,mu===(mu|0)?Au.x=mu:bu+=mu;for(var Cu=0;Cu<bu.length+64;Cu++)Au.x^=bu.charCodeAt(Cu)|0,Cu==bu.length&&(Au.d=Au.x<<10^Au.x>>>4),Au.next()}function hu(mu,Au){return Au.x=mu.x,Au.y=mu.y,Au.z=mu.z,Au.w=mu.w,Au.v=mu.v,Au.d=mu.d,Au}function pu(mu,Au){var bu=new cu(mu),Cu=Au&&Au.state,wu=function(){return(bu.next()>>>0)/4294967296};return wu.double=function(){do var Eu=bu.next()>>>11,Tu=(bu.next()>>>0)/4294967296,Ru=(Eu+Tu)/(1<<21);while(Ru===0);return Ru},wu.int32=bu.next,wu.quick=wu,Cu&&(typeof Cu=="object"&&hu(Cu,bu),wu.state=function(){return hu(bu,{})}),wu}ru&&ru.exports?ru.exports=pu:this.xorwow=pu})(Qv,ou)})(JM);var i$=JM.exports,eR={exports:{}};(function(ou){(function(nu,ru,lu){function cu(mu){var Au=this;Au.next=function(){var Cu=Au.x,wu=Au.i,Eu,Tu;return Eu=Cu[wu],Eu^=Eu>>>7,Tu=Eu^Eu<<24,Eu=Cu[wu+1&7],Tu^=Eu^Eu>>>10,Eu=Cu[wu+3&7],Tu^=Eu^Eu>>>3,Eu=Cu[wu+4&7],Tu^=Eu^Eu<<7,Eu=Cu[wu+7&7],Eu=Eu^Eu<<13,Tu^=Eu^Eu<<9,Cu[wu]=Tu,Au.i=wu+1&7,Tu};function bu(Cu,wu){var Eu,Tu=[];if(wu===(wu|0))Tu[0]=wu;else for(wu=""+wu,Eu=0;Eu<wu.length;++Eu)Tu[Eu&7]=Tu[Eu&7]<<15^wu.charCodeAt(Eu)+Tu[Eu+1&7]<<13;for(;Tu.length<8;)Tu.push(0);for(Eu=0;Eu<8&&Tu[Eu]===0;++Eu);for(Eu==8?Tu[7]=-1:Tu[Eu],Cu.x=Tu,Cu.i=0,Eu=256;Eu>0;--Eu)Cu.next()}bu(Au,mu)}function hu(mu,Au){return Au.x=mu.x.slice(),Au.i=mu.i,Au}function pu(mu,Au){mu==null&&(mu=+new Date);var bu=new cu(mu),Cu=Au&&Au.state,wu=function(){return(bu.next()>>>0)/4294967296};return wu.double=function(){do var Eu=bu.next()>>>11,Tu=(bu.next()>>>0)/4294967296,Ru=(Eu+Tu)/(1<<21);while(Ru===0);return Ru},wu.int32=bu.next,wu.quick=wu,Cu&&(Cu.x&&hu(Cu,bu),wu.state=function(){return hu(bu,{})}),wu}ru&&ru.exports?ru.exports=pu:this.xorshift7=pu})(Qv,ou)})(eR);var r$=eR.exports,tR={exports:{}};(function(ou){(function(nu,ru,lu){function cu(mu){var Au=this;Au.next=function(){var Cu=Au.w,wu=Au.X,Eu=Au.i,Tu,Ru;return Au.w=Cu=Cu+1640531527|0,Ru=wu[Eu+34&127],Tu=wu[Eu=Eu+1&127],Ru^=Ru<<13,Tu^=Tu<<17,Ru^=Ru>>>15,Tu^=Tu>>>12,Ru=wu[Eu]=Ru^Tu,Au.i=Eu,Ru+(Cu^Cu>>>16)|0};function bu(Cu,wu){var Eu,Tu,Ru,Nu,Pu,Fu=[],Gu=128;for(wu===(wu|0)?(Tu=wu,wu=null):(wu=wu+"\0",Tu=0,Gu=Math.max(Gu,wu.length)),Ru=0,Nu=-32;Nu<Gu;++Nu)wu&&(Tu^=wu.charCodeAt((Nu+32)%wu.length)),Nu===0&&(Pu=Tu),Tu^=Tu<<10,Tu^=Tu>>>15,Tu^=Tu<<4,Tu^=Tu>>>13,Nu>=0&&(Pu=Pu+1640531527|0,Eu=Fu[Nu&127]^=Tu+Pu,Ru=Eu==0?Ru+1:0);for(Ru>=128&&(Fu[(wu&&wu.length||0)&127]=-1),Ru=127,Nu=4*128;Nu>0;--Nu)Tu=Fu[Ru+34&127],Eu=Fu[Ru=Ru+1&127],Tu^=Tu<<13,Eu^=Eu<<17,Tu^=Tu>>>15,Eu^=Eu>>>12,Fu[Ru]=Tu^Eu;Cu.w=Pu,Cu.X=Fu,Cu.i=Ru}bu(Au,mu)}function hu(mu,Au){return Au.i=mu.i,Au.w=mu.w,Au.X=mu.X.slice(),Au}function pu(mu,Au){mu==null&&(mu=+new Date);var bu=new cu(mu),Cu=Au&&Au.state,wu=function(){return(bu.next()>>>0)/4294967296};return wu.double=function(){do var Eu=bu.next()>>>11,Tu=(bu.next()>>>0)/4294967296,Ru=(Eu+Tu)/(1<<21);while(Ru===0);return Ru},wu.int32=bu.next,wu.quick=wu,Cu&&(Cu.X&&hu(Cu,bu),wu.state=function(){return hu(bu,{})}),wu}ru&&ru.exports?ru.exports=pu:this.xor4096=pu})(Qv,ou)})(tR);var s$=tR.exports,nR={exports:{}};(function(ou){(function(nu,ru,lu){function cu(mu){var Au=this,bu="";Au.next=function(){var wu=Au.b,Eu=Au.c,Tu=Au.d,Ru=Au.a;return wu=wu<<25^wu>>>7^Eu,Eu=Eu-Tu|0,Tu=Tu<<24^Tu>>>8^Ru,Ru=Ru-wu|0,Au.b=wu=wu<<20^wu>>>12^Eu,Au.c=Eu=Eu-Tu|0,Au.d=Tu<<16^Eu>>>16^Ru,Au.a=Ru-wu|0},Au.a=0,Au.b=0,Au.c=-1640531527,Au.d=1367130551,mu===Math.floor(mu)?(Au.a=mu/4294967296|0,Au.b=mu|0):bu+=mu;for(var Cu=0;Cu<bu.length+20;Cu++)Au.b^=bu.charCodeAt(Cu)|0,Au.next()}function hu(mu,Au){return Au.a=mu.a,Au.b=mu.b,Au.c=mu.c,Au.d=mu.d,Au}function pu(mu,Au){var bu=new cu(mu),Cu=Au&&Au.state,wu=function(){return(bu.next()>>>0)/4294967296};return wu.double=function(){do var Eu=bu.next()>>>11,Tu=(bu.next()>>>0)/4294967296,Ru=(Eu+Tu)/(1<<21);while(Ru===0);return Ru},wu.int32=bu.next,wu.quick=wu,Cu&&(typeof Cu=="object"&&hu(Cu,bu),wu.state=function(){return hu(bu,{})}),wu}ru&&ru.exports?ru.exports=pu:this.tychei=pu})(Qv,ou)})(nR);var o$=nR.exports,iR={exports:{}};const a$=uP(Object.freeze(Object.defineProperty({__proto__:null,default:{}},Symbol.toStringTag,{value:"Module"})));(function(ou){(function(nu,ru,lu){var cu=256,hu=6,pu=52,mu="random",Au=lu.pow(cu,hu),bu=lu.pow(2,pu),Cu=bu*2,wu=cu-1,Eu;function Tu(Qu,Ju,ip){var rp=[];Ju=Ju==!0?{entropy:!0}:Ju||{};var op=Fu(Pu(Ju.entropy?[Qu,Xu(ru)]:Qu??Gu(),3),rp),hp=new Ru(rp),Ap=function(){for(var Up=hp.g(hu),Vp=Au,zp=0;Up<bu;)Up=(Up+zp)*cu,Vp*=cu,zp=hp.g(1);for(;Up>=Cu;)Up/=2,Vp/=2,zp>>>=1;return(Up+zp)/Vp};return Ap.int32=function(){return hp.g(4)|0},Ap.quick=function(){return hp.g(4)/4294967296},Ap.double=Ap,Fu(Xu(hp.S),ru),(Ju.pass||ip||function(Up,Vp,zp,qp){return qp&&(qp.S&&Nu(qp,hp),Up.state=function(){return Nu(hp,{})}),zp?(lu[mu]=Up,Vp):Up})(Ap,op,"global"in Ju?Ju.global:this==lu,Ju.state)}function Ru(Qu){var Ju,ip=Qu.length,rp=this,op=0,hp=rp.i=rp.j=0,Ap=rp.S=[];for(ip||(Qu=[ip++]);op<cu;)Ap[op]=op++;for(op=0;op<cu;op++)Ap[op]=Ap[hp=wu&hp+Qu[op%ip]+(Ju=Ap[op])],Ap[hp]=Ju;(rp.g=function(Up){for(var Vp,zp=0,qp=rp.i,Yp=rp.j,em=rp.S;Up--;)Vp=em[qp=wu&qp+1],zp=zp*cu+em[wu&(em[qp]=em[Yp=wu&Yp+Vp])+(em[Yp]=Vp)];return rp.i=qp,rp.j=Yp,zp})(cu)}function Nu(Qu,Ju){return Ju.i=Qu.i,Ju.j=Qu.j,Ju.S=Qu.S.slice(),Ju}function Pu(Qu,Ju){var ip=[],rp=typeof Qu,op;if(Ju&&rp=="object")for(op in Qu)try{ip.push(Pu(Qu[op],Ju-1))}catch{}return ip.length?ip:rp=="string"?Qu:Qu+"\0"}function Fu(Qu,Ju){for(var ip=Qu+"",rp,op=0;op<ip.length;)Ju[wu&op]=wu&(rp^=Ju[wu&op]*19)+ip.charCodeAt(op++);return Xu(Ju)}function Gu(){try{var Qu;return Eu&&(Qu=Eu.randomBytes)?Qu=Qu(cu):(Qu=new Uint8Array(cu),(nu.crypto||nu.msCrypto).getRandomValues(Qu)),Xu(Qu)}catch{var Ju=nu.navigator,ip=Ju&&Ju.plugins;return[+new Date,nu,ip,nu.screen,Xu(ru)]}}function Xu(Qu){return String.fromCharCode.apply(0,Qu)}if(Fu(lu.random(),ru),ou.exports){ou.exports=Tu;try{Eu=a$}catch{}}else lu["seed"+mu]=Tu})(typeof self<"u"?self:Qv,[],Math)})(iR);var l$=iR.exports,c$=t$,u$=n$,h$=i$,d$=r$,p$=s$,f$=o$,l1=l$;l1.alea=c$,l1.xor128=u$,l1.xorwow=h$,l1.xorshift7=d$,l1.xor4096=p$,l1.tychei=f$;var tI=l1;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class rR{constructor(nu,ru,lu,cu,hu){this.mean=nu,this.stdDev=ru,this.dtype=lu,this.nextVal=NaN,this.truncated=cu,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const pu=hu||Math.random();this.random=tI.alea(pu.toString())}nextValue(){if(!isNaN(this.nextVal)){const cu=this.nextVal;return this.nextVal=NaN,cu}let nu,ru,lu=!1;for(;!lu;){let cu,hu,pu;do cu=2*this.random()-1,hu=2*this.random()-1,pu=cu*cu+hu*hu;while(pu>=1||pu===0);const mu=Math.sqrt(-2*Math.log(pu)/pu);nu=this.mean+this.stdDev*cu*mu,ru=this.mean+this.stdDev*hu*mu,(!this.truncated||this.isValidTruncated(nu))&&(lu=!0)}return(!this.truncated||this.isValidTruncated(ru))&&(this.nextVal=this.convertValue(ru)),this.convertValue(nu)}convertValue(nu){return this.dtype==null||this.dtype==="float32"?nu:Math.round(nu)}isValidTruncated(nu){return nu<=this.upper&&nu>=this.lower}}class m${constructor(nu=0,ru=1,lu,cu){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=nu,this.range=ru-nu,this.dtype=lu,cu==null&&(cu=Math.random()),typeof cu=="number"&&(cu=cu.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${nu} - ${ru} <= 1 and dtype is not float`);this.random=tI.alea(cu)}convertValue(nu){return this.canReturnFloat()?nu:Math.round(nu)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g$(ou,nu=0,ru=1,lu,cu){if(nm(ou),lu!=null&&lu==="bool")throw new Error(`Unsupported data type ${lu}`);const hu=new rR(nu,ru,lu,!1,cu),pu=t0(ou,lu);for(let mu=0;mu<pu.values.length;mu++)pu.values[mu]=hu.nextValue();return pu.toTensor()}const A$=Fp({randomNormal_:g$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function y$(ou,nu=0,ru=1,lu="float32",cu){nm(ou);const hu=t0(ou,lu),pu=new m$(nu,ru,null,cu);for(let mu=0;mu<hu.values.length;mu++)hu.values[mu]=pu.nextValue();return hu.toTensor()}const uw=Fp({randomUniform_:y$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hw(ou,nu,ru=1,lu="float32"){if(ru===0)throw new Error("Cannot have a step of zero");const cu={start:ou,stop:nu,step:ru,dtype:lu};return Tp.runKernel(sS,{},cu)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b$(ou){const nu={input:fp(ou,"input","real")};return Tp.runKernel(oS,nu)}const WE=Fp({real_:b$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function x$(ou){const nu={x:fp(ou,"x","reciprocal")};return Tp.runKernel(LC,nu)}const v$=Fp({reciprocal_:x$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function C$(ou){const nu={x:fp(ou,"x","relu")};return Tp.runKernel(NC,nu)}const c1=Fp({relu_:C$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w$(ou){const nu={x:fp(ou,"x","relu6")};return Tp.runKernel(DC,nu)}const sR=Fp({relu6_:w$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function E$(ou,nu){const ru={x:fp(ou,"x","reverse")},lu={dims:nu};return Tp.runKernel(yE,ru,lu)}const u1=Fp({reverse_:E$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S$(ou){const nu={x:fp(ou,"x","round")};return Tp.runKernel(FC,nu)}const oR=Fp({round_:S$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I$(ou){const nu={x:fp(ou,"x","rsqrt","float32")};return Tp.runKernel(PC,nu)}const aR=Fp({rsqrt_:I$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function T$(ou){const nu={x:fp(ou,"x","selu")};return Tp.runKernel(GC,nu)}const lR=Fp({selu_:T$});function _$(ou,nu,ru,lu,cu,hu=[1,1],pu="NHWC"){const mu=fp(ou,"x","separableConv2d"),Au=fp(nu,"depthwiseFilter","separableConv2d"),bu=fp(ru,"pointwiseFilter","separableConv2d");let Cu=mu,wu=!1;if(mu.rank===3&&(wu=!0,Cu=Pp(mu,[1,mu.shape[0],mu.shape[1],mu.shape[2]])),pu==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");vu(Cu.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${Cu.rank}.`),vu(Au.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${Au.rank}.`),vu(bu.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${Au.rank}.`),vu(bu.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${bu.shape[0]}.`),vu(bu.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${bu.shape[1]}.`);const Eu=Au.shape[2],Tu=Au.shape[3];vu(bu.shape[2]===Eu*Tu,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${Eu*Tu}, but got ${bu.shape[2]}.`);const Ru=WS(Cu,Au,lu,cu,pu,hu),Nu=o1(Ru,bu,1,"valid",pu);return wu?Pp(Nu,[Nu.shape[1],Nu.shape[2],Nu.shape[3]]):Nu}const cR=Fp({separableConv2d_:_$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function M$(ou){const nu={x:fp(ou,"x","sign")};return Tp.runKernel($C,nu)}const R$=Fp({sign_:M$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k$(ou){const nu={x:fp(ou,"x","sin","float32")};return Tp.runKernel(OC,nu)}const uR=Fp({sin_:k$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function B$(ou){const nu={x:fp(ou,"x","sinh")};return Tp.runKernel(UC,nu)}const hR=Fp({sinh_:B$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L$(ou,nu,ru){const lu=fp(ou,"x","slice1d");return vu(lu.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${lu.rank} tensor`),E0(lu,[nu],[ru])}const nI=Fp({slice1d_:L$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N$(ou,nu,ru){const lu=fp(ou,"x","slice2d");return vu(lu.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${lu.rank} tensor`),E0(lu,nu,ru)}const dR=Fp({slice2d_:N$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function D$(ou,nu,ru){const lu=fp(ou,"x","slice3d");return vu(lu.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${lu.rank} tensor`),E0(lu,nu,ru)}const iI=Fp({slice3d_:D$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F$(ou,nu,ru){const lu=fp(ou,"x","slice4d");return vu(lu.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${lu.rank} tensor`),E0(lu,nu,ru)}const HE=Fp({slice4d_:F$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P$(ou,nu=-1){const ru=fp(ou,"logits","softmax","float32");if(nu===-1&&(nu=ru.rank-1),nu!==ru.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${ru.rank} and dim was ${nu}`);const lu={logits:ru},cu={dim:nu};return Tp.runKernel(EE,lu,cu)}const rI=Fp({softmax_:P$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function G$(ou){vu(ou.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${ou.dtype}.`);const nu={input:ou};return Tp.runKernel(h0,nu)}const pR=Fp({fft_:G$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function O$(ou){vu(ou.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${ou.dtype}.`);const nu={input:ou};return Tp.runKernel(Dx,nu)}const sI=Fp({ifft_:O$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function U$(ou){const nu=ou.shape[ou.shape.length-1],ru=ou.size/nu;let lu;if(nu<=2){const cu=Pp(ou,[ru,nu]);lu=sI(cu)}else{const cu=[ru,2*(nu-1)],hu=Pp(WE(ou),[ru,nu]),pu=Pp(QS(ou),[ru,nu]),mu=u1(E0(hu,[0,1],[ru,nu-2]),1),Au=_p(u1(E0(pu,[0,1],[ru,nu-2]),1),A0(-1)),bu=By([hu,mu],1),Cu=By([pu,Au],1),wu=Pp(z1(bu,Cu),[cu[0],cu[1]]);lu=sI(wu)}if(lu=WE(lu),ou.rank===3&&ou.shape[0]!==0){const cu=lu,hu=ou.shape[0];lu=Pp(lu,[hu,lu.shape[0]/hu,lu.shape[1]]),cu.dispose()}return lu}const $$=Fp({irfft_:U$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function V$(ou,nu,ru=0){const lu={x:fp(ou,"x","split")},cu={numOrSizeSplits:nu,axis:ru};return Tp.runKernel(wE,lu,cu)}const qy=Fp({split_:V$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function z$(ou,nu){vu(ou.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${ou.dtype}`);let ru=ou.shape[ou.shape.length-1];const lu=ou.size/ru;let cu;if(nu!=null&&nu<ru){const Ru=ou.shape.map(Pu=>0),Nu=ou.shape.map(Pu=>Pu);Nu[ou.shape.length-1]=nu,cu=E0(ou,Ru,Nu),ru=nu}else if(nu!=null&&nu>ru){const Ru=ou.shape.map(Nu=>Nu);Ru[ou.shape.length-1]=nu-ru,cu=By([ou,ay(Ru)],ou.shape.length-1),ru=nu}else cu=ou;const hu=l0(cu),pu=Pp(z1(cu,hu),[lu,ru]),mu=pR(pu),Au=Math.floor(ru/2)+1,bu=WE(mu),Cu=QS(mu),wu=qy(bu,[Au,ru-Au],bu.shape.length-1),Eu=qy(Cu,[Au,ru-Au],Cu.shape.length-1),Tu=cu.shape.slice();return Tu[cu.shape.length-1]=Au,Pp(z1(wu[0],Eu[0]),Tu)}const W$=Fp({rfft_:z$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function H$(ou,nu){let ru=fp(ou,"a","squaredDifference"),lu=fp(nu,"b","squaredDifference");[ru,lu]=W0(ru,lu),_g(ru.shape,lu.shape);const cu={a:ru,b:lu},hu={};return Tp.runKernel(HC,cu,hu)}const X$=Fp({squaredDifference_:H$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Q$(ou,nu){const ru=fp(ou,"x","squeeze","string_or_numeric");return Pp(ru,Zu(ru.shape,nu).newShape)}const dw=Fp({squeeze_:Q$});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function K$(ou,nu=0){const ru=CM(ou,"tensors","stack","string_or_numeric");vu(ru.length>=1,()=>"Pass at least one tensor to tf.stack"),ru.length>0&&vu(nu<=ru[0].rank,()=>"Axis must be <= rank of the tensor");const lu=ru,cu={axis:nu};return Tp.runKernel(hE,lu,cu)}const Ux=Fp({stack_:K$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Z$(ou,nu=0){const ru={x:fp(ou,"x","step")},lu={alpha:nu};return Tp.runKernel(jC,ru,lu)}const pw=Fp({step_:Z$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function j$(ou,nu,ru,lu,cu=0,hu=0,pu=0,mu=0,Au=0){const bu={x:fp(ou,"x","stridedSlice","string_or_numeric")},Cu={begin:nu,end:ru,strides:lu,beginMask:cu,endMask:hu,ellipsisMask:pu,newAxisMask:mu,shrinkAxisMask:Au};return Tp.runKernel(hS,bu,Cu)}const Y$=Fp({stridedSlice_:j$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function q$(ou){const nu={x:fp(ou,"x","tan","float32")};return Tp.runKernel(QC,nu)}const J$=Fp({tan_:q$});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $y(ou,nu){Iu(ou);const ru=ew(ou,nu);if(ru.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return tw(ou,null,ru,nu)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oI(ou,nu,ru){if(Iu(ou),nu!=null&&nu.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const lu=ew(ou,ru);if(lu.length!==2&&lu.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(lu.length===1&&nu==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return tw(ou,nu,lu,ru)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eV(ou,nu,ru){if(Iu(ou),nu!=null&&nu.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const lu=ew(ou,ru);if(lu.length!==3&&lu.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(lu.length===1&&nu==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return tw(ou,nu,lu,ru)}function fR(ou,nu,ru){const lu=nu.rank>1?nu.shape[nu.rank-1]:1,cu=nu.rank>1?nu.rank-1:1,hu=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${ru.shape}, indices.shape: ${nu.shape}, shape: ${ou}, sliceDim: ${lu}, and batchDim: ${cu}.`;if(ru.rank<cu)throw new Error(hu+` update.rank < ${cu}. `);if(ou.length<lu+(ru.rank-cu))throw new Error(hu+` Output shape length < ${lu+(ru.rank-cu)}`);if(ru.rank!==cu+ou.length-lu)throw new Error(hu+` update.rank != ${cu+ou.length-lu}`);for(let pu=0;pu<cu;++pu)if(ru.shape[pu]!==nu.shape[pu])throw new Error(hu+` updates.shape[${pu}] (${ru.shape[pu]}) != indices.shape[${pu}] (${nu.shape[pu]}).`);for(let pu=0;pu<ru.rank-cu;++pu)if(ru.shape[pu+cu]!==ou[pu+lu])throw new Error(hu+` updates.shape[${pu+cu}] (${ru.shape[pu+cu]}) != shape[${pu+cu}] (${ou[pu+cu]})`)}function tV(ou,nu,ru){if(nu.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${nu.rank}.`);if(ou.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${ou.rank}.`);if(nu.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${nu.dtype}`);if(ru.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${ru}`);if(ru.length===0){if(nu.size===0)throw new Error(`Indices specified for empty output. indices shape: ${nu.shape}`);if(ou.size===0)throw new Error(`Updates specified for empty output. updates shape: ${ou.shape}`)}fR(ru,nu,ou)}function h1(ou,nu,ru){const lu=nu.shape.length,cu=lu>1?nu.shape[lu-1]:1,hu=ru.length;let pu=1;for(let wu=cu;wu<hu;++wu)pu*=ru[wu];const mu=cu<1?1:cu,Au=Mu(nu.shape)/mu,bu=[...xp(ru.slice(0,cu)),1],Cu=Mu(ru);return{sliceRank:cu,numUpdates:Au,sliceSize:pu,strides:bu,outputSize:Cu}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nV(ou,nu=1,ru=!0){const lu=fp(ou,"x","topk");if(lu.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const cu=lu.shape[lu.shape.length-1];if(nu<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${nu}`);if(nu>cu)throw new Error(`'k' passed to topk() must be <= the last dimension (${cu}) but got ${nu}`);const hu={x:lu},pu={k:nu,sorted:ru},[mu,Au]=Tp.runKernel(dS,hu,pu);return{values:mu,indices:Au}}const iV=Fp({topk_:nV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rV(ou,nu=0,ru=1,lu,cu){if(nm(ou),lu!=null&&lu==="bool")throw new Error("Unsupported data type $ { dtype }");const hu=new rR(nu,ru,lu,!0,cu),pu=t0(ou,lu);for(let mu=0;mu<pu.values.length;mu++)pu.values[mu]=hu.nextValue();return pu.toTensor()}const mR=Fp({truncatedNormal_:rV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sV(ou,nu=0){const ru=fp(ou,"x","unique","string_or_numeric");vu(ru.rank>0,()=>"The input tensor must be at least 1D");const lu={x:ru},cu={axis:nu},[hu,pu]=Tp.runKernel(fS,lu,cu);return{values:hu,indices:pu}}const oV=Fp({unique_:sV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aV(ou,nu,ru){const lu=fp(ou,"x","unsortedSegmentSum"),cu=fp(nu,"segmentIds","unsortedSegmentSum","int32");vu(Bu(ru),()=>"numSegments must be of dtype int");const hu={x:lu,segmentIds:cu},pu={numSegments:ru};return Tp.runKernel(IE,hu,pu)}const gR=Fp({unsortedSegmentSum_:aV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lV(ou,nu=0){const ru=fp(ou,"x","unstack","string_or_numeric");vu(nu>=-ru.shape.length&&nu<ru.shape.length,()=>`Axis = ${nu} is not in [-${ru.shape.length}, ${ru.shape.length})`);const lu={value:ru},cu={axis:nu};return Tp.runKernel(SE,lu,cu)}const d1=Fp({unstack_:lV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cV(ou,nu=!0,ru,lu){return Tp.makeVariable(ou,nu,ru,lu)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AR(ou,nu){const ru=[];for(let hu=0;hu<nu.length;hu++)nu[hu]&&ru.push(hu);const lu=t0(ou,"int32"),cu=t0([ru.length,ou.length],"int32");for(let hu=0;hu<ru.length;hu++){const pu=lu.indexToLoc(ru[hu]),mu=hu*ou.length;cu.values.set(pu,mu)}return cu.toTensor()}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uV(ou,nu,ru){const lu=fp(ou,"x","transpose");if(nu==null&&(nu=lu.shape.map((pu,mu)=>mu).reverse()),vu(lu.rank===nu.length,()=>`Error in transpose: rank of input ${lu.rank} must match length of perm ${nu}.`),nu.forEach(pu=>{vu(pu>=0&&pu<lu.rank,()=>`All entries in 'perm' must be between 0 and ${lu.rank-1} but got ${nu}`)}),lu.rank<=1)return lu.clone();const cu={x:lu},hu={perm:nu};return lu.dtype==="complex64"?Op(()=>{let pu=WE(lu),mu=QS(lu);return pu=Tp.runKernel(G1,{x:pu},hu),mu=Tp.runKernel(G1,{x:mu},hu),ru&&(mu=X0(mu)),z1(pu,mu)}):Tp.runKernel(G1,cu,hu)}const c0=Fp({transpose_:uV});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hV(ou,nu){if(nu==null)return ou.shape.slice();if(ku(ou.shape,nu))return nu;if(ou.shape.length===nu.length){const ru=[];for(let lu=0;lu<ou.shape.length;lu++)nu[lu]==null&&ou.shape[lu]!=null?ru.push(ou.shape[lu]):ru.push(nu[lu]);return ru}return nu}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dV(ou,nu,ru,lu){const cu=fp(ou,"x","dropout");if(vu(cu.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${cu.dtype} tensor instead.`),vu(nu>=0&&nu<1,()=>`rate must be a float in the range [0, 1), but got ${nu}.`),nu===0)return ou instanceof q0?cu.clone():cu;const hu=hV(cu,ru),pu=1-nu,mu=Xm($E(Am(uw(hu,0,1,"float32",lu),pu)),pu);return _p(cu,mu)}const pV=Fp({dropout_:dV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fV(ou,nu,ru,lu,cu,hu="NHWC",pu){let mu=ou;ou.rank===3&&(mu=Pp(ou,[1,ou.shape[0],ou.shape[1],ou.shape[2]]));let Au=nu;Au.rank===3&&(Au=Pp(nu,[1,nu.shape[0],nu.shape[1],nu.shape[2]])),vu(mu.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${mu.shape}.`),vu(Au.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${Au.shape}.`),vu(ru.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${ru}.`);const bu=hu==="NHWC"?mu.shape[3]:mu.shape[1],Cu=hu==="NHWC"?Au.shape[3]:Au.shape[1];vu(bu===ru[2],()=>`Error in conv2dDerFilter: depth of input ${bu}) must match input depth in filter (${ru[2]}.`),vu(Cu===ru[3],()=>`Error in conv2dDerFilter: depth of dy (${Cu}) must match output depth for filter (${ru[3]}).`),ky("conv2dDerFilter",cu,pu);const wu={x:mu,dy:Au},Eu={strides:lu,pad:cu,dataFormat:hu,dimRoundingMode:pu,filterShape:ru};return Tp.runKernel(N1,wu,Eu)}const aI=Fp({conv2DBackpropFilter_:fV});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lI(ou,nu,ru){if(ru==null||ru==="linear")return ou;if(ru==="relu")return _p(ou,pw(nu));throw new Error(`Cannot compute gradient for fused activation ${ru}.`)}function cI(ou,nu){let ru=nu;const lu=J0(ou.shape,nu.shape);return lu.length>0&&(ru=zm(ru,lu)),Pp(ru,ou.shape)}function uI(ou,nu,ru,lu){if(nu==="linear")return ou;if(nu==="relu")return c1(ou);if(nu==="elu")return GE(ou);if(nu==="relu6")return sR(ou);if(nu==="prelu")return eI(ou,ru);if(nu==="leakyrelu")return KS(ou,lu);if(nu==="sigmoid")return Q1(ou);throw new Error(`Unknown fused activation ${nu}.`)}const hI=(ou,nu)=>!(ou>0)||nu==="linear";/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mV({x:ou,filter:nu,strides:ru,pad:lu,dataFormat:cu="NHWC",dilations:hu=[1,1],dimRoundingMode:pu,bias:mu,activation:Au="linear",preluActivationWeights:bu,leakyreluAlpha:Cu}){if(Au=Au||"linear",hI(Tp.state.gradientDepth,Au)===!1){vu(cu==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${cu} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let ip=o1(ou,nu,ru,lu,cu,hu,pu);return mu!=null&&(ip=Am(ip,mu)),uI(ip,Au,bu,Cu)}const wu=fp(ou,"x","conv2d","float32"),Eu=fp(nu,"filter","conv2d","float32");let Tu=wu,Ru=!1;wu.rank===3&&(Ru=!0,Tu=Pp(wu,[1,wu.shape[0],wu.shape[1],wu.shape[2]])),vu(Tu.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Tu.rank}.`),vu(Eu.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${Eu.rank}.`),ky("fused conv2d",lu,pu);const Nu=cu==="NHWC"?Tu.shape[3]:Tu.shape[1];vu(Eu.shape[2]===Nu,()=>`Error in conv2d: depth of input (${Nu}) must match input depth for filter ${Eu.shape[2]}.`),vu(gy(ru,hu),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${ru} and dilations '${hu}'`);const Pu=hy(Tu.shape,Eu.shape,ru,hu,lu,pu);let Fu;mu!=null&&(Fu=fp(mu,"bias","fused conv2d"),[Fu]=W0(Fu,wu),cu==="NHWC"?_g(Pu.outShape,Fu.shape):(vu(Fu.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${Fu.shape.length}.`),vu(Fu.shape.length===0||Fu.shape[0]===Pu.outChannels||Fu.shape[0]===1,()=>`Error in fused conv2d: bias shape (${Fu.shape}) is not compatible with the number of output channels (${Pu.outChannels})`)));let Gu;if(bu!=null){const ip=bu.shape;if(vu(ip.length<=1||ip.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${ip.length}.`),ip.length===1)vu(ip[0]===1||ip[0]===Pu.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${ip}) is not compatible with the number of output channels (${Pu.outChannels}).`);else if(ip.length===3)try{_g(ip,Pu.outShape)}catch{const rp=`Error in fused conv2d: PReLU activation weights (${ip}) is not compatible with the output shape of the conv2d (${Pu.outShape}).`;throw Error(rp)}Gu=fp(bu,"prelu weights","fused conv2d")}const Xu=(ip,rp)=>{vu(cu==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${cu} but only NHWC is currently supported.`);const[op,hp,Ap,Up]=rp,Vp=lI(ip,Ap,Au);vu(r1(hu),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${hu}'`);const zp=$S(hp.shape,Vp,op,ru,lu),qp=aI(hp,Vp,op.shape,ru,lu),Yp=[zp,qp];if(Up!=null){const em=cI(Up,Vp);Yp.push(em)}return Yp},Qu={x:Tu,filter:Eu,bias:Fu,preluActivationWeights:Gu},Ju={strides:ru,pad:lu,dataFormat:cu,dilations:hu,dimRoundingMode:pu,activation:Au,leakyreluAlpha:Cu};return mu==null?Y1((ip,rp,op)=>{let hp=Tp.runKernel(ME,Qu,Ju);return op([rp,ip,hp]),Ru&&(hp=Pp(hp,[hp.shape[1],hp.shape[2],hp.shape[3]])),{value:hp,gradFunc:Xu}})(Tu,Eu):Y1((ip,rp,op,hp)=>{let Ap=Tp.runKernel(ME,Qu,Ju);return hp([rp,ip,Ap,op]),Ru&&(Ap=Pp(Ap,[Ap.shape[1],Ap.shape[2],Ap.shape[3]])),{value:Ap,gradFunc:Xu}})(Tu,Eu,Fu)}const gV=Fp({fusedConv2d_:mV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AV(ou,nu,ru,lu,cu,hu=[1,1],pu){let mu=ou;ou.rank===3&&(mu=Pp(ou,[1,ou.shape[0],ou.shape[1],ou.shape[2]]));let Au=nu;Au.rank===3&&(Au=Pp(nu,[1,nu.shape[0],nu.shape[1],nu.shape[2]]));const bu={x:mu,dy:Au},Cu={strides:lu,pad:cu,dimRoundingMode:pu,dilations:hu,filterShape:ru};return Tp.runKernel(EC,bu,Cu)}const yV=Fp({depthwiseConv2dNativeBackpropFilter_:AV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bV(ou,nu,ru,lu,cu,hu=[1,1],pu){let mu=nu,Au=!1;nu.rank===3&&(Au=!0,mu=Pp(nu,[1,nu.shape[0],nu.shape[1],nu.shape[2]]));const bu={dy:mu,filter:ru},Cu={strides:lu,pad:cu,dimRoundingMode:pu,dilations:hu,inputShape:ou},wu=Tp.runKernel(SC,bu,Cu);return Au?Pp(wu,[wu.shape[1],wu.shape[2],wu.shape[3]]):wu}const xV=Fp({depthwiseConv2dNativeBackpropInput_:bV});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vV({a:ou,b:nu,transposeA:ru=!1,transposeB:lu=!1,bias:cu,activation:hu="linear",preluActivationWeights:pu,leakyreluAlpha:mu=.2}){if(hI(Tp.state.gradientDepth,hu)===!1){let Ap=g0(ou,nu,ru,lu);return cu!=null&&(Ap=Am(Ap,cu)),uI(Ap,hu,pu,mu)}let Au=fp(ou,"a","fused matMul"),bu=fp(nu,"b","fused matMul");[Au,bu]=W0(Au,bu);const Cu=ru?Au.shape[Au.rank-2]:Au.shape[Au.rank-1],wu=lu?bu.shape[bu.rank-1]:bu.shape[bu.rank-2],Eu=ru?Au.shape[Au.rank-1]:Au.shape[Au.rank-2],Tu=lu?bu.shape[bu.rank-2]:bu.shape[bu.rank-1],Ru=Au.shape.slice(0,-2),Nu=bu.shape.slice(0,-2),Pu=Mu(Ru),Fu=Mu(Nu);vu(Cu===wu,()=>`Error in fused matMul: inner shapes (${Cu}) and (${wu}) of Tensors with shapes ${Au.shape} and ${bu.shape} and transposeA=${ru} and transposeB=${lu} must match.`);const Gu=_g(Au.shape.slice(0,-2),bu.shape.slice(0,-2)).concat([Eu,Tu]),Xu=ru?Pp(Au,[Pu,Cu,Eu]):Pp(Au,[Pu,Eu,Cu]),Qu=lu?Pp(bu,[Fu,Tu,wu]):Pp(bu,[Fu,wu,Tu]);let Ju;cu!=null&&(Ju=fp(cu,"bias","fused matMul"),[Ju]=W0(Ju,Au),_g(Gu,Ju.shape));let ip;pu!=null&&(ip=fp(pu,"prelu weights","fused matMul"));const rp=(Ap,Up)=>{const[Vp,zp,qp,Yp]=Up,em=lI(Pp(Ap,qp.shape),qp,hu);let am,im;if(!ru&&!lu?(am=g0(em,zp,!1,!0),im=g0(Vp,em,!0,!1)):!ru&&lu?(am=g0(em,zp,!1,!1),im=g0(em,Vp,!0,!1)):ru&&!lu?(am=g0(zp,em,!1,!0),im=g0(Vp,em,!1,!1)):(am=g0(zp,em,!0,!0),im=g0(em,Vp,!0,!0)),cu!=null){const um=cI(Yp,em);return[am,im,um]}else return[am,im]},op={a:Xu,b:Qu,bias:Ju,preluActivationWeights:ip},hp={transposeA:ru,transposeB:lu,activation:hu,leakyreluAlpha:mu};return cu==null?Y1((Ap,Up,Vp)=>{const zp=Tp.runKernel(_E,op,hp);return Vp([Ap,Up,zp]),{value:Pp(zp,Gu),gradFunc:rp}})(Xu,Qu):Y1((Ap,Up,Vp,zp)=>{const qp=Tp.runKernel(_E,op,hp);return zp([Ap,Up,qp,Vp]),{value:Pp(qp,Gu),gradFunc:rp}})(Xu,Qu,Ju)}const yR=Fp({fusedMatMul_:vV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CV(ou,nu,ru,lu,cu="bilinear",hu=0){const pu=fp(ou,"image","cropAndResize"),mu=fp(nu,"boxes","cropAndResize","float32"),Au=fp(ru,"boxInd","cropAndResize","int32"),bu=mu.shape[0];vu(pu.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${pu.rank}.`),vu(mu.rank===2&&mu.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${bu},4] but had shape ${mu.shape}.`),vu(Au.rank===1&&Au.shape[0]===bu,()=>`Error in cropAndResize: boxInd must be have size [${bu}] but had shape ${mu.shape}.`),vu(lu.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${lu.length}.`),vu(lu[0]>=1&&lu[1]>=1,()=>`cropSize must be atleast [1,1], but was ${lu}`),vu(cu==="bilinear"||cu==="nearest",()=>`method must be bilinear or nearest, but was ${cu}`);const Cu={image:pu,boxes:mu,boxInd:Au},wu={method:cu,extrapolationValue:hu,cropSize:lu};return Tp.runKernel(F1,Cu,wu)}const wV=Fp({cropAndResize_:CV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EV(ou){const nu=fp(ou,"image","flipLeftRight","float32");vu(nu.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${nu.rank}.`);const ru={image:nu};return Tp.runKernel(N0,ru,{})}const SV=Fp({flipLeftRight_:EV});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IV(ou){const nu=fp(ou,"image","grayscaleToRGB"),ru=nu.rank-1,lu=nu.shape[ru];vu(nu.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${nu.rank}.`),vu(lu===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${lu}.`);const cu=new Array(nu.rank);return cu.fill(1,0,ru),cu[ru]=3,Cx(nu,cu)}const TV=Fp({grayscaleToRGB_:IV});/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _V(ou){const nu=fp(ou,"image","RGBToGrayscale"),ru=nu.rank-1,lu=nu.shape[ru];vu(nu.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${nu.rank}.`),vu(lu===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${lu}.`);const cu=nu.dtype,hu=km(nu,"float32"),pu=$y([.2989,.587,.114]);let mu;switch(nu.rank){case 2:mu=aw("ij,j->i",hu,pu);break;case 3:mu=aw("ijk,k->ij",hu,pu);break;case 4:mu=aw("ijkl,l->ijk",hu,pu);break;case 5:mu=aw("ijklm,m->ijkl",hu,pu);break;case 6:mu=aw("ijklmn,n->ijklm",hu,pu);break;default:throw new Error("Not a valid tensor rank.")}return mu=Ly(mu,-1),km(mu,cu)}const MV=Fp({rgbToGrayscale_:_V});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RV(ou,nu,ru=0,lu=.5){const cu=fp(ou,"image","rotateWithOffset","float32");vu(cu.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${cu.rank}.`);const hu={image:cu},pu={radians:nu,fillValue:ru,center:lu};return Tp.runKernel(gS,hu,pu)}const kV=Fp({rotateWithOffset_:RV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function q1(ou,nu,ru,lu,cu,hu){lu==null&&(lu=.5),cu==null&&(cu=Number.NEGATIVE_INFINITY),hu==null&&(hu=0);const pu=ou.shape[0];return ru=Math.min(ru,pu),vu(0<=lu&&lu<=1,()=>`iouThreshold must be in [0, 1], but was '${lu}'`),vu(ou.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${ou.rank}'`),vu(ou.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${ou.shape[1]}`),vu(nu.rank===1,()=>"scores must be a 1D tensor"),vu(nu.shape[0]===pu,()=>`scores has incompatible shape with boxes. Expected ${pu}, but was ${nu.shape[0]}`),vu(0<=hu&&hu<=1,()=>`softNmsSigma must be in [0, 1], but was '${hu}'`),{maxOutputSize:ru,iouThreshold:lu,scoreThreshold:cu,softNmsSigma:hu}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BV(ou,nu,ru,lu=.5,cu=Number.NEGATIVE_INFINITY){const hu=fp(ou,"boxes","nonMaxSuppression","float32"),pu=fp(nu,"scores","nonMaxSuppression","float32"),mu=q1(hu,pu,ru,lu,cu);ru=mu.maxOutputSize,lu=mu.iouThreshold,cu=mu.scoreThreshold;const Au={maxOutputSize:ru,iouThreshold:lu,scoreThreshold:cu};return Tp.runKernel(nS,{boxes:hu,scores:pu},Au)}const LV=Fp({nonMaxSuppression_:BV});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NV(ou,nu,ru){const lu=DV(ou,nu,ru),cu=lu<0?-(lu+1):lu;ou.splice(cu,0,nu)}function DV(ou,nu,ru){return PV(ou,nu,ru||FV)}function FV(ou,nu){return ou>nu?1:ou<nu?-1:0}function PV(ou,nu,ru){let lu=0,cu=ou.length,hu=0,pu=!1;for(;lu<cu;){hu=lu+(cu-lu>>>1);const mu=ru(nu,ou[hu]);mu>0?lu=hu+1:(cu=hu,pu=!mu)}return pu?lu:-lu-1}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dI(ou,nu,ru,lu,cu){return mI(ou,nu,ru,lu,cu,0)}function pI(ou,nu,ru,lu,cu,hu){return mI(ou,nu,ru,lu,cu,0,!1,hu,!0)}function fI(ou,nu,ru,lu,cu,hu){return mI(ou,nu,ru,lu,cu,hu,!0)}function mI(ou,nu,ru,lu,cu,hu,pu=!1,mu=!1,Au=!1){const bu=[];for(let Pu=0;Pu<nu.length;Pu++)nu[Pu]>cu&&bu.push({score:nu[Pu],boxIndex:Pu,suppressBeginIndex:0});bu.sort(bR);const Cu=hu>0?-.5/hu:0,wu=[],Eu=[];for(;wu.length<ru&&bu.length>0;){const Pu=bu.pop(),{score:Fu,boxIndex:Gu,suppressBeginIndex:Xu}=Pu;if(Fu<cu)break;let Qu=!1;for(let Ju=wu.length-1;Ju>=Xu;--Ju){const ip=GV(ou,Gu,wu[Ju]);if(ip>=lu){Qu=!0;break}if(Pu.score=Pu.score*OV(lu,Cu,ip),Pu.score<=cu)break}Pu.suppressBeginIndex=wu.length,Qu||(Pu.score===Fu?(wu.push(Gu),Eu.push(Pu.score)):Pu.score>cu&&NV(bu,Pu,bR))}const Tu=wu.length,Ru=ru-Tu;mu&&Ru>0&&(wu.push(...new Array(Ru).fill(0)),Eu.push(...new Array(Ru).fill(0)));const Nu={selectedIndices:wu};return pu&&(Nu.selectedScores=Eu),Au&&(Nu.validOutputs=Tu),Nu}function GV(ou,nu,ru){const lu=ou.subarray(nu*4,nu*4+4),cu=ou.subarray(ru*4,ru*4+4),hu=Math.min(lu[0],lu[2]),pu=Math.min(lu[1],lu[3]),mu=Math.max(lu[0],lu[2]),Au=Math.max(lu[1],lu[3]),bu=Math.min(cu[0],cu[2]),Cu=Math.min(cu[1],cu[3]),wu=Math.max(cu[0],cu[2]),Eu=Math.max(cu[1],cu[3]),Tu=(mu-hu)*(Au-pu),Ru=(wu-bu)*(Eu-Cu);if(Tu<=0||Ru<=0)return 0;const Nu=Math.max(hu,bu),Pu=Math.max(pu,Cu),Fu=Math.min(mu,wu),Gu=Math.min(Au,Eu),Xu=Math.max(Fu-Nu,0)*Math.max(Gu-Pu,0);return Xu/(Tu+Ru-Xu)}function OV(ou,nu,ru){const lu=Math.exp(nu*ru*ru);return ru<=ou?lu:0}function bR(ou,nu){return ou.score-nu.score||ou.score===nu.score&&nu.boxIndex-ou.boxIndex}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function UV(ou,nu,ru,lu=.5,cu=Number.NEGATIVE_INFINITY){const hu=fp(ou,"boxes","nonMaxSuppressionAsync"),pu=fp(nu,"scores","nonMaxSuppressionAsync"),mu=q1(hu,pu,ru,lu,cu);ru=mu.maxOutputSize,lu=mu.iouThreshold,cu=mu.scoreThreshold;const Au=await Promise.all([hu.data(),pu.data()]),bu=Au[0],Cu=Au[1],{selectedIndices:wu}=dI(bu,Cu,ru,lu,cu);return hu!==ou&&hu.dispose(),pu!==nu&&pu.dispose(),$y(wu,"int32")}const $V=UV;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VV(ou,nu,ru,lu=.5,cu=Number.NEGATIVE_INFINITY,hu=0){const pu=fp(ou,"boxes","nonMaxSuppression"),mu=fp(nu,"scores","nonMaxSuppression"),Au=q1(pu,mu,ru,lu,cu,hu);ru=Au.maxOutputSize,lu=Au.iouThreshold,cu=Au.scoreThreshold,hu=Au.softNmsSigma;const bu={boxes:pu,scores:mu},Cu={maxOutputSize:ru,iouThreshold:lu,scoreThreshold:cu,softNmsSigma:hu},wu=Tp.runKernel(rS,bu,Cu);return{selectedIndices:wu[0],selectedScores:wu[1]}}const zV=Fp({nonMaxSuppressionWithScore_:VV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function WV(ou,nu,ru,lu=.5,cu=Number.NEGATIVE_INFINITY,hu=0){const pu=fp(ou,"boxes","nonMaxSuppressionAsync"),mu=fp(nu,"scores","nonMaxSuppressionAsync"),Au=q1(pu,mu,ru,lu,cu,hu);ru=Au.maxOutputSize,lu=Au.iouThreshold,cu=Au.scoreThreshold,hu=Au.softNmsSigma;const bu=await Promise.all([pu.data(),mu.data()]),Cu=bu[0],wu=bu[1],{selectedIndices:Eu,selectedScores:Tu}=fI(Cu,wu,ru,lu,cu,hu);return pu!==ou&&pu.dispose(),mu!==nu&&mu.dispose(),{selectedIndices:$y(Eu,"int32"),selectedScores:$y(Tu)}}const HV=WV;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XV(ou,nu,ru,lu=.5,cu=Number.NEGATIVE_INFINITY,hu=!1){const pu=fp(ou,"boxes","nonMaxSuppression"),mu=fp(nu,"scores","nonMaxSuppression"),Au=q1(pu,mu,ru,lu,cu,null),bu=Au.maxOutputSize,Cu=Au.iouThreshold,wu=Au.scoreThreshold,Eu={boxes:pu,scores:mu},Tu={maxOutputSize:bu,iouThreshold:Cu,scoreThreshold:wu,padToMaxOutputSize:hu},Ru=Tp.runKernel(iS,Eu,Tu);return{selectedIndices:Ru[0],validOutputs:Ru[1]}}const QV=Fp({nonMaxSuppressionPadded_:XV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function KV(ou,nu,ru,lu=.5,cu=Number.NEGATIVE_INFINITY,hu=!1){const pu=fp(ou,"boxes","nonMaxSuppressionAsync"),mu=fp(nu,"scores","nonMaxSuppressionAsync"),Au=q1(pu,mu,ru,lu,cu,null),bu=Au.maxOutputSize,Cu=Au.iouThreshold,wu=Au.scoreThreshold,[Eu,Tu]=await Promise.all([pu.data(),mu.data()]),{selectedIndices:Ru,validOutputs:Nu}=pI(Eu,Tu,bu,Cu,wu,hu);return pu!==ou&&pu.dispose(),mu!==nu&&mu.dispose(),{selectedIndices:$y(Ru,"int32"),validOutputs:A0(Nu,"int32")}}const ZV=KV;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jV(ou,nu,ru=!1,lu=!1){const cu=fp(ou,"images","resizeBilinear");vu(cu.rank===3||cu.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${cu.rank}.`),vu(nu.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${nu}.`),vu(lu===!1||ru===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let hu=cu,pu=!1;cu.rank===3&&(pu=!0,hu=Pp(cu,[1,cu.shape[0],cu.shape[1],cu.shape[2]]));const mu={images:hu},Au={alignCorners:ru,halfPixelCenters:lu,size:nu},bu=Tp.runKernel(AE,mu,Au);return pu?Pp(bu,[bu.shape[1],bu.shape[2],bu.shape[3]]):bu}const xR=Fp({resizeBilinear_:jV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YV(ou,nu,ru=!1,lu=!1){const cu=fp(ou,"images","resizeNearestNeighbor");vu(cu.rank===3||cu.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${cu.rank}.`),vu(nu.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${nu}.`),vu(cu.dtype==="float32"||cu.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),vu(lu===!1||ru===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let hu=cu,pu=!1;cu.rank===3&&(pu=!0,hu=Pp(cu,[1,cu.shape[0],cu.shape[1],cu.shape[2]]));const mu={images:hu},Au={alignCorners:ru,halfPixelCenters:lu,size:nu},bu=Tp.runKernel(gE,mu,Au);return pu?Pp(bu,[bu.shape[1],bu.shape[2],bu.shape[3]]):bu}const vR=Fp({resizeNearestNeighbor_:YV});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qV(ou,nu="binary",ru=!1,lu=.5){const cu=fp(ou,"image","threshold"),hu=.2989,pu=.587,mu=.114,Au=cu.shape[0]*cu.shape[1];let bu=_p($y([lu]),255),Cu,wu,Eu,Tu;if(vu(cu.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${cu.rank}.`),vu(cu.shape[2]===3||cu.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${cu.shape[2]}.`),vu(cu.dtype==="int32"||cu.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${cu.dtype}.`),vu(nu==="otsu"||nu==="binary",()=>`Method must be binary or otsu, but was ${nu}`),cu.shape[2]===3){[Cu,wu,Eu]=qy(cu,[1,1,1],-1);const Nu=_p(Cu,hu),Pu=_p(wu,pu),Fu=_p(Eu,mu);Tu=Am(Am(Nu,Pu),Fu)}else Tu=ou;if(nu==="otsu"){const Nu=YG(km(oR(Tu),"int32"),Ky([]),256);bu=JV(Nu,Au)}const Ru=ru?j1(Tu,bu):Yy(Tu,bu);return km(_p(Ru,255),"int32")}function JV(ou,nu){let ru=$y([-1]),lu=$y([0]),cu=$y([0]),hu,pu,mu,Au,bu,Cu;for(let wu=0;wu<ou.size-1;wu++){hu=E0(ou,0,wu+1),pu=E0(ou,wu+1),bu=Xm(zm(hu),nu),Cu=Xm(zm(pu),nu);const Eu=zm(_p(hu,hw(0,hu.size)));mu=Xm(Eu,zm(hu));const Tu=PE(pu.shape,hu.size),Ru=Am(hw(0,pu.size),Tu),Nu=_p(pu,Ru);Au=Xm(zm(Nu),zm(pu));const Pu=Qm(mu,Au),Fu=Qm(mu,Au),Gu=_p(bu,Cu);cu=_p(_p(Gu,Pu),Fu);const Xu=Yy(cu,lu);lu=Cy(Xu,cu,lu),ru=Cy(Xu,$y([wu]),ru)}return ru}const ez=Fp({threshold_:qV});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tz(ou,nu,ru="nearest",lu="constant",cu=0,hu){const pu=fp(ou,"image","transform","float32"),mu=fp(nu,"transforms","transform","float32");vu(pu.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${pu.rank}.`),vu(mu.rank===2&&(mu.shape[0]===pu.shape[0]||mu.shape[0]===1)&&mu.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),vu(hu==null||hu.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${hu}.`);const Au={image:pu,transforms:mu},bu={interpolation:ru,fillMode:lu,fillValue:cu,outputShape:hu};return Tp.runKernel(pS,Au,bu)}const nz=Fp({transform_:tz});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iz(ou,nu,ru){const lu=fp(ou,"a","bandPart");vu(lu.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${lu.rank}.`);const cu=lu.shape,[hu,pu]=lu.shape.slice(-2);let mu,Au;typeof nu=="number"?(vu(nu%1===0,()=>`bandPart(): numLower must be an integer, got ${nu}.`),vu(nu<=hu,()=>`bandPart(): numLower (${nu}) must not be greater than the number of rows (${hu}).`),mu=fp(nu<0?hu:nu,"numLower","bandPart")):(vu(nu.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),mu=Cy(VE(nu,0),hu,cw(nu,hu))),typeof ru=="number"?(vu(ru%1===0,()=>`bandPart(): numUpper must be an integer, got ${ru}.`),vu(ru<=pu,()=>`bandPart(): numUpper (${ru}) must not be greater than the number of columns (${pu}).`),Au=fp(ru<0?pu:ru,"numUpper","bandPart")):(vu(ru.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),Au=Cy(VE(ru,0),pu,cw(ru,pu)));const bu=Pp(hw(0,hu,1,"int32"),[-1,1]),Cu=hw(0,pu,1,"int32"),wu=Qm(bu,Cu),Eu=iv(j1(wu,mu),a1(wu,X0(Au))),Tu=ay([hu,pu],lu.dtype);return Pp(Ux(d1(Pp(lu,[-1,hu,pu])).map(Ru=>Cy(Eu,Ru,Tu))),cu)}const rz=Fp({bandPart_:iz});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sz(ou){let nu;if(Array.isArray(ou)){nu=!1,vu(ou!=null&&ou.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const cu=ou[0].shape[0];for(let hu=1;hu<ou.length;++hu)vu(ou[hu].shape[0]===cu,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${ou[hu].shape[0]} vs. ${cu})`)}else nu=!0,ou=qy(ou,ou.shape[0],0).map(cu=>dw(cu,[0]));vu(ou.length<=ou[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${ou.length}) exceeds number of dimensions (${ou[0].shape[0]}).`);const ru=[],lu=ou;for(let cu=0;cu<ou.length;++cu)ru.push(Tp.tidy(()=>{let hu=lu[cu];if(cu>0)for(let pu=0;pu<cu;++pu){const mu=_p(zm(_p(ru[pu],hu)),ru[pu]);hu=Qm(hu,mu)}return Xm(hu,UE(hu,"euclidean"))}));return nu?Ux(ru,0):ru}const oz=Fp({gramSchmidt_:sz});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function az(ou,nu=!1){if(vu(ou.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${ou.rank}`),ou.rank===2)return CR(ou,nu);{const ru=ou.shape.slice(0,ou.shape.length-2).reduce((Au,bu)=>Au*bu),lu=d1(Pp(ou,[ru,ou.shape[ou.shape.length-2],ou.shape[ou.shape.length-1]]),0),cu=[],hu=[];lu.forEach(Au=>{const[bu,Cu]=CR(Au,nu);cu.push(bu),hu.push(Cu)});const pu=Pp(Ux(cu,0),ou.shape),mu=Pp(Ux(hu,0),ou.shape);return[pu,mu]}}function CR(ou,nu=!1){return Tp.tidy(()=>{vu(ou.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${ou.shape.length}D Tensor.`);const ru=ou.shape[0],lu=ou.shape[1];let cu=HM(ru),hu=i1(ou);const pu=oI([[1]],[1,1]);let mu=i1(pu);const Au=ru>=lu?lu:ru;for(let bu=0;bu<Au;++bu){const Cu=hu,wu=mu,Eu=cu;[mu,hu,cu]=Tp.tidy(()=>{const Tu=E0(hu,[bu,bu],[ru-bu,1]),Ru=UE(Tu),Nu=E0(hu,[bu,bu],[1,1]),Pu=Cy(Yy(Nu,0),oI([[-1]]),oI([[1]])),Fu=Qm(Nu,_p(Pu,Ru)),Gu=Xm(Tu,Fu);Gu.shape[0]===1?mu=i1(pu):mu=By([pu,E0(Gu,[1,0],[Gu.shape[0]-1,Gu.shape[1]])],0);const Xu=X0(Xm(g0(Pu,Fu),Ru)),Qu=E0(hu,[bu,0],[ru-bu,lu]),Ju=_p(Xu,mu),ip=c0(mu);if(bu===0)hu=Qm(Qu,g0(Ju,g0(ip,Qu)));else{const hp=Qm(Qu,g0(Ju,g0(ip,Qu)));hu=By([E0(hu,[0,0],[bu,lu]),hp],0)}const rp=c0(Ju),op=E0(cu,[0,bu],[ru,cu.shape[1]-bu]);if(bu===0)cu=Qm(op,g0(g0(op,mu),rp));else{const hp=Qm(op,g0(g0(op,mu),rp));cu=By([E0(cu,[0,0],[ru,bu]),hp],1)}return[mu,hu,cu]}),o0([Cu,wu,Eu])}return!nu&&ru>lu&&(cu=E0(cu,[0,0],[ru,lu]),hu=E0(hu,[0,0],[lu,lu])),[cu,hu]})}const lz=Fp({qr_:az});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rv={flipLeftRight:SV,grayscaleToRGB:TV,resizeNearestNeighbor:vR,resizeBilinear:xR,rgbToGrayscale:MV,rotateWithOffset:kV,cropAndResize:wV,nonMaxSuppression:LV,nonMaxSuppressionAsync:$V,nonMaxSuppressionWithScore:zV,nonMaxSuppressionWithScoreAsync:HV,nonMaxSuppressionPadded:QV,nonMaxSuppressionPaddedAsync:ZV,threshold:ez,transform:nz},cz={bandPart:rz,gramSchmidt:oz,qr:lz};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uz=new Map,hz=new Map;class J1{getClassName(){return this.constructor.className}static fromConfig(nu,ru){return new nu(ru)}}class lx{constructor(){this.classNameMap={}}static getMap(){return lx.instance==null&&(lx.instance=new lx),lx.instance}static register(nu){lx.getMap().classNameMap[nu.className]=[nu,nu.fromConfig]}}function hm(ou,nu,ru){vu(ou.className!=null,()=>"Class being registered does not have the static className property defined."),vu(typeof ou.className=="string",()=>"className is required to be a string, but got type "+typeof ou.className),vu(ou.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof nu>"u"&&(nu="Custom"),typeof ru>"u"&&(ru=ou.className);const lu=ru,cu=nu+">"+lu;return lx.register(ou),uz.set(cu,ou),hz.set(ou,cu),ou}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Tv extends J1{minimize(nu,ru=!1,lu){const{value:cu,grads:hu}=this.computeGradients(nu,lu);if(lu!=null){const pu=lu.map(mu=>({name:mu.name,tensor:hu[mu.name]}));this.applyGradients(pu)}else this.applyGradients(hu);return o0(hu),ru?cu:(cu.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(nu,ru){return bU(nu,ru)}dispose(){this.iterations_!=null&&o0(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:A0(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(nu){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(nu){return this.iterations_=(await nu[0].tensor.data())[0],nu.slice(1)}}Object.defineProperty(Tv,Symbol.hasInstance,{value:ou=>ou.minimize!=null&&ou.computeGradients!=null&&ou.applyGradients!=null});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wR extends Tv{static get className(){return"Adadelta"}constructor(nu,ru,lu=null){super(),this.learningRate=nu,this.rho=ru,this.epsilon=lu,this.accumulatedGrads=[],this.accumulatedUpdates=[],lu==null&&(this.epsilon=Tp.backend.epsilon())}applyGradients(nu){(Array.isArray(nu)?nu.map(ru=>ru.name):Object.keys(nu)).forEach((ru,lu)=>{const cu=Tp.registeredVariables[ru],hu=!1;this.accumulatedGrads[lu]==null&&(this.accumulatedGrads[lu]={originalName:`${ru}/accum_grad`,variable:Op(()=>l0(cu).variable(hu))}),this.accumulatedUpdates[lu]==null&&(this.accumulatedUpdates[lu]={originalName:`${ru}/accum_var`,variable:Op(()=>l0(cu).variable(hu))});const pu=Array.isArray(nu)?nu[lu].tensor:nu[ru];if(pu==null)return;const mu=this.accumulatedGrads[lu].variable,Au=this.accumulatedUpdates[lu].variable;Op(()=>{const bu=Am(_p(mu,this.rho),_p(k0(pu),1-this.rho)),Cu=_p(Xm(wy(Am(Au,this.epsilon)),wy(Am(mu,this.epsilon))),pu),wu=Am(_p(Au,this.rho),_p(k0(Cu),1-this.rho));mu.assign(bu),Au.assign(wu);const Eu=Am(_p(Cu,-this.learningRate),cu);cu.assign(Eu)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(o0(this.accumulatedGrads.map(nu=>nu.variable)),o0(this.accumulatedUpdates.map(nu=>nu.variable)))}async getWeights(){const nu=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(nu.map(ru=>({name:ru.originalName,tensor:ru.variable})))}async setWeights(nu){nu=await this.extractIterations(nu);const ru=nu.length/2,lu=!1;this.accumulatedGrads=nu.slice(0,ru).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)})),this.accumulatedUpdates=nu.slice(ru,ru*2).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(nu,ru){return new nu(ru.learningRate,ru.rho,ru.epsilon)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ER extends Tv{static get className(){return"Adagrad"}constructor(nu,ru=.1){super(),this.learningRate=nu,this.initialAccumulatorValue=ru,this.accumulatedGrads=[]}applyGradients(nu){(Array.isArray(nu)?nu.map(ru=>ru.name):Object.keys(nu)).forEach((ru,lu)=>{const cu=Tp.registeredVariables[ru];this.accumulatedGrads[lu]==null&&(this.accumulatedGrads[lu]={originalName:`${ru}/accumulator`,variable:Op(()=>PE(cu.shape,this.initialAccumulatorValue).variable(!1))});const hu=Array.isArray(nu)?nu[lu].tensor:nu[ru];if(hu==null)return;const pu=this.accumulatedGrads[lu].variable;Op(()=>{const mu=Am(pu,k0(hu));pu.assign(mu);const Au=Am(_p(Xm(hu,wy(Am(mu,Tp.backend.epsilon()))),-this.learningRate),cu);cu.assign(Au)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&o0(this.accumulatedGrads.map(nu=>nu.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(nu=>({name:nu.originalName,tensor:nu.variable})))}async setWeights(nu){nu=await this.extractIterations(nu);const ru=!1;this.accumulatedGrads=nu.map(lu=>({originalName:lu.name,variable:lu.tensor.variable(ru)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(nu,ru){return new nu(ru.learningRate,ru.initialAccumulatorValue)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class SR extends Tv{static get className(){return"Adam"}constructor(nu,ru,lu,cu=null){super(),this.learningRate=nu,this.beta1=ru,this.beta2=lu,this.epsilon=cu,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Op(()=>{this.accBeta1=A0(ru).variable(),this.accBeta2=A0(lu).variable()}),cu==null&&(this.epsilon=Tp.backend.epsilon())}applyGradients(nu){const ru=Array.isArray(nu)?nu.map(lu=>lu.name):Object.keys(nu);Op(()=>{const lu=Qm(1,this.accBeta1),cu=Qm(1,this.accBeta2);ru.forEach((hu,pu)=>{const mu=Tp.registeredVariables[hu],Au=!1;this.accumulatedFirstMoment[pu]==null&&(this.accumulatedFirstMoment[pu]={originalName:`${hu}/m`,variable:Op(()=>l0(mu).variable(Au))}),this.accumulatedSecondMoment[pu]==null&&(this.accumulatedSecondMoment[pu]={originalName:`${hu}/v`,variable:Op(()=>l0(mu).variable(Au))});const bu=Array.isArray(nu)?nu[pu].tensor:nu[hu];if(bu==null)return;const Cu=this.accumulatedFirstMoment[pu].variable,wu=this.accumulatedSecondMoment[pu].variable,Eu=Am(_p(Cu,this.beta1),_p(bu,1-this.beta1)),Tu=Am(_p(wu,this.beta2),_p(k0(bu),1-this.beta2)),Ru=Xm(Eu,lu),Nu=Xm(Tu,cu);Cu.assign(Eu),wu.assign(Tu);const Pu=Am(_p(Xm(Ru,Am(wy(Nu),this.epsilon)),-this.learningRate),mu);mu.assign(Pu)}),this.accBeta1.assign(_p(this.accBeta1,this.beta1)),this.accBeta2.assign(_p(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&o0(this.accumulatedFirstMoment.map(nu=>nu.variable)),this.accumulatedSecondMoment!=null&&o0(this.accumulatedSecondMoment.map(nu=>nu.variable))}async getWeights(){const nu=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(nu.map(ru=>({name:ru.originalName,tensor:ru.variable})))}async setWeights(nu){nu=await this.extractIterations(nu),Op(()=>{this.accBeta1.assign(Z1(this.beta1,this.iterations_+1)),this.accBeta2.assign(Z1(this.beta2,this.iterations_+1))});const ru=nu.length/2,lu=!1;this.accumulatedFirstMoment=nu.slice(0,ru).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)})),this.accumulatedSecondMoment=nu.slice(ru,ru*2).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(nu,ru){return new nu(ru.learningRate,ru.beta1,ru.beta2,ru.epsilon)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class IR extends Tv{static get className(){return"Adamax"}constructor(nu,ru,lu,cu=null,hu=0){super(),this.learningRate=nu,this.beta1=ru,this.beta2=lu,this.epsilon=cu,this.decay=hu,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Op(()=>{this.iteration=A0(0).variable(),this.accBeta1=A0(ru).variable()}),cu==null&&(this.epsilon=Tp.backend.epsilon())}applyGradients(nu){const ru=Array.isArray(nu)?nu.map(lu=>lu.name):Object.keys(nu);Op(()=>{const lu=Qm(1,this.accBeta1),cu=Xm(-this.learningRate,Am(_p(this.iteration,this.decay),1));ru.forEach((hu,pu)=>{const mu=Tp.registeredVariables[hu],Au=!1;this.accumulatedFirstMoment[pu]==null&&(this.accumulatedFirstMoment[pu]={originalName:`${hu}/m`,variable:l0(mu).variable(Au)}),this.accumulatedWeightedInfNorm[pu]==null&&(this.accumulatedWeightedInfNorm[pu]={originalName:`${hu}/v`,variable:l0(mu).variable(Au)});const bu=Array.isArray(nu)?nu[pu].tensor:nu[hu];if(bu==null)return;const Cu=this.accumulatedFirstMoment[pu].variable,wu=this.accumulatedWeightedInfNorm[pu].variable,Eu=Am(_p(Cu,this.beta1),_p(bu,1-this.beta1)),Tu=_p(wu,this.beta2),Ru=vy(bu),Nu=Sv(Tu,Ru);Cu.assign(Eu),wu.assign(Nu);const Pu=Am(_p(Xm(cu,lu),Xm(Eu,Am(Nu,this.epsilon))),mu);mu.assign(Pu)}),this.iteration.assign(Am(this.iteration,1)),this.accBeta1.assign(_p(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&o0(this.accumulatedFirstMoment.map(nu=>nu.variable)),this.accumulatedWeightedInfNorm!=null&&o0(this.accumulatedWeightedInfNorm.map(nu=>nu.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(nu){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(nu,ru){return new nu(ru.learningRate,ru.beta1,ru.beta2,ru.epsilon,ru.decay)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gI extends Tv{static get className(){return"SGD"}constructor(nu){super(),this.learningRate=nu,this.setLearningRate(nu)}applyGradients(nu){(Array.isArray(nu)?nu.map(ru=>ru.name):Object.keys(nu)).forEach((ru,lu)=>{const cu=Array.isArray(nu)?nu[lu].tensor:nu[ru];if(cu==null)return;const hu=Tp.registeredVariables[ru];Op(()=>{const pu=Am(_p(this.c,cu),hu);hu.assign(pu)})}),this.incrementIterations()}setLearningRate(nu){this.learningRate=nu,this.c!=null&&this.c.dispose(),this.c=Zy(A0(-nu))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(nu){if(nu=await this.extractIterations(nu),nu.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(nu,ru){return new nu(ru.learningRate)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class TR extends gI{static get className(){return"Momentum"}constructor(nu,ru,lu=!1){super(nu),this.learningRate=nu,this.momentum=ru,this.useNesterov=lu,this.accumulations=[],this.m=A0(this.momentum)}applyGradients(nu){(Array.isArray(nu)?nu.map(ru=>ru.name):Object.keys(nu)).forEach((ru,lu)=>{const cu=Tp.registeredVariables[ru];this.accumulations[lu]==null&&(this.accumulations[lu]={originalName:`${ru}/momentum`,variable:Op(()=>l0(cu).variable(!1))});const hu=this.accumulations[lu].variable,pu=Array.isArray(nu)?nu[lu].tensor:nu[ru];pu!=null&&Op(()=>{let mu;const Au=Am(_p(this.m,hu),pu);this.useNesterov?mu=Am(_p(this.c,Am(pu,_p(Au,this.m))),cu):mu=Am(_p(this.c,Au),cu),hu.assign(Au),cu.assign(mu)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&o0(this.accumulations.map(nu=>nu.variable))}setMomentum(nu){this.momentum=nu}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(nu=>({name:nu.originalName,tensor:nu.variable})))}async setWeights(nu){nu=await this.extractIterations(nu);const ru=!1;this.accumulations=nu.map(lu=>({originalName:lu.name,variable:lu.tensor.variable(ru)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(nu,ru){return new nu(ru.learningRate,ru.momentum,ru.useNesterov)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class _R extends Tv{static get className(){return"RMSProp"}constructor(nu,ru=.9,lu=0,cu=null,hu=!1){if(super(),this.learningRate=nu,this.decay=ru,this.momentum=lu,this.epsilon=cu,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=hu,cu==null&&(this.epsilon=Tp.backend.epsilon()),nu==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(nu){(Array.isArray(nu)?nu.map(ru=>ru.name):Object.keys(nu)).forEach((ru,lu)=>{const cu=Tp.registeredVariables[ru],hu=!1;this.accumulatedMeanSquares[lu]==null&&(this.accumulatedMeanSquares[lu]={originalName:`${ru}/rms`,variable:Op(()=>l0(cu).variable(hu))}),this.accumulatedMoments[lu]==null&&(this.accumulatedMoments[lu]={originalName:`${ru}/momentum`,variable:Op(()=>l0(cu).variable(hu))}),this.accumulatedMeanGrads[lu]==null&&this.centered&&(this.accumulatedMeanGrads[lu]={originalName:`${ru}/mg`,variable:Op(()=>l0(cu).variable(hu))});const pu=Array.isArray(nu)?nu[lu].tensor:nu[ru];if(pu==null)return;const mu=this.accumulatedMeanSquares[lu].variable,Au=this.accumulatedMoments[lu].variable;Op(()=>{const bu=Am(_p(mu,this.decay),_p(k0(pu),1-this.decay));if(this.centered){const Cu=this.accumulatedMeanGrads[lu].variable,wu=Am(_p(Cu,this.decay),_p(pu,1-this.decay)),Eu=Xm(_p(pu,this.learningRate),wy(Qm(bu,Am(k0(wu),this.epsilon)))),Tu=Am(_p(Au,this.momentum),Eu);mu.assign(bu),Cu.assign(wu),Au.assign(Tu);const Ru=Qm(cu,Tu);cu.assign(Ru)}else{const Cu=Am(_p(mu,this.decay),_p(k0(pu),1-this.decay)),wu=Am(_p(Au,this.momentum),Xm(_p(pu,this.learningRate),wy(Am(Cu,this.epsilon))));mu.assign(Cu),Au.assign(wu);const Eu=Qm(cu,wu);cu.assign(Eu)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&o0(this.accumulatedMeanSquares.map(nu=>nu.variable)),this.accumulatedMeanGrads!=null&&this.centered&&o0(this.accumulatedMeanGrads.map(nu=>nu.variable)),this.accumulatedMoments!=null&&o0(this.accumulatedMoments.map(nu=>nu.variable))}async getWeights(){const nu=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&nu.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(nu.map(ru=>({name:ru.originalName,tensor:ru.variable})))}async setWeights(nu){nu=await this.extractIterations(nu);const ru=this.centered?nu.length/3:nu.length/2,lu=!1;this.accumulatedMeanSquares=nu.slice(0,ru).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)})),this.accumulatedMoments=nu.slice(ru,ru*2).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)})),this.centered&&(this.accumulatedMeanGrads=nu.slice(ru*2,ru*3).map(cu=>({originalName:cu.name,variable:cu.tensor.variable(lu)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(nu,ru){return new nu(ru.learningRate,ru.decay,ru.momentum,ru.epsilon,ru.centered)}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dz=[wR,ER,SR,IR,TR,_R,gI];function fz(){for(const ou of dz)hm(ou)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let p1;function mz(ou,nu=3){if(nu>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(ou==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let ru=!1,lu=!1,cu=!1,hu=!1,pu=!1,mu=!1;if(ou.data instanceof Uint8Array)ru=!0;else if(typeof ImageData<"u"&&ou instanceof ImageData)lu=!0;else if(typeof HTMLVideoElement<"u"&&ou instanceof HTMLVideoElement)cu=!0;else if(typeof HTMLImageElement<"u"&&ou instanceof HTMLImageElement)hu=!0;else if(ou.getContext!=null)pu=!0;else if(typeof ImageBitmap<"u"&&ou instanceof ImageBitmap)mu=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${ou.constructor.name}`);if(yS(mS,Tp.backendName)!=null){const Eu={pixels:ou},Tu={numChannels:nu};return Tp.runKernel(mS,Eu,Tu)}const[Au,bu]=cu?[ou.videoWidth,ou.videoHeight]:[ou.width,ou.height];let Cu;if(pu)Cu=ou.getContext("2d").getImageData(0,0,Au,bu).data;else if(lu||ru)Cu=ou.data;else if(hu||cu||mu){if(p1==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")p1=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else p1=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});p1.canvas.width=Au,p1.canvas.height=bu,p1.drawImage(ou,0,0,Au,bu),Cu=p1.getImageData(0,0,Au,bu).data}let wu;if(nu===4)wu=new Int32Array(Cu);else{const Eu=Au*bu;wu=new Int32Array(Eu*nu);for(let Tu=0;Tu<Eu;Tu++)for(let Ru=0;Ru<nu;++Ru)wu[Tu*nu+Ru]=Cu[Tu*4+Ru]}return eV(wu,[bu,Au,nu],"int32")}const gz=Fp({fromPixels_:mz});function AI(ou,nu){const ru=ou.shape.length,lu=nu.shape.length;if(ru<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${ru}.`);if(lu<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${lu}.`);if(nu.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${nu.dtype}.`);if(nu.shape[lu-1]>ru)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${nu.shape[lu-1]} vs. ${ru}`);if(Mu(ou.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${ou.shape}.`);const cu=nu.shape,hu=cu[cu.length-1];let pu=1;for(let wu=0;wu<cu.length-1;++wu)pu*=cu[wu];const mu=ou.shape,Au=cu.slice();Au.pop();let bu=1;for(let wu=hu;wu<ru;++wu)bu*=mu[wu],Au.push(mu[wu]);const Cu=[...xp(ou.shape).map(wu=>wu/bu),1].slice(0,hu);return[Au,pu,bu,Cu]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yI=-2,Az=-1;function bI(ou,nu,ru){const lu=ou.shape.length;vu(lu===nu.length,()=>`Error in slice${lu}D: Length of begin ${nu} must match the rank of the array (${lu}).`),vu(lu===ru.length,()=>`Error in slice${lu}D: Length of size ${ru} must match the rank of the array (${lu}).`);for(let cu=0;cu<lu;++cu)vu(nu[cu]+ru[cu]<=ou.shape[cu],()=>`Error in slice${lu}D: begin[${cu}] + size[${cu}] (${nu[cu]+ru[cu]}) would overflow input.shape[${cu}] (${ou.shape[cu]})`)}function yz(ou){const nu=[];let ru=0;for(;ou>0;)ou&1&&nu.push(ru),ou/=2,ru++;return nu}function xI(ou,nu,ru){const lu=[];for(let cu=0;cu<ou.length;cu++)lu[cu]=Math.ceil((nu[cu]-ou[cu])/ru[cu]);return lu}function MR(ou,nu,ru,lu){const cu=[...ou];for(let hu=cu.length;hu<lu.length;hu++)cu.push(1);for(let hu=0;hu<ru;hu++)hu===0?cu[nu]=1:(cu.splice(nu,0,1),cu.pop());return cu}function RR(ou,nu,ru){return ru<=ou?ru:ru-(nu-1)}function kR(ou,nu){const ru=[];for(let lu=0;lu<ou;lu++)ru.push(nu+lu);return ru}function bz(ou,nu,ru,lu,cu,hu,pu,mu,Au){const bu=ou.length;let Cu=new Array(bu),wu=new Array(bu),Eu=new Array(bu);if(nu.length&&ru>0){const Tu=nu[0],Ru=ru+1;Cu=BR(pu,Tu,Ru,lu,ou),wu=LR(mu,Tu,Ru,cu,ou),Eu=MR(hu,Tu,Ru,ou)}else for(let Tu=0;Tu<bu;Tu++)Cu[Tu]=DR(pu,lu,hu,ou,Tu,Au),wu[Tu]=FR(mu,cu,hu,ou,Tu,Au),Eu[Tu]=NR(hu,Tu,Au);return{begin:Cu,end:wu,strides:Eu}}function BR(ou,nu,ru,lu,cu){const hu=[...cu],pu=kR(ru,nu);for(let mu=0;mu<hu.length;mu++)if(pu.indexOf(mu)>-1)hu[mu]=0;else{const Au=RR(nu,ru,mu);let bu=lu[Au];ou&1<<Au&&(bu=0),hu[mu]=bu}return hu}function LR(ou,nu,ru,lu,cu){const hu=[...cu],pu=kR(ru,nu);for(let mu=0;mu<hu.length;mu++)if(pu.indexOf(mu)>-1)hu[mu]=Number.MAX_SAFE_INTEGER;else{const Au=RR(nu,ru,mu);let bu=lu[Au];ou&1<<Au&&(bu=Number.MAX_SAFE_INTEGER),hu[mu]=bu}for(let mu=0;mu<hu.length;mu++){const Au=cu[mu];hu[mu]<0&&(hu[mu]+=Au),hu[mu]=fu(0,hu[mu],cu[mu])}return hu}function NR(ou,nu,ru){let lu=ou[nu];return(ru&1<<nu||lu==null)&&(lu=1),lu}function DR(ou,nu,ru,lu,cu,hu){let pu=nu[cu];const mu=ru[cu]||1;(ou&1<<cu||hu&1<<cu||pu==null)&&(mu>0?pu=Number.MIN_SAFE_INTEGER:pu=Number.MAX_SAFE_INTEGER);const Au=lu[cu];return pu<0&&(pu+=Au),pu=fu(0,pu,Au-1),pu}function FR(ou,nu,ru,lu,cu,hu){let pu=nu[cu];const mu=ru[cu]||1;(ou&1<<cu||hu&1<<cu||pu==null)&&(mu>0?pu=Number.MAX_SAFE_INTEGER:pu=Number.MIN_SAFE_INTEGER);const Au=lu[cu];return pu<0&&(pu+=Au),mu>0?pu=fu(0,pu,Au):pu=fu(-1,pu,Au-1),pu}function vI(ou,nu,ru){let lu=ru.length;for(let cu=0;cu<ru.length;cu++)if(ru[cu]>1){lu=cu;break}for(let cu=lu+1;cu<ru.length;cu++)if(nu[cu]>0||ru[cu]!==ou[cu])return!1;return!0}function CI(ou,nu){let ru=ou.length>0?ou[ou.length-1]:1;for(let lu=0;lu<ou.length-1;lu++)ru+=ou[lu]*nu[lu];return ru}function XE(ou,nu,ru){let lu;const cu=ou.shape.length;typeof nu=="number"?lu=[nu,...new Array(cu-1).fill(0)]:nu.length<cu?lu=nu.concat(new Array(cu-nu.length).fill(0)):lu=nu.slice(),lu.forEach(pu=>{vu(pu!==-1,()=>"slice() does not support negative begin indexing.")});let hu;return ru==null?hu=new Array(cu).fill(-1):typeof ru=="number"?hu=[ru,...new Array(cu-1).fill(-1)]:ru.length<cu?hu=ru.concat(new Array(cu-ru.length).fill(-1)):hu=ru,hu=hu.map((pu,mu)=>pu>=0?pu:(vu(pu===-1,()=>`Negative size values should be exactly -1 but got ${pu} for the slice() size at index ${mu}.`),ou.shape[mu]-lu[mu])),[lu,hu]}function wI(ou,nu,ru,lu,cu,hu,pu,mu,Au){let bu;if(lu==null?(bu=new Array(nu.length),bu.fill(1)):bu=lu,pu!=null&&pu&pu-1)throw new Error("Multiple ellipses in slice is not allowed.");let Cu=!1;const wu={dims:bu.length,numAddAxisAfterEllipsis:0,begin:nu.slice(),end:ru.slice(),strides:bu.slice(),beginMask:cu,endMask:hu,ellipsisMask:pu,newAxisMask:mu,shrinkAxisMask:Au};for(let Gu=0;Gu<wu.dims;Gu++)Cu&&1<<Gu&mu&&wu.numAddAxisAfterEllipsis++,1<<Gu&pu&&(Cu=!0);Cu||(wu.ellipsisMask|=1<<wu.dims,wu.dims++);const Eu={dims:ou.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};xz(wu,Eu);let Tu=!0,Ru=!0,Nu=!0;const Pu=[],Fu=[];for(let Gu=0;Gu<ou.length;++Gu){if(Eu.strides[Gu]===0)throw Error(`strides[${Gu}] must be non-zero`);const Xu=!!(Eu.shrinkAxisMask&1<<Gu),Qu=ou[Gu];if(Qu===-1){Pu.push(Xu?1:-1);continue}const Ju=[Eu.beginMask&1<<Gu,Eu.endMask&1<<Gu],ip=[Eu.strides[Gu]>0?0:-1,Eu.strides[Gu]>0?Qu:Qu-1];if(Xu&&Eu.strides[Gu]<=0)throw Error("only stride 1 allowed on non-range indexing.");Nu=Nu&&Eu.strides[Gu]===1;const rp=!!(Eu.beginMask&1<<Gu&&Eu.endMask&1<<Gu);if(Eu.beginValid&&Eu.endValid){if(Xu){const Up=Eu.begin[Gu]<0?Qu+Eu.begin[Gu]:Eu.begin[Gu];if(Eu.begin[Gu]=Up,Eu.end[Gu]=Eu.begin[Gu]+1,Up<0||Up>=Qu)throw Error(`slice index ${Eu.begin[Gu]} of dimension ${Gu} out of bounds.`)}else Eu.begin[Gu]=PR(Eu.begin[Gu],0,Eu.strides[Gu],Qu,Ju,ip),Eu.end[Gu]=PR(Eu.end[Gu],1,Eu.strides[Gu],Qu,Ju,ip);const Ap=Eu.strides[Gu]===1&&Eu.begin[Gu]===0&&Eu.end[Gu]===Qu;Tu=Tu&&Ap,Ru=Ru&&(Gu===0&&Eu.strides[Gu]===1||Ap)}else Tu=Tu&&Eu.strides[Gu]===1&&rp,Ru=Ru&&(Gu===0&&Eu.strides[Gu]===1||rp);let op,hp=!1;if(Eu.beginValid&&Eu.endValid?(op=Eu.end[Gu]-Eu.begin[Gu],hp=!0):Xu?(op=1,hp=!0):rp&&Qu>=0&&(Eu.strides[Gu]<0?op=-Qu:op=Qu,hp=!0),hp){let Ap;op===0||op<0!=Eu.strides[Gu]<0?Ap=0:Ap=Math.trunc(op/Eu.strides[Gu])+(op%Eu.strides[Gu]!==0?1:0),Pu.push(Ap)}else Pu.push(-1)}for(let Gu=0;Gu<Eu.finalShapeGatherIndices.length;++Gu){const Xu=Eu.finalShapeGatherIndices[Gu];Xu>=0?Fu.push(Pu[Xu]):Xu===yI&&Fu.push(1)}return{finalShapeSparse:Fu.filter((Gu,Xu)=>Eu.finalShapeGatherIndices[Xu]!==yI),finalShape:Fu,isIdentity:Tu,sliceDim0:Ru,isSimpleSlice:Nu,begin:Eu.begin,end:Eu.end,strides:Eu.strides}}function xz(ou,nu){nu.beginMask=0,nu.endMask=0,nu.shrinkAxisMask=0;let ru=0;nu.beginValid=ou.begin!=null,nu.endValid=ou.end!=null,nu.begin=new Array(nu.dims),nu.end=new Array(nu.dims),nu.strides=new Array(nu.dims),nu.finalShapeGatherIndices=[],nu.finalShapeGatherIndicesSparse=[],nu.inputShapeGatherIndicesSparse=new Array(nu.dims);for(let lu=0;lu<ou.dims;lu++)if(1<<lu&ou.ellipsisMask){const cu=Math.min(nu.dims-(ou.dims-lu)+1+ou.numAddAxisAfterEllipsis,nu.dims);for(;ru<cu;ru++)nu.begin[ru]=0,nu.end[ru]=0,nu.strides[ru]=1,nu.beginMask|=1<<ru,nu.endMask|=1<<ru,nu.finalShapeGatherIndices.push(ru),nu.finalShapeGatherIndicesSparse.push(-1),nu.inputShapeGatherIndicesSparse[ru]=lu}else if(1<<lu&ou.newAxisMask)nu.finalShapeGatherIndices.push(yI),nu.finalShapeGatherIndicesSparse.push(-1);else{if(ru===nu.begin.length)throw Error(`Index out of range using input dim ${ru}; input has only ${nu.dims} dims, ${nu.begin.length}.`);ou.begin!=null&&(nu.begin[ru]=ou.begin[lu]),ou.end!=null&&(nu.end[ru]=ou.end[lu]),nu.strides[ru]=ou.strides[lu],ou.beginMask&1<<lu&&(nu.beginMask|=1<<ru),ou.endMask&1<<lu&&(nu.endMask|=1<<ru),ou.shrinkAxisMask&1<<lu?(nu.finalShapeGatherIndices.push(Az),nu.finalShapeGatherIndicesSparse.push(-1),nu.shrinkAxisMask|=1<<ru):(nu.finalShapeGatherIndices.push(ru),nu.finalShapeGatherIndicesSparse.push(lu)),nu.inputShapeGatherIndicesSparse[ru]=lu,ru++}}function PR(ou,nu,ru,lu,cu,hu){if(cu[nu])return ru>0?hu[nu]:hu[nu+1&1];{const pu=ou<0?lu+ou:ou;return pu<hu[0]?hu[0]:pu>hu[1]?hu[1]:pu}}const vz=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:bI,computeFlatOffset:CI,computeOutShape:xI,getNormalizedAxes:bz,isSliceContinous:vI,maskToAxes:yz,parseSliceParams:XE,sliceInfo:wI,startForAxis:DR,startIndicesWithElidedDims:BR,stopForAxis:FR,stopIndicesWithElidedDims:LR,stridesForAxis:NR,stridesWithElidedDims:MR},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Cz{static sgd(nu){return new gI(nu)}static momentum(nu,ru,lu=!1){return new TR(nu,ru,lu)}static rmsprop(nu,ru=.9,lu=0,cu=null,hu=!1){return new _R(nu,ru,lu,cu,hu)}static adam(nu=.001,ru=.9,lu=.999,cu=null){return new SR(nu,ru,lu,cu)}static adadelta(nu=.001,ru=.95,lu=null){return new wR(nu,ru,lu)}static adamax(nu=.002,ru=.9,lu=.999,cu=null,hu=0){return new IR(nu,ru,lu,cu,hu)}static adagrad(nu,ru=.1){return new ER(nu,ru)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eC=Cz;/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wz=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:ou=>ou();function QE(){return new Promise(ou=>wz(()=>ou()))}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EI(ou,nu){const ru=ou[0].length;ou.forEach((cu,hu)=>{vu(cu.length===ru,()=>`Error in concat${ru}D: rank of tensors[${hu}] must be the same as the rank of the rest (${ru})`)}),vu(nu>=0&&nu<ru,()=>`Error in concat${ru}D: axis must be between 0 and ${ru-1}.`);const lu=ou[0];ou.forEach((cu,hu)=>{for(let pu=0;pu<ru;pu++)vu(pu===nu||cu[pu]===lu[pu],()=>`Error in concat${ru}D: Shape of tensors[${hu}] (${cu}) does not match the shape of the rest (${lu}) along the non-concatenated axis ${hu}.`)})}function $x(ou,nu){const ru=ou[0].slice();for(let lu=1;lu<ou.length;lu++)ru[nu]+=ou[lu][nu];return ru}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var wx;(function(ou){ou[ou.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",ou[ou.VALUE_ROWIDS=1]="VALUE_ROWIDS",ou[ou.ROW_LENGTHS=2]="ROW_LENGTHS",ou[ou.ROW_SPLITS=3]="ROW_SPLITS",ou[ou.ROW_LIMITS=4]="ROW_LIMITS",ou[ou.ROW_STARTS=5]="ROW_STARTS"})(wx||(wx={}));function GR(ou,nu,ru){let lu=new Array;if(ru==null&&nu==null)return lu;if(nu==null)for(;lu.length<ou+ru.length;)lu.push(-1);else lu=nu.slice();if(ru==null)return lu;if(ou+ru.length!==lu.length)throw new Error(`rt input.shape and shape=${nu} are incompatible: rt input.rank = ${ou+ru.length}, but shape.rank = ${lu.length}`);for(let cu=1;cu<ru.length;++cu){const hu=ru[cu],pu=lu[lu.length-ru.length+cu],mu=lu[pu];if(hu>=0)if(mu>=0){if(mu!==hu)throw new Error(`rt input.shape and shape=${nu} are incompatible: rt input.shape[${cu+ou}] = ${hu} but shape[${cu+ou}] = ${mu}`)}else lu[pu]=hu}return lu}function OR(ou){const nu={FIRST_DIM_SIZE:wx.FIRST_DIM_SIZE,VALUE_ROWIDS:wx.VALUE_ROWIDS,ROW_LENGTHS:wx.ROW_LENGTHS,ROW_SPLITS:wx.ROW_SPLITS,ROW_LIMITS:wx.ROW_LIMITS,ROW_STARTS:wx.ROW_STARTS},ru=[];for(const lu of ou)if(lu in nu)ru.push(nu[lu]);else break;return ru}function UR(ou){return ou.length===0?0:ou[0]===wx.FIRST_DIM_SIZE?ou.length-1:ou.length}function $R(ou,nu){if(ou==null||nu==null)return;const ru=ou.length,lu=nu.length;if(ru>=lu)throw new Error(`defaultValue.shape=${ou} and ragged tensor flatValues.shape=${nu}, are incompatible: defaultValue.rank = ${ru} must be less than ragged tensor input flatValues.rank = ${lu})`);for(let cu=0;cu<Math.min(ru,lu-1);++cu){const hu=ou[cu],pu=nu[cu+1];if(hu>=0&&pu>=0&&hu!==1&&hu!==pu)throw new Error(`defaultValue.shape=${ou}, and ragged tensor input flatValues.shape=${nu} are incompatible: defaultValue.shape[${cu-ou.length}] = ${hu} but ragged tensor input.flatValues.shape[${cu-ou.length}] = ${pu}`)}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SI=30;function KE(ou){return ou<=SI?ou:Rp(ou,Math.floor(Math.sqrt(ou)))}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function II(ou,nu,ru){const lu=ru*(typeof ou=="number"?ou:ou[0]),cu=nu*(typeof ou=="number"?ou:ou[1]);return[lu,cu]}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fw(ou,nu,ru,lu=!0){let cu=[];if(lu)cu=cu.concat(nu.slice(0)),cu.push(ou[0]/ru),cu=cu.concat(ou.slice(1));else{cu=cu.concat(ou[0]);const hu=nu.length;for(let pu=0;pu<hu;++pu)cu=cu.concat([ou[pu+1]/nu[pu],nu[pu]]);cu=cu.concat(ou.slice(hu+1))}return cu}function mw(ou,nu,ru=!0){const lu=[];if(ru){lu.push(nu);for(let cu=nu+1;cu<ou;++cu)cu<=2*nu?(lu.push(cu),lu.push(cu-(nu+1))):lu.push(cu)}else{const cu=[],hu=[];for(let pu=1;pu<ou;++pu)pu>=nu*2+1||pu%2===1?hu.push(pu):cu.push(pu);lu.push(...cu),lu.push(0),lu.push(...hu)}return lu}function gw(ou,nu,ru,lu=!0){const cu=[];lu?cu.push(ou[0]/ru):cu.push(ou[0]*ru);for(let hu=1;hu<ou.length;++hu)hu<=nu.length?lu?cu.push(nu[hu-1]*ou[hu]):cu.push(ou[hu]/nu[hu-1]):cu.push(ou[hu]);return cu}function TI(ou,nu){const ru=[0];for(let lu=0;lu<nu;++lu)ru.push(ou[lu][0]);return ru}function _I(ou,nu,ru){const lu=ou.slice(0,1);for(let cu=0;cu<ru;++cu)lu.push(ou[cu+1]-nu[cu][0]-nu[cu][1]);return lu}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZE=1.7580993408473768,jE=1.0507009873554805;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MI=.3275911,RI=.254829592,kI=-.284496736,BI=1.421413741,LI=-1.453152027,NI=1.061405429;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sv(ou,nu){if(ou.length!==nu.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${ou.length}, imag: ${nu.length}.`);const ru=new Float32Array(ou.length*2);for(let lu=0;lu<ru.length;lu+=2)ru[lu]=ou[lu/2],ru[lu+1]=nu[lu/2];return ru}function VR(ou){const nu=new Float32Array(ou.length/2),ru=new Float32Array(ou.length/2);for(let lu=0;lu<ou.length;lu+=2)nu[lu/2]=ou[lu],ru[lu/2]=ou[lu+1];return{real:nu,imag:ru}}function zR(ou){const nu=Math.ceil(ou.length/4),ru=new Float32Array(nu),lu=new Float32Array(nu);for(let cu=0;cu<ou.length;cu+=4)ru[Math.floor(cu/4)]=ou[cu],lu[Math.floor(cu/4)]=ou[cu+1];return{real:ru,imag:lu}}function WR(ou){const nu=Math.floor(ou.length/4),ru=new Float32Array(nu),lu=new Float32Array(nu);for(let cu=2;cu<ou.length;cu+=4)ru[Math.floor(cu/4)]=ou[cu],lu[Math.floor(cu/4)]=ou[cu+1];return{real:ru,imag:lu}}function DI(ou,nu){const ru=ou[nu*2],lu=ou[nu*2+1];return{real:ru,imag:lu}}function HR(ou,nu,ru,lu){ou[lu*2]=nu,ou[lu*2+1]=ru}function XR(ou,nu){const ru=new Float32Array(ou/2),lu=new Float32Array(ou/2);for(let cu=0;cu<Math.ceil(ou/2);cu++){const hu=(nu?2:-2)*Math.PI*(cu/ou);ru[cu]=Math.cos(hu),lu[cu]=Math.sin(hu)}return{real:ru,imag:lu}}function QR(ou,nu,ru){const lu=(ru?2:-2)*Math.PI*(ou/nu),cu=Math.cos(lu),hu=Math.sin(lu);return{real:cu,imag:hu}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const FI="->",Ez=/->/g,KR=",",ZR="...";function PI(ou,nu){ou=ou.replace(/\s/g,"");const ru=(ou.length-ou.replace(Ez,"").length)/FI.length;if(ru<1)throw new Error("Equations without an arrow are not supported.");if(ru>1)throw new Error(`Equation must contain exactly one arrow ("${FI}").`);const[lu,cu]=ou.split(FI);vu(lu.indexOf(ZR)===-1,()=>`The ellipsis notation ("${ZR}") is not supported yet.`);const hu=lu.split(KR),pu=hu.length;if(nu!==pu)throw new Error(`Expected ${pu} input tensors, received ${nu}`);if(pu>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const mu=[];for(let Eu=0;Eu<cu.length;++Eu){const Tu=cu[Eu];if(!hu.some(Ru=>Ru.indexOf(Tu)!==-1))throw new Error(`Output subscripts contain the label ${Tu} not present in the input subscripts.`);mu.indexOf(Tu)===-1&&mu.push(Tu)}for(let Eu=0;Eu<lu.length;++Eu){const Tu=lu[Eu];mu.indexOf(Tu)===-1&&Tu!==KR&&mu.push(Tu)}const Au=new Array(hu.length);for(let Eu=0;Eu<pu;++Eu){if(new Set(hu[Eu].split("")).size!==hu[Eu].length)throw new Error(`Found duplicate axes in input component ${hu[Eu]}. Support for duplicate axes in input is not implemented yet.`);Au[Eu]=[];for(let Tu=0;Tu<hu[Eu].length;++Tu)Au[Eu].push(mu.indexOf(hu[Eu][Tu]))}const bu=mu.length,Cu=cu.length,wu=[];for(let Eu=Cu;Eu<bu;++Eu)wu.push(Eu);return{allDims:mu,summedDims:wu,idDims:Au}}function GI(ou,nu){let ru=new Array(ou);ru.fill(-1);for(let cu=0;cu<nu.length;++cu)ru[nu[cu]]=cu;const lu=[];for(let cu=0;cu<ou;++cu)ru[cu]===-1&&lu.push(cu);return ru=ru.filter(cu=>cu!==-1),{permutationIndices:ru,expandDims:lu}}function OI(ou,nu,ru){const lu=new Array(ou);for(let cu=0;cu<ru.length;++cu){const hu=ru[cu].shape;for(let pu=0;pu<nu[cu].length;++pu)lu[nu[cu][pu]]===void 0?lu[nu[cu][pu]]=hu[pu]:vu(lu[nu[cu][pu]]===hu[pu],()=>`Expected dimension ${lu[nu[cu][pu]]} at axis ${pu} of input shaped ${JSON.stringify(hu)}, but got dimension ${hu[pu]}`)}}function UI(ou,nu){const ru=ou,lu=[];let cu=0;ou.length===0&&ru.push(-1),cu=ou.length+1;for(let pu=0;pu<cu;++pu)lu.push([]);const hu=[];for(let pu=0;pu<ru.length;++pu){const mu=ru[pu],Au=Sz(nu,mu);for(const bu of Au)hu.indexOf(bu)===-1&&(lu[pu].push(bu),hu.push(bu))}return{path:ru,steps:lu}}function $I(ou){return ou.every((nu,ru)=>nu===ru)}function Sz(ou,nu){const ru=[];for(let lu=0;lu<ou.length;++lu)(ou[lu].length===0||ou[lu].indexOf(nu)!==-1||nu===-1)&&ru.push(lu);return ru}function VI(ou,nu,ru=0){let lu=[];if(typeof nu=="number")vu(ou.shape[ru]%nu===0,()=>"Number of splits must evenly divide the axis."),lu=new Array(nu).fill(ou.shape[ru]/nu);else{const cu=nu.reduce((pu,mu)=>(mu===-1&&(pu+=1),pu),0);vu(cu<=1,()=>"There should be only one negative value in split array.");const hu=nu.indexOf(-1);if(hu!==-1){const pu=nu.reduce((mu,Au)=>Au>0?mu+Au:mu);nu[hu]=ou.shape[ru]-pu}vu(ou.shape[ru]===nu.reduce((pu,mu)=>pu+mu),()=>"The sum of sizes must match the size of the axis dimension."),lu=nu}return lu}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jR(ou){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${ou}`}function YR(ou,nu){return`indices(${ou}, 0) is invalid: ${nu} < 0`}function qR(ou,nu,ru){return`indices(${ou}, 0) is invalid: ${nu} >= ${ru}`}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JR(ou,nu){return`only one output dimension may be -1, not both ${ou} and ${nu}`}function _k(ou,nu){return`size ${ou} must be non-negative, not ${nu}`}function eB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function tB(ou,nu){const ru=Mu(ou),lu=Mu(nu);return`Input to reshape is a SparseTensor with ${ru}
  dense values, but the requested shape requires a multiple of ${lu}. inputShape=${ou} outputShape= ${nu}`}function nB(ou,nu){const ru=Mu(ou),lu=Mu(nu);return`Input to reshape is a tensor with ${ru} dense values, but the requested shape has ${lu}. inputShape=${ou} outputShape=${nu}`}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zI(){return"segment ids must be >= 0"}function iB(){return"segment ids are not increasing"}function rB(ou,nu){return`Segment id ${ou} out of range [0, ${nu}), possibly because segmentIds input is not sorted.`}function sB(ou,nu,ru){return`Bad: indices[${ou}] == ${nu} out of range [0, ${ru})`}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oB(ou,nu){let ru=!1,lu;for(ou<=SI?(lu=ou,ru=!0):lu=Rp(ou,Math.floor(Math.sqrt(ou)));!ru;)lu>nu||lu===ou?ru=!0:lu=Rp(ou,lu+1);return lu}function aB(ou,nu,ru){const lu=[],cu=ou.length;for(let hu=0;hu<cu;hu++)hu!==nu?lu.push(ou[hu]):lu.push(ru);return lu}function WI(ou,nu,ru,lu){const cu=nu.shape.length,hu=ou.shape.length;if(lu!==0&&(lu<-cu||lu>cu))throw new Error(`Expect batchDims in the range of [-${cu}, ${cu}], but got ${lu}`);if(lu<0&&(lu+=cu),lu>hu)throw new Error(`batchDims (${lu}) must be less than rank(x) (
    ${hu}).`);if(ru<lu)throw new Error(`batchDims (${lu}) must be less than or equal to axis (${ru}).`);for(let wu=0;wu<lu;++wu)if(ou.shape[wu]!==nu.shape[wu])throw new Error(`x.shape[${wu}]: ${ou.shape[wu]} should be equal to indices.shape[${wu}]: ${nu.shape[wu]}.`);const pu=ou.shape[ru],mu=[];let Au=1,bu=1,Cu=1;for(let wu=0;wu<lu;++wu)mu.push(ou.shape[wu]),Au*=ou.shape[wu];for(let wu=lu;wu<ru;wu++)mu.push(ou.shape[wu]),bu*=ou.shape[wu];for(let wu=lu;wu<cu;wu++)mu.push(nu.shape[wu]);for(let wu=ru+1;wu<hu;wu++)mu.push(ou.shape[wu]),Cu*=ou.shape[wu];return{batchSize:Au,sliceSize:Cu,outerSize:bu,dimSize:pu,outputShape:mu}}const Iz=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:WI,computeOutShape:aB,segOpComputeOptimalWindowSize:oB},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ov(ou){try{return ou.map(nu=>xv(nu))}catch(nu){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${nu}`)}}function lB(ou){return ou.map(nu=>bv(nu))}const Tz=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:RI,ERF_A2:kI,ERF_A3:BI,ERF_A4:LI,ERF_A5:NI,ERF_P:MI,PARALLELIZE_THRESHOLD:SI,get RowPartitionType(){return wx},SELU_SCALE:jE,SELU_SCALEALPHA:ZE,applyActivation:uI,assertAndGetBroadcastShape:_g,assertAxesAreInnerMostDims:dy,assertParamsConsistent:EI,assignToTypedArray:HR,axesAreInnerMostDims:HS,calculateShapes:h1,checkEinsumDimSizes:OI,checkPadOnDimRoundingMode:ky,combineLocations:zM,combineRaggedTensorToTensorShapes:GR,complexWithEvenIndex:zR,complexWithOddIndex:WR,computeConv2DInfo:hy,computeConv3DInfo:wv,computeDefaultPad:FS,computeDilation2DInfo:iw,computeOptimalWindowSize:KE,computeOutAndReduceShapes:oy,computeOutShape:$x,computePool2DInfo:ox,computePool3DInfo:tv,convertConv2DDataFormat:nv,decodeEinsumEquation:PI,eitherStridesOrDilationsAreOne:gy,expandShapeToKeepDim:j0,exponent:QR,exponents:XR,fromStringArrayToUint8:lB,fromUint8ToStringArray:ov,getAxesPermutation:G0,getBroadcastDims:K1,getComplexWithIndex:DI,getEinsumComputePath:UI,getEinsumPermutation:GI,getFusedBiasGradient:cI,getFusedDyActivation:lI,getImageCenter:II,getInnerMostAxes:H0,getPermuted:mw,getRaggedRank:UR,getReductionAxes:J0,getReshaped:fw,getReshapedPermuted:gw,getRowPartitionTypesHelper:OR,getSliceBeginCoords:TI,getSliceSize:_I,getSparseFillEmptyRowsIndicesDenseShapeMismatch:jR,getSparseFillEmptyRowsNegativeIndexErrorMessage:YR,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:qR,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:eB,getSparseReshapeInputOutputMismatchErrorMessage:nB,getSparseReshapeInputOutputMultipleErrorMessage:tB,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:JR,getSparseReshapeNegativeOutputDimErrorMessage:_k,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:sB,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:zI,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:iB,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:rB,getUndoAxesPermutation:Ev,isIdentityPermutation:$I,log:aP,mergeRealAndImagArrays:sv,prepareAndValidate:AI,prepareSplitSize:VI,segment_util:Iz,shouldFuse:hI,slice_util:vz,splitRealAndImagArrays:VR,stridesOrDilationsArePositive:s1,tupleValuesAreOne:r1,upcastType:Uy,validateDefaultValueShape:$R,validateInput:tV,validateUpdateShape:fR,warn:Xy},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/fz();/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cB={kernelName:Lp,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,pw(km(ru,"float32"),-1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Mz={kernelName:Kp,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>{const lu=k0(km(ru,"float32")),cu=wy(Qm(A0(1),lu));return X0(Xm(ou,cu))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rz={kernelName:vm,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>{const lu=wy(Qm(k0(km(ru,"float32")),1));return Xm(ou,lu)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kz={kernelName:sp,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{let hu=ou;const pu=J0(ru.shape,cu);return pu.length>0&&(hu=zm(hu,pu)),Pp(hu,ru.shape)},b:()=>{let hu=ou;const pu=J0(lu.shape,cu);return pu.length>0&&(hu=zm(hu,pu)),Pp(hu,lu.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bz={kernelName:_d,saveAllInputs:!0,gradFunc:(ou,nu)=>{const ru={};return nu.forEach((lu,cu)=>{ru[cu]=()=>ou.clone()}),ru}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Lz={kernelName:qu,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>l0(ru)}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nz={kernelName:Uu,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>l0(ru)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Dz={kernelName:zu,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,wy(Qm(A0(1),k0(km(ru,"float32")))))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Fz={kernelName:ep,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>{const lu=wy(Am(A0(1),k0(km(ru,"float32"))));return Xm(ou,lu)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Pz={kernelName:Ip,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{const hu=Am(k0(ru),k0(lu));let pu=_p(ou,Xm(lu,hu));const mu=J0(ru.shape,cu);return mu.length>0&&(pu=zm(pu,mu)),Pp(pu,ru.shape)},b:()=>{const hu=Am(k0(ru),k0(lu));let pu=X0(_p(ou,Xm(ru,hu)));const mu=J0(lu.shape,cu);return mu.length>0&&(pu=zm(pu,mu)),Pp(pu,lu.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gz={kernelName:up,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,Am(k0(km(ru,"float32")),1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Oz={kernelName:Mp,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,Qm(A0(1),k0(km(ru,"float32"))))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Uz(ou,nu,ru,lu,cu,hu){const pu=fp(ou,"dy","avgPool3dGrad"),mu=fp(nu,"input","avgPool3dGrad");let Au=pu,bu=mu,Cu=!1;mu.rank===4&&(Cu=!0,Au=Pp(pu,[1,pu.shape[0],pu.shape[1],pu.shape[2],pu.shape[3]]),bu=Pp(mu,[1,mu.shape[0],mu.shape[1],mu.shape[2],mu.shape[3]])),vu(Au.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${Au.rank}.`),vu(bu.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${bu.rank}.`),ky("avgPool3dGrad",cu,hu);const wu={dy:Au,input:bu},Eu={filterSize:ru,strides:lu,pad:cu,dimRoundingMode:hu},Tu=Tp.runKernel(Zp,wu,Eu);return Cu?Pp(Tu,[Tu.shape[1],Tu.shape[2],Tu.shape[3],Tu.shape[4]]):Tu}const $z=Fp({avgPool3dGrad_:Uz});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Vz={kernelName:pp,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{filterSize:cu,strides:hu,pad:pu,dimRoundingMode:mu}=ru;return{x:()=>$z(ou,lu,cu,hu,pu,mu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zz(ou,nu,ru,lu,cu){const hu=fp(ou,"dy","avgPoolGrad"),pu=fp(nu,"input","avgPoolGrad");vu(pu.rank===hu.rank,()=>`Rank of input (${pu.rank}) does not match rank of dy (${hu.rank})`);let mu=pu,Au=hu,bu=!1;pu.rank===3&&(bu=!0,mu=Pp(pu,[1,pu.shape[0],pu.shape[1],pu.shape[2]]),Au=Pp(hu,[1,hu.shape[0],hu.shape[1],hu.shape[2]])),vu(Au.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${Au.rank}.`),vu(mu.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${mu.rank}.`);const Cu={dy:Au,input:mu},wu={filterSize:ru,strides:lu,pad:cu},Eu=Tp.runKernel(Gm,Cu,wu);return bu?Pp(Eu,[Eu.shape[1],Eu.shape[2],Eu.shape[3]]):Eu}const Wz=Fp({avgPoolGrad_:zz});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hz={kernelName:fm,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{filterSize:cu,strides:hu,pad:pu}=ru;return{x:()=>Wz(ou,lu,cu,hu,pu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Xz={kernelName:om,inputsToSave:["a","b"],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{transposeA:hu,transposeB:pu}=ru;return!hu&&!pu?{a:()=>g0(ou,cu,!1,!0),b:()=>g0(lu,ou,!0,!1)}:!hu&&pu?{a:()=>g0(ou,cu,!1,!1),b:()=>g0(ou,lu,!0,!1)}:hu&&!pu?{a:()=>g0(cu,ou,!1,!0),b:()=>g0(lu,ou,!1,!1)}:{a:()=>g0(cu,ou,!0,!0),b:()=>g0(ou,lu,!0,!0)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qz={kernelName:Mm,gradFunc:(ou,nu,ru)=>{const{blockShape:lu,crops:cu}=ru;return{x:()=>JS(ou,lu,cu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kz={kernelName:Ym,gradFunc:(ou,nu,ru)=>{const lu=ru,cu=lu.inputShape,hu=lu.shape,pu=Array.from(hu);for(let Au=cu.length-1;Au>=0;Au--)if(cu[Au]===hu[Au])pu[Au]=1;else if(cu[Au]!==1)throw new Error(`broadcastTo(): [${cu}] cannot be broadcast to [${hu}].`);const mu=[];for(let Au=0;Au<pu.length;Au++)pu[Au]>1&&mu.push(Au);return{x:()=>zm(ou,mu,!0)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Zz={kernelName:Sm,gradFunc:ou=>({x:()=>ou.clone()})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jz={kernelName:Fm,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Yz={kernelName:i0,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{clipValueMin:cu,clipValueMax:hu}=ru;return{x:()=>Cy(iv(a1(lu,cu),j1(lu,hu)),ou,l0(ou))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qz={kernelName:pv,inputsToSave:["x"],gradFunc:cB.gradFunc};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Jz={kernelName:L1,saveAllInputs:!0,gradFunc:(ou,nu,ru)=>{const lu=nu.map(mu=>mu.shape),{axis:cu}=ru,hu=Wu(cu,nu[0].shape)[0],pu=lu.map(mu=>mu[hu]);return qy(ou,pu,hu).map(mu=>()=>mu)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eW={kernelName:zv,inputsToSave:["x","filter"],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{dilations:hu,strides:pu,pad:mu,dataFormat:Au}=ru;return vu(r1(hu),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${hu}'`),{x:()=>$S(lu.shape,ou,cu,pu,mu,Au),filter:()=>aI(lu,ou,cu.shape,pu,mu,Au)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tW={kernelName:tx,inputsToSave:["dy","filter"],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{strides:hu,pad:pu,dataFormat:mu,dimRoundingMode:Au}=ru;return{dy:()=>o1(ou,cu,hu,pu,mu,1,Au),filter:()=>aI(ou,lu,cu.shape,hu,pu,mu,Au)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nW(ou,nu,ru,lu,cu){let hu=ou;ou.rank===4&&(hu=Pp(ou,[1,ou.shape[0],ou.shape[1],ou.shape[2],ou.shape[3]]));let pu=nu;pu.rank===4&&(pu=Pp(nu,[1,nu.shape[0],nu.shape[1],nu.shape[2],nu.shape[3]])),vu(hu.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${hu.shape}.`),vu(pu.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${pu.shape}.`),vu(ru.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${ru}.`),vu(hu.shape[4]===ru[3],()=>`Error in conv3dDerFilter: depth of input ${hu.shape[4]}) must match input depth in filter (${ru[3]}.`),vu(pu.shape[4]===ru[4],()=>`Error in conv3dDerFilter: depth of dy (${pu.shape[4]}) must match output depth for filter (${ru[4]}).`);const mu={x:hu,dy:pu},Au={strides:lu,pad:cu,filterShape:ru};return Tp.runKernel(Wv,mu,Au)}const iW=Fp({conv3DBackpropFilter_:nW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rW={kernelName:fv,inputsToSave:["x","filter"],gradFunc:(ou,nu,ru)=>{const{dilations:lu,strides:cu,pad:hu}=ru;vu(r1(lu),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${lu}'`);const[pu,mu]=nu;return{x:()=>OM(pu.shape,ou,mu,cu,hu),filter:()=>iW(pu,ou,mu.shape,cu,hu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sW={kernelName:Lx,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(X0(uR(km(ru,"float32"))),ou)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oW={kernelName:mv,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(hR(km(ru,"float32")),ou)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aW={kernelName:Hv,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{axis:cu,exclusive:hu,reverse:pu}=ru;return{x:()=>{const mu=G0([cu],lu.rank);let Au=$M(ou,cu,hu,!pu);return mu!=null&&(Au=c0(Au,mu)),Au}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lW={kernelName:P1,inputsToSave:["x","filter"],gradFunc:(ou,nu,ru)=>{const{dilations:lu,strides:cu,pad:hu,dimRoundingMode:pu}=ru,mu=lu??[1,1];vu(r1(mu),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${mu}'`);const[Au,bu]=nu;return vu(Au.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${Au.rank}.`),vu(bu.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${bu.rank}.`),vu(Au.shape[3]===bu.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${Au.shape[3]}) must match the inChannels dimension in filter ${bu.shape[2]}.`),vu(gy(cu,mu),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${cu} and dilations '${mu}'.`),ky("depthwiseConv2d",hu,pu),{x:()=>xV(Au.shape,ou,bu,cu,hu,mu,pu),filter:()=>yV(Au,ou,bu.shape,cu,hu,mu,pu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cW={kernelName:np,inputsToSave:["x","filter"],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,hu={x:lu,filter:cu,dy:ou},pu={x:lu,filter:cu,dy:ou};return{x:()=>Tp.runKernel(Np,hu,ru),filter:()=>Tp.runKernel(Wp,pu,ru)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uW={kernelName:_m,outputsToSave:[!0],gradFunc:(ou,nu)=>{const[ru]=nu,lu={dy:ou,y:ru};return{x:()=>Tp.runKernel(Nm,lu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hW={kernelName:Dm,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu,lu=_p(Gx(X0(k0(ru))),2/Math.sqrt(Math.PI));return{x:()=>_p(ou,lu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dW={kernelName:Zm,outputsToSave:[!0],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,ru)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pW={kernelName:Vm,inputsToSave:["input"],gradFunc:(ou,nu)=>{const[ru]=nu;return{input:()=>Pp(ou,ru.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fW={kernelName:r0,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,Gx(ru))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mW={kernelName:s0,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gW={kernelName:z0,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{const hu=Xm(ou,km(lu,"float32")),pu=J0(ru.shape,cu);return pu.length>0?Pp(zm(hu,pu),ru.shape):hu},b:()=>{let hu=_p(ou,km(ru,"float32"));const pu=J0(lu.shape,cu);pu.length>0&&(hu=Pp(zm(hu,pu),lu.shape));const mu=k0(lu);return X0(Xm(hu,km(mu,"float32")))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AW={kernelName:Um,inputsToSave:["x","mean","variance","scale"],gradFunc:(ou,nu,ru)=>{const{varianceEpsilon:lu}=ru,[cu,hu,pu,mu]=nu,Au=mu??A0(1),bu=J0(hu.shape,cu.shape),Cu=[];if(hu.rank===1){for(let Nu=0;Nu<cu.shape.length-1;++Nu)Cu.push(cu.shape[Nu]);Cu.push(1)}const wu=Qm(cu,hu),Eu=_p(ou,Au),Tu=aR(Am(pu,A0(lu))),Ru=_p(_p(_p(Tu,Tu),Tu),A0(-.5));return{x:()=>hu.rank===1?Pp(_p(_p(ou,Cx(Pp(Tu,[1,1,1,hu.shape[0]]),Cu)),Au),cu.shape):Pp(_p(_p(ou,Tu),Au),cu.shape),mean:()=>{let Nu=_p(_p(Tu,A0(-1)),Eu);return hu.rank===1&&(Nu=zm(Nu,bu)),Pp(Nu,hu.shape)},variance:()=>{let Nu=_p(_p(Ru,wu),Eu);return hu.rank===1&&(Nu=zm(Nu,bu)),Pp(Nu,hu.shape)},scale:()=>{const Nu=_p(wu,Tu);let Pu=_p(ou,Nu);return hu.rank===1&&(Pu=zm(Pu,bu)),Pp(Pu,hu.shape)},offset:()=>{let Nu=ou;return hu.rank===1&&(Nu=zm(Nu,bu)),Pp(Nu,hu.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yW={kernelName:Nx,inputsToSave:["x","indices"],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{axis:hu,batchDims:pu}=ru,mu=Wu(hu,lu.shape)[0],Au=(bu,Cu,wu)=>()=>{const Eu=bu.shape,Tu=Cu.size,Ru=Eu.slice(0,mu),Nu=Ru.length,Pu=Eu.slice(hu,Eu.length).slice(1),Fu=Pu.length,Gu=uB(0,Nu),Xu=uB(Nu+1,Nu+1+Fu),Qu=hB([Ru,[Tu],Pu]),Ju=Pp(wu,Qu),ip=Pp(Cu,[Tu]),rp=hB([[Nu],Gu,Xu]),op=c0(Ju,rp);let hp=gR(op,ip,bu.shape[mu]);const Ap=Ev(rp);return hp=c0(hp,Ap),hp};if(pu===1){const bu=lu.shape[0],Cu=lu.split(bu,0);return{x:()=>Ux(Cu.map((wu,Eu)=>Au(wu,cu.slice(Eu,1),ou.slice(Eu,1))())).reshape(lu.shape),indices:()=>cu}}else return{x:Au(lu,cu,ou),indices:()=>cu}}};function uB(ou,nu){const ru=[];for(let lu=ou;lu<nu;++lu)ru.push(lu);return ru}function hB(ou){const nu=[];for(let ru=0;ru<ou.length;++ru)for(let lu=0;lu<ou[ru].length;++lu)nu.push(ou[ru][lu]);return nu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bW={kernelName:yy,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu;return{a:()=>l0(ru),b:()=>l0(lu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xW={kernelName:Hy,gradFunc:ou=>({x:()=>km(ou,"float32")})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vW={kernelName:V0,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CW={kernelName:Py,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wW={kernelName:_0,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EW={kernelName:Ax,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{alpha:cu}=ru,hu=Yy(lu,0);return{x:()=>Cy(hu,ou,_p(ou,cu))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SW={kernelName:TC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,Am(ru,1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const IW={kernelName:IC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,km(ru,"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TW={kernelName:oP,inputsToSave:[],outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{axis:cu}=ru;return{logits:()=>{const hu=Gx(lu);return Qm(ou,_p(zm(ou,cu,!0),hu))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _W(ou,nu,ru,lu=5,cu=1,hu=1,pu=.5){const mu={x:ou,y:nu,dy:ru},Au={depthRadius:lu,bias:cu,alpha:hu,beta:pu};return Tp.runKernel(J2,mu,Au)}const MW=Fp({localResponseNormalizationBackprop_:_W});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RW={kernelName:eE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{depthRadius:hu,bias:pu,alpha:mu,beta:Au}=ru;return{x:()=>MW(lu,cu,ou,hu,pu,mu,Au)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dB(ou,nu,ru,lu){return nu.rank<ru.rank&&(nu=Pp(nu,j0(nu.shape,lu))),ou.rank<ru.rank&&(ou=Pp(ou,j0(ou.shape,lu))),{x:()=>_p(ou,km(Px(ru,nu),ou.dtype))}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pB={kernelName:tE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const lu=ru,{reductionIndices:cu}=lu,hu=nu[0],pu=nu[1],mu=Wu(cu,hu.shape),Au=dB(ou,pu,hu,mu);return{x:()=>Au.x()}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kW={kernelName:_C,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu;return{a:()=>_p(ou,km(a1(ru,lu),"float32")),b:()=>_p(ou,km(VE(ru,lu),"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BW(ou,nu,ru,lu,cu,hu,pu){const mu=fp(ou,"dy","maxPool3dGrad"),Au=fp(nu,"input","maxPool3dGrad"),bu=fp(ru,"output","maxPool3dGrad");let Cu=mu,wu=Au,Eu=bu,Tu=!1;Au.rank===4&&(Tu=!0,Cu=Pp(mu,[1,mu.shape[0],mu.shape[1],mu.shape[2],mu.shape[3]]),wu=Pp(Au,[1,Au.shape[0],Au.shape[1],Au.shape[2],Au.shape[3]]),Eu=Pp(bu,[1,bu.shape[0],bu.shape[1],bu.shape[2],bu.shape[3]])),vu(Cu.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${Cu.rank}.`),vu(wu.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${wu.rank}.`),vu(Eu.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${Eu.rank}.`),ky("maxPool3dGrad",hu,pu);const Ru={dy:Cu,input:wu,output:Eu},Nu={filterSize:lu,strides:cu,pad:hu,dimRoundingMode:pu},Pu=Tp.runKernel(tS,Ru,Nu);return Tu?Pp(Pu,[Pu.shape[1],Pu.shape[2],Pu.shape[3],Pu.shape[4]]):Pu}const LW=Fp({maxPool3dGrad_:BW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NW={kernelName:iE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au}=ru;return{x:()=>LW(ou,lu,cu,hu,pu,mu,Au)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DW(ou,nu,ru,lu,cu,hu,pu){const mu=fp(ou,"dy","maxPoolGrad"),Au=fp(nu,"input","maxPoolGrad"),bu=fp(ru,"output","maxPoolGrad");vu(Au.rank===mu.rank,()=>`Rank of input (${Au.rank}) does not match rank of dy (${mu.rank})`),vu(mu.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${mu.rank}.`),vu(Au.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${Au.rank}.`),ky("maxPoolGrad",hu,pu);const Cu={dy:mu,input:Au,output:bu},wu={filterSize:lu,strides:cu,pad:hu,dimRoundingMode:pu};return Tp.runKernel(eS,Cu,wu)}const FW=Fp({maxPoolGrad_:DW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const PW={kernelName:nE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const[lu,cu]=nu,{filterSize:hu,strides:pu,pad:mu}=ru;return{x:()=>FW(ou,lu,cu,hu,pu,mu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const GW={kernelName:rE,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{axis:cu}=ru,hu=Wu(cu,lu.shape),pu=oy(lu.shape,hu)[1],mu=Mu(pu);return{x:()=>{const Au=lu.shape.slice();hu.forEach(Cu=>{Au[Cu]=1});const bu=Pp(ou,Au);return Xm(_p(bu,Iv(lu.shape,"float32")),mu)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const OW={kernelName:sE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const lu=ru,{axis:cu}=lu,[hu,pu]=nu,mu=Wu(cu,hu.shape),Au=dB(ou,pu,hu,mu);return{x:()=>Au.x()}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UW={kernelName:MC,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu;return{a:()=>_p(ou,km(j1(ru,lu),"float32")),b:()=>_p(ou,km(Yy(ru,lu),"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $W={kernelName:oE,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const lu=nu[0],{paddings:cu}=ru,hu=cu.map(pu=>pu[0]);return{x:()=>E0(ou,hu,lu.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const VW={kernelName:RC,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{const hu=J0(ru.shape,cu);return hu.length>0?Pp(zm(ou,hu),ru.shape):ou},b:()=>{const hu=_p(ou,X0($E(Xm(ru,lu)))),pu=J0(lu.shape,cu);return pu.length>0?Pp(zm(hu,pu),lu.shape):hu}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zW={kernelName:kC,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{const hu=_p(ou,km(lu,"float32")),pu=J0(ru.shape,cu);return pu.length>0?Pp(zm(hu,pu),ru.shape):hu},b:()=>{const hu=_p(ou,km(ru,"float32")),pu=J0(lu.shape,cu);return pu.length>0?Pp(zm(hu,pu),lu.shape):hu}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WW={kernelName:aE,gradFunc:ou=>({x:()=>X0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const HW={kernelName:uE,inputsToSave:["indices"],gradFunc:(ou,nu)=>{const ru=nu[0];return{indices:()=>ay(ru.shape,"float32")}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XW={kernelName:cE,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const QW={kernelName:hE,saveAllInputs:!0,gradFunc:(ou,nu,ru)=>{const{axis:lu}=ru;return d1(ou,lu).map(cu=>()=>cu)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fB={kernelName:dE,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const lu=nu[0],{paddings:cu}=ru,hu=cu.map(pu=>pu[0]);return{x:()=>E0(ou,hu,lu.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KW={kernelName:BC,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(ou,nu)=>{const[ru,lu,cu]=nu,hu=ru,pu=lu,mu=_g(hu.shape,pu.shape);return{a:()=>{const Au=km(pu,"float32");let bu=_p(ou,_p(Au,Z1(hu,Qm(Au,A0(1)))));const Cu=J0(hu.shape,mu);return Cu.length>0&&(bu=zm(bu,Cu)),Pp(bu,hu.shape)},b:()=>{const Au=Yy(hu,0),bu=Cy(Au,Ox(hu),l0(hu));let Cu=_p(ou,_p(cu,bu));const wu=J0(pu.shape,mu);return wu.length>0&&(Cu=zm(Cu,wu)),Pp(Cu,pu.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZW={kernelName:pE,inputsToSave:["x","alpha"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=Yy(ru,0);return{x:()=>Cy(cu,ou,_p(ou,lu)),alpha:()=>{let hu=Cy(cu,l0(ou),_p(ou,ru));const pu=J0(lu.shape,ou.shape);return pu.length>0&&(hu=zm(hu,pu)),Pp(hu,lu.shape)}}}};/**
* @license
* Copyright 2022 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jW(ou,nu,ru){const lu=ou.shape.slice();lu[ru]=1;const cu=Pp(nu,lu),hu=zS(ou,ru,!0,!1),pu=zS(ou,ru,!0,!0),mu=_p(hu,pu);return _p(cu,mu)}function YW(ou,nu,ru){const lu=ou.shape.length,cu=lu-ru.length,hu=G0(ru,lu);let pu=ou;hu!=null&&(pu=c0(ou,hu));const mu=pu.shape.slice(),Au=mu.splice(lu-ru.length,ru.length).reduce((wu,Eu)=>wu*Eu,1);mu.push(Au);const bu=pu.reshape(mu);let Cu=jW(bu,nu,cu);if(Cu=Cu.reshape(pu.shape),hu!=null){const wu=Ev(hu);Cu=c0(Cu,wu)}return Cu}const qW={kernelName:fE,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{axis:cu}=ru;let hu=[];return cu==null?hu=lu.shape.map((pu,mu)=>mu):typeof cu=="number"?hu=[cu]:hu=cu,{x:()=>YW(lu,ou,hu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const JW={kernelName:Gp,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{const hu=Xm(ou,km(lu,"float32")),pu=J0(ru.shape,cu);return pu.length>0?Pp(zm(hu,pu),ru.shape):hu},b:()=>{let hu=_p(ou,km(ru,"float32"));const pu=J0(lu.shape,cu);pu.length>0&&(hu=Pp(zm(hu,pu),lu.shape));const mu=k0(lu);return X0(Xm(hu,km(mu,"float32")))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const e5={kernelName:LC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,X0(k0(ru)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const t5={kernelName:DC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu,lu=_p(j1(ru,6),pw(ru));return{x:()=>_p(ou,km(lu,"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const n5={kernelName:NC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,km(pw(ru),"float32"))}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const i5={kernelName:mE,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Pp(ou,ru.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const r5={kernelName:AE,inputsToSave:["images"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,cu={dy:ou,images:lu};return{images:()=>Tp.runKernel(lS,cu,ru)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s5={kernelName:gE,inputsToSave:["images"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,cu={dy:ou,images:lu};return{images:()=>Tp.runKernel(aS,cu,ru)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const o5={kernelName:yE,gradFunc:(ou,nu,ru)=>{const{dims:lu}=ru,cu=Wu(lu,ou.shape);return{x:()=>u1(ou,cu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const a5={kernelName:FC,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const l5={kernelName:PC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>X0(Xm(ou,_p(Z1(ru,1.5),2)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const c5={kernelName:bE,inputsToSave:["condition"],gradFunc:(ou,nu)=>{const[ru]=nu;return{condition:()=>km(l0(ru),"float32"),t:()=>_p(ou,km(ru,ou.dtype)),e:()=>_p(ou,km(ZS(ru),ou.dtype))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const u5={kernelName:GC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>{const lu=Yy(ru,A0(0)),cu=A0(ZE),hu=A0(jE),pu=_p(ou,hu),mu=_p(_p(ou,cu),Gx(km(ru,"float32")));return Cy(lu,pu,mu)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const h5={kernelName:VC,outputsToSave:[!0],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,_p(ru,Qm(A0(1),ru)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const d5={kernelName:$C,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const p5={kernelName:OC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(VS(km(ru,"float32")),ou)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f5={kernelName:UC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(UM(km(ru,"float32")),ou)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const m5={kernelName:xE,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{begin:cu,size:hu}=ru,pu=lu.shape,[mu,Au]=XE(lu,cu,hu),bu=[];for(let Cu=0;Cu<ou.rank;Cu++)bu.push([mu[Cu],pu[Cu]-mu[Cu]-Au[Cu]]);return{x:()=>qS(ou,bu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const g5={kernelName:EE,outputsToSave:[!0],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{dim:cu}=ru,hu=!0,pu=_p(ou,lu);return{logits:()=>Qm(pu,_p(zm(pu,[cu],hu),lu))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const A5={kernelName:zC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,Q1(ru))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mB={kernelName:CE,gradFunc:(ou,nu,ru)=>{const{blockShape:lu,paddings:cu}=ru;return{x:()=>US(ou,lu,cu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gB={kernelName:wE,gradFunc:(ou,nu,ru)=>{const{axis:lu}=ru;return{x:()=>By(ou,lu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const y5={kernelName:WC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,_p(wy(km(ru,"float32")),2))}}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const b5={kernelName:cS,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(ou,_p(km(ru,"float32"),2))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const x5={kernelName:HC,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=A0(2);return{a:()=>_p(ou,_p(cu,Qm(ru,lu))),b:()=>_p(ou,_p(cu,Qm(lu,ru)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const v5={kernelName:jC,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const C5={kernelName:XC,inputsToSave:["a","b"],gradFunc:(ou,nu)=>{const[ru,lu]=nu,cu=_g(ru.shape,lu.shape);return{a:()=>{let hu=ou;const pu=J0(ru.shape,cu);return pu.length>0&&(hu=zm(hu,pu)),Pp(hu,ru.shape)},b:()=>{let hu=ou;const pu=J0(lu.shape,cu);return pu.length>0&&(hu=zm(hu,pu)),Pp(X0(hu),lu.shape)}}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const w5={kernelName:vE,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,cu=lu.shape.slice(),{axis:hu}=ru;Wu(hu,lu.shape).forEach(Au=>{cu[Au]=1});const pu=Pp(ou,cu),mu=_p(pu,Iv(lu.shape,"float32"));return{x:()=>mu}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const E5={kernelName:QC,inputsToSave:["x"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>Xm(ou,k0(VS(ru)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S5={kernelName:KC,outputsToSave:[!0],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>_p(Qm(A0(1),k0(ru)),ou)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const I5={kernelName:ZC,inputsToSave:["x"],gradFunc:(ou,nu,ru)=>{const[lu]=nu,{reps:cu}=ru;return{x:()=>{let hu=l0(lu);if(lu.rank===1)for(let pu=0;pu<cu[0];++pu)hu=Am(hu,E0(ou,[pu*lu.shape[0]],[lu.shape[0]]));else if(lu.rank===2)for(let pu=0;pu<cu[0];++pu)for(let mu=0;mu<cu[1];++mu)hu=Am(hu,E0(ou,[pu*lu.shape[0],mu*lu.shape[1]],[lu.shape[0],lu.shape[1]]));else if(lu.rank===3)for(let pu=0;pu<cu[0];++pu)for(let mu=0;mu<cu[1];++mu)for(let Au=0;Au<cu[2];++Au)hu=Am(hu,E0(ou,[pu*lu.shape[0],mu*lu.shape[1],Au*lu.shape[2]],[lu.shape[0],lu.shape[1],lu.shape[2]]));else if(lu.rank===4)for(let pu=0;pu<cu[0];++pu)for(let mu=0;mu<cu[1];++mu)for(let Au=0;Au<cu[2];++Au)for(let bu=0;bu<cu[3];++bu)hu=Am(hu,E0(ou,[pu*lu.shape[0],mu*lu.shape[1],Au*lu.shape[2],bu*lu.shape[3]],[lu.shape[0],lu.shape[1],lu.shape[2],lu.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${lu.rank} tensors yet.`);return hu}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const T5={kernelName:G1,gradFunc:(ou,nu,ru)=>{const lu=ru,{perm:cu}=lu,hu=Ev(cu);return{x:()=>c0(ou,hu)}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _5={kernelName:SE,gradFunc:(ou,nu,ru)=>{const lu=ru,{axis:cu}=lu;return{value:()=>Ux(ou,cu)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const M5={kernelName:IE,inputsToSave:["segmentIds"],gradFunc:(ou,nu)=>{const[ru]=nu;return{x:()=>R5(ou,ru)}}};function R5(ou,nu){const ru=Sv(nu,l0(nu)),lu=XS(ou,ru);let cu=a1(nu,A0(0,"int32"));const hu=lu.rank-cu.rank;for(let mu=0;mu<hu;++mu)cu=Ly(cu,mu+1);cu=iv(cu,Iv(lu.shape,"bool"));const pu=l0(lu);return Cy(cu,lu,pu)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const k5={kernelName:TE,gradFunc:ou=>({x:()=>l0(ou)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const B5=[cB,Mz,Rz,kz,Bz,Lz,Nz,Dz,Fz,Pz,Gz,Oz,Vz,Hz,Xz,Qz,Kz,Zz,jz,Yz,qz,Jz,tW,eW,rW,sW,oW,aW,lW,cW,JW,uW,hW,dW,pW,fW,gW,mW,AW,yW,bW,xW,vW,CW,wW,EW,SW,IW,TW,RW,pB,pB,kW,NW,PW,GW,OW,UW,$W,VW,zW,WW,HW,XW,QW,fB,fB,KW,ZW,qW,e5,t5,n5,i5,r5,s5,o5,a5,l5,c5,u5,h5,d5,p5,f5,m5,g5,A5,mB,mB,gB,gB,y5,x5,b5,v5,C5,w5,E5,S5,I5,T5,_5,M5,k5];for(const ou of B5)lP(ou);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.abs=function(){return this.throwIfDisposed(),vy(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.acos=function(){return this.throwIfDisposed(),uG(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.acosh=function(){return this.throwIfDisposed(),dG(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.add=function(ou){return this.throwIfDisposed(),Am(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.all=function(ou,nu){return this.throwIfDisposed(),FM(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.any=function(ou,nu){return this.throwIfDisposed(),DS(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.argMax=function(ou){return this.throwIfDisposed(),nw(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.argMin=function(ou){return this.throwIfDisposed(),AG(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.asScalar=function(){return this.throwIfDisposed(),vu(this.size===1,()=>"The array must have only 1 element."),Pp(this,[])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.asType=function(ou){return this.throwIfDisposed(),km(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.as1D=function(){return this.throwIfDisposed(),Pp(this,[this.size])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.as2D=function(ou,nu){return this.throwIfDisposed(),Pp(this,[ou,nu])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.as3D=function(ou,nu,ru){return this.throwIfDisposed(),Pp(this,[ou,nu,ru])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.as4D=function(ou,nu,ru,lu){return this.throwIfDisposed(),Pp(this,[ou,nu,ru,lu])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.as5D=function(ou,nu,ru,lu,cu){return this.throwIfDisposed(),Pp(this,[ou,nu,ru,lu,cu])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.asin=function(){return this.throwIfDisposed(),bG(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.asinh=function(){return this.throwIfDisposed(),vG(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.atan=function(){return this.throwIfDisposed(),wG(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.atan2=function(ou){return this.throwIfDisposed(),SG(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.atanh=function(){return this.throwIfDisposed(),TG(this)},Jp().prototype.avgPool=function(ou,nu,ru,lu){return this.throwIfDisposed(),GS(this,ou,nu,ru,lu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.batchToSpaceND=function(ou,nu){return this.throwIfDisposed(),US(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.batchNorm=function(ou,nu,ru,lu,cu){return this.throwIfDisposed(),FE(this,ou,nu,ru,lu,cu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.broadcastTo=function(ou){return this.throwIfDisposed(),ow(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.cast=function(ou){return this.throwIfDisposed(),km(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.ceil=function(){return this.throwIfDisposed(),eO(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.clipByValue=function(ou,nu){return this.throwIfDisposed(),jy(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.concat=function(ou,nu){return this.throwIfDisposed(),ou instanceof q0&&(ou=[ou]),By([this,...ou],nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.conv1d=function(ou,nu,ru,lu,cu,hu){return this.throwIfDisposed(),PM(this,ou,nu,ru,lu,cu,hu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.conv2dTranspose=function(ou,nu,ru,lu,cu){return this.throwIfDisposed(),GM(this,ou,nu,ru,lu,cu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.conv2d=function(ou,nu,ru,lu,cu,hu){return this.throwIfDisposed(),o1(this,ou,nu,ru,lu,cu,hu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.cos=function(){return this.throwIfDisposed(),VS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.cosh=function(){return this.throwIfDisposed(),UM(this)};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.cumprod=function(ou,nu,ru){return this.throwIfDisposed(),zS(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.cumsum=function(ou,nu,ru){return this.throwIfDisposed(),$M(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.depthToSpace=function(ou,nu){return this.throwIfDisposed(),SO(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.depthwiseConv2d=function(ou,nu,ru,lu,cu,hu){return this.throwIfDisposed(),WS(this,ou,nu,ru,lu,cu,hu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.dilation2d=function(ou,nu,ru,lu,cu){return this.throwIfDisposed(),_O(this,ou,nu,ru,lu,cu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.divNoNan=function(ou){return this.throwIfDisposed(),LO(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.div=function(ou){return this.throwIfDisposed(),Xm(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.dot=function(ou){return this.throwIfDisposed(),DO(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.elu=function(){return this.throwIfDisposed(),GE(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.equal=function(ou){return this.throwIfDisposed(),Px(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.erf=function(){return this.throwIfDisposed(),OO(this)};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.euclideanNorm=function(ou,nu){return this.throwIfDisposed(),KO(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.exp=function(){return this.throwIfDisposed(),Gx(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.expandDims=function(ou){return this.throwIfDisposed(),Ly(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.expm1=function(){return this.throwIfDisposed(),qO(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.fft=function(){return this.throwIfDisposed(),pR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.flatten=function(){return this.throwIfDisposed(),Pp(this,[this.size])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.floor=function(){return this.throwIfDisposed(),$E(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.floorDiv=function(ou){return this.throwIfDisposed(),DM(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.gather=function(ou,nu,ru){return this.throwIfDisposed(),XS(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.greaterEqual=function(ou){return this.throwIfDisposed(),a1(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.greater=function(ou){return this.throwIfDisposed(),Yy(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.ifft=function(){return this.throwIfDisposed(),sI(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.irfft=function(){return this.throwIfDisposed(),$$(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.isFinite=function(){return this.throwIfDisposed(),aU(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.isInf=function(){return this.throwIfDisposed(),cU(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.isNaN=function(){return this.throwIfDisposed(),hU(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.leakyRelu=function(ou){return this.throwIfDisposed(),KS(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.lessEqual=function(ou){return this.throwIfDisposed(),j1(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.less=function(ou){return this.throwIfDisposed(),VE(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.localResponseNormalization=function(ou,nu,ru,lu){return this.throwIfDisposed(),gU(this,ou,nu,ru,lu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logSigmoid=function(){return this.throwIfDisposed(),wU(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logSoftmax=function(ou){return this.throwIfDisposed(),QM(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logSumExp=function(ou,nu){return this.throwIfDisposed(),KM(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.log=function(){return this.throwIfDisposed(),Ox(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.log1p=function(){return this.throwIfDisposed(),XM(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logicalAnd=function(ou){return this.throwIfDisposed(),iv(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logicalNot=function(){return this.throwIfDisposed(),ZS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logicalOr=function(ou){return this.throwIfDisposed(),ZM(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.logicalXor=function(ou){return this.throwIfDisposed(),kU(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.matMul=function(ou,nu,ru){return this.throwIfDisposed(),g0(this,ou,nu,ru)},Jp().prototype.maxPool=function(ou,nu,ru,lu){return this.throwIfDisposed(),jS(this,ou,nu,ru,lu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.max=function(ou,nu){return this.throwIfDisposed(),vx(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.maximum=function(ou){return this.throwIfDisposed(),Sv(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.mean=function(ou,nu){return this.throwIfDisposed(),Y0(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.min=function(ou,nu){return this.throwIfDisposed(),OE(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.minimum=function(ou){return this.throwIfDisposed(),cw(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.mirrorPad=function(ou,nu){return this.throwIfDisposed(),OU(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.mod=function(ou){return this.throwIfDisposed(),$U(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.mul=function(ou){return this.throwIfDisposed(),_p(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.neg=function(){return this.throwIfDisposed(),X0(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.norm=function(ou,nu,ru){return this.throwIfDisposed(),UE(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.notEqual=function(ou){return this.throwIfDisposed(),zE(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.oneHot=function(ou,nu=1,ru=0){return this.throwIfDisposed(),jM(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.onesLike=function(){return this.throwIfDisposed(),ax(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.pad=function(ou,nu){return this.throwIfDisposed(),qS(this,ou,nu)},Jp().prototype.pool=function(ou,nu,ru,lu,cu,hu){return this.throwIfDisposed(),YU(this,ou,nu,ru,lu,cu,hu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.pow=function(ou){return this.throwIfDisposed(),Z1(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.prelu=function(ou){return this.throwIfDisposed(),eI(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.prod=function(ou,nu){return this.throwIfDisposed(),e$(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.reciprocal=function(){return this.throwIfDisposed(),v$(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.relu=function(){return this.throwIfDisposed(),c1(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.relu6=function(){return this.throwIfDisposed(),sR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.reshapeAs=function(ou){return this.throwIfDisposed(),Pp(this,ou.shape)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.reshape=function(ou){return this.throwIfDisposed(),Pp(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.resizeBilinear=function(ou,nu,ru){return this.throwIfDisposed(),xR(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.resizeNearestNeighbor=function(ou,nu,ru){return this.throwIfDisposed(),vR(this,ou,nu,ru)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.reverse=function(ou){return this.throwIfDisposed(),u1(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.rfft=function(){return this.throwIfDisposed(),W$(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.round=function(){return this.throwIfDisposed(),oR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.rsqrt=function(){return this.throwIfDisposed(),aR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.selu=function(){return this.throwIfDisposed(),lR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.separableConv2d=function(ou,nu,ru,lu,cu,hu){return this.throwIfDisposed(),cR(this,ou,nu,ru,lu,cu,hu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sigmoid=function(){return this.throwIfDisposed(),Q1(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sign=function(){return this.throwIfDisposed(),R$(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sin=function(){return this.throwIfDisposed(),uR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sinh=function(){return this.throwIfDisposed(),hR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.slice=function(ou,nu){return this.throwIfDisposed(),E0(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.softmax=function(ou){return this.throwIfDisposed(),rI(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.softplus=function(){return this.throwIfDisposed(),lw(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.spaceToBatchND=function(ou,nu){return this.throwIfDisposed(),JS(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.split=function(ou,nu){return this.throwIfDisposed(),qy(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sqrt=function(){return this.throwIfDisposed(),wy(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.square=function(){return this.throwIfDisposed(),k0(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.squaredDifference=function(ou){return this.throwIfDisposed(),X$(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.squeeze=function(ou){return this.throwIfDisposed(),dw(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.stack=function(ou,nu){this.throwIfDisposed();const ru=ou instanceof q0?[this,ou]:[this,...ou];return Ux(ru,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.step=function(ou){return this.throwIfDisposed(),pw(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.stridedSlice=function(ou,nu,ru,lu,cu,hu,pu,mu){return this.throwIfDisposed(),Y$(this,ou,nu,ru,lu,cu,hu,pu,mu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sub=function(ou){return this.throwIfDisposed(),Qm(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.sum=function(ou,nu){return this.throwIfDisposed(),zm(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.tan=function(){return this.throwIfDisposed(),J$(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.tanh=function(){return this.throwIfDisposed(),OS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.tile=function(ou){return this.throwIfDisposed(),Cx(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.toBool=function(){return this.throwIfDisposed(),km(this,"bool")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.toFloat=function(){return this.throwIfDisposed(),km(this,"float32")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.toInt=function(){return this.throwIfDisposed(),km(this,"int32")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.topk=function(ou,nu){return this.throwIfDisposed(),iV(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.transpose=function(ou){return this.throwIfDisposed(),c0(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.unique=function(ou){return this.throwIfDisposed(),oV(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.unsortedSegmentSum=function(ou,nu){return this.throwIfDisposed(),gR(this,ou,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.unstack=function(ou){return this.throwIfDisposed(),d1(this,ou)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.where=function(ou,nu){return this.throwIfDisposed(),Cy(ou,this,nu)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Jp().prototype.zerosLike=function(){return this.throwIfDisposed(),l0(this)};/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class Vx extends Error{constructor(nu){super(nu),Object.setPrototypeOf(this,Vx.prototype)}}class cx extends Error{constructor(nu){super(nu),Object.setPrototypeOf(this,cx.prototype)}}class Ep extends Error{constructor(nu){super(nu),Object.setPrototypeOf(this,Ep.prototype)}}class e0 extends Error{constructor(nu){super(nu),Object.setPrototypeOf(this,e0.prototype)}}class HI extends Error{constructor(nu){super(nu),Object.setPrototypeOf(this,HI.prototype)}}/**
* @license
* Copyright 2022 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class AB{constructor(nu){this.maxEntries=nu||100,this.cache=new Map}get(nu){let ru;return this.cache.has(nu)&&(ru=this.cache.get(nu),this.cache.delete(nu),this.cache.set(nu,ru)),ru}put(nu,ru){if(this.cache.has(nu))this.cache.delete(nu);else if(this.cache.size>=this.maxEntries){const lu=this.cache.keys().next().value;this.cache.delete(lu)}this.cache.set(nu,ru)}getMaxEntries(){return this.maxEntries}setMaxEntries(nu){if(nu<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${nu}.`);if(this.maxEntries>nu)for(let ru=0;ru<this.maxEntries-nu;ru++){const lu=this.cache.keys().next().value;this.cache.delete(lu)}this.maxEntries=nu}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function f1(ou,nu){if(Array.isArray(ou)){let ru=[];for(let lu=0;lu<nu;lu++)ru=ru.concat(ou);return ru}else{const ru=new Array(nu);return ru.fill(ou),ru}}function zx(ou,nu){if(!ou)throw new HI(nu)}function yB(ou,nu){let ru=0;for(const lu of ou)lu===nu&&ru++;return ru}function Ny(ou){return ou.length===1?ou[0]:ou}function y0(ou){return Array.isArray(ou)?ou:[ou]}function av(ou){const nu=ou.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return nu[0]!=="_"?nu:"private"+nu}function m1(ou){return ou.length<=1||ou.indexOf("_")===-1?ou:ou.replace(/[_]+(\w|$)/g,(nu,ru)=>ru.toUpperCase())}let ux={};function XI(ou){if(ou==null)return null;const nu={};return nu.className=ou.getClassName(),nu.config=ou.getConfig(),nu}function QI(ou){if(!(ou==null||typeof ou!="object"))if(Array.isArray(ou))ou.forEach(nu=>QI(nu));else{const nu=Object.keys(ou);for(const ru of nu){const lu=ou[ru];lu!=null&&typeof lu=="object"&&(!Array.isArray(lu)&&lu.type==="ndarray"&&typeof lu.value=="number"?ou[ru]=lu.value:QI(lu))}}}function Aw(ou,nu={},ru={},lu="object",cu=!1){if(typeof ou=="string"){const hu=ou;let pu;if(hu in ru)pu=ru[hu];else if(hu in ux)pu=ux[hu];else if(pu=nu[hu],pu==null)throw new Ep(`Unknown ${lu}: ${ou}. This may be due to one of the following reasons:
1. The ${lu} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${lu} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return pu}else{const hu=ou;if(hu.className==null||hu.config==null)throw new Ep(`${lu}: Improper config format: ${JSON.stringify(hu)}.
'className' and 'config' must set.`);const pu=hu.className;let mu,Au;if(pu in ru?[mu,Au]=ru[pu]:pu in ux?[mu,Au]=ux.className:pu in nu&&([mu,Au]=nu[pu]),mu==null)throw new Ep(`Unknown ${lu}: ${pu}. This may be due to one of the following reasons:
1. The ${lu} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${lu} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(Au!=null){const bu={};for(const Tu of Object.keys(ux))bu[Tu]=ux[Tu];for(const Tu of Object.keys(ru))bu[Tu]=ru[Tu];const Cu=hu.config;Cu.customObjects=bu;const wu=Object.assign({},ux);for(const Tu of Object.keys(ru))ux[Tu]=ru[Tu];QI(hu.config);const Eu=Au(mu,hu.config,ru,cu);return ux=Object.assign({},wu),Eu}else{const bu=Object.assign({},ux);for(const wu of Object.keys(ru))ux[wu]=ru[wu];const Cu=new mu(hu.config);return ux=Object.assign({},bu),Cu}}}function L5(ou,nu){return ou<nu?-1:ou>nu?1:0}function YE(ou,nu){return-1*L5(ou,nu)}function _v(ou){if(ou==null)return ou;const nu=[];for(const ru of ou)nu.indexOf(ru)===-1&&nu.push(ru);return nu}function N5(ou){if(ou==null)throw new Ep(`Invalid value in obj: ${JSON.stringify(ou)}`);for(const nu in ou)if(ou.hasOwnProperty(nu))return!1;return!0}function g1(ou,nu,ru){if(ru!=null&&ou.indexOf(ru)<0)throw new Ep(`${ru} is not a valid ${nu}.  Valid values are ${ou} or null/undefined.`)}function KI(ou,nu,ru=0,lu=1/0){return zx(ru>=0),zx(lu>=ru),Array.isArray(ou)&&ou.length>=ru&&ou.length<=lu&&ou.every(cu=>typeof cu===nu)}function ly(ou,nu){Array.isArray(ou)?(vu(ou.length>0,()=>`${nu} is unexpectedly an empty array.`),ou.forEach((ru,lu)=>ly(ru,`element ${lu+1} of ${nu}`))):vu(Number.isInteger(ou)&&ou>0,()=>`Expected ${nu} to be a positive integer, but got ${bB(ou)}.`)}function bB(ou){return ou===null?"null":Array.isArray(ou)?"["+ou.map(nu=>bB(nu)).join(",")+"]":typeof ou=="string"?`"${ou}"`:`${ou}`}function D5(ou,nu,ru){let lu=ru!=null?ru():My(),cu;return(...hu)=>{const pu=ru!=null?ru():My();return pu-lu<nu||(lu=pu,cu=ou(...hu)),cu}}function xB(ou){return ou==="relu"?"relu":ou==="linear"?"linear":ou==="elu"?"elu":null}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let F5=0;function vB(){return F5++}const qE={};function JE(ou=""){return ou in qE||(qE[ou]=0),qE[ou]+=1,ou+qE[ou].toString()}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const P5=["channelsFirst","channelsLast"],G5=["nearest","bilinear"],O5=["valid","same","causal"],U5=["max","avg"],$5=["sum","mul","concat","ave"];/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const tC=new Map;function Q0(ou){g1(P5,"DataFormat",ou)}function V5(ou){g1(G5,"InterpolationFormat",ou)}function Jy(ou){g1(O5,"PaddingMode",ou)}function CB(ou){g1(U5,"PoolMode",ou)}const yw=[],wB="/";function A1(ou,nu){yw.push(ou);try{const ru=nu();return yw.pop(),ru}catch(ru){throw yw.pop(),ru}}function z5(){return yw.length===0?"":yw.join(wB)+wB}function EB(ou){if(!IB(ou))throw new Error("Not a valid tensor name: '"+ou+"'");return z5()+ou}function SB(ou){if(!IB(ou))throw new Error("Not a valid tensor name: '"+ou+"'");tC.has(ou)||tC.set(ou,0);const nu=tC.get(ou);if(tC.set(ou,tC.get(ou)+1),nu>0){const ru=`${ou}_${nu}`;return tC.set(ru,1),ru}else return ou}const W5=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function IB(ou){return!!ou.match(W5)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function H5(ou){return ou===parseInt(ou.toString(),10)}function Mv(ou,nu,ru){nu==null&&(nu=0),ru==null&&(ru=ou.length);let lu=1;for(let cu=nu;cu<ru;++cu)lu*=ou[cu];return lu}function nC(ou){if(ou.length===0)return Number.NaN;let nu=Number.POSITIVE_INFINITY;for(let ru=0;ru<ou.length;ru++){const lu=ou[ru];lu<nu&&(nu=lu)}return nu}function Rv(ou){if(ou.length===0)return Number.NaN;let nu=Number.NEGATIVE_INFINITY;for(let ru=0;ru<ou.length;ru++){const lu=ou[ru];lu>nu&&(nu=lu)}return nu}function Ex(ou,nu){if(nu<ou)throw new Ep(`end (${nu}) < begin (${ou}) is forbidden.`);const ru=[];for(let lu=ou;lu<nu;++lu)ru.push(lu);return ru}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let ZI;function ey(){return ZI==null&&(ZI=vv().epsilon()),ZI}function Sx(){return"channelsLast"}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function lv(ou,nu){return km(ou,nu)}function bw(ou,nu=-1){const ru=ou.shape.slice();return nu<0&&(nu=ru.length+nu+1),ru.splice(nu,0,1),Pp(ou,ru)}function X5(ou,nu){return Op(()=>{if(ou.shape.length!==2)throw new Ep(`repeat() expects a rank-2 tensor, but received a rank-${ou.shape.length} tensor.`);const ru=bw(ou,1);return qI(ru,[1,nu,1])})}function Q5(ou){const nu=[Mv(ou.shape)];return Pp(ou,nu)}function K5(ou){if(ou.rank<=1)throw new Ep(`batchFlatten requires a minimum rank of 2. Got rank: ${ou.rank}.`);const nu=[ou.shape[0],Mv(ou.shape,1)];return Pp(ou,nu)}function y1(ou,nu,ru){return Op(()=>{switch(ou.rank){case 1:return nI(ou,nu,ru);case 2:return dR(ou,[nu,0],[ru,ou.shape[1]]);case 3:return iI(ou,[nu,0,0],[ru,ou.shape[1],ou.shape[2]]);case 4:return HE(ou,[nu,0,0,0],[ru,ou.shape[1],ou.shape[2],ou.shape[3]]);case 5:return E0(ou,[nu,0,0,0,0],[ru,ou.shape[1],ou.shape[2],ou.shape[3],ou.shape[4]]);case 6:return E0(ou,[nu,0,0,0,0,0],[ru,ou.shape[1],ou.shape[2],ou.shape[3],ou.shape[4],ou.shape[5]]);default:throw new Ep(`sliceAlongFirstAxis() received an unsupported tensor rank: ${ou.rank}`)}})}function jI(ou,nu,ru){return Op(()=>{switch(ou.rank){case 1:return nI(ou,nu,ru);case 2:return dR(ou,[0,nu],[ou.shape[0],ru]);case 3:return iI(ou,[0,0,nu],[ou.shape[0],ou.shape[1],ru]);case 4:return HE(ou,[0,0,0,nu],[ou.shape[0],ou.shape[1],ou.shape[2],ru]);default:throw new Ep(`sliceAlongLastAxis() received an unsupported tensor rank: ${ou.rank}`)}})}function e2(ou,nu,ru,lu){return Op(()=>{switch(ou.rank){case 1:return nI(ou,nu,ru);case 2:switch(lu){case 1:return y1(ou,nu,ru);case 2:return jI(ou,nu,ru);default:throw new Ep(`The axis is not within the rank of the tensor ${lu}`)}case 3:switch(lu){case 1:return y1(ou,nu,ru);case 2:return iI(ou,[0,nu,0],[ou.shape[0],ru,ou.shape[2]]);case 3:return jI(ou,nu,ru);default:throw new Ep(`The axis is not within the rank of the tensor ${lu}`)}case 4:switch(lu){case 1:return y1(ou,nu,ru);case 2:return HE(ou,[0,nu,0,0],[ou.shape[0],ru,ou.shape[2],ou.shape[3]]);case 3:return HE(ou,[0,0,nu,0],[ou.shape[0],ou.shape[1],ru,ou.shape[3]]);case 4:return jI(ou,nu,ru);default:throw new Ep(`The axis is not within the rank of the tensor ${lu}`)}default:throw new Ep(`sliceAlongLastAxis() received an unsupported tensor rank: ${ou.rank}`)}})}function YI(ou,nu=-1){let ru;return nu<0&&(ru=ou[0].rank,ru!==0?nu=ru:nu=0),nu===ou[0].rank&&(nu=-1),By(ou,nu)}function TB(ou,nu){switch(ou.rank){case 1:return iO([ou,nu]);case 2:return sO([ou,nu],0);case 3:return aO([ou,nu],0);case 4:return cO([ou,nu],0);default:throw new Ep(`concatAlongFirstAxis() received an unsupported tensor rank: ${ou.rank}`)}}function qI(ou,nu){if(Array.isArray(nu)||(nu=[nu]),ou.rank!==nu.length)throw new Ep(`The length of input n (${nu.length}) does not match the number of dimensions in input x (${ou.rank})`);return Cx(ou,nu)}function t2(ou,nu=0,ru=1,lu,cu){return A$(ou,nu,ru,lu,cu)}function Wx(ou,nu,ru,lu){if(ou.rank<2||nu.rank<2)throw new e0(`dot requires both inputs to be rank >= 2 but got x shape = ${ou.shape} and y shape = ${nu.shape}`);if(nu.rank>=3){const cu=ou.shape.slice(-1)[0],hu=nu.shape.slice(-2)[0];if(cu!==hu)throw new e0(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${ou.shape} and  y shape = ${nu.shape}`)}if(ou.rank===2&&nu.rank===2)return yR({a:ou,b:nu,transposeA:!1,transposeB:!1,bias:lu?JI(ou.rank,lu,Sx()):null,activation:ru});{const cu=ou.shape.slice(),hu=cu.pop();ou=Pp(ou,[-1,hu]);const pu=nu.shape.slice(),mu=pu.pop(),Au=pu.pop(),bu=[...pu,mu],Cu=Array.from({length:nu.rank},(Eu,Tu)=>Tu===0?nu.rank-2:Tu<=nu.rank-2?Tu-1:Tu);nu=Pp(c0(nu,Cu),[Au,-1]);const wu=[...cu,...bu];return Pp(yR({a:ou,b:nu,transposeA:!1,transposeB:!1,bias:lu?JI(ou.rank,lu,Sx()):null,activation:ru}),wu)}}function _B(ou,nu,ru){return Op(()=>(Array.isArray(nu)?nu=$y(nu,"int32"):nu=km(nu,"int32"),XS(ou,nu,ru)))}function xw(ou){return _p(ou,ou)}function JI(ou,nu,ru){const lu=nu.shape;if(nu.rank!==1&&nu.rank!==ou)throw new Ep(`Unexpected bias dimensions: ${nu.rank}; expected it to be 1 or ${ou}`);if(ou===5){if(ru==="channelsFirst")return lu.length===1?Pp(nu,[1,lu[0],1,1,1]):Pp(nu,[1,lu[3],lu[0],lu[1],lu[2]]);if(ru==="channelsLast")return lu.length===1?Pp(nu,[1,1,1,1,lu[0]]):Pp(nu,[1].concat(lu))}else if(ou===4){if(ru==="channelsFirst")return lu.length===1?Pp(nu,[1,lu[0],1,1]):Pp(nu,[1,lu[2],lu[0],lu[1]]);if(ru==="channelsLast")return lu.length===1?Pp(nu,[1,1,1,lu[0]]):Pp(nu,[1].concat(lu))}else if(ou===3){if(ru==="channelsFirst")return lu.length===1?Pp(nu,[1,lu[0],1]):Pp(nu,[1,lu[1],lu[0]]);if(ru==="channelsLast")return lu.length===1?Pp(nu,[1,1,lu[0]]):Pp(nu,[1].concat(lu))}else if(ou<3)return nu;throw new Ep(`Unsupported input rank by biasAdd: ${nu.rank}`)}function Ix(ou,nu,ru){return Op(()=>(ru==null&&(ru=Sx()),Q0(ru),Am(ou,JI(ou.rank,nu,ru))))}function Z5(ou,nu=1){if(nu!==1)throw new e0(`Support for alpha values other than 1 (${nu}) is not implemented yet.`);return GE(ou)}function j5(ou){return Op(()=>Xm(ou,Am(vy(ou),1)))}function MB(ou,nu,ru,lu){return Op(()=>pV(ou,nu,ru,lu))}function Y5(ou){return Op(()=>{const nu=Am(.5,_p(.2,ou));return jy(nu,0,1)})}function vw(ou,nu,ru=!1){return ru?ou():nu()}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const q5=["fanIn","fanOut","fanAvg"],J5=["normal","uniform","truncatedNormal"];/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function eH(ou){g1(q5,"FanMode",ou)}function tH(ou){g1(J5,"Distribution",ou)}class hx extends J1{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class RB extends hx{apply(nu,ru){return ay(nu,ru)}}RB.className="Zeros",hm(RB);class eT extends hx{apply(nu,ru){return Iv(nu,ru)}}eT.className="Ones",hm(eT);class kB extends hx{constructor(nu){if(super(),typeof nu!="object")throw new Ep(`Expected argument of type ConstantConfig but got ${nu}`);if(nu.value===void 0)throw new Ep(`config must have value set but got ${nu}`);this.value=nu.value}apply(nu,ru){return Op(()=>_p(A0(this.value),Iv(nu,ru)))}getConfig(){return{value:this.value}}}kB.className="Constant",hm(kB);class BB extends hx{constructor(nu){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=nu.minval||this.DEFAULT_MINVAL,this.maxval=nu.maxval||this.DEFAULT_MAXVAL,this.seed=nu.seed}apply(nu,ru){return uw(nu,this.minval,this.maxval,ru,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}BB.className="RandomUniform",hm(BB);class LB extends hx{constructor(nu){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=nu.mean||this.DEFAULT_MEAN,this.stddev=nu.stddev||this.DEFAULT_STDDEV,this.seed=nu.seed}apply(nu,ru){if(ru=ru||"float32",ru!=="float32"&&ru!=="int32")throw new e0(`randomNormal does not support dType ${ru}.`);return t2(nu,this.mean,this.stddev,ru,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}LB.className="RandomNormal",hm(LB);class NB extends hx{constructor(nu){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=nu.mean||this.DEFAULT_MEAN,this.stddev=nu.stddev||this.DEFAULT_STDDEV,this.seed=nu.seed}apply(nu,ru){if(ru=ru||"float32",ru!=="float32"&&ru!=="int32")throw new e0(`truncatedNormal does not support dType ${ru}.`);return mR(nu,this.mean,this.stddev,ru,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}NB.className="TruncatedNormal",hm(NB);class DB extends hx{constructor(nu){super(),this.gain=nu.gain!=null?nu.gain:1}apply(nu,ru){return Op(()=>{if(nu.length!==2||nu[0]!==nu[1])throw new Ep("Identity matrix initializer can only be used for 2D square matrices.");return _p(this.gain,HM(nu[0]))})}getConfig(){return{gain:this.gain}}}DB.className="Identity",hm(DB);function nH(ou,nu="channelsLast"){let ru,lu;if(Q0(nu),ou.length===2)ru=ou[0],lu=ou[1];else if([3,4,5].indexOf(ou.length)!==-1){if(nu==="channelsFirst"){const cu=Mv(ou,2);ru=ou[1]*cu,lu=ou[0]*cu}else if(nu==="channelsLast"){const cu=Mv(ou,0,ou.length-2);ru=ou[ou.length-2]*cu,lu=ou[ou.length-1]*cu}}else{const cu=Mv(ou);ru=Math.sqrt(cu),lu=Math.sqrt(cu)}return[ru,lu]}class Vy extends hx{constructor(nu){if(super(),nu.scale<0)throw new Ep(`scale must be a positive float. Got: ${nu.scale}`);this.scale=nu.scale==null?1:nu.scale,this.mode=nu.mode==null?"fanIn":nu.mode,eH(this.mode),this.distribution=nu.distribution==null?"normal":nu.distribution,tH(this.distribution),this.seed=nu.seed}apply(nu,ru){const lu=nH(nu),cu=lu[0],hu=lu[1];let pu=this.scale;if(this.mode==="fanIn"?pu/=Math.max(1,cu):this.mode==="fanOut"?pu/=Math.max(1,hu):pu/=Math.max(1,(cu+hu)/2),this.distribution==="normal"){const mu=Math.sqrt(pu);if(ru=ru||"float32",ru!=="float32"&&ru!=="int32")throw new e0(`${this.getClassName()} does not support dType ${ru}.`);return mR(nu,0,mu,ru,this.seed)}else{const mu=Math.sqrt(3*pu);return uw(nu,-mu,mu,ru,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Vy.className="VarianceScaling",hm(Vy);class tT extends Vy{constructor(nu){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:nu==null?null:nu.seed})}getClassName(){return Vy.className}}tT.className="GlorotUniform",hm(tT);class nT extends Vy{constructor(nu){super({scale:1,mode:"fanAvg",distribution:"normal",seed:nu==null?null:nu.seed})}getClassName(){return Vy.className}}nT.className="GlorotNormal",hm(nT);class iT extends Vy{constructor(nu){super({scale:2,mode:"fanIn",distribution:"normal",seed:nu==null?null:nu.seed})}getClassName(){return Vy.className}}iT.className="HeNormal",hm(iT);class rT extends Vy{constructor(nu){super({scale:2,mode:"fanIn",distribution:"uniform",seed:nu==null?null:nu.seed})}getClassName(){return Vy.className}}rT.className="HeUniform",hm(rT);class sT extends Vy{constructor(nu){super({scale:1,mode:"fanIn",distribution:"normal",seed:nu==null?null:nu.seed})}getClassName(){return Vy.className}}sT.className="LeCunNormal",hm(sT);class oT extends Vy{constructor(nu){super({scale:1,mode:"fanIn",distribution:"uniform",seed:nu==null?null:nu.seed})}getClassName(){return Vy.className}}oT.className="LeCunUniform",hm(oT);class FB extends hx{constructor(nu){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=nu.gain==null?this.DEFAULT_GAIN:nu.gain,this.seed=nu.seed}apply(nu,ru){return Op(()=>{if(nu.length<2)throw new e0("Shape must be at least 2D.");if(ru!=="int32"&&ru!=="float32"&&ru!==void 0)throw new TypeError(`Unsupported data type ${ru}.`);ru=ru;const lu=Mu(nu.slice(0,-1)),cu=nu[nu.length-1],hu=lu*cu;hu>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${hu}) elements: Slowness may result.`);const pu=[Math.max(cu,lu),Math.min(cu,lu)],mu=t2(pu,0,1,ru,this.seed),Au=cz.qr(mu,!1);let bu=Au[0];const Cu=Au[1].flatten().stridedSlice([0],[Math.min(cu,lu)*Math.min(cu,lu)],[Math.min(cu,lu)+1]);return bu=_p(bu,Cu.sign()),lu<cu&&(bu=bu.transpose()),_p(A0(this.gain),bu.reshape(nu))})}getConfig(){return{gain:this.gain,seed:this.seed}}}FB.className="Orthogonal",hm(FB);const PB={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function GB(ou,nu={}){return Aw(ou,lx.getMap().classNameMap,nu,"initializer")}function O0(ou){return XI(ou)}function D0(ou){if(typeof ou=="string"){const nu=ou in PB?PB[ou]:ou;if(nu==="GlorotNormal")return new nT;if(nu==="GlorotUniform")return new tT;if(nu==="HeNormal")return new iT;if(nu==="HeUniform")return new rT;if(nu==="LeCunNormal")return new sT;if(nu==="LeCunUniform")return new oT;{const ru={};return ru.className=nu,ru.config={},GB(ru)}}else return ou instanceof hx?ou:GB(ou)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function aT(ou){return Array.isArray(ou)&&Array.isArray(ou[0])}function n2(ou){return ou.length===0?[]:Array.isArray(ou[0])?ou:[ou]}function jm(ou){let nu;if(Array.isArray(ou)){if(ou.length!==1)throw new Ep(`Expected Tensor length to be 1; got ${ou.length}`);nu=ou[0]}else nu=ou;return nu}function p0(ou){if(Array.isArray(ou)&&Array.isArray(ou[0])){if(ou.length===1)return ou=ou,ou[0];throw new Ep(`Expected exactly 1 Shape; got ${ou.length}`)}else return ou}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function i2(ou){let nu=0;for(const ru of ou)ru.shape.length===0?nu+=1:nu+=ru.shape.reduce((lu,cu)=>lu*cu);return nu}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const OB="Variable";class iH{constructor(nu,ru="float32",lu=OB,cu=!0,hu=null){this.dtype=ru??"float32",this.shape=nu.shape,this.id=vB(),lu=lu??OB,this.originalName=EB(lu),this.name=SB(this.originalName),this.trainable_=cu,this.constraint=hu,this.val=cV(nu,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(nu){return this.assertNotDisposed(),rH(this.val,nu),this.val.id!==nu.id&&(this.val.assign(nu),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(nu){this.trainable_=nu,this.val.trainable=nu}}function rH(ou,nu){if(ou.shape.toString()!==nu.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(ou.shape)+" vs. "+JSON.stringify(nu.shape))}function lT(ou){return ou.map(nu=>nu.read())}function cT(ou){ou.forEach(nu=>{nu[0].write(nu[1])})}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class ty{constructor(nu){this.dtype=nu.dtype,this.shape=nu.shape,nu.shape!=null?this.ndim=nu.shape.length:this.ndim=nu.ndim,this.maxNDim=nu.maxNDim,this.minNDim=nu.minNDim,this.axes=nu.axes||{}}}class Hx{constructor(nu,ru,lu,cu,hu,pu,mu){this.dtype=nu,this.shape=ru,this.sourceLayer=lu,this.inputs=cu,this.callArgs=hu,this.outputTensorIndex=mu,this.id=vB(),pu!=null&&(this.originalName=EB(pu),this.name=SB(this.originalName)),this.rank=ru.length}}let sH=0;class r2{constructor(nu,ru){this.callArgs=ru,this.id=sH++,this.outboundLayer=nu.outboundLayer,this.inboundLayers=nu.inboundLayers,this.nodeIndices=nu.nodeIndices,this.tensorIndices=nu.tensorIndices,this.inputTensors=nu.inputTensors,this.outputTensors=nu.outputTensors,this.inputMasks=nu.inputMasks,this.outputMasks=nu.outputMasks,this.inputShapes=nu.inputShapes,this.outputShapes=nu.outputShapes;for(const lu of nu.inboundLayers)lu!=null&&lu.outboundNodes.push(this);nu.outboundLayer.inboundNodes.push(this)}getConfig(){const nu=[];for(const ru of this.inboundLayers)ru!=null?nu.push(ru.name):nu.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:nu,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let oH=0;class n0 extends J1{constructor(nu={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=oH++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let ru=nu.name;if(!ru){const lu=this.getClassName();ru=av(lu)+"_"+JE(lu)}if(this.name=ru,this.trainable_=nu.trainable==null?!0:nu.trainable,nu.inputShape!=null||nu.batchInputShape!=null){let lu;if(nu.batchInputShape!=null)lu=nu.batchInputShape;else if(nu.inputShape!=null){let hu=null;nu.batchSize!=null&&(hu=nu.batchSize),lu=[hu].concat(nu.inputShape)}this.batchInputShape=lu;let cu=nu.dtype;cu==null&&(cu=nu.inputDType),cu==null&&(cu="float32"),this.dtype=cu}nu.weights!=null?this.initialWeights=nu.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(nu,ru){return nu.name+"_ib-"+ru.toString()}getNodeAtIndex(nu,ru){if(this.inboundNodes.length===0)throw new cx(`The layer has never been called and thus has no defined ${ru}.`);if(this.inboundNodes.length<=nu)throw new Ep(`Asked to get ${ru} at node ${nu}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[nu]}getInputAt(nu){return Ny(this.getNodeAtIndex(nu,"input").inputTensors)}getOutputAt(nu){return Ny(this.getNodeAtIndex(nu,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Vx(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Vx(`Layer ${this.name} is not connected, no input to return.`);return Ny(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Vx(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Vx(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ny(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(nu=>nu())}get updates(){return this._updates}get built(){return this._built}set built(nu){this._built=nu}get trainable(){return this.trainable_}set trainable(nu){this._trainableWeights.forEach(ru=>ru.trainable=nu),this.trainable_=nu}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(nu=>nu.trainable):[]}set trainableWeights(nu){this._trainableWeights=nu}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(nu=>!nu.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(nu){this._nonTrainableWeights=nu}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(nu){const ru=y0(nu);if(this.inputSpec==null||this.inputSpec.length===0)return;const lu=y0(this.inputSpec);if(ru.length!==lu.length)throw new Ep(`Layer ${this.name} expects ${lu.length} inputs, but it received ${ru.length} input tensors. Input received: ${nu}`);for(let cu=0;cu<ru.length;cu++){const hu=ru[cu],pu=lu[cu];if(pu==null)continue;const mu=hu.rank;if(pu.ndim!=null&&mu!==pu.ndim)throw new Ep(`Input ${cu} is incompatible with layer ${this.name}: expected ndim=${pu.ndim}, found ndim=${mu}`);if(pu.maxNDim!=null&&mu>pu.maxNDim)throw new Ep(`Input ${cu} is incompatible with layer ${this.name}: expected max_ndim=${pu.maxNDim}, found ndim=${mu}`);if(pu.minNDim!=null&&mu<pu.minNDim)throw new Ep(`Input ${cu} is incompatible with layer ${this.name}: expected min_ndim=${pu.minNDim}, found ndim=${mu}.`);if(pu.dtype!=null&&hu.dtype!==pu.dtype)throw new Ep(`Input ${cu} is incompatible with layer ${this.name} : expected dtype=${pu.dtype}, found dtype=${hu.dtype}.`);if(pu.axes){const Au=hu.shape;for(const bu in pu.axes){const Cu=Number(bu),wu=pu.axes[bu],Eu=Cu>=0?Au[Cu]:Au[Au.length+Cu];if(wu!=null&&[wu,null].indexOf(Eu)===-1)throw new Ep(`Input ${cu} is incompatible with layer ${this.name}: expected axis ${Cu} of input shape to have value ${wu} but got shape ${Au}.`)}}if(pu.shape!=null)for(let Au=0;Au<pu.shape.length;++Au){const bu=pu.shape[Au],Cu=hu.shape[Au];if(bu!=null&&Cu!=null&&bu!==Cu)throw new Ep(`Input ${cu} is incompatible with layer ${this.name}: expected shape=${pu.shape}, found shape=${hu.shape}.`)}}}call(nu,ru){return nu}invokeCallHook(nu,ru){this._callHook!=null&&this._callHook(nu,ru)}setCallHook(nu){this._callHook=nu}clearCallHook(){this._callHook=null}apply(nu,ru){ru=ru||{},this.assertNotDisposed();const lu=y0(nu),cu=cH(nu),hu=uH(nu);if(cu===hu)throw new Ep("Arguments to apply() must be all SymbolicTensors or all Tensors");return A1(this.name,()=>{if(!this.built){this.assertInputCompatibility(nu);const pu=[];for(const mu of y0(nu))pu.push(mu.shape);this.build(Ny(pu)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&hu&&(this._refCount=1)}if(this.assertInputCompatibility(nu),hu){let pu=this.call(nu,ru);this.supportsMasking&&this.setMaskMetadata(nu,pu);const mu=y0(pu),Au=[];for(let bu of mu)lu.indexOf(bu)!==-1&&(bu=bu.clone()),Au.push(bu);if(pu=Ny(Au),this.activityRegularizer!=null)throw new e0("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return pu}else{const pu=aH(nu),mu=this.computeOutputShape(pu);let Au;const bu=lH(nu);if(this.warnOnIncompatibleInputShape(Array.isArray(nu)?pu[0]:pu),mu!=null&&mu.length>0&&Array.isArray(mu[0])?Au=mu.map((Cu,wu)=>new Hx(bu,Cu,this,y0(nu),ru,this.name,wu)):Au=new Hx(bu,mu,this,y0(nu),ru,this.name),this.addInboundNode(nu,Au,null,null,pu,mu,ru),this._refCount++,this.activityRegularizer!=null)throw new e0("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return Au}})}warnOnIncompatibleInputShape(nu){if(this.batchInputShape!=null)if(nu.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(nu)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let ru=!1;this.batchInputShape.forEach((lu,cu)=>{lu!=null&&nu[cu]!=null&&nu[cu]!==lu&&(ru=!0)}),ru&&console.warn(`The shape of the input tensor (${JSON.stringify(nu)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Vx(`The layer ${this.name} has never been called and thus has no defined output shape.`);const nu=[];for(const ru of this.inboundNodes){const lu=JSON.stringify(ru.outputShapes);nu.indexOf(lu)===-1&&nu.push(lu)}if(nu.length===1){const ru=this.inboundNodes[0].outputShapes;return Array.isArray(ru)&&Array.isArray(ru[0])&&ru.length===1?ru[0]:ru}else throw new Vx(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new cx(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return i2(this.weights)}build(nu){this.built=!0}getWeights(nu=!1){return lT(nu?this.trainableWeights:this.weights)}setWeights(nu){Op(()=>{const ru=this.weights;if(ru.length!==nu.length)throw new Ep(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${nu.length}, but the layer was expecting ${ru.length} weights. Provided weights: ${nu}...`);if(ru.length===0)return;const lu=[],cu=lT(ru);for(let hu=0;hu<cu.length;++hu){const pu=cu[hu],mu=ru[hu],Au=nu[hu];if(!ku(pu.shape,Au.shape))throw new Ep(`Layer weight shape ${pu.shape} not compatible with provided weight shape ${Au.shape}`);lu.push([mu,Au])}cT(lu)})}addWeight(nu,ru,lu,cu,hu,pu,mu,Au){if(this._addedWeightNames.indexOf(nu)!==-1)throw new Ep(`Duplicate weight name ${nu} for layer ${this.name}`);this._addedWeightNames.push(nu),lu==null&&(lu="float32"),this.fastWeightInitDuringBuild&&(cu=Au!=null?Au():D0("zeros"));const bu=cu.apply(ru,lu),Cu=new iH(bu,lu,nu,pu,mu);return bu.dispose(),hu!=null&&this.addLoss(()=>hu.apply(Cu.read())),pu==null&&(pu=!0),pu?this._trainableWeights.push(Cu):this._nonTrainableWeights.push(Cu),Cu}setFastWeightInitDuringBuild(nu){this.fastWeightInitDuringBuild=nu}addLoss(nu){nu==null||Array.isArray(nu)&&nu.length===0||(nu=y0(nu),this._losses!==void 0&&this._losses!==null&&this.losses.push(...nu))}computeOutputShape(nu){return nu}computeMask(nu,ru){if(!this.supportsMasking){if(ru!=null)if(Array.isArray(ru))ru.forEach(lu=>{if(lu!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return ru}setMaskMetadata(nu,ru,lu){if(!this.supportsMasking)return;const cu=this.computeMask(nu,lu),hu=y0(ru),pu=y0(cu);if(hu.length!==pu.length)throw new Error(`${this.name} outputs ${hu.length} tensors but ${hu.length} masks for those tensors`);for(let mu=0;mu<hu.length;mu++)hu[mu].kerasMask=pu[mu]}addInboundNode(nu,ru,lu,cu,hu,pu,mu=null){const Au=y0(nu);ru=y0(ru),lu=y0(lu),cu=y0(cu),hu=n2(hu),pu=n2(pu);const bu=[],Cu=[],wu=[];for(const Eu of Au)bu.push(Eu.sourceLayer),Cu.push(Eu.nodeIndex),wu.push(Eu.tensorIndex);new r2({outboundLayer:this,inboundLayers:bu,nodeIndices:Cu,tensorIndices:wu,inputTensors:Au,outputTensors:ru,inputMasks:lu,outputMasks:cu,inputShapes:hu,outputShapes:pu},mu);for(let Eu=0;Eu<ru.length;Eu++)ru[Eu].sourceLayer=this,ru[Eu].nodeIndex=this.inboundNodes.length-1,ru[Eu].tensorIndex=Eu}getConfig(){const nu={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(nu.batchInputShape=this.batchInputShape),this.dtype!=null&&(nu.dtype=this.dtype),nu}disposeWeights(){return this.weights.forEach(nu=>nu.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let nu=0;return--this._refCount===0&&(nu=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:nu}}}function aH(ou){ou=y0(ou);const nu=[];for(const ru of ou)nu.push(ru.shape);return Ny(nu)}function lH(ou){return"float32"}function UB(ou,nu,ru){if((nu==null||ru!=null&&ru>0)&&(nu=ou.sourceLayer,ru=ou.nodeIndex),nu.inboundNodes.length===0)return[ou];{const lu=nu.inboundNodes[ru];if(lu.inboundLayers.length===0)return lu.inputTensors;{const cu=[];for(let hu=0;hu<lu.inboundLayers.length;hu++){const pu=lu.inputTensors[hu],mu=lu.inboundLayers[hu],Au=lu.nodeIndices[hu],bu=UB(pu,mu,Au);for(const Cu of bu)cu.indexOf(Cu)===-1&&cu.push(Cu)}return cu}}}function cH(ou){let nu=!0;for(const ru of y0(ou))if(!(ru instanceof Hx)){nu=!1;break}return nu}function uH(ou){let nu=!0;for(const ru of y0(ou))if(ru instanceof Hx){nu=!1;break}return nu}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class Cw extends n0{constructor(nu){if(super({dtype:nu.dtype,name:nu.name!=null?nu.name:JE("input").toString()}),nu.batchSize==null&&(nu.batchSize=null),nu.sparse==null&&(nu.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=nu.sparse,nu.inputShape!=null&&nu.batchInputShape!=null)throw new Ep("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let ru=nu.batchInputShape;if(ru==null){if(nu.inputShape==null)throw new Ep("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");ru=[nu.batchSize].concat(nu.inputShape)}else if(nu.batchSize!=null)throw new Ep("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const lu=nu.dtype||"float32";this.batchInputShape=ru,this.dtype=lu,this.inputSpec=[{shape:ru}];const cu=new Hx(this.dtype,this.batchInputShape,this,[],{},this.name);cu.nodeIndex=0,cu.tensorIndex=0,new r2({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[cu],outputTensors:[cu],inputMasks:[null],outputMasks:[null],inputShapes:[ru],outputShapes:[ru]})}apply(nu,ru){throw new Ep(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Cw.className="InputLayer",hm(Cw);function hH(ou){if(ou.batchShape==null&&ou.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(ou.batchShape!=null&&ou.shape!=null)throw new Ep("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let nu=ou.batchShape;ou.shape!=null&&nu==null&&(nu=[null].concat(ou.shape));let ru=ou.dtype;return ru==null&&(ru="float32"),new Cw({batchInputShape:nu,name:ou.name,dtype:ru,sparse:ou.sparse}).inboundNodes[0].outputTensors[0]}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function dH(ou,nu){if(ou.dtype==null||ou.dtype===nu.dtype)return nu;try{return km(nu,ou.dtype)}catch{throw new Ep(`The dtype of the feed (${nu.dtype}) can not be cast to the dtype of the key '${ou.name}' (${ou.dtype}).`)}}class kv{constructor(nu){if(this.id2Value={},this.id2Mask={},this.name2Id={},nu instanceof kv)for(const ru in nu.id2Value)this.id2Value[ru]=nu.id2Value[ru],ru in nu.id2Mask&&(this.id2Mask[ru]=nu.id2Mask[ru]);else{if(nu==null)return;for(const ru of nu)this.add(ru.key,ru.value)}}add(nu,ru,lu){if(this.id2Value[nu.id]==null)this.id2Value[nu.id]=dH(nu,ru),this.name2Id[nu.name]=nu.id,lu!=null&&(this.id2Mask[nu.id]=lu);else throw new Ep(`Duplicate key: name=${nu.name}, id=${nu.id}`);return this}addFeed(nu){this.add(nu.key,nu.value)}hasKey(nu){return this.id2Value[nu.id]!=null}names(){return Object.keys(this.name2Id)}getValue(nu){if(nu instanceof Hx){if(this.id2Value[nu.id]==null)throw new Ep(`Nonexistent key: ${nu.name}`);return this.id2Value[nu.id]}else{const ru=this.name2Id[nu];if(ru==null)throw new Ep(`Feed dict has no SymbolicTensor name: ${nu}`);return this.id2Value[ru]}}getMask(nu){if(nu instanceof Hx){if(this.id2Value[nu.id]==null)throw new Ep(`Nonexistent key: ${nu.name}`);return this.id2Mask[nu.id]}else{const ru=this.name2Id[nu];if(ru==null)throw new Ep(`Feed dict has no SymbolicTensor name: ${nu}`);return this.id2Mask[ru]}}disposeMasks(){this.id2Mask!=null&&o0(this.id2Mask)}}const s2=new AB,o2=new AB;function pH(ou){s2!=null&&s2.setMaxEntries(ou),o2!=null&&o2.setMaxEntries(ou)}function ww(ou,nu,ru,lu){const cu=ru==null?!1:ru.training,hu=Array.isArray(ou),pu=hu?ou:[ou],mu=pu.map(Ru=>Ru.name),Au=[],bu=nu.names();for(const Ru of mu)bu.indexOf(Ru)!==-1?Au.push(nu.getValue(Ru)):Au.push(null);const Cu=mu.join(",")+"|"+nu.names().sort().join(",");let wu=s2.get(Cu),Eu;if(wu==null){const Ru=fH(pu,nu);wu=Ru.sorted,Eu=Ru.recipientCounts,s2.put(Cu,wu),o2.put(Cu,Eu)}Eu={},cu||Object.assign(Eu,o2.get(Cu));const Tu=new kv(nu);for(let Ru=0;Ru<wu.length;++Ru){const Nu=wu[Ru],Pu=Nu.sourceLayer;if(Pu instanceof Cw)continue;const Fu=[],Gu=[],Xu=[];let Qu=!1;for(const hp of Nu.inputs){const Ap=Tu.getValue(hp),Up=Tu.getMask(hp);Fu.push(Ap),Gu.push(Up),Up!=null&&(Qu=!0),cu||(Eu[hp.name]--,Eu[hp.name]===0&&!nu.hasKey(hp)&&mu.indexOf(hp.name)===-1&&!Ap.isDisposed&&hp.sourceLayer.stateful!==!0&&Xu.push(Ap))}Qu&&(ru=ru||{},ru.mask=Gu[0]);const Ju=y0(Pu.apply(Fu,ru));let ip=null;Pu.supportsMasking&&(ip=Pu.computeMask(Fu,Gu));const rp=gH(Nu),op=Array.isArray(rp)?rp:[rp];for(let hp=0;hp<op.length;++hp){Tu.hasKey(op[hp])||Tu.add(op[hp],Ju[hp],Array.isArray(ip)?ip[0]:ip);const Ap=mu.indexOf(op[hp].name);Ap!==-1&&(Au[Ap]=Ju[hp])}cu||o0(Xu)}return Tu.disposeMasks(),hu?Au:Au[0]}function fH(ou,nu){vu(ou!=null&&ou.length>0,()=>"Expected at least one fetch, got none");let ru=[],lu={};if(ou.length===1){const cu=$B(ou[0],nu);ru=cu.sorted,lu=cu.recipientMap}else{const cu=new Set;for(const hu of ou){const{sorted:pu,recipientMap:mu}=$B(hu,nu);for(const Au of pu)cu.has(Au.name)||(ru.push(Au),cu.add(Au.name));for(const Au in mu)lu[Au]==null&&(lu[Au]=new Set),mu[Au].forEach(bu=>lu[Au].add(bu))}}return{sorted:ru,recipientCounts:mH(lu)}}function mH(ou){const nu={};for(const ru in ou)nu[ru]=ou[ru].size;return nu}function $B(ou,nu){const ru=new Set,lu=[],cu={};for(const mu of nu.names())ru.add(mu);const hu=[],pu=[];for(hu.push(ou);hu.length>0;){const mu=hu[hu.length-1];if(ru.has(mu.name)){hu.pop();continue}const Au=pu[pu.length-1]===hu.length-1;if(mu.inputs.length===0||Au)hu.pop(),lu.push(mu),ru.add(mu.name),Au&&pu.pop();else{pu.push(hu.length-1);for(const bu of mu.inputs)cu[bu.name]==null&&(cu[bu.name]=new Set),cu[bu.name].add(mu.name),!ru.has(bu.name)&&hu.push(bu)}}return{sorted:lu,recipientMap:cu}}function gH(ou){let nu;if(ou.sourceLayer.inboundNodes.length===1)nu=ou.sourceLayer.output;else{let ru=null;for(let lu=0;lu<ou.sourceLayer.inboundNodes.length;++lu)for(const cu of ou.sourceLayer.inboundNodes[lu].outputTensors)if(cu.id===ou.id){ru=lu;break}nu=ou.sourceLayer.getOutputAt(ru)}return nu}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/cp().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,pH);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function uT(ou,nu){return Op(()=>wy(zm(_p(ou,ou),nu,!0)))}class Ew extends J1{getConfig(){return{}}}class VB extends Ew{constructor(nu){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=nu.maxValue!=null?nu.maxValue:this.defaultMaxValue,this.axis=nu.axis!=null?nu.axis:this.defaultAxis}apply(nu){return Op(()=>{const ru=uT(nu,this.axis),lu=jy(ru,0,this.maxValue);return _p(nu,Xm(lu,Am(ey(),ru)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}VB.className="MaxNorm",hm(VB);class zB extends Ew{constructor(nu){super(),this.defaultAxis=0,this.axis=nu.axis!=null?nu.axis:this.defaultAxis}apply(nu){return Op(()=>Xm(nu,Am(ey(),uT(nu,this.axis))))}getConfig(){return{axis:this.axis}}}zB.className="UnitNorm",hm(zB);class WB extends Ew{apply(nu){return c1(nu)}}WB.className="NonNeg",hm(WB);class HB extends Ew{constructor(nu){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=nu.minValue!=null?nu.minValue:this.defaultMinValue,this.maxValue=nu.maxValue!=null?nu.maxValue:this.defaultMaxValue,this.rate=nu.rate!=null?nu.rate:this.defaultRate,this.axis=nu.axis!=null?nu.axis:this.defaultAxis}apply(nu){return Op(()=>{const ru=uT(nu,this.axis),lu=Am(_p(this.rate,jy(ru,this.minValue,this.maxValue)),_p(1-this.rate,ru));return _p(nu,Xm(lu,Am(ey(),ru)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}HB.className="MinMaxNorm",hm(HB);const XB={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ny(ou){return XI(ou)}function QB(ou,nu={}){return Aw(ou,lx.getMap().classNameMap,nu,"constraint")}function iy(ou){if(ou==null)return null;if(typeof ou=="string"){const nu={className:ou in XB?XB[ou]:ou,config:{}};return QB(nu)}else return ou instanceof Ew?ou:QB(ou)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/async function b1(ou){if(ou==null)return;const nu=[],ru=[],lu=[];for(const cu in ou){const hu=ou[cu];if(typeof hu!="number"){const pu=hu;nu.push(pu.data()),ru.push(cu),lu.push(pu)}}if(nu.length>0){const cu=await Promise.all(nu);for(let hu=0;hu<cu.length;++hu)ou[ru[hu]]=cu[hu][0];o0(lu)}}function KB(ou){if(ou!=null)for(const nu in ou){const ru=ou[nu];typeof ru!="number"&&ru.dispose()}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/var ZB;(function(ou){ou[ou.SILENT=0]="SILENT",ou[ou.VERBOSE=1]="VERBOSE"})(ZB||(ZB={}));const AH=125;class Sw{constructor(){this.validationData=null}setParams(nu){this.params=nu}async onEpochBegin(nu,ru){}async onEpochEnd(nu,ru){}async onBatchBegin(nu,ru){}async onBatchEnd(nu,ru){}async onTrainBegin(nu){}async onTrainEnd(nu){}setModel(nu){}}class yH{constructor(nu,ru=10){nu==null&&(nu=[]),this.callbacks=nu,this.queueLength=ru}append(nu){this.callbacks.push(nu)}setParams(nu){for(const ru of this.callbacks)ru.setParams(nu)}setModel(nu){for(const ru of this.callbacks)ru.setModel(nu)}async onEpochBegin(nu,ru){ru==null&&(ru={});for(const lu of this.callbacks)await lu.onEpochBegin(nu,ru)}async onEpochEnd(nu,ru){ru==null&&(ru={});for(const lu of this.callbacks)await lu.onEpochEnd(nu,ru)}async onBatchBegin(nu,ru){ru==null&&(ru={});for(const lu of this.callbacks)await lu.onBatchBegin(nu,ru)}async onBatchEnd(nu,ru){ru==null&&(ru={});for(const lu of this.callbacks)await lu.onBatchEnd(nu,ru)}async onTrainBegin(nu){nu==null&&(nu={});for(const ru of this.callbacks)await ru.onTrainBegin(nu)}async onTrainEnd(nu){nu==null&&(nu={});for(const ru of this.callbacks)await ru.onTrainEnd(nu)}}class bH extends Sw{constructor(){super()}async onEpochBegin(nu){this.seen=0,this.totals={}}async onBatchEnd(nu,ru){ru==null&&(ru={});const lu=ru.size==null?0:ru.size;this.seen+=lu;for(const cu in ru){const hu=ru[cu];if(typeof hu=="number")this.totals.hasOwnProperty(cu)||(this.totals[cu]=0),this.totals[cu]=this.totals[cu]+hu*lu;else{let pu;cu in this.totals?pu=this.totals[cu]:this.totals[cu]=0;const mu=Op(()=>Am(this.totals[cu],_p(hu,lu)));this.totals[cu]=mu,pu!=null&&pu.dispose()}}}async onEpochEnd(nu,ru){if(ru!=null)for(const lu of this.params.metrics)this.totals[lu]!=null&&(typeof this.totals[lu]=="number"?ru[lu]=this.totals[lu]/this.seen:Op(()=>{const cu=_p(Xm(1,this.seen),this.totals[lu]);ru[lu]=cu,this.totals[lu].dispose(),Zy(ru[lu])}))}}class xH extends Sw{async onTrainBegin(nu){this.epoch=[],this.history={}}async onEpochEnd(nu,ru){ru==null&&(ru={}),this.epoch.push(nu);for(const lu in ru)this.history[lu]==null&&(this.history[lu]=[]),this.history[lu].push(ru[lu])}async syncData(){const nu=[],ru=[],lu=[];for(const hu in this.history){const pu=this.history[hu];for(let mu=0;mu<pu.length;++mu)if(typeof pu[mu]!="number"){const Au=pu[mu];nu.push(Au.data()),ru.push(hu),lu.push(mu)}}const cu=await Promise.all(nu);for(let hu=0;hu<cu.length;++hu)this.history[ru[hu]][lu[hu]].dispose(),this.history[ru[hu]][lu[hu]]=cu[hu][0]}}class vH extends Sw{constructor(nu,ru){if(super(),this.currentEpoch=0,this.nowFunc=nu.nowFunc,this.nextFrameFunc=nu.nextFrameFunc||QE,this.yieldEvery=ru||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=AH),this.yieldEvery==="never"&&nu.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");wp(this.yieldEvery)&&(this.maybeWait=D5(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=nu.onTrainBegin,this.trainEnd=nu.onTrainEnd,this.epochBegin=nu.onEpochBegin,this.epochEnd=nu.onEpochEnd,this.batchBegin=nu.onBatchBegin,this.batchEnd=nu.onBatchEnd,this.yield=nu.onYield}async maybeWait(nu,ru,lu){const cu=[];this.yield!=null&&(await b1(lu),cu.push(this.yield(nu,ru,lu))),cu.push(this.nextFrameFunc()),await Promise.all(cu)}async onEpochBegin(nu,ru){this.currentEpoch=nu,this.epochBegin!=null&&(await b1(ru),await this.epochBegin(nu,ru))}async onEpochEnd(nu,ru){const lu=[];this.epochEnd!=null&&(await b1(ru),lu.push(this.epochEnd(nu,ru))),this.yieldEvery==="epoch"&&lu.push(this.nextFrameFunc()),await Promise.all(lu)}async onBatchBegin(nu,ru){this.batchBegin!=null&&(await b1(ru),await this.batchBegin(nu,ru))}async onBatchEnd(nu,ru){const lu=[];this.batchEnd!=null&&(await b1(ru),lu.push(this.batchEnd(nu,ru))),this.yieldEvery==="batch"?lu.push(this.nextFrameFunc()):wp(this.yieldEvery)&&lu.push(this.maybeWait(this.currentEpoch,nu,ru)),await Promise.all(lu)}async onTrainBegin(nu){this.trainBegin!=null&&(await b1(nu),await this.trainBegin(nu))}async onTrainEnd(nu){this.trainEnd!=null&&(await b1(nu),await this.trainEnd(nu))}}function jB(ou,nu){return ou==null&&(ou={}),ou instanceof Sw?[ou]:Array.isArray(ou)&&ou[0]instanceof Sw?ou:y0(ou).map(ru=>new vH(ru,nu))}class dx{constructor(){}static registerCallbackConstructor(nu,ru){vu(nu>=0&&Number.isInteger(nu),()=>`Verbosity level is expected to be an integer >= 0, but got ${nu}`),dx.checkForDuplicate(ru),dx.constructors[nu]==null&&(dx.constructors[nu]=[]),dx.constructors[nu].push(ru)}static checkForDuplicate(nu){for(const ru in dx.constructors)dx.constructors[+ru].forEach(lu=>{if(lu===nu)throw new Ep("Duplicate callback constructor.")})}static clear(){dx.constructors={}}static createCallbacks(nu){const ru=[];for(const lu in dx.constructors){const cu=+lu;nu>=cu&&ru.push(...dx.constructors[cu])}return ru.map(lu=>new lu)}}dx.constructors={};function YB(ou,nu,ru,lu,cu,hu,pu,mu,Au){const bu=new xH,Cu=[new bH,...dx.createCallbacks(nu)];ou!=null&&Cu.push(...ou),Cu.push(bu);const wu=new yH(Cu);return wu.setParams({epochs:ru,initialEpoch:lu,samples:cu,steps:hu,batchSize:pu,verbose:nu,doValidation:mu,metrics:Au}),{callbackList:wu,history:bu}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function cv(ou,nu={},ru=!1){return Aw(ou,lx.getMap().classNameMap,nu,"layer",ru)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function a2(ou,nu){return Op(()=>{ou.dtype!=="float32"&&(ou=km(ou,"float32"));const ru=zm(xw(ou),nu,!0),lu=PE(ru.shape,ey()),cu=wy(Sv(ru,lu));return Xm(ou,cu)})}function l2(ou,nu){return Op(()=>Y0(xw(Qm(nu,ou)),-1))}function hT(ou,nu){return Op(()=>Y0(vy(Qm(nu,ou)),-1))}function dT(ou,nu){return Op(()=>{const ru=Qm(ou,nu),lu=jy(vy(ou),ey(),Number.MAX_VALUE),cu=vy(Xm(ru,lu));return _p(100,Y0(cu,-1))})}function CH(ou,nu){return Op(()=>{const ru=jy(nu,ey(),Number.MAX_VALUE),lu=Ox(Am(1,ru)),cu=jy(ou,ey(),Number.MAX_VALUE),hu=Ox(Am(1,cu));return Y0(xw(Qm(lu,hu)),-1)})}function wH(ou,nu){return Op(()=>{const ru=Sv(0,Qm(1,_p(ou,nu)));return Y0(xw(ru),-1)})}function EH(ou,nu){return Op(()=>{const ru=Sv(0,Qm(1,_p(ou,nu)));return Y0(ru,-1)})}function SH(ou,nu){return Op(()=>{const ru=zm(_p(ou,nu),-1),lu=vx(_p(Qm(1,ou),nu),-1);return Sv(0,Am(1,Qm(lu,ru)))})}function IH(ou,nu){return Op(()=>{const ru=Math.log(2),lu=Qm(nu,ou),cu=Qm(Am(lu,lw(_p(-2,lu))),ru);return Y0(cu,-1)})}function Iw(ou,nu,ru=!1){return Op(()=>{if(ru)nu=rI(nu);else{const lu=zm(nu,nu.shape.length-1,!0);nu=Xm(nu,lu)}return nu=jy(nu,ey(),1-ey()),X0(zm(_p(km(ou,"float32"),Ox(nu)),nu.shape.length-1))})}function c2(ou,nu,ru=!1){return Op(()=>{const lu=km($E(Q5(ou)),"int32");nu=jy(nu,ey(),1-ey());const cu=nu.shape,hu=Pp(jM(lu,cu[cu.length-1]),cu);return Iw(hu,nu,ru)})}function TH(ou,nu){if(!ku(ou.shape,nu.shape))throw new Ep(`logits and labels must have the same shape, but got shapes ${JSON.stringify(ou.shape)} and ${JSON.stringify(nu.shape)}`);return Op(()=>{const ru=c1(nu),lu=X0(vy(nu));return Am(Qm(ru,_p(nu,ou)),XM(Gx(lu)))})}function u2(ou,nu){return Op(()=>{let ru;return ru=jy(nu,ey(),1-ey()),ru=Ox(Xm(ru,Qm(1,ru))),Y0(TH(ou,ru),-1)})}function _H(ou,nu){return Op(()=>{const ru=jy(ou,ey(),1),lu=jy(nu,ey(),1);return zm(_p(ou,Ox(Xm(ru,lu))),-1)})}function MH(ou,nu){return Op(()=>{const ru=Ox(Am(ey(),nu));return Y0(Qm(nu,_p(ou,ru)),-1)})}function qB(ou,nu){return Op(()=>{const ru=a2(ou,-1),lu=a2(nu,-1),cu=_p(ru,lu);return X0(zm(cu,-1))})}const h2={meanSquaredError:l2,meanAbsoluteError:hT,meanAbsolutePercentageError:dT,meanSquaredLogarithmicError:CH,squaredHinge:wH,hinge:EH,categoricalHinge:SH,logcosh:IH,categoricalCrossentropy:Iw,sparseCategoricalCrossentropy:c2,binaryCrossentropy:u2,kullbackLeiblerDivergence:_H,poisson:MH,cosineProximity:qB};function pT(ou){if(typeof ou=="string"){if(ou in h2)return h2[ou];let nu=`Unknown loss ${ou}`;throw ou.toLowerCase().includes("softmaxcrossentropy")&&(nu=`Unknown loss ${ou}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Ep(nu)}else return ou}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function JB(ou,nu){return Op(()=>{const ru=_p(.5,ax(nu)),lu=lv(Yy(nu,ru),ou.dtype);return Y0(Px(ou,lu),-1)})}function eL(ou,nu){return Op(()=>lv(Px(nw(ou,-1),nw(nu,-1)),"float32"))}function RH(ou,nu){return Op(()=>km(zm(iv(Px(ou,1),Px(nu,1))),"float32"))}function kH(ou,nu){return Op(()=>km(zm(iv(Px(ou,0),Px(nu,1))),"float32"))}function BH(ou,nu){return Op(()=>{const ru=RH(ou,nu),lu=kH(ou,nu),cu=Am(ru,lu);return km(Cy(Yy(cu,0),Xm(ru,cu),0),"float32")})}function LH(ou,nu){return u2(ou,nu)}function NH(ou,nu){return ou.rank===nu.rank&&(ou=dw(ou,[ou.rank-1])),nu=nw(nu,-1),nu.dtype!==ou.dtype&&(nu=km(nu,ou.dtype)),km(Px(ou,nu),"float32")}const DH=l2,FH=l2,PH=hT,GH=hT,OH=dT,UH=dT,tL=Iw,$H=qB,nL=c2,d2={binaryAccuracy:JB,categoricalAccuracy:eL,precision:BH,categoricalCrossentropy:tL,sparseCategoricalCrossentropy:nL,mse:DH,MSE:FH,mae:PH,MAE:GH,mape:OH,MAPE:UH,cosine:$H};function VH(ou){if(typeof ou=="string"&&ou in d2)return d2[ou];if(typeof ou!="string"&&ou!=null)return ou;throw new Ep(`Unknown metric ${ou}`)}function p2(ou){if(zx(ou!==null,`Unknown LossOrMetricFn ${ou}`),typeof ou=="string")return ou;{let nu;for(const ru of Object.keys(h2))if(h2[ru]===ou){nu=ru;break}if(nu!==void 0)return nu;for(const ru of Object.keys(d2))if(d2[ru]===ou){nu=ru;break}return nu!==void 0?nu:ou.name}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function zH(ou){const nu={Adagrad:()=>eC.adagrad(.01),Adadelta:()=>eC.adadelta(1,.95,ey()),Adam:()=>eC.adam(.001,.9,.999,ey()),Adamax:()=>eC.adamax(.002,.9,.999,ey(),0),RMSProp:()=>eC.rmsprop(.001,.9,0,ey()),SGD:()=>eC.sgd(.01)};if(nu.adagrad=nu.Adagrad,nu.adadelta=nu.Adadelta,nu.adam=nu.Adam,nu.adamax=nu.Adamax,nu.rmsprop=nu.RMSProp,nu.sgd=nu.SGD,ou in nu)return nu[ou]();throw new Ep(`Unknown Optimizer ${ou}`)}/**
* @license
* Copyright 2019 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const iL=1*1024*1024;function rL(ou,nu,ru=!1){if(ou==null||typeof ou!="object"||Object.getPrototypeOf(ou)!==Object.prototype||!fT(ou))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(ru){const lu=JSON.stringify(ou);lu.length>iL&&console.warn(`User-defined metadata of model "${nu}" is too large in size (length=${lu.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${iL}.`)}}function fT(ou){if(ou===null)return!0;if(typeof ou=="object")if(Object.getPrototypeOf(ou)===Object.prototype){const nu=Object.keys(ou);for(const ru of nu)if(typeof ru!="string"||!fT(ou[ru]))return!1;return!0}else if(Array.isArray(ou)){for(const nu of ou)if(!fT(nu))return!1;return!0}else return!1;else{const nu=typeof ou;return nu==="string"||nu==="number"||nu==="boolean"}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function WH(ou,nu,ru,lu=console.log){const cu=XH(ou),hu=["Layer (type)","Input Shape","Output shape","Param #"];cu?(nu=nu||90,ru=ru||[.32,.61,.89,1]):(nu=nu||115,ru=ru||[.24,.48,.7,.8,1]),ru[ru.length-1]<=1&&(ru=ru.map(Cu=>Math.floor(nu*Cu)));let pu;if(!cu){hu.push("Receives inputs"),pu=[];for(const Cu in ou.nodesByDepth)pu.push(...ou.nodesByDepth[Cu])}lu("_".repeat(nu)),f2(hu,ru,lu),lu("=".repeat(nu));const mu=ou.layers;for(let Cu=0;Cu<mu.length;++Cu)cu?QH(mu[Cu],ru,lu):KH(mu[Cu],ru,pu,lu),lu((Cu===mu.length-1?"=":"_").repeat(nu));ou.checkTrainableWeightsConsistency();const Au=HH(ou),bu=i2(ou.nonTrainableWeights);lu(`Total params: ${Au+bu}`),lu(`Trainable params: ${Au}`),lu(`Non-trainable params: ${bu}`),lu("_".repeat(nu))}function HH(ou){let nu;return ou.collectedTrainableWeights!=null?nu=i2(ou.collectedTrainableWeights):nu=i2(ou.trainableWeights),nu}function XH(ou){let nu=!0;const ru=[],lu=[];for(const cu in ou.nodesByDepth)ru.push(ou.nodesByDepth[cu]);for(const cu of ru){if(cu.length>1||cu.length===1&&cu[0].inboundLayers.length>1){nu=!1;break}lu.push(...cu)}if(nu)for(const cu of ou.layers){let hu=!1;for(const pu of cu.inboundNodes)if(lu.indexOf(pu)!==-1)if(hu){nu=!1;break}else hu=!0;if(!nu)break}return nu}function f2(ou,nu,ru=console.log){let lu="";for(let cu=0;cu<ou.length;++cu)cu>0&&(lu=lu.slice(0,lu.length-1)+" "),lu+=ou[cu],lu=lu.slice(0,nu[cu]),lu+=" ".repeat(nu[cu]-lu.length);ru(lu)}function QH(ou,nu,ru){let lu,cu;try{cu=ou.inboundNodes.map(Au=>JSON.stringify(Au.inputShapes)).join(",")}catch{cu="multiple"}try{lu=JSON.stringify(ou.outputShape)}catch{lu="multiple"}const hu=ou.name,pu=ou.getClassName(),mu=[`${hu} (${pu})`,cu,lu,ou.countParams().toString()];f2(mu,nu,ru)}function KH(ou,nu,ru,lu){let cu,hu;try{hu=ou.inboundNodes.map(wu=>JSON.stringify(wu.inputShapes)).join(",")}catch{hu="multiple"}try{cu=JSON.stringify(ou.outputShape)}catch{cu="multiple"}const pu=[];for(const wu of ou.inboundNodes)if(!(ru!=null&&ru.length>0&&ru.indexOf(wu)===-1))for(let Eu=0;Eu<wu.inboundLayers.length;++Eu){const Tu=wu.inboundLayers[Eu].name,Ru=wu.nodeIndices[Eu],Nu=wu.tensorIndices[Eu];pu.push(`${Tu}[${Ru}][${Nu}]`)}const mu=ou.name,Au=ou.getClassName(),bu=pu.length===0?"":pu[0],Cu=[`${mu} (${Au})`,hu,cu,ou.countParams().toString(),bu];f2(Cu,nu,lu);for(let wu=1;wu<pu.length;++wu)f2(["","","","",pu[wu]],nu,lu)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function sL(ou,nu,ru){return(ou==="inboundNodes"||ou==="outputLayers"||ou==="inputLayers")&&nu===0&&typeof ru=="string"}function mT(ou,nu){if(ou===null)return null;if(typeof ou=="string")return m1(ou);if(typeof ou=="number"||typeof ou=="boolean")return ou;if(ou instanceof Array){const ru=[],lu=ou.length;for(let cu=0;cu<lu;++cu){const hu=ou[cu];sL(nu,cu,hu)?ru.push(hu):ru.push(mT(hu,nu))}return ru}else{const ru={};for(const lu of Object.keys(ou)){const cu=ou[lu];if(lu==="name"&&typeof cu=="string")ru[lu]=cu;else{const hu=m1(lu);ru[hu]=mT(cu,hu)}}return ru}}function gT(ou,nu){if(ou==null)return null;if(typeof ou=="string")return av(ou);if(typeof ou=="number"||typeof ou=="boolean")return ou;if(ou instanceof Array){const ru=[],lu=ou.length;for(let cu=0;cu<lu;++cu){const hu=ou[cu];sL(nu,cu,hu)?ru.push(hu):ru.push(gT(hu,nu))}return ru}else{const ru={};for(const lu of Object.keys(ou)){const cu=ou[lu],hu=av(lu);(lu==="name"||lu==="className")&&typeof cu=="string"?ru[hu]=cu:ru[hu]=gT(cu,lu)}return ru}}/** @license See the LICENSE file. */const oL="4.16.0";/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const ZH=ou=>{const nu=Object.keys(ou);if(nu.length===0)return!1;const ru=nu[0].split("/");return!isNaN(parseInt(ru[ru.length-1],10))};class Tx extends n0{constructor(nu){if(super({}),this.containerNodes=new Set,this.name=nu.name,this.name==null){const Gu=this.getClassName().toLowerCase();this.name=JE(Gu)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(nu.inputs)?this.inputs=nu.inputs.slice():this.inputs=[nu.inputs],Array.isArray(nu.outputs)?this.outputs=nu.outputs.slice():this.outputs=[nu.outputs],_v(this.inputs).length!==this.inputs.length)throw new Ep(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(Gu=>Gu.name)}`);_v(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(Gu=>Gu.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const Gu of this.outputs){const Xu=Gu.sourceLayer,Qu=Gu.nodeIndex,Ju=Gu.tensorIndex;this.outputLayers.push(Xu),this.outputLayersNodeIndices.push(Qu),this.outputLayersTensorIndices.push(Ju)}for(const Gu of this.inputs){const Xu=Gu.sourceLayer,Qu=Gu.nodeIndex,Ju=Gu.tensorIndex;zx(Qu===0,"input layer has >1 nodes"),zx(Ju===0,"input layer has >1 tensors"),this.inputLayers.push(Xu),this.inputLayersNodeIndices.push(Qu),this.inputLayersTensorIndices.push(Ju)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let Gu=0;Gu<this.inputLayers.length;Gu++){const Xu=this.inputLayers[Gu];if(!(Xu instanceof Cw))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${nu.inputs}. Input ${Gu} (0-based) originates from layer type ${Xu.getClassName()}.`);this.inputNames.push(Xu.name),this.feedInputShapes.push(Xu.batchInputShape),this.feedInputNames.push(Xu.name)}for(const Gu of this.outputLayers)this.outputNames.push(Gu.name);this.internalInputShapes=this.inputs.map(Gu=>Gu.shape),this.internalOutputShapes=this.outputs.map(Gu=>Gu.shape);const ru={},lu={},cu={},hu={},pu={},mu=[],Au=(Gu,Xu,Qu,Ju,ip,rp)=>{(Ju==null||ip==null||rp==null)&&(Ju=Gu.sourceLayer,ip=Gu.nodeIndex,rp=Gu.tensorIndex);const op=Ju.inboundNodes[ip];if(Qu.indexOf(op)!==-1)throw new cx(`The tensor ${Gu.name} at layer "${Ju.name}" is part of a cycle.`);if(Xu.indexOf(op)!==-1)return;this.containerNodes.add(Tx.nodeKey(Ju,ip)),Ju.id in pu||(pu[Ju.id]=Object.keys(pu).length),Qu.indexOf(op)===-1&&Qu.push(op);const hp=op.inboundLayers.length;for(let Ap=0;Ap<hp;Ap++){const Up=op.inputTensors[Ap],Vp=op.inboundLayers[Ap],zp=op.nodeIndices[Ap],qp=op.tensorIndices[Ap];Au(Up,Xu,Qu,Vp,zp,qp)}for(Xu.push(op);Qu.indexOf(op)>=0;)Qu.splice(Qu.indexOf(op),1);mu.push(op)},bu=[],Cu=[];for(const Gu of this.outputs)Au(Gu,bu,Cu);const wu=mu.slice().reverse();for(const Gu of wu){lu[Gu.id]=Gu,Gu.id in ru||(ru[Gu.id]=0);let Xu=ru[Gu.id];const Qu=cu[Gu.outboundLayer.id]==null?0:cu[Gu.outboundLayer.id];Xu=Math.max(Xu,Qu),cu[Gu.outboundLayer.id]=Xu,hu[Gu.outboundLayer.id]=Gu.outboundLayer,ru[Gu.id]=Xu;for(let Ju=0;Ju<Gu.inboundLayers.length;Ju++){const ip=Gu.inboundLayers[Ju],rp=Gu.nodeIndices[Ju],op=ip.inboundNodes[rp],hp=ru[op.id]==null?0:ru[op.id];ru[op.id]=Math.max(Xu+1,hp),lu[op.id]=op}}const Eu={};for(const Gu in ru){const Xu=ru[Gu];Xu in Eu||(Eu[Xu]=[]),Eu[Xu].push(lu[Gu])}const Tu={};for(const Gu in cu){const Xu=cu[Gu];Xu in Tu||(Tu[Xu]=[]),Tu[Xu].push(hu[Gu])}let Ru=Object.keys(Tu).map(Gu=>parseInt(Gu,10)).sort(YE);this.layers=[];for(const Gu of Ru){const Xu=Tu[Gu];Xu.sort((Qu,Ju)=>{const ip=pu[Qu.id],rp=pu[Ju.id];return ip<rp?-1:ip>rp?1:0});for(const Qu of Xu)Qu instanceof Tx&&this.internalContainerRefs.push(Qu),this.layers.push(Qu)}this.layersByDepth=Tu,Ru=Object.keys(Eu).map(Gu=>parseInt(Gu,10)).sort(YE);const Nu=this.inputs.slice(),Pu=[];for(const Gu of Ru)for(const Xu of Eu[Gu]){const Qu=Xu.outboundLayer;if(Qu!=null){for(const Ju of Xu.inputTensors)if(Nu.indexOf(Ju)===-1)throw new cx(`Graph disconnected: cannot obtain value for tensor ${Ju} at layer "${Qu.name}". The following previous layers were accessed without issue: ${Pu}`);for(const Ju of Xu.outputTensors)Nu.push(Ju);Pu.push(Qu.name)}}this.nodesByDepth=Eu;const Fu=this.layers.map(Gu=>Gu.name);for(const Gu of Fu){const Xu=Fu.filter(Qu=>Qu===Gu).length;if(Xu!==1)throw new cx(`The name "${Gu}" is used ${Xu} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(Fu))}this.outboundNodes=[],this.inboundNodes=[],new r2({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(Gu=>null),outputMasks:this.outputs.map(Gu=>null),inputShapes:this.inputs.map(Gu=>Gu.shape),outputShapes:this.outputs.map(Gu=>Gu.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const nu={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const ru of this.layers)nu.numDisposedVariables+=ru.dispose().numDisposedVariables;for(const ru of this.internalContainerRefs)nu.numDisposedVariables+=ru.dispose().numDisposedVariables}return nu.refCountAfterDispose=this._refCount,nu}get trainable(){return this.trainable_}set trainable(nu){this.layers.forEach(ru=>{ru._trainableWeights.forEach(lu=>lu.trainable=nu)}),this.trainable_=nu}get trainableWeights(){if(this._trainableWeights.length>0)throw new Ep("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let nu=[];for(const ru of this.layers)nu=nu.concat(ru.trainableWeights);return nu}get nonTrainableWeights(){const nu=[];for(const ru of this.layers)nu.push(...ru.nonTrainableWeights);if(!this.trainable){const ru=[];for(const lu of this.layers)ru.push(...lu.trainableWeights);return ru.concat(nu)}return nu}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(nu,ru=!0){const lu={};let cu=0;const hu=ZH(nu);hu&&this.parseWeights(nu);for(const mu of this.layers)for(const[Au,bu]of mu.weights.entries()){const Cu=hu?`${bu.name.split("/").slice(0,-1).join("/")+"/"}${Au}`:bu.originalName;if(lu[Cu]!=null)throw new Ep(`Duplicate weight name: ${Cu}`);lu[Cu]=bu,cu++}const pu=[];for(const mu in nu){let Au=mu;if(lu[mu]==null){const bu=mu.split("/");Au=bu.slice(0,-2).concat([bu[bu.length-1]]).join("/")}if(lu[Au]!=null)pu.push([lu[Au],nu[mu]]);else if(ru)throw new Ep(`Provided weight data has no target variable: ${mu}`);delete lu[Au]}if(ru){const mu=[];for(const Au in lu)mu.push(Au);if(mu.length>0)throw new Ep(`${mu.length} of ${cu} weights are not set: ${mu}`)}cT(pu)}parseWeights(nu){for(const ru in Object.keys(nu)){const lu=ru.split("/"),cu=["vars","layer_checkpoint_dependencies"],hu=lu.map(pu=>pu.startsWith("_")?pu.slice(1):pu).filter(pu=>!cu.includes(pu)).join("/");hu!==ru&&(nu[hu]=nu[ru],delete nu[ru])}}updatedConfig(){const nu=this.getConfig(),ru={};return ru.className=this.getClassName(),ru.config=nu,ru.kerasVersion=`tfjs-layers ${oL}`,ru.backend="TensorFlow.js",ru}toJSON(nu,ru=!0){const lu=gT(this.updatedConfig());return ru?JSON.stringify(lu):lu}call(nu,ru){return Op(()=>{nu=y0(nu);const lu=new kv;for(let cu=0;cu<this.inputs.length;++cu)lu.add(this.inputs[cu],nu[cu]);return ww(this.outputs,lu,ru)})}computeMask(nu,ru){return Op(()=>{nu=y0(nu);let lu;return ru==null?lu=f1(null,nu.length):lu=y0(ru),this.runInternalGraph(nu,lu)[1]})}computeOutputShape(nu){const ru=n2(nu);if(ru.length!==this.inputLayers.length)throw new Ep(`Invalid inputShape argument ${nu}: model has ${this.inputLayers.length} tensor inputs.`);const lu={};for(let mu=0;mu<ru.length;mu++){const Au=this.inputLayers[mu],bu=ru[mu],Cu=Au.name+"_0_0";lu[Cu]=bu}const cu=Object.keys(this.nodesByDepth).map(mu=>parseInt(mu,10)).sort(YE);if(cu.length>1)for(const mu of cu){const Au=this.nodesByDepth[mu];for(const bu of Au){const Cu=bu.outboundLayer;if(this.inputLayers.map(Nu=>Nu.id).indexOf(Cu.id)!==-1)continue;const wu=[];for(let Nu=0;Nu<bu.inboundLayers.length;Nu++){const Pu=bu.inboundLayers[Nu],Fu=bu.nodeIndices[Nu],Gu=bu.tensorIndices[Nu],Xu=`${Pu.name}_${Fu}_${Gu}`,Qu=lu[Xu];wu.push(Qu)}const Eu=Cu.computeOutputShape(Ny(wu)),Tu=n2(Eu),Ru=Cu.inboundNodes.indexOf(bu);for(let Nu=0;Nu<Tu.length;Nu++){const Pu=`${Cu.name}_${Ru}_${Nu}`;lu[Pu]=Tu[Nu]}}}const hu=[],pu=[];for(let mu=0;mu<this.outputLayers.length;mu++){const Au=this.outputLayers[mu],bu=this.outputLayersNodeIndices[mu],Cu=this.outputLayersTensorIndices[mu],wu=`${Au.name}_${bu}_${Cu}`;pu.push(wu)}for(let mu=0;mu<pu.length;mu++){const Au=pu[mu];zx(Au in lu),hu.push(lu[Au])}return Ny(hu)}runInternalGraph(nu,ru){ru==null&&(ru=f1(null,nu.length));const lu={};for(let Au=0;Au<this.inputs.length;++Au){const bu=this.inputs[Au],Cu=nu[Au],wu=ru[Au];lu[bu.id]=[Cu,wu]}const cu=Object.keys(this.nodesByDepth).map(Au=>parseInt(Au,10)).sort(YE);for(const Au of cu){const bu=this.nodesByDepth[Au];for(const Cu of bu){const wu=Cu.outboundLayer,Eu=Cu.inputTensors,Tu=Cu.outputTensors,Ru=new Array;for(const Nu of Eu)Nu.id in lu&&Ru.push(lu[Nu.id]);if(Ru.length===Eu.length){let Nu={},Pu,Fu,Gu,Xu;if(Cu.callArgs!=null&&(Nu=Cu.callArgs),Ru.length===1){const[Qu,Ju]=Ru[0];Nu.mask==null&&(Nu.mask=Ju),Gu=y0(wu.call(Qu,Nu)),Xu=y0(wu.computeMask(Qu,Ju)),Pu=[Qu],Fu=[Ju]}else Pu=Ru.map(Qu=>Qu[0]),Fu=Ru.map(Qu=>Qu[1]),Nu.mask==null&&(Nu.mask=Fu),Gu=y0(wu.call(Pu,Nu)),Xu=y0(wu.computeMask(Pu,Fu));if(wu.activityRegularizer)throw new e0("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let Qu=0;Qu<Tu.length;++Qu){const Ju=Tu[Qu],ip=Gu[Qu],rp=Xu[Qu];lu[Ju.id]=[ip,rp]}}}}const hu=[],pu=[],mu=[];for(const Au of this.outputs){zx(Au.id in lu,`Could not compute output ${Au.name} : ${Au.id}`);const[bu,Cu]=lu[Au.id];mu.push(bu.shape),hu.push(bu),pu.push(Cu)}return[hu,pu,mu]}buildNodeConversionMap(nu){const ru={};let lu;for(const cu of this.layers){lu=cu instanceof Tx?1:0;for(let hu=0;hu<cu.inboundNodes.length;hu++){const pu=Tx.nodeKey(cu,hu);this.containerNodes.has(pu)&&(ru[pu]=lu,lu+=1)}}return ru}getLayer(nu,ru){if(ru!=null)return this.findLayer(ru);if(nu==null)throw new Ep("Provide either a layer name or layer index");if(typeof nu=="number")return this.findLayer(nu);for(const lu of this.layers)if(lu.name===nu)return lu;throw new Ep(`No such layer: ${nu}`)}findLayer(nu){if(this.layers.length<=nu)throw new Ep(`Was asked to retrieve layer at index ${nu}, but model only has ${this.layers.length} layer(s).`);return this.layers[nu]}calculateLosses(){return Op(()=>{const nu=[];for(const ru of this.layers)for(let lu=0;lu<ru.inboundNodes.length;++lu){const cu=Tx.nodeKey(ru,lu);this.containerNodes.has(cu)&&nu.push(...ru.calculateLosses())}return nu})}getConfig(){const nu={name:this.name},ru=this.buildNodeConversionMap(this.layers),lu=[];for(const pu of this.layers){const mu=pu.getClassName(),Au=pu.getConfig(),bu=[];for(let wu=0;wu<pu.inboundNodes.length;wu++){const Eu=pu.inboundNodes[wu],Tu=Tx.nodeKey(pu,wu);let Ru={};if(this.containerNodes.has(Tu)){if(Eu.callArgs)try{JSON.stringify(Eu.callArgs),Ru=Eu.callArgs}catch{console.warn(`Layer ${pu.name} was passed non-serializable keyword arguments: ${Eu.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),Ru={}}if(Eu.inboundLayers.length>0){const Nu=[];for(let Pu=0;Pu<Eu.inboundLayers.length;Pu++){const Fu=Eu.inboundLayers[Pu],Gu=Eu.nodeIndices[Pu],Xu=Eu.tensorIndices[Pu],Qu=Tx.nodeKey(Fu,Gu);let Ju=ru[Qu];Ju==null&&(Ju=0),Nu.push([Fu.name,Ju,Xu,Ru])}bu.push(Nu)}}}const Cu={};Cu.name=pu.name,Cu.className=mu,Cu.config=Au,Cu.inboundNodes=bu,lu.push(Cu)}nu.layers=lu;const cu=[];for(let pu=0;pu<this.inputLayers.length;pu++){const mu=this.inputLayers[pu],Au=this.inputLayersNodeIndices[pu],bu=Tx.nodeKey(mu,Au);if(!this.containerNodes.has(bu))continue;let Cu=ru[bu];Cu==null&&(Cu=0);const wu=this.inputLayersTensorIndices[pu];cu.push([mu.name,Cu,wu])}nu.inputLayers=cu;const hu=[];for(let pu=0;pu<this.outputLayers.length;pu++){const mu=this.outputLayers[pu],Au=this.outputLayersNodeIndices[pu],bu=Tx.nodeKey(mu,Au);if(!this.containerNodes.has(bu))continue;let Cu=ru[bu];Cu==null&&(Cu=0);const wu=this.outputLayersTensorIndices[pu];hu.push([mu.name,Cu,wu])}return nu.outputLayers=hu,nu}static fromConfig(nu,ru,lu={},cu=!1){const hu={},pu={};function mu(Pu,Fu){Pu.name in pu?pu[Pu.name].push(Fu):pu[Pu.name]=[Fu]}function Au(Pu,Fu){const Gu=[];let Xu;for(const Qu of Fu){const Ju=Qu[0],ip=Qu[1],rp=Qu[2];if(Xu=Qu[3]==null?{}:Qu[3],!(Ju in hu)){mu(Pu,Fu);return}const op=hu[Ju];if(op.inboundNodes.length<=ip){mu(Pu,Fu);return}const hp=op.inboundNodes[ip];Gu.push(hp.outputTensors[rp])}Gu.length>0&&Pu.apply(Ny(Gu),Xu)}function bu(Pu){const Fu=Pu.name,Gu=cv(Pu,ru.customObjects!=null?ru.customObjects:{});Gu.setFastWeightInitDuringBuild(cu),hu[Fu]=Gu,Pu.inboundNodes.forEach(Xu=>{if(!(Xu instanceof Array))throw new Ep(`Corrupted configuration, expected array for nodeData: ${Xu}`);mu(Gu,Xu)})}const Cu=ru.name,wu=ru.layers;for(const Pu of wu)bu(Pu);for(;!N5(pu);)for(const Pu of wu){const Fu=hu[Pu.name];if(Fu.name in pu){const Gu=pu[Fu.name];delete pu[Fu.name];for(const Xu of Gu)Au(Fu,Xu)}}const Eu=[],Tu=[],Ru=ru.inputLayers;for(const Pu of Ru){const Fu=Pu[0],Gu=Pu[1],Xu=Pu[2];zx(Fu in hu);const Qu=hu[Fu].inboundNodes[Gu].outputTensors;Eu.push(Qu[Xu])}const Nu=ru.outputLayers;for(const Pu of Nu){const Fu=Pu[0],Gu=Pu[1],Xu=Pu[2];zx(Fu in hu);const Qu=hu[Fu].inboundNodes[Gu].outputTensors;Tu.push(Qu[Xu])}return new nu({inputs:Eu,outputs:Tu,name:Cu})}get stateful(){if(this._stateful)throw new Ep("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const nu of this.layers)if(nu.stateful)return!0;return!1}resetStates(){Op(()=>{this.layers.forEach(nu=>{nu.stateful&&nu.resetStates()})})}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function jH(ou,nu,ru){const lu=nu.length;if(ou==null||Array.isArray(ou)&&ou.length===0)return nu.map(cu=>null);if(lu===1)return Array.isArray(ou)&&ou.length===1?ou:typeof ou=="object"&&nu[0]in ou?[ou[nu[0]]]:[ou];if(Array.isArray(ou)){if(ou.length!==lu)throw new Error(`Provided ${ru} is an array of ${ou.length} element(s), but the model has ${lu} outputs. Make sure a set of weights is provided for each model output.`);return ou}else if(typeof ou=="object"&&Object.keys(ou).length>0&&typeof ou[Object.keys(ou)[0]]=="object"){const cu=[];return nu.forEach(hu=>{hu in ou?cu.push(ou[hu]):cu.push(null)}),cu}else throw new Error(`The model has multiple (${lu}) outputs, so ${ru} must be either an array with ${lu} elements or an object with ${nu} keys. Provided ${ru} not understood: ${JSON.stringify(ou)}`)}function aL(ou,nu){return jH(ou,nu,"classWeight")}async function lL(ou,nu,ru,lu){if(ru!=null){const cu=Op(()=>{if(ou.shape.length===1)return i1(ou);if(ou.shape.length===2){if(ou.shape[1]>1)return nw(ou,1);if(ou.shape[1]===1)return Pp(ou,[ou.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${ou.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${ou.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),hu=Array.from(await cu.data());o0(cu);const pu=[];return hu.forEach(mu=>{if(ru[mu]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${mu} exists in the data but not in classWeight`);pu.push(ru[mu])}),$y(pu,"float32")}else return null}function YH(ou,nu){return _p(ou,nu)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const qH=32;function cL(ou,nu){let ru,lu;const cu=nu;ru=cu.xs,lu=cu.ys,vu(ru!=null&&lu!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${nu}`);const hu=uL("input",ou.inputNames,ru),pu=uL("output",ou.outputNames,lu),mu=hu[0].shape[0];vu(hu.length===ou.inputs.length,()=>`LayersModel has ${ou.inputs.length} inputs, but the dataset provides ${hu.length} inputs.  (Expected input keys: ${JSON.stringify(ou.inputNames)})`),vu(pu.length===ou.outputs.length,()=>`LayersModel has ${ou.outputs.length} outputs, but the dataset provides ${pu.length} outputs.  (Expected output keys: ${JSON.stringify(ou.outputNames)})`);for(let Au=0;Au<hu.length;Au++)vu(hu[Au].shape[0]===mu,()=>`Batch size mismatch: input ${ou.inputNames[Au]} has ${hu[Au].shape[0]}; expected  ${mu} based on input ${ou.inputNames[0]}.`);for(let Au=0;Au<pu.length;Au++)vu(pu[Au].shape[0]===mu,()=>`Batch size mismatch: output ${ou.outputNames[Au]} has ${pu[Au].shape[0]}; expected  ${mu} based on input ${ou.inputNames[0]}.`);return{xs:hu,ys:pu}}function uL(ou,nu,ru){if(ru instanceof q0)return[ru];if(Array.isArray(ru))return vu(ru.length===nu.length,()=>`Received an array of ${ru.length} Tensors, but expected ${nu.length} to match the ${ou} keys ${nu}.`),ru;{const lu=[];for(const cu of nu){if(ru[cu]==null)throw new Ep(`The feature data generated by the dataset lacks the required ${ou} key '${cu}'.`);lu.push(ru[cu])}return lu}}function JH(ou){if(ou.length===3)throw new e0("Validation with sample weights is not implemented yet.");return{xs:ou[0],ys:ou[1]}}async function e4(ou,nu,ru){const lu=ru.batchesPerEpoch!=null;if(vu(ou.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),vu(ru!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),vu(ru.epochs!=null&&ru.epochs>0&&Number.isInteger(ru.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${ru.epochs}`),vu(!lu||ru.batchesPerEpoch>0&&Number.isInteger(ru.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${ru.batchesPerEpoch}`),vu(ru.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),ou.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");ou.isTraining=!0;try{const cu=ru.validationData!=null;let hu,pu;if(cu)if(hL(ru.validationData))vu(ru.validationBatches==null||ru.validationBatches>0&&Number.isInteger(ru.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${ru.validationBatches}`);else{const Pu=JH(ru.validationData);hu=Pu.xs,pu=Pu.ys}const mu=ou.makeTrainFunction(),Au=ou.getDedupedMetricsNames();let bu;cu?bu=Au.slice().concat(Au.map(Pu=>"val_"+Pu)):bu=Au.slice();const Cu=jB(ru.callbacks,ru.yieldEvery),wu=ru.verbose==null?1:ru.verbose,{callbackList:Eu,history:Tu}=YB(Cu,wu,ru.epochs,null,null,t4(nu,ru),null,cu,bu);Eu.setModel(ou),ou.history=Tu,await Eu.onTrainBegin(),ou.stopTraining_=!1;let Ru=ru.initialEpoch==null?0:ru.initialEpoch,Nu=await nu.iterator();for(;Ru<ru.epochs;){const Pu={};await Eu.onEpochBegin(Ru);let Fu=0,Gu=0;for(lu||(Nu=await nu.iterator());!lu||Fu<ru.batchesPerEpoch;){const Xu=await Nu.next();if(lu&&Xu.done){console.warn(`You provided \`batchesPerEpoch\` as ${ru.batchesPerEpoch}, but your dataset iterator ran out of data after ${Fu} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${ru.batchesPerEpoch*ru.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(Xu.value!=null){const{xs:Qu,ys:Ju}=cL(ou,Xu.value),ip={};ip.batch=Gu,ip.size=Qu[0].shape[0],await Eu.onBatchBegin(Gu,ip);const rp=[];if(ru.classWeight!=null){const Ap=aL(ru.classWeight,ou.outputNames);for(let Up=0;Up<Ap.length;++Up)rp.push(await lL(Ju[Up],null,Ap[Up]))}const op=Qu.concat(Ju).concat(rp),hp=mu(op);o0(op);for(let Ap=0;Ap<Au.length;++Ap){const Up=Au[Ap],Vp=hp[Ap];ip[Up]=Vp,Zy(Vp)}await Eu.onBatchEnd(Gu,ip),KB(ip),Gu++,Fu++}if(lu?Fu>=ru.batchesPerEpoch:Xu.done){if(cu){let Qu;hL(ru.validationData)?Qu=y0(await ou.evaluateDataset(ru.validationData,{batches:ru.validationBatches})):Qu=y0(ou.evaluate(hu,pu,{batchSize:ru.validationBatchSize==null?qH:ru.validationBatchSize,verbose:0}));for(let Ju=0;Ju<ou.metricsNames.length;++Ju)Pu[`val_${ou.metricsNames[Ju]}`]=Qu[Ju]}break}if(ou.stopTraining_)break}if(await Eu.onEpochEnd(Ru,Pu),Ru++,ou.stopTraining_)break}return await Eu.onTrainEnd(),await ou.history.syncData(),ou.history}finally{ou.isTraining=!1}}function t4(ou,nu){let ru=null;return nu.batchesPerEpoch!=null?ru=nu.batchesPerEpoch:Number.isFinite(ou.size)&&(ru=ou.size),ru}function hL(ou){return typeof ou.iterator=="function"}function n4(ou){return typeof ou.next=="function"}async function i4(ou,nu,ru){ru=ru||{};const lu=ru.batches!=null,cu=ou.testFunction;let hu=[];if(ru.verbose>0)throw new e0("Verbose mode is not implemented yet.");vu(!lu||ru.batches>0&&Number.isInteger(ru.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(ru.batches)}`);const pu=n4(nu)?nu:await nu.iterator();let mu=0,Au=0;for(;!lu||Au<ru.batches;){const bu=await pu.next();if(hu=Op(()=>{if(bu.value){const{xs:Cu,ys:wu}=cL(ou,bu.value),Eu=Cu.concat(wu),Tu=Op(()=>cu(Eu));if(o0(Eu),Au===0)for(let Nu=0;Nu<Tu.length;++Nu)hu.push(A0(0));const Ru=Eu[0].shape[0];for(let Nu=0;Nu<Tu.length;++Nu){const Pu=Tu[Nu],Fu=hu[Nu];hu[Nu]=Op(()=>Am(hu[Nu],_p(Ru,Pu))),Au>0&&o0(Fu)}o0(Tu),mu+=Ru,++Au}return hu}),bu.done){lu&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${ru.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let bu=0;bu<hu.length;++bu){const Cu=hu[bu];hu[bu]=Xm(hu[bu],mu),o0(Cu)}return Ny(hu)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function AT(ou){vu(ou>0&&Number.isInteger(ou),()=>`batchSize is required to be a positive integer, but got ${ou}`)}function Tw(ou,nu,ru){return ou==null?[null]:Array.isArray(ou)?ou.map(lu=>y1(lu,nu,ru-nu)):y1(ou,nu,ru-nu)}function yT(ou,nu){return Op(()=>ou==null?null:Array.isArray(ou)?ou.map(ru=>yT(ru,nu)):_B(ou,nu.dtype==="int32"?nu:km(nu,"int32")))}function bT(ou,nu){const ru=[];let lu=0,cu=null;for(;lu<ou;)cu=lu+nu,cu>=ou&&(cu=ou),ru.push([lu,cu]),lu=cu;return ru}function dL(ou){const nu=[];ou instanceof q0&&(ou=[ou]);for(let ru=0;ru<ou.length;++ru){const lu=ou[ru];if(lu.rank===1)nu.push(bw(lu,1));else{if(lu.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");nu.push(lu)}}return nu}function Mx(ou,nu){if(ou==null)return;const ru=[];if(nu instanceof q0)ru.push(nu.id);else if(Array.isArray(nu))nu.forEach(cu=>ru.push(cu.id));else if(nu!=null)for(const cu in nu){const hu=nu[cu];ru.push(hu.id)}const lu=[];if(ou instanceof q0)ru.indexOf(ou.id)===-1&&lu.push(ou);else if(Array.isArray(ou))ou.forEach(cu=>{ru.indexOf(cu.id)===-1&&lu.push(cu)});else if(ou!=null)for(const cu in ou){const hu=ou[cu];ru.indexOf(hu.id)===-1&&lu.push(hu)}lu.forEach(cu=>{cu.isDisposed||cu.dispose()})}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function r4(ou){return ou instanceof q0}function xT(ou){return Array.isArray(ou)}function pL(ou){return!r4(ou)&&!xT(ou)}function fL(ou,nu,ru,lu=!0,cu=""){if(nu==null||nu.length===0){if(ou!=null){let pu=!1;if(xT(ou)&&ou.length>0)pu=!0;else if(pL(ou)){for(const mu in ou)if(ou.hasOwnProperty(mu)){pu=!0;break}}else pu=!0;if(pu)throw new Ep(`Error when checking model ${cu} expected no data, but got ${ou}`)}return[]}if(ou==null)return nu.map(pu=>null);let hu;if(pL(ou)){ou=ou,hu=[];for(const pu of nu){if(ou[pu]==null)throw new Ep(`No data provided for "${pu}". Need data for each key in: ${nu}`);hu.push(ou[pu])}}else if(xT(ou)){if(ou=ou,ou.length!==nu.length)throw new Ep(`Error when checking model ${cu}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${nu.length} Tensor(s), but instead got the following list of Tensor(s): ${ou}`);hu=ou}else{if(ou=ou,nu.length>1)throw new Ep(`The model ${cu} expects ${nu.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${ou.shape}`);hu=[ou]}if(hu=dL(hu),ru!=null)for(let pu=0;pu<nu.length;++pu){if(ru[pu]==null)continue;const mu=hu[pu];if(mu.shape.length!==ru[pu].length)throw new Ep(`Error when checking ${cu}: expected ${nu[pu]} to have ${ru[pu].length} dimension(s). but got array with shape ${mu.shape}`);for(let Au=0;Au<ru[pu].length;++Au){if(Au===0&&!lu)continue;const bu=mu.shape[Au],Cu=ru[pu][Au];if(Cu!=null&&Cu>=0&&bu!==Cu)throw new Ep(`${cu} expected a batch of elements where each example has shape [${ru[pu].slice(1,ru[pu].length)}] (i.e.,tensor shape [*,${ru[pu].slice(1,ru[pu].length)}]) but the ${cu} received an input with ${mu.shape[0]} examples, each with shape [${mu.shape.slice(1,mu.shape.length)}] (tensor shape [${mu.shape}])`)}}return hu}function s4(ou,nu,ru){const lu=_v(ou.map(hu=>hu.shape[0]));lu.sort();const cu=_v(nu.map(hu=>hu.shape[0]));if(cu.sort(),lu.length>1)throw new Ep(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(ou.map(hu=>hu.shape))}`);if(cu.length>1)throw new Ep(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(nu.map(hu=>hu.shape))}`);if(lu.length>0&&cu.length>0&&!ku(lu,cu))throw new Ep(`Input Tensors should have the same number of samples as target Tensors. Found ${lu[0]} input sample(s) and ${cu[0]} target sample(s).`)}function o4(ou,nu,ru){const lu=[l2,u2,Iw];for(let cu=0;cu<ou.length;++cu){const hu=ou[cu],pu=nu[cu],mu=ru[cu];if(pu!=null){if(pu===Iw&&hu.shape[hu.shape.length-1]===1)throw new Ep(`You are passing a target array of shape ${hu.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(lu.indexOf(pu)!==-1){const Au=hu.shape.slice(1),bu=mu.slice(1);for(let Cu=0;Cu<Au.length;++Cu){const wu=Au[Cu],Eu=bu[Cu];if(Eu!=null&&wu!==Eu)throw new Ep(`A target Tensor with shape ${hu.shape} was passed for an output of shape ${mu}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function mL(ou,nu,ru,lu=!0,cu=""){let hu;if(Array.isArray(ou)){if(ou.length!==nu.length)throw new Ep(`Error when checking model ${cu}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${nu.length} Tensor(s), but instead got ${ou.length} Tensors(s).`);hu=ou}else{if(nu.length>1)throw new Ep(`The model expects ${nu.length} ${cu} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(ou.shape)}.`);hu=[ou]}if(ru!=null)for(let pu=0;pu<nu.length;++pu){if(ru[pu]==null)continue;const mu=hu[pu];if(mu.shape.length!==ru[pu].length)throw new Ep(`Error when checking ${cu}: expected ${nu[pu]} to have ${ru[pu].length} dimension(s), but got array with shape ${JSON.stringify(mu.shape)}`);for(let Au=0;Au<ru[pu].length;++Au){if(Au===0&&!lu)continue;const bu=mu.shape[Au],Cu=ru[pu][Au];if(Cu!=null&&Cu!==bu)throw new Ep(`Error when checking ${cu}: expected ${nu[pu]} to have shape ${JSON.stringify(ru[pu])} but got array with shape ${JSON.stringify(mu.shape)}.`)}}}function a4(ou,nu){if(ou==null||Array.isArray(ou)&&ou.length===0)return nu.map(lu=>[]);let ru;if(typeof ou=="string"||typeof ou=="function")ru=[ou];else if(Array.isArray(ou)||typeof ou=="object")ru=ou;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${ou}`);if(Array.isArray(ru))return nu.map(lu=>ru);{const lu=[];for(const cu of nu){let hu=ru.hasOwnProperty(cu)?ru[cu]:[];Array.isArray(hu)||(hu=[hu]),lu.push(hu)}return lu}}const l4="layers-model";class iC extends Tx{constructor(nu){super(nu),this.isTraining=!1}summary(nu,ru,lu=console.log){if(!this.built)throw new Ep("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");WH(this,nu,ru,lu)}compile(nu){if(nu.loss==null&&(nu.loss=[]),this.loss=nu.loss,typeof nu.optimizer=="string")this.optimizer_=zH(nu.optimizer),this.isOptimizerOwned=!0;else{if(!(nu.optimizer instanceof Tv))throw new Ep("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=nu.optimizer,this.isOptimizerOwned=!1}let ru=[];if(!Array.isArray(nu.loss)&&typeof nu.loss!="string"&&typeof nu.loss!="function"){nu.loss=nu.loss;for(const pu in nu.loss)if(this.outputNames.indexOf(pu)===-1)throw new Ep(`Unknown entry in loss dictionary: "${pu}". Only expected the following keys: ${this.outputNames}`);for(const pu of this.outputNames)nu.loss[pu]==null&&console.warn(`Output "${pu}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${pu} during training`),ru.push(pT(nu.loss[pu]))}else if(Array.isArray(nu.loss)){if(nu.loss.length!==this.outputs.length)throw new Ep(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${nu.loss}.`);ru=nu.loss.map(pu=>pT(pu))}else{const pu=pT(nu.loss);this.outputs.forEach(mu=>{ru.push(pu)})}this.lossFunctions=ru,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let pu=0;pu<this.outputs.length;++pu){const mu=this.internalOutputShapes[pu],Au=this.outputNames[pu];this.feedOutputNames.push(Au),this.feedOutputShapes.push(mu),this.feedLossFns.push(this.lossFunctions[pu])}const lu=[];this.metrics=nu.metrics,this.metricsNames=["loss"],this.metricsTensors=[],A1("loss",()=>{for(let pu=0;pu<this.outputs.length;++pu){if(lu.indexOf(pu)!==-1)continue;const mu=this.lossFunctions[pu];this.outputs.length>1&&(this.metricsTensors.push([mu,pu]),this.metricsNames.push(this.outputNames[pu]+"_loss"))}});const cu=a4(nu.metrics,this.outputNames),hu=(pu,mu,Au)=>{this.outputNames.length>1&&(mu=this.outputNames[pu]+"_"+mu),this.metricsNames.push(mu),this.metricsTensors.push([Au,pu])};A1("metric",()=>{for(let pu=0;pu<this.outputs.length;++pu){if(lu.indexOf(pu)!==-1)continue;const mu=cu[pu];(Au=>{const bu="";let Cu,wu,Eu;for(const Tu of Au){if(typeof Tu=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(Tu)!==-1){const Nu=this.internalOutputShapes[pu];Nu[Nu.length-1]===1||this.lossFunctions[pu]===u2?["accuracy","acc"].indexOf(Tu)!==-1?wu=JB:["crossentropy","ce"].indexOf(Tu)!==-1&&(wu=LH):this.lossFunctions[pu]===c2?["accuracy","acc"].indexOf(Tu)!==-1?wu=NH:["crossentropy","ce"].indexOf(Tu)!==-1&&(wu=nL):["accuracy","acc"].indexOf(Tu)!==-1?wu=eL:["crossentropy","ce"].indexOf(Tu)!==-1&&(wu=tL);let Pu;["accuracy","acc"].indexOf(Tu)!==-1?Pu="acc":["crossentropy","ce"].indexOf(Tu)!==-1&&(Pu="ce"),Eu=wu,Cu=bu+Pu}else Eu=VH(Tu),Cu=bu+p2(Tu);let Ru;A1(Cu,()=>{Ru=Eu}),hu(pu,Cu,Ru)}})(mu)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(nu,ru,lu={}){const cu=lu.batchSize==null?32:lu.batchSize;AT(cu);const hu=this.standardizeUserDataXY(nu,ru,!0,cu);try{const pu=hu[0].concat(hu[1]);this.makeTestFunction();const mu=this.testFunction,Au=this.testLoop(mu,pu,cu,lu.verbose,lu.steps);return Ny(Au)}finally{Mx(hu[0],nu),Mx(hu[1],ru)}}async evaluateDataset(nu,ru){return this.makeTestFunction(),i4(this,nu,ru)}checkNumSamples(nu,ru,lu,cu="steps"){let hu;if(lu!=null){if(hu=null,ru!=null)throw new Ep(`If ${cu} is set, batchSize must be null or undefined.Got batchSize = ${ru}`)}else if(nu!=null)Array.isArray(nu)?hu=nu[0].shape[0]:hu=nu.shape[0];else throw new Ep(`Either the input data should have a defined shape, or ${cu} shoud be specified.`);return hu}execute(nu,ru){if(Array.isArray(ru)&&ru.length===0)throw new Ep("`outputs` is an empty Array, which is not allowed.");const lu=Array.isArray(ru),cu=lu?ru:[ru],hu=this.retrieveSymbolicTensors(cu),pu=new kv;if(nu instanceof q0&&(nu=[nu]),Array.isArray(nu)){if(nu.length!==this.inputs.length)throw new Ep(`The number of inputs provided (${nu.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let Au=0;Au<this.inputs.length;++Au)pu.add(this.inputs[Au],nu[Au])}else for(const Au of this.inputs){const bu=nu[Au.name];if(bu==null)throw new Ep(`No value is provided for the model's input ${Au.name}`);pu.add(Au,bu)}const mu=ww(hu,pu);return lu?mu:mu[0]}retrieveSymbolicTensors(nu){const ru=f1(null,nu.length);let lu=nu.length;for(const cu of this.layers){const hu=Array.isArray(cu.output)?cu.output:[cu.output],pu=hu.map(mu=>mu.name);for(let mu=0;mu<nu.length;++mu){const Au=pu.indexOf(nu[mu]);if(Au!==-1&&(ru[mu]=hu[Au],lu--),lu===0)break}if(lu===0)break}if(lu>0){const cu=[];throw ru.forEach((hu,pu)=>{hu==null&&cu.push(nu[pu])}),new Ep(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(cu)}`)}return ru}predictLoop(nu,ru=32,lu=!1){return Op(()=>{const cu=this.checkNumSamples(nu);if(lu)throw new e0("Verbose predictLoop() is not implemented yet.");const hu=bT(cu,ru),pu=this.outputs.map(mu=>[]);for(let mu=0;mu<hu.length;++mu)Op(()=>{const Au=hu[mu][0],bu=hu[mu][1],Cu=Tw(nu,Au,bu),wu=[];if(Array.isArray(Cu))for(let Tu=0;Tu<Cu.length;++Tu)wu.push({key:this.inputs[Tu],value:Cu[Tu]});else wu.push({key:this.inputs[0],value:Cu});const Eu=new kv(wu);return ww(this.outputs,Eu)}).forEach((Au,bu)=>pu[bu].push(Au));return Ny(pu.map(mu=>By(mu,0)))})}predict(nu,ru={}){const lu=dL(nu);mL(lu,this.inputNames,this.feedInputShapes,!1);try{const cu=ru.batchSize==null?32:ru.batchSize;return AT(cu),this.predictLoop(lu,cu)}finally{Mx(lu,nu)}}predictOnBatch(nu){mL(nu,this.inputNames,this.feedInputShapes,!0);const ru=(Array.isArray(nu)?nu[0]:nu).shape[0];return this.predictLoop(nu,ru)}standardizeUserDataXY(nu,ru,lu=!0,cu){if(this.optimizer_==null)throw new cx("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const hu=[];for(let pu=0;pu<this.feedOutputShapes.length;++pu){const mu=this.feedOutputShapes[pu];this.feedLossFns[pu]===c2?hu.push(mu.slice(0,mu.length-1).concat([1])):hu.push(mu)}if(nu=fL(nu,this.feedInputNames,this.feedInputShapes,!1,"input"),ru=fL(ru,this.feedOutputNames,hu,!1,"target"),s4(nu,ru),o4(ru,this.feedLossFns,this.feedOutputShapes),this.stateful&&cu!=null&&cu>0&&nu[0].shape[0]%cu!==0)throw new Ep(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${cu}. Found: ${nu[0].shape[0]} sample(s).`);return[nu,ru]}async standardizeUserData(nu,ru,lu,cu,hu=!0,pu){const[mu,Au]=this.standardizeUserDataXY(nu,ru,hu,pu);if(lu!=null)throw new Error("sample weight is not supported yet.");let bu=null;if(cu!=null){const Cu=aL(cu,this.outputNames);bu=[];for(let wu=0;wu<Cu.length;++wu)bu.push(await lL(Au[wu],null,Cu[wu]))}return[mu,Au,bu]}testLoop(nu,ru,lu,cu=0,hu){return Op(()=>{const pu=this.checkNumSamples(ru,lu,hu,"steps"),mu=[];if(cu>0)throw new e0("Verbose mode is not implemented yet.");if(hu!=null)throw new e0("steps mode in testLoop() is not implemented yet");{const Au=bT(pu,lu),bu=$y(Ex(0,pu));for(let Cu=0;Cu<Au.length;++Cu){const wu=Au[Cu][0],Eu=Au[Cu][1],Tu=y1(bu,wu,Eu-wu),Ru=yT(ru,Tu),Nu=nu(Ru);if(Cu===0)for(let Pu=0;Pu<Nu.length;++Pu)mu.push(A0(0));for(let Pu=0;Pu<Nu.length;++Pu){const Fu=Nu[Pu];mu[Pu]=Am(mu[Pu],_p(Eu-wu,Fu))}}for(let Cu=0;Cu<mu.length;++Cu)mu[Cu]=Xm(mu[Cu],pu)}return mu})}getDedupedMetricsNames(){const nu=this.metricsNames,ru=[];for(let lu=0;lu<nu.length;++lu){const cu=nu[lu];let hu=cu;if(yB(nu,cu)>1){const pu=yB(nu.slice(0,lu),cu);hu+=`_${pu}`}ru.push(hu)}return ru}makeTrainFunction(){return nu=>{const ru=[],lu=nu.slice(0,this.inputs.length),cu=nu.slice(this.inputs.length,this.inputs.length+this.outputs.length),hu=nu.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),pu=[],mu=()=>{const bu=[];for(let Tu=0;Tu<this.inputs.length;++Tu)bu.push({key:this.inputs[Tu],value:lu[Tu]});const Cu=new kv(bu),wu=ww(this.outputs,Cu,{training:!0});let Eu;for(let Tu=0;Tu<this.lossFunctions.length;++Tu){const Ru=this.lossFunctions[Tu];let Nu=Ru(cu[Tu],wu[Tu]);hu[Tu]!=null&&(Nu=YH(Nu,hu[Tu]));const Pu=Y0(Nu);ru.push(Pu),Tu===0?Eu=Nu:Eu=Am(Eu,Nu)}for(let Tu=0;Tu<this.metricsTensors.length;++Tu){let Ru;if(this.outputs.length>1&&Tu<this.outputs.length)Ru=ru[Tu];else{const Nu=this.metricsTensors[Tu][0],Pu=this.metricsTensors[Tu][1];Ru=Y0(Nu(cu[Pu],wu[Pu]))}Zy(Ru),pu.push(Ru)}return Eu=Y0(Eu),this.calculateLosses().forEach(Tu=>{Eu=Am(Eu,Tu)}),Eu},Au=this.collectedTrainableWeights.map(bu=>bu.read());return[this.optimizer_.minimize(mu,!0,Au)].concat(pu)}}makeTestFunction(){this.testFunction=nu=>Op(()=>{const ru=[];let lu;const cu=nu.slice(0,this.inputs.length),hu=nu.slice(this.inputs.length,this.inputs.length+this.outputs.length),pu=[];for(let bu=0;bu<this.inputs.length;++bu)pu.push({key:this.inputs[bu],value:cu[bu]});const mu=new kv(pu),Au=ww(this.outputs,mu);for(let bu=0;bu<this.lossFunctions.length;++bu){const Cu=this.lossFunctions[bu],wu=Y0(Cu(hu[bu],Au[bu]));bu===0?lu=wu:lu=Am(lu,wu),ru.push(lu)}for(let bu=0;bu<this.metricsTensors.length;++bu){const Cu=this.metricsTensors[bu][0],wu=this.metricsTensors[bu][1],Eu=Y0(Cu(hu[wu],Au[wu]));ru.push(Eu)}return ru})}async fit(nu,ru,lu={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let cu,hu,pu,mu,Au,bu,Cu,wu,Eu;try{const Tu=lu.batchSize==null?32:lu.batchSize;AT(Tu);const Ru=await this.standardizeUserData(nu,ru,lu.sampleWeight,lu.classWeight,!1,Tu);cu=Ru[0],hu=Ru[1],Eu=Ru[2];let Nu=!1,Pu;if(lu.validationData!=null&&lu.validationData.length>0){if(Nu=!0,lu.validationData.length===2)Au=lu.validationData[0],bu=lu.validationData[1];else throw lu.validationData.length===3?new e0("validationData including sample weights is not supported yet."):new Ep(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${lu.validationData} is invalid.`);const rp=await this.standardizeUserData(Au,bu,null,null,!0,Tu);Cu=rp[0],wu=rp[1],Pu=Cu.concat(wu)}else if(lu.validationSplit!=null&&lu.validationSplit>0&&lu.validationSplit<1){Nu=!0;const rp=Math.floor(cu[0].shape[0]*(1-lu.validationSplit)),op=cu[0].shape[0];Cu=Tw(cu,rp,op),pu=cu,cu=Tw(cu,0,rp),wu=Tw(hu,rp,op),mu=hu,hu=Tw(hu,0,rp),Pu=Cu.concat(wu)}else lu.validationSteps!=null&&(Nu=!0);const Fu=cu.concat(hu).concat(Eu);this.checkTrainableWeightsConsistency();const Gu=this.makeTrainFunction(),Xu=this.getDedupedMetricsNames();let Qu,Ju;Nu?(this.makeTestFunction(),Qu=this.testFunction,Ju=Xu.slice().concat(Xu.map(rp=>"val_"+rp))):(Qu=null,Pu=[],Ju=Xu.slice());const ip=jB(lu.callbacks,lu.yieldEvery);return await this.fitLoop(Gu,Fu,Xu,Tu,lu.epochs,lu.verbose,ip,Qu,Pu,lu.shuffle,Ju,lu.initialEpoch,null,null)}finally{this.isTraining=!1,Mx(cu,nu),Mx(hu,ru),Mx(pu,nu),Mx(mu,ru),Mx(Cu,Au),Mx(wu,bu),Eu!=null&&o0(Eu)}}async fitLoop(nu,ru,lu,cu,hu,pu,mu,Au,bu,Cu,wu,Eu,Tu,Ru){cu==null&&(cu=32),hu==null&&(hu=1),Cu==null&&(Cu=!0),Eu==null&&(Eu=0);let Nu=!1;if(Au!=null&&bu!=null&&(Nu=!0),Ru!=null&&(Nu=!0,Tu==null))throw new Ep("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const Pu=this.checkNumSamples(ru,cu,Tu,"steps_per_epoch");let Fu;Pu!=null&&(Fu=Ex(0,Pu)),pu==null&&(pu=1);const{callbackList:Gu,history:Xu}=YB(mu,pu,hu,Eu,Pu,Tu,cu,Nu,wu);Gu.setModel(this),this.history=Xu,await Gu.onTrainBegin(),this.stopTraining_=!1;for(let Qu=Eu;Qu<hu;++Qu){await Gu.onEpochBegin(Qu);const Ju={};if(Tu!=null)throw new e0("stepsPerEpoch mode is not implemented yet.");{if(Cu==="batch")throw new e0("batch shuffling is not implemneted yet");Cu&&du(Fu);const ip=$y(Fu),rp=bT(Pu,cu);for(let op=0;op<rp.length;++op){const hp={};if(await Gu.onBatchBegin(op,hp),Op(()=>{const Ap=rp[op][0],Up=rp[op][1],Vp=y1(ip,Ap,Up-Ap);hp.batch=op,hp.size=Up-Ap;const zp=yT(ru,Vp),qp=nu(zp);for(let Yp=0;Yp<lu.length;++Yp){const em=lu[Yp],am=qp[Yp];hp[em]=am,Zy(am)}if(op===rp.length-1&&Nu){const Yp=this.testLoop(Au,bu,cu);for(let em=0;em<lu.length;++em){const am=lu[em],im=Yp[em];Zy(im),Ju["val_"+am]=im}}}),await Gu.onBatchEnd(op,hp),KB(hp),this.stopTraining_)break}ip.dispose()}if(await Gu.onEpochEnd(Qu,Ju),this.stopTraining_)break}return await Gu.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(nu,ru){return e4(this,nu,ru)}async trainOnBatch(nu,ru){const lu=await this.standardizeUserData(nu,ru),cu=lu[0],hu=lu[1],pu=this.makeTrainFunction()(cu.concat(hu)),mu=[];for(const Au of pu){const bu=await Au.data();mu.push(bu[0])}return o0(pu),Mx(lu[0],nu),Mx(lu[1],ru),Ny(mu)}getNamedWeights(nu){const ru=[],lu=nu!=null&&nu.trainableOnly,cu=lu?this.trainableWeights:this.weights,hu=this.getWeights(lu);for(let pu=0;pu<cu.length;++pu)lu&&!cu[pu].trainable||ru.push({name:cu[pu].originalName,tensor:hu[pu]});return ru}set stopTraining(nu){this.stopTraining_=nu}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(nu){this.optimizer_!==nu&&(this.optimizer_=nu,this.isOptimizerOwned=!1)}dispose(){const nu=super.dispose();if(nu.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const ru=MS().numTensors;this.optimizer_.dispose(),nu.numDisposedVariables+=ru-MS().numTensors}return nu}getLossIdentifiers(){let nu;if(typeof this.loss=="string")nu=av(this.loss);else if(Array.isArray(this.loss)){for(const ru of this.loss)if(typeof ru!="string")throw new Error("Serialization of non-string loss is not supported.");nu=this.loss.map(ru=>av(ru))}else{const ru=Object.keys(this.loss);nu={};const lu=this.loss;for(const cu of ru)if(typeof lu[cu]=="string")nu[cu]=av(lu[cu]);else throw new Error("Serialization of non-string loss is not supported.")}return nu}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[av(p2(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(nu=>av(p2(nu)));{const nu={};for(const ru in this.metrics)nu[ru]=av(p2(this.metrics[ru]));return nu}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(nu){if(nu.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(nu.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(nu.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const ru=mT(nu.optimizer_config),lu=cv(ru);let cu;if(typeof nu.loss=="string")cu=m1(nu.loss);else if(Array.isArray(nu.loss))cu=nu.loss.map(pu=>m1(pu));else if(nu.loss!=null){cu={};for(const pu in nu.loss)cu[pu]=m1(nu.loss[pu])}let hu;if(Array.isArray(nu.metrics))hu=nu.metrics.map(pu=>m1(pu));else if(nu.metrics!=null){hu={};for(const pu in nu.metrics)hu[pu]=m1(nu.metrics[pu])}this.compile({loss:cu,metrics:hu,optimizer:lu})}async save(nu,ru){if(typeof nu=="string"){const hu=UP(nu);if(hu.length===0)throw new Ep(`Cannot find any save handlers for URL '${nu}'`);if(hu.length>1)throw new Ep(`Found more than one (${hu.length}) save handlers for URL '${nu}'`);nu=hu[0]}if(nu.save==null)throw new Ep("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const lu=await SM(this.getNamedWeights(ru)),cu={modelTopology:this.toJSON(null,!1),format:l4,generatedBy:`TensorFlow.js tfjs-layers v${oL}`,convertedBy:null};if(ru!=null&&ru.includeOptimizer&&this.optimizer!=null){cu.trainingConfig=this.getTrainingConfig();const hu="optimizer",{data:pu,specs:mu}=await SM(await this.optimizer.getWeights(),hu);lu.specs.push(...mu),lu.data=OP([lu.data,pu])}return this.userDefinedMetadata!=null&&(rL(this.userDefinedMetadata,this.name,!0),cu.userDefinedMetadata=this.userDefinedMetadata),cu.weightData=lu.data,cu.weightSpecs=lu.specs,nu.save(cu)}setUserDefinedMetadata(nu){rL(nu,this.name),this.userDefinedMetadata=nu}getUserDefinedMetadata(){return this.userDefinedMetadata}}iC.className="Model",hm(iC);class gL extends iC{}gL.className="Functional",hm(gL);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class _w extends iC{constructor(nu){if(super({inputs:[],outputs:[]}),nu=nu||{},this.trainable=!0,this.built=!1,this.name=nu.name!=null?nu.name:JE("sequential_"),nu.layers!=null)for(const ru of nu.layers)this.add(ru)}checkShape(nu){if(nu.inboundNodes[0].outputTensors[0].shape.some(ru=>ru<0))throw new Ep(`Negative dimension size caused by adding layer ${nu.name} with input shape [${nu.inboundNodes[0].inputTensors[0].shape}]`)}add(nu){const ru=nu instanceof _w||nu instanceof iC;let lu;if(ru){if(lu=nu,lu.outputs.length!==1)throw new Ep("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(lu.inputs.length!==1)throw new Ep("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(nu.inboundNodes.length===0){if(nu.batchInputShape==null)throw new Ep("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const cu=hH({batchShape:nu.batchInputShape,dtype:nu.dtype,name:nu.name+"_input"});nu.apply(cu)}if(ru)this.outputs=lu.outputs,this.inputs=lu.inputs;else{if(nu.inboundNodes.length!==1)throw new Ep(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${nu.name} which has ${nu.inboundNodes.length} pre-existing inbound connections.`);if(nu.inboundNodes[0].outputTensors.length!==1)throw new Ep("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(nu),this.outputs=[nu.inboundNodes[0].outputTensors[0]],this.inputs=UB(this.outputs[0])}this.inboundNodes=[],new r2({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:f1(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(cu=>cu.shape),outputShapes:this.outputs[0].shape})}else{const cu=nu.apply(this.outputs[0]);if(Array.isArray(cu))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(nu),this.outputs=[cu],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(nu),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const nu=this.layers.length-1;this.layers[nu].outboundNodes=[],this.outputs=[this.layers[nu].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(nu,ru){return this.model==null&&this.build(),this.model.call(nu,ru)}build(nu){if(p0(nu),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new iC({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(nu,ru,lu=console.log){this.built||this.build(),super.summary(nu,ru,lu)}setWeights(nu){this.model==null&&this.build(),this.model.setWeights(nu)}evaluate(nu,ru,lu={}){if(!this.built)throw new cx("The model needs to be compiled before being used.");return this.model.evaluate(nu,ru,lu)}async evaluateDataset(nu,ru){if(!this.built)throw new cx("The model needs to be compiled before being used.");return this.model.evaluateDataset(nu,ru)}predict(nu,ru={}){return this.model==null&&this.build(),this.model.predict(nu,ru)}predictOnBatch(nu){return this.model==null&&this.build(),this.model.predictOnBatch(nu)}compile(nu){this.build(),this.model.compile(nu),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(nu){this.model.optimizer=nu}async fit(nu,ru,lu={}){if(!this.built)throw new cx("The model needs to be compiled before being used.");return this.model.fit(nu,ru,lu)}async fitDataset(nu,ru){if(!this.built)throw new cx("The model needs to be compiled before being used.");return this.model.fitDataset(nu,ru)}async trainOnBatch(nu,ru){return this.model.trainOnBatch(nu,ru)}static fromConfig(nu,ru,lu={},cu=!1){let hu,pu={};if(ru instanceof Array){if(ru[0].className==null||ru[0].className==="Merge")throw new Ep("Legacy serialization format not supported yet.");hu=ru}else vu(ru.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),hu=ru.layers,delete ru.layers,pu=ru;const mu=new nu(pu);if(!(mu instanceof _w))throw new e0(`Sequential.fromConfig called on non-Sequential input: ${mu}`);for(const Au of hu){const bu=cv(Au,void 0,cu);cu&&bu.setFastWeightInitDuringBuild(!0),mu.add(bu)}return mu}set stopTraining(nu){if(this.model==null)throw new Ep("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=nu}get stopTraining(){if(this.model==null)throw new Ep("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const nu=[];for(const ru of this.layers){const lu={};lu.className=ru.getClassName(),lu.config=ru.getConfig(),nu.push(lu)}return{name:this.name,layers:nu}}}_w.className="Sequential",hm(_w);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let Dy=class extends J1{getConfig(){return{}}};class AL extends Dy{apply(nu,ru=1){return Z5(nu,ru)}}AL.className="elu",hm(AL);class yL extends Dy{apply(nu){return lR(nu)}}yL.className="selu",hm(yL);class bL extends Dy{apply(nu){return c1(nu)}}bL.className="relu",hm(bL);class xL extends Dy{apply(nu){return Op(()=>cw(6,c1(nu)))}}xL.className="relu6",hm(xL);class vL extends Dy{apply(nu){return nu}}vL.className="linear",hm(vL);class CL extends Dy{apply(nu){return Q1(nu)}}CL.className="sigmoid",hm(CL);class wL extends Dy{apply(nu){return Y5(nu)}}wL.className="hardSigmoid",hm(wL);class EL extends Dy{apply(nu){return lw(nu)}}EL.className="softplus",hm(EL);class SL extends Dy{apply(nu){return j5(nu)}}SL.className="softsign",hm(SL);class IL extends Dy{apply(nu){return OS(nu)}}IL.className="tanh",hm(IL);let vT=class extends Dy{apply(ou,nu=-1){return rI(ou,nu)}};vT.className="softmax",hm(vT);class TL extends Dy{apply(nu,ru=-1){return QM(nu,ru)}}TL.className="logSoftmax",hm(TL);class _L extends Dy{apply(nu,ru=1){return Op(()=>_p(Q1(_p(nu,ru)),nu))}}_L.className="swish",hm(_L);class ML extends Dy{apply(nu){return Op(()=>_p(nu,OS(lw(nu))))}}ML.className="mish",hm(ML);function Bv(ou){return ou.getClassName()}function CT(ou,nu={}){return Aw(ou,lx.getMap().classNameMap,nu,"activation")}function Lv(ou){if(ou==null){const nu={};return nu.className="linear",nu.config={},CT(nu)}if(typeof ou=="string"){const nu={};return nu.className=ou,nu.config={},CT(nu)}else return ou instanceof Dy?ou:CT(ou)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function c4(ou){if(ou!=null&&typeof ou!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${ou}`)}class RL extends J1{}class kL extends RL{constructor(nu){super(),c4(nu),this.l1=nu==null||nu.l1==null?.01:nu.l1,this.l2=nu==null||nu.l2==null?.01:nu.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(nu){return Op(()=>{let ru=ay([1]);return this.hasL1&&(ru=Am(ru,zm(_p(this.l1,vy(nu))))),this.hasL2&&(ru=Am(ru,zm(_p(this.l2,xw(nu))))),Pp(ru,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(nu,ru){return new nu({l1:ru.l1,l2:ru.l2})}}kL.className="L1L2",hm(kL);const BL={l1l2:"L1L2"};function v0(ou){return XI(ou)}function LL(ou,nu={}){return Aw(ou,lx.getMap().classNameMap,nu,"regularizer")}function F0(ou){if(ou==null)return null;if(typeof ou=="string"){const nu={className:ou in BL?BL[ou]:ou,config:{}};return LL(nu)}else return ou instanceof RL?ou:LL(ou)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class NL extends n0{constructor(nu){super(nu??{}),this.supportsMasking=!0,nu!=null&&(this.maxValue=nu.maxValue)}call(nu,ru){nu=jm(nu);let lu=c1(nu);return this.maxValue!=null&&(lu=jy(lu,0,this.maxValue)),lu}computeOutputShape(nu){return nu}getConfig(){const nu={maxValue:this.maxValue},ru=super.getConfig();return Object.assign(nu,ru),nu}}NL.className="ReLU",hm(NL);class DL extends n0{constructor(nu){super(nu??{}),this.DEFAULT_ALPHA=.3,nu==null&&(nu={}),this.alpha=nu.alpha==null?this.DEFAULT_ALPHA:nu.alpha}call(nu,ru){const lu=jm(nu);return KS(lu,this.alpha)}computeOutputShape(nu){return nu}getConfig(){const nu={alpha:this.alpha},ru=super.getConfig();return Object.assign(nu,ru),nu}}DL.className="LeakyReLU",hm(DL);class FL extends n0{constructor(nu){if(super(nu??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",nu==null&&(nu={}),this.supportsMasking=!0,this.alphaInitializer=D0(nu.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=F0(nu.alphaRegularizer),this.alphaConstraint=iy(nu.alphaConstraint),nu.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(nu.sharedAxes))this.sharedAxes=nu.sharedAxes;else if(typeof nu.sharedAxes=="number")this.sharedAxes=[nu.sharedAxes];else throw new Ep(`Expected sharedAxes to be a number or an array of numbers, but got ${nu.sharedAxes}`)}build(nu){nu=p0(nu);const ru=nu.slice(1);if(this.sharedAxes!=null)for(const cu of this.sharedAxes)ru[cu-1]=1;this.alpha=this.addWeight("alpha",ru,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const lu={};if(this.sharedAxes!=null)for(let cu=1;cu<nu.length;++cu)lu[cu]=nu[cu];this.inputSpec=[new ty({ndim:nu.length,axes:lu})],this.built=!0}call(nu,ru){return nu=jm(nu),eI(nu,this.alpha.read())}getConfig(){const nu={alphaInitializer:O0(this.alphaInitializer),alphaRegularizer:v0(this.alphaRegularizer),alphaConstraint:ny(this.alphaConstraint),sharedAxes:this.sharedAxes},ru=super.getConfig();return Object.assign(nu,ru),nu}}FL.className="PReLU",hm(FL);let PL=class extends n0{constructor(ou){if(super(ou??{}),this.DEFAULT_ALPHA=1,ou==null&&(ou={}),ou.alpha!=null&&ou.alpha!==this.DEFAULT_ALPHA)throw new e0(`Non-default alpha value (${ou.alpha}) is not supported by the ELU layer yet.`);this.alpha=ou.alpha==null?this.DEFAULT_ALPHA:ou.alpha}call(ou,nu){const ru=jm(ou);return GE(ru)}computeOutputShape(ou){return ou}getConfig(){const ou={alpha:this.alpha},nu=super.getConfig();return Object.assign(ou,nu),ou}};PL.className="ELU",hm(PL);class GL extends n0{constructor(nu){super(nu??{}),this.DEFAULT_THETA=1,nu==null&&(nu={}),this.theta=nu.theta==null?this.DEFAULT_THETA:nu.theta}call(nu,ru){const lu=jm(nu);return _p(lu,km(Yy(lu,this.theta),"float32"))}computeOutputShape(nu){return nu}getConfig(){const nu={theta:this.theta},ru=super.getConfig();return Object.assign(nu,ru),nu}}GL.className="ThresholdedReLU",hm(GL);class OL extends n0{constructor(nu){super(nu??{}),this.DEFAULT_AXIS=1,nu==null&&(nu={}),this.softmax=new vT().apply,this.axis=nu.axis==null?this.DEFAULT_AXIS:nu.axis}call(nu,ru){return Op(()=>{let lu=jm(nu);const cu=ru.mask;if(cu!=null){const hu=_p(Qm(Iv(lu.shape),km(cu,lu.dtype)),A0(-1e9));lu=Am(lu,hu)}return this.axis instanceof Array?this.axis.length>1?Gx(Qm(lu,KM(lu,this.axis,!0))):this.softmax(lu,this.axis[0]):this.softmax(lu,this.axis)})}computeOutputShape(nu){return nu}getConfig(){const nu={axis:this.axis},ru=super.getConfig();return Object.assign(nu,ru),nu}}OL.className="Softmax",hm(OL);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function rC(ou,nu,ru){if(typeof ou=="number")return f1(ou,nu);if(ou.length!==nu)throw new Ep(`The ${ru} argument must be an integer or tuple of ${nu} integers. Received: ${ou.length} elements.`);for(let lu=0;lu<nu;++lu){const cu=ou[lu];if(!H5(cu))throw new Ep(`The ${ru} argument must be an integer or tuple of ${nu} integers. Received: ${JSON.stringify(ou)} including a non-integer number ${cu}`)}return ou}function Rx(ou,nu,ru,lu,cu=1){if(ou==null)return ou;const hu=nu+(nu-1)*(cu-1);let pu;return ru==="same"?pu=ou:pu=ou-hu+1,Math.floor((pu+lu-1)/lu)}function Xx(ou,nu,ru,lu){if(ou==null)return null;if(lu==="valid")ou=ou*nu+Rv([ru-nu,0]);else if(lu==="same")ou=ou*nu;else throw new Ep(`Unsupport padding mode: ${lu}.`);return ou}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function wT(ou,nu){return Op(()=>(Q0(nu),nu==="channelsFirst"?c0(ou,[0,2,3,1]):ou))}function UL(ou,nu){return Op(()=>(Q0(nu),nu==="channelsFirst"?c0(ou,[0,2,3,4,1]):ou))}function u4(ou,nu,ru,lu=1,cu="valid",hu,pu=1){return Op(()=>{if(hu==null&&(hu=Sx()),Q0(hu),ou.shape.length!==3)throw new Ep(`The input of a conv1dWithBias operation should be 3, but is ${ou.shape.length} instead.`);if(nu.shape.length!==3)throw new Ep(`The kernel for a conv1dWithBias operation should be 3, but is ${nu.shape.length} instead`);if(ru!=null&&ru.shape.length!==1)throw new Ep(`The bias for a conv1dWithBias operation should be 1, but is ${nu.shape.length} instead`);if(hu==="channelsFirst"&&(ou=c0(ou,[0,2,1])),cu==="causal")throw new e0("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let mu=PM(ou,nu,lu,cu==="same"?"same":"valid","NWC",pu);return ru!=null&&(mu=Ix(mu,ru)),mu})}function $L(ou,nu,ru,lu=[1,1],cu="valid",hu,pu,mu=null){return Op(()=>{if(hu==null&&(hu=Sx()),Q0(hu),ou.rank!==3&&ou.rank!==4)throw new Ep(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${ou.rank}.`);if(nu.rank!==3&&nu.rank!==4)throw new Ep(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${ou.rank}.`);let Au=wT(ou,hu);if(cu==="causal")throw new e0("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return Au=gV({x:Au,filter:nu,strides:lu,pad:cu==="same"?"same":"valid",dilations:pu,dataFormat:"NHWC",bias:ru,activation:mu}),hu==="channelsFirst"&&(Au=c0(Au,[0,3,1,2])),Au})}function h4(ou,nu,ru,lu=[1,1,1],cu="valid",hu,pu){return Op(()=>{if(hu==null&&(hu=Sx()),Q0(hu),ou.rank!==4&&ou.rank!==5)throw new Ep(`conv3dWithBias expects input to be of rank 4 or 5, but received ${ou.rank}.`);if(nu.rank!==4&&nu.rank!==5)throw new Ep(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${ou.rank}.`);let mu=UL(ou,hu);if(cu==="causal")throw new e0("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return mu=mO(mu,nu,lu,cu==="same"?"same":"valid","NDHWC",pu),ru!=null&&(mu=Ix(mu,ru)),hu==="channelsFirst"&&(mu=c0(mu,[0,4,1,2,3])),mu})}class m2 extends n0{constructor(nu,ru){if(super(ru),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",m2.verifyArgs(ru),this.rank=nu,ly(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new e0(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=rC(ru.kernelSize,nu,"kernelSize"),this.strides=rC(ru.strides==null?1:ru.strides,nu,"strides"),this.padding=ru.padding==null?"valid":ru.padding,Jy(this.padding),this.dataFormat=ru.dataFormat==null?"channelsLast":ru.dataFormat,Q0(this.dataFormat),this.activation=Lv(ru.activation),this.useBias=ru.useBias==null?!0:ru.useBias,this.biasInitializer=D0(ru.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=iy(ru.biasConstraint),this.biasRegularizer=F0(ru.biasRegularizer),this.activityRegularizer=F0(ru.activityRegularizer),this.dilationRate=rC(ru.dilationRate==null?1:ru.dilationRate,nu,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Ep(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Ep(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Ep(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(nu){if(zx("kernelSize"in nu,"required key 'kernelSize' not in config"),typeof nu.kernelSize!="number"&&!KI(nu.kernelSize,"number",1,3))throw new Ep(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(nu.kernelSize)}.`)}getConfig(){const nu={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Bv(this.activation),useBias:this.useBias,biasInitializer:O0(this.biasInitializer),biasRegularizer:v0(this.biasRegularizer),activityRegularizer:v0(this.activityRegularizer),biasConstraint:ny(this.biasConstraint)},ru=super.getConfig();return Object.assign(nu,ru),nu}}class sC extends m2{constructor(nu,ru){super(nu,ru),this.kernel=null,sC.verifyArgs(ru),this.filters=ru.filters,ly(this.filters,"filters"),this.kernelInitializer=D0(ru.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=iy(ru.kernelConstraint),this.kernelRegularizer=F0(ru.kernelRegularizer)}build(nu){nu=p0(nu);const ru=this.dataFormat==="channelsFirst"?1:nu.length-1;if(nu[ru]==null)throw new Ep(`The channel dimension of the input should be defined. Found ${nu[ru]}`);const lu=nu[ru],cu=this.kernelSize.concat([lu,this.filters]);this.kernel=this.addWeight("kernel",cu,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[ru]:lu}}],this.built=!0}call(nu,ru){return Op(()=>{nu=jm(nu);let lu;const cu=this.bias==null?null:this.bias.read(),hu=xB(this.activation.getClassName());if(hu!=null&&this.rank===2)lu=$L(nu,this.kernel.read(),cu,this.strides,this.padding,this.dataFormat,this.dilationRate,hu);else{if(this.rank===1)lu=u4(nu,this.kernel.read(),cu,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)lu=$L(nu,this.kernel.read(),cu,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)lu=h4(nu,this.kernel.read(),cu,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new e0("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(lu=this.activation.apply(lu))}return lu})}computeOutputShape(nu){nu=p0(nu);const ru=[],lu=this.dataFormat==="channelsLast"?nu.slice(1,nu.length-1):nu.slice(2);for(let hu=0;hu<lu.length;++hu){const pu=Rx(lu[hu],this.kernelSize[hu],this.padding,this.strides[hu],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[hu]);ru.push(pu)}let cu=[nu[0]];return this.dataFormat==="channelsLast"?(cu=cu.concat(ru),cu.push(this.filters)):(cu.push(this.filters),cu=cu.concat(ru)),cu}getConfig(){const nu={filters:this.filters,kernelInitializer:O0(this.kernelInitializer),kernelRegularizer:v0(this.kernelRegularizer),kernelConstraint:ny(this.kernelConstraint)},ru=super.getConfig();return Object.assign(nu,ru),nu}static verifyArgs(nu){if(!("filters"in nu)||typeof nu.filters!="number"||nu.filters<1)throw new Ep(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(nu.filters)}`)}}class Mw extends sC{constructor(nu){super(2,nu),Mw.verifyArgs(nu)}getConfig(){const nu=super.getConfig();return delete nu.rank,nu}static verifyArgs(nu){if(typeof nu.kernelSize!="number"&&!KI(nu.kernelSize,"number",1,2))throw new Ep(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(nu.kernelSize)}.`)}}Mw.className="Conv2D",hm(Mw);class Rw extends sC{constructor(nu){super(3,nu),Rw.verifyArgs(nu)}getConfig(){const nu=super.getConfig();return delete nu.rank,nu}static verifyArgs(nu){if(typeof nu.kernelSize!="number"&&!(Array.isArray(nu.kernelSize)&&(nu.kernelSize.length===1||nu.kernelSize.length===3)))throw new Ep(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(nu.kernelSize)}.`)}}Rw.className="Conv3D",hm(Rw);class VL extends Mw{constructor(nu){if(super(nu),this.inputSpec=[new ty({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Ep(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(nu){if(nu=p0(nu),nu.length!==4)throw new Ep("Input should have rank 4; Received input shape: "+JSON.stringify(nu));const ru=this.dataFormat==="channelsFirst"?1:nu.length-1;if(nu[ru]==null)throw new Ep("The channel dimension of the inputs should be defined. Found `None`.");const lu=nu[ru],cu=this.kernelSize.concat([this.filters,lu]);this.kernel=this.addWeight("kernel",cu,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ty({ndim:4,axes:{[ru]:lu}})],this.built=!0}call(nu,ru){return Op(()=>{let lu=jm(nu);if(lu.shape.length!==4)throw new Ep(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${lu.shape.length}`);const cu=lu.shape,hu=cu[0];let pu,mu;this.dataFormat==="channelsFirst"?(pu=2,mu=3):(pu=1,mu=2);const Au=cu[pu],bu=cu[mu],Cu=this.kernelSize[0],wu=this.kernelSize[1],Eu=this.strides[0],Tu=this.strides[1],Ru=Xx(Au,Eu,Cu,this.padding),Nu=Xx(bu,Tu,wu,this.padding),Pu=[hu,Ru,Nu,this.filters];this.dataFormat!=="channelsLast"&&(lu=c0(lu,[0,2,3,1]));let Fu=GM(lu,this.kernel.read(),Pu,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(Fu=c0(Fu,[0,3,1,2])),this.bias!=null&&(Fu=Ix(Fu,this.bias.read(),this.dataFormat)),this.activation!=null&&(Fu=this.activation.apply(Fu)),Fu})}computeOutputShape(nu){nu=p0(nu);const ru=nu.slice();let lu,cu,hu;this.dataFormat==="channelsFirst"?(lu=1,cu=2,hu=3):(lu=3,cu=1,hu=2);const pu=this.kernelSize[0],mu=this.kernelSize[1],Au=this.strides[0],bu=this.strides[1];return ru[lu]=this.filters,ru[cu]=Xx(ru[cu],Au,pu,this.padding),ru[hu]=Xx(ru[hu],bu,mu,this.padding),ru}getConfig(){const nu=super.getConfig();return delete nu.dilationRate,nu}}VL.className="Conv2DTranspose",hm(VL);class zL extends Rw{constructor(nu){if(super(nu),this.inputSpec=[new ty({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Ep(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(nu){if(nu=p0(nu),nu.length!==5)throw new Ep("Input should have rank 5; Received input shape: "+JSON.stringify(nu));const ru=this.dataFormat==="channelsFirst"?1:nu.length-1;if(nu[ru]==null)throw new Ep("The channel dimension of the inputs should be defined. Found `None`.");const lu=nu[ru],cu=this.kernelSize.concat([this.filters,lu]);this.kernel=this.addWeight("kernel",cu,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ty({ndim:5,axes:{[ru]:lu}})],this.built=!0}call(nu,ru){return Op(()=>{let lu=jm(nu);if(lu.shape.length!==5)throw new Ep(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${lu.shape.length}`);const cu=lu.shape,hu=cu[0];let pu,mu,Au;this.dataFormat==="channelsFirst"?(Au=2,pu=3,mu=4):(Au=1,pu=2,mu=3);const bu=cu[Au],Cu=cu[pu],wu=cu[mu],Eu=this.kernelSize[0],Tu=this.kernelSize[1],Ru=this.kernelSize[2],Nu=this.strides[0],Pu=this.strides[1],Fu=this.strides[2],Gu=Xx(bu,Nu,Eu,this.padding),Xu=Xx(Cu,Pu,Tu,this.padding),Qu=Xx(wu,Fu,Ru,this.padding),Ju=[hu,Gu,Xu,Qu,this.filters];this.dataFormat!=="channelsLast"&&(lu=c0(lu,[0,2,3,4,1]));let ip=yO(lu,this.kernel.read(),Ju,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(ip=c0(ip,[0,4,1,2,3])),this.bias!==null&&(ip=Ix(ip,this.bias.read(),this.dataFormat)),this.activation!==null&&(ip=this.activation.apply(ip)),ip})}computeOutputShape(nu){nu=p0(nu);const ru=nu.slice();let lu,cu,hu,pu;this.dataFormat==="channelsFirst"?(lu=1,cu=2,hu=3,pu=4):(lu=4,cu=1,hu=2,pu=3);const mu=this.kernelSize[0],Au=this.kernelSize[1],bu=this.kernelSize[2],Cu=this.strides[0],wu=this.strides[1],Eu=this.strides[2];return ru[lu]=this.filters,ru[cu]=Xx(ru[cu],Cu,mu,this.padding),ru[hu]=Xx(ru[hu],wu,Au,this.padding),ru[pu]=Xx(ru[pu],Eu,bu,this.padding),ru}getConfig(){const nu=super.getConfig();return delete nu.dilationRate,nu}}zL.className="Conv3DTranspose",hm(zL);class WL extends sC{constructor(nu,ru){if(super(nu,ru),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,ru.filters==null)throw new Ep("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(ru.kernelInitializer!=null||ru.kernelRegularizer!=null||ru.kernelConstraint!=null)throw new Ep("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(ru.padding!=null&&ru.padding!=="same"&&ru.padding!=="valid")throw new Ep(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(ru.padding)}`);this.depthMultiplier=ru.depthMultiplier==null?1:ru.depthMultiplier,this.depthwiseInitializer=D0(ru.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=F0(ru.depthwiseRegularizer),this.depthwiseConstraint=iy(ru.depthwiseConstraint),this.pointwiseInitializer=D0(ru.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=F0(ru.pointwiseRegularizer),this.pointwiseConstraint=iy(ru.pointwiseConstraint)}build(nu){if(nu=p0(nu),nu.length<this.rank+2)throw new Ep(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(nu)}`);const ru=this.dataFormat==="channelsFirst"?1:nu.length-1;if(nu[ru]==null||nu[ru]<0)throw new Ep(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(nu[ru])}`);const lu=nu[ru],cu=this.kernelSize.concat([lu,this.depthMultiplier]),hu=[];for(let mu=0;mu<this.rank;++mu)hu.push(1);hu.push(lu*this.depthMultiplier,this.filters);const pu=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",cu,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,pu,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",hu,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,pu,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,pu,this.biasConstraint):this.bias=null,this.inputSpec=[new ty({ndim:this.rank+2,axes:{[ru]:lu}})],this.built=!0}call(nu,ru){return Op(()=>{nu=jm(nu);let lu;if(this.rank===1)throw new e0("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(nu=c0(nu,[0,2,3,1])),lu=cR(nu,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(lu=Ix(lu,this.bias.read(),this.dataFormat)),this.activation!=null&&(lu=this.activation.apply(lu)),this.dataFormat==="channelsFirst"&&(lu=c0(lu,[0,3,1,2])),lu})}getConfig(){const nu=super.getConfig();return delete nu.rank,delete nu.kernelInitializer,delete nu.kernelRegularizer,delete nu.kernelConstraint,nu.depthwiseInitializer=O0(this.depthwiseInitializer),nu.pointwiseInitializer=O0(this.pointwiseInitializer),nu.depthwiseRegularizer=v0(this.depthwiseRegularizer),nu.pointwiseRegularizer=v0(this.pointwiseRegularizer),nu.depthwiseConstraint=ny(this.depthwiseConstraint),nu.pointwiseConstraint=ny(this.pointwiseConstraint),nu}}WL.className="SeparableConv";class HL extends WL{constructor(nu){super(2,nu)}}HL.className="SeparableConv2D",hm(HL);class g2 extends sC{constructor(nu){super(1,nu),g2.verifyArgs(nu),this.inputSpec=[{ndim:3}]}getConfig(){const nu=super.getConfig();return delete nu.rank,delete nu.dataFormat,nu}static verifyArgs(nu){if(typeof nu.kernelSize!="number"&&!KI(nu.kernelSize,"number",1,1))throw new Ep(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(nu.kernelSize)}.`)}}g2.className="Conv1D",hm(g2);class XL extends n0{constructor(nu){super(nu),typeof nu.cropping=="number"?this.cropping=[[nu.cropping,nu.cropping],[nu.cropping,nu.cropping]]:typeof nu.cropping[0]=="number"?this.cropping=[[nu.cropping[0],nu.cropping[0]],[nu.cropping[1],nu.cropping[1]]]:this.cropping=nu.cropping,this.dataFormat=nu.dataFormat===void 0?"channelsLast":nu.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(nu){return this.dataFormat==="channelsFirst"?[nu[0],nu[1],nu[2]-this.cropping[0][0]-this.cropping[0][1],nu[3]-this.cropping[1][0]-this.cropping[1][1]]:[nu[0],nu[1]-this.cropping[0][0]-this.cropping[0][1],nu[2]-this.cropping[1][0]-this.cropping[1][1],nu[3]]}call(nu,ru){return Op(()=>{if(nu=jm(nu),this.dataFormat==="channelsLast"){const lu=e2(nu,this.cropping[0][0],nu.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return e2(lu,this.cropping[1][0],nu.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const lu=e2(nu,this.cropping[0][0],nu.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return e2(lu,this.cropping[1][0],nu.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const nu={cropping:this.cropping,dataFormat:this.dataFormat},ru=super.getConfig();return Object.assign(nu,ru),nu}}XL.className="Cropping2D",hm(XL);class QL extends n0{constructor(nu){super(nu),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=nu.size==null?this.DEFAULT_SIZE:nu.size,this.dataFormat=nu.dataFormat==null?"channelsLast":nu.dataFormat,Q0(this.dataFormat),this.interpolation=nu.interpolation==null?"nearest":nu.interpolation,V5(this.interpolation)}computeOutputShape(nu){if(this.dataFormat==="channelsFirst"){const ru=nu[2]==null?null:this.size[0]*nu[2],lu=nu[3]==null?null:this.size[1]*nu[3];return[nu[0],nu[1],ru,lu]}else{const ru=nu[1]==null?null:this.size[0]*nu[1],lu=nu[2]==null?null:this.size[1]*nu[2];return[nu[0],ru,lu,nu[3]]}}call(nu,ru){return Op(()=>{let lu=jm(nu);const cu=lu.shape;if(this.dataFormat==="channelsFirst"){lu=c0(lu,[0,2,3,1]);const hu=this.size[0]*cu[2],pu=this.size[1]*cu[3],mu=this.interpolation==="nearest"?rv.resizeNearestNeighbor(lu,[hu,pu]):rv.resizeBilinear(lu,[hu,pu]);return c0(mu,[0,3,1,2])}else{const hu=this.size[0]*cu[1],pu=this.size[1]*cu[2];return this.interpolation==="nearest"?rv.resizeNearestNeighbor(lu,[hu,pu]):rv.resizeBilinear(lu,[hu,pu])}})}getConfig(){const nu={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},ru=super.getConfig();return Object.assign(nu,ru),nu}}QL.className="UpSampling2D",hm(QL);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function d4(ou,nu,ru=[1,1],lu="valid",cu,hu){return Op(()=>{cu==null&&(cu=Sx()),Q0(cu);let pu=wT(ou,cu);if(ou.rank!==4)throw new Ep(`Input for depthwiseConv2d is required to be 4-D, but is instead ${ou.rank}-D`);if(nu.rank!==4)throw new Ep(`depthwiseKernel is required to be 4-D, but is instead ${nu.rank}-D`);return pu=WS(pu,nu,ru,lu==="same"?"same":"valid","NHWC",hu),cu==="channelsFirst"&&(pu=c0(pu,[0,3,1,2])),pu})}class KL extends m2{constructor(nu){super(2,nu),this.depthwiseKernel=null,this.depthMultiplier=nu.depthMultiplier==null?1:nu.depthMultiplier,this.depthwiseInitializer=D0(nu.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=iy(nu.depthwiseConstraint),this.depthwiseRegularizer=F0(nu.depthwiseRegularizer)}build(nu){if(nu=p0(nu),nu.length<4)throw new Ep(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(nu)}.`);const ru=this.dataFormat==="channelsFirst"?1:3;if(nu[ru]==null||nu[ru]<0)throw new Ep(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${nu[ru]}).`);const lu=nu[ru],cu=[this.kernelSize[0],this.kernelSize[1],lu,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",cu,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[lu*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(nu,ru){return Op(()=>{nu=jm(nu);let lu=d4(nu,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(lu=Ix(lu,this.bias.read(),this.dataFormat)),this.activation!=null&&(lu=this.activation.apply(lu)),lu})}computeOutputShape(nu){nu=p0(nu);const ru=this.dataFormat==="channelsFirst"?nu[2]:nu[1],lu=this.dataFormat==="channelsFirst"?nu[3]:nu[2],cu=this.dataFormat==="channelsFirst"?nu[1]*this.depthMultiplier:nu[3]*this.depthMultiplier,hu=Rx(ru,this.kernelSize[0],this.padding,this.strides[0]),pu=Rx(lu,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[nu[0],cu,hu,pu]:[nu[0],hu,pu,cu]}getConfig(){const nu=super.getConfig();return nu.depthMultiplier=this.depthMultiplier,nu.depthwiseInitializer=O0(this.depthwiseInitializer),nu.depthwiseRegularizer=v0(this.depthwiseRegularizer),nu.depthwiseConstraint=ny(this.depthwiseRegularizer),nu}}KL.className="DepthwiseConv2D",hm(KL);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function ZL(ou,nu,ru,lu){if(Array.isArray(ou)){if(nu!=null||ru!=null)throw new Ep("When inputs is an array, neither initialState or constants should be provided");lu!=null&&(ru=ou.slice(ou.length-lu,ou.length),ou=ou.slice(0,ou.length-lu)),ou.length>1&&(nu=ou.slice(1,ou.length)),ou=ou[0]}function cu(hu){return hu==null||Array.isArray(hu)?hu:[hu]}return nu=cu(nu),ru=cu(ru),{inputs:ou,initialState:nu,constants:ru}}function jL(ou,nu,ru,lu=!1,cu,hu,pu=!1,mu=!1){return Op(()=>{const Au=nu.shape.length;if(Au<3)throw new Ep(`Input should be at least 3D, but is ${Au}D.`);const bu=[1,0].concat(Ex(2,Au));nu=c0(nu,bu),hu!=null,pu&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),cu!=null&&(cu=km(km(cu,"bool"),"float32"),cu.rank===Au-1&&(cu=Ly(cu,-1)),cu=c0(cu,bu)),lu&&(nu=u1(nu,0),cu!=null&&(cu=u1(cu,0)));const Cu=[];let wu,Eu=ru;const Tu=nu.shape[0],Ru=d1(nu);let Nu;cu!=null&&(Nu=d1(cu));for(let Fu=0;Fu<Tu;++Fu){const Gu=Ru[Fu],Xu=Op(()=>ou(Gu,Eu));if(cu==null)wu=Xu[0],Eu=Xu[1];else{const Qu=Op(()=>{const Ju=Nu[Fu],ip=Qm(ax(Ju),Ju),rp=Am(_p(Xu[0],Ju),_p(Eu[0],ip)),op=Eu.map((hp,Ap)=>Am(_p(Xu[1][Ap],Ju),_p(hp,ip)));return{output:rp,newStates:op}});wu=Qu.output,Eu=Qu.newStates}mu&&Cu.push(wu)}let Pu;return mu&&(Pu=Ux(Cu,1)),[wu,Pu,Eu]})}class Nv extends n0{constructor(nu){super(nu);let ru;if(nu.cell==null)throw new Ep("cell property is missing for the constructor of RNN.");if(Array.isArray(nu.cell)?ru=new IT({cells:nu.cell}):ru=nu.cell,ru.stateSize==null)throw new Ep("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=ru,this.returnSequences=nu.returnSequences==null?!1:nu.returnSequences,this.returnState=nu.returnState==null?!1:nu.returnState,this.goBackwards=nu.goBackwards==null?!1:nu.goBackwards,this._stateful=nu.stateful==null?!1:nu.stateful,this.unroll=nu.unroll==null?!1:nu.unroll,this.supportsMasking=!0,this.inputSpec=[new ty({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const nu=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ex(0,nu).map(ru=>null)}else return this.states_}setStates(nu){this.states_=nu}computeOutputShape(nu){aT(nu)&&(nu=nu[0]),nu=nu;let ru=this.cell.stateSize;Array.isArray(ru)||(ru=[ru]);const lu=ru[0];let cu;if(this.returnSequences?cu=[nu[0],nu[1],lu]:cu=[nu[0],lu],this.returnState){const hu=[];for(const pu of ru)hu.push([nu[0],pu]);return[cu].concat(hu)}else return cu}computeMask(nu,ru){return Op(()=>{Array.isArray(ru)&&(ru=ru[0]);const lu=this.returnSequences?ru:null;if(this.returnState){const cu=this.states.map(hu=>null);return[lu].concat(cu)}else return lu})}get states(){if(this.states_==null){const nu=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,ru=[];for(let lu=0;lu<nu;++lu)ru.push(null);return ru}else return this.states_}set states(nu){this.states_=nu}build(nu){if(this.numConstants!=null)throw new e0("Constants support is not implemented in RNN yet.");aT(nu)&&(nu=nu[0]),nu=nu;const ru=this.stateful?nu[0]:null,lu=nu.slice(2);this.inputSpec[0]=new ty({shape:[ru,null,...lu]});const cu=[nu[0]].concat(nu.slice(2));this.cell.build(cu);let hu;if(Array.isArray(this.cell.stateSize)?hu=this.cell.stateSize:hu=[this.cell.stateSize],this.stateSpec!=null){if(!ku(this.stateSpec.map(pu=>pu.shape[pu.shape.length-1]),hu))throw new Ep(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=hu.map(pu=>new ty({shape:[null,pu]}));this.stateful&&this.resetStates()}resetStates(nu,ru=!1){Op(()=>{if(!this.stateful)throw new Vx("Cannot call resetStates() on an RNN Layer that is not stateful.");const lu=this.inputSpec[0].shape[0];if(lu==null)throw new Ep("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(cu=>ay([lu,cu])):this.states_=[ay([lu,this.cell.stateSize])];else if(nu==null)o0(this.states_),this.keptStates!=null&&(o0(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(cu=>ay([lu,cu])):this.states_[0]=ay([lu,this.cell.stateSize]);else{if(Array.isArray(nu)||(nu=[nu]),nu.length!==this.states_.length)throw new Ep(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${nu.length} state value(s). Input received: ${nu}`);ru===!0?this.keptStates.push(this.states_.slice()):o0(this.states_);for(let cu=0;cu<this.states_.length;++cu){const hu=nu[cu],pu=Array.isArray(this.cell.stateSize)?this.cell.stateSize[cu]:this.cell.stateSize,mu=[lu,pu];if(!ku(hu.shape,mu))throw new Ep(`State ${cu} is incompatible with layer ${this.name}: expected shape=${mu}, received shape=${hu.shape}`);this.states_[cu]=hu}}this.states_=this.states_.map(cu=>Zy(cu.clone()))})}apply(nu,ru){let lu=ru==null?null:ru.initialState,cu=ru==null?null:ru.constants;ru==null&&(ru={});const hu=ZL(nu,lu,cu,this.numConstants);nu=hu.inputs,lu=hu.initialState,cu=hu.constants;let pu=[],mu=[];if(lu!=null){ru.initialState=lu,pu=pu.concat(lu),this.stateSpec=[];for(const Au of lu)this.stateSpec.push(new ty({shape:Au.shape}));mu=mu.concat(this.stateSpec)}if(cu!=null&&(ru.constants=cu,pu=pu.concat(cu),this.numConstants=cu.length),pu[0]instanceof Hx){const Au=[nu].concat(pu),bu=this.inputSpec.concat(mu),Cu=this.inputSpec;this.inputSpec=bu;const wu=super.apply(Au,ru);return this.inputSpec=Cu,wu}else return super.apply(nu,ru)}call(nu,ru){return Op(()=>{const lu=ru==null?null:ru.mask,cu=ru==null?null:ru.training;let hu=ru==null?null:ru.initialState;nu=jm(nu),hu==null&&(this.stateful?hu=this.states_:hu=this.getInitialState(nu));const pu=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(hu.length!==pu)throw new Ep(`RNN Layer has ${pu} state(s) but was passed ${hu.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const mu={training:cu},Au=jL((Tu,Ru)=>{const Nu=this.cell.call([Tu].concat(Ru),mu);return[Nu[0],Nu.slice(1)]},nu,hu,this.goBackwards,lu,null,this.unroll,this.returnSequences),bu=Au[0],Cu=Au[1],wu=Au[2];this.stateful&&this.resetStates(wu,cu);const Eu=this.returnSequences?Cu:bu;return this.returnState?[Eu].concat(wu):Eu})}getInitialState(nu){return Op(()=>{let ru=ay(nu.shape);return ru=zm(ru,[1,2]),ru=bw(ru),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(lu=>lu>1?qI(ru,[1,lu]):ru):this.cell.stateSize>1?[qI(ru,[1,this.cell.stateSize])]:[ru]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(nu){super.setFastWeightInitDuringBuild(nu),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(nu)}getConfig(){const nu=super.getConfig(),ru={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(ru.numConstants=this.numConstants);const lu=this.cell.getConfig();return this.getClassName()===Nv.className&&(ru.cell={className:this.cell.getClassName(),config:lu}),Object.assign(Object.assign(Object.assign({},lu),nu),ru)}static fromConfig(nu,ru,lu={}){const cu=ru.cell,hu=cv(cu,lu);return new nu(Object.assign(ru,{cell:hu}))}}Nv.className="RNN",hm(Nv);class A2 extends n0{}class ET extends A2{constructor(nu){super(nu),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=nu.units,ly(this.units,"units"),this.activation=Lv(nu.activation==null?this.DEFAULT_ACTIVATION:nu.activation),this.useBias=nu.useBias==null?!0:nu.useBias,this.kernelInitializer=D0(nu.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=D0(nu.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=D0(nu.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=F0(nu.kernelRegularizer),this.recurrentRegularizer=F0(nu.recurrentRegularizer),this.biasRegularizer=F0(nu.biasRegularizer),this.kernelConstraint=iy(nu.kernelConstraint),this.recurrentConstraint=iy(nu.recurrentConstraint),this.biasConstraint=iy(nu.biasConstraint),this.dropout=nC([1,Rv([0,nu.dropout==null?0:nu.dropout])]),this.recurrentDropout=nC([1,Rv([0,nu.recurrentDropout==null?0:nu.recurrentDropout])]),this.dropoutFunc=nu.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(nu){nu=p0(nu),this.kernel=this.addWeight("kernel",[nu[nu.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(nu,ru){return Op(()=>{if(nu=nu,nu.length!==2)throw new Ep(`SimpleRNNCell expects 2 input Tensors, got ${nu.length}.`);let lu=nu[1];nu=nu[0];const cu=ru.training==null?!1:ru.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Dv({ones:()=>ax(nu),rate:this.dropout,training:cu,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Dv({ones:()=>ax(lu),rate:this.recurrentDropout,training:cu,dropoutFunc:this.dropoutFunc}));let hu;const pu=this.dropoutMask,mu=this.recurrentDropoutMask;pu!=null?hu=Wx(_p(nu,pu),this.kernel.read()):hu=Wx(nu,this.kernel.read()),this.bias!=null&&(hu=Ix(hu,this.bias.read())),mu!=null&&(lu=_p(lu,mu));let Au=Am(hu,Wx(lu,this.recurrentKernel.read()));return this.activation!=null&&(Au=this.activation.apply(Au)),[Au,Au]})}getConfig(){const nu=super.getConfig(),ru={units:this.units,activation:Bv(this.activation),useBias:this.useBias,kernelInitializer:O0(this.kernelInitializer),recurrentInitializer:O0(this.recurrentInitializer),biasInitializer:O0(this.biasInitializer),kernelRegularizer:v0(this.kernelRegularizer),recurrentRegularizer:v0(this.recurrentRegularizer),biasRegularizer:v0(this.biasRegularizer),activityRegularizer:v0(this.activityRegularizer),kernelConstraint:ny(this.kernelConstraint),recurrentConstraint:ny(this.recurrentConstraint),biasConstraint:ny(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},nu),ru)}}ET.className="SimpleRNNCell",hm(ET);class YL extends Nv{constructor(nu){nu.cell=new ET(nu),super(nu)}call(nu,ru){return Op(()=>{this.cell.dropoutMask!=null&&(o0(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o0(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const lu=ru==null?null:ru.mask,cu=ru==null?null:ru.training,hu=ru==null?null:ru.initialState;return super.call(nu,{mask:lu,training:cu,initialState:hu})})}static fromConfig(nu,ru){return new nu(ru)}}YL.className="SimpleRNN",hm(YL);class ST extends A2{constructor(nu){if(super(nu),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",nu.resetAfter)throw new Ep("GRUCell does not support reset_after parameter set to true.");this.units=nu.units,ly(this.units,"units"),this.activation=Lv(nu.activation===void 0?this.DEFAULT_ACTIVATION:nu.activation),this.recurrentActivation=Lv(nu.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:nu.recurrentActivation),this.useBias=nu.useBias==null?!0:nu.useBias,this.kernelInitializer=D0(nu.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=D0(nu.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=D0(nu.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=F0(nu.kernelRegularizer),this.recurrentRegularizer=F0(nu.recurrentRegularizer),this.biasRegularizer=F0(nu.biasRegularizer),this.kernelConstraint=iy(nu.kernelConstraint),this.recurrentConstraint=iy(nu.recurrentConstraint),this.biasConstraint=iy(nu.biasConstraint),this.dropout=nC([1,Rv([0,nu.dropout==null?0:nu.dropout])]),this.recurrentDropout=nC([1,Rv([0,nu.recurrentDropout==null?0:nu.recurrentDropout])]),this.dropoutFunc=nu.dropoutFunc,this.implementation=nu.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(nu){nu=p0(nu);const ru=nu[nu.length-1];this.kernel=this.addWeight("kernel",[ru,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(nu,ru){return Op(()=>{if(nu=nu,nu.length!==2)throw new Ep(`GRUCell expects 2 input Tensors (inputs, h, c), got ${nu.length}.`);const lu=ru.training==null?!1:ru.training;let cu=nu[1];nu=nu[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Dv({ones:()=>ax(nu),rate:this.dropout,training:lu,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Dv({ones:()=>ax(cu),rate:this.recurrentDropout,training:lu,count:3,dropoutFunc:this.dropoutFunc}));const hu=this.dropoutMask,pu=this.recurrentDropoutMask;let mu,Au,bu;0<this.dropout&&this.dropout<1&&(nu=_p(nu,hu[0]));let Cu=Wx(nu,this.kernel.read());this.useBias&&(Cu=Ix(Cu,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(cu=_p(cu,pu[0]));const wu=this.recurrentKernel.read(),[Eu,Tu]=qy(wu,[2*this.units,this.units],wu.rank-1),Ru=Wx(cu,Eu),[Nu,Pu,Fu]=qy(Cu,3,Cu.rank-1),[Gu,Xu]=qy(Ru,2,Ru.rank-1);mu=this.recurrentActivation.apply(Am(Nu,Gu)),Au=this.recurrentActivation.apply(Am(Pu,Xu));const Qu=Wx(_p(Au,cu),Tu);bu=this.activation.apply(Am(Fu,Qu));const Ju=Am(_p(mu,cu),_p(Am(1,X0(mu)),bu));return[Ju,Ju]})}getConfig(){const nu=super.getConfig(),ru={units:this.units,activation:Bv(this.activation),recurrentActivation:Bv(this.recurrentActivation),useBias:this.useBias,kernelInitializer:O0(this.kernelInitializer),recurrentInitializer:O0(this.recurrentInitializer),biasInitializer:O0(this.biasInitializer),kernelRegularizer:v0(this.kernelRegularizer),recurrentRegularizer:v0(this.recurrentRegularizer),biasRegularizer:v0(this.biasRegularizer),activityRegularizer:v0(this.activityRegularizer),kernelConstraint:ny(this.kernelConstraint),recurrentConstraint:ny(this.recurrentConstraint),biasConstraint:ny(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},nu),ru)}}ST.className="GRUCell",hm(ST);class qL extends Nv{constructor(nu){nu.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),nu.cell=new ST(nu),super(nu)}call(nu,ru){return Op(()=>{this.cell.dropoutMask!=null&&(o0(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o0(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const lu=ru==null?null:ru.mask,cu=ru==null?null:ru.training,hu=ru==null?null:ru.initialState;return super.call(nu,{mask:lu,training:cu,initialState:hu})})}static fromConfig(nu,ru){return ru.implmentation===0&&(ru.implementation=1),new nu(ru)}}qL.className="GRU",hm(qL);class y2 extends A2{constructor(nu){super(nu),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=nu.units,ly(this.units,"units"),this.activation=Lv(nu.activation===void 0?this.DEFAULT_ACTIVATION:nu.activation),this.recurrentActivation=Lv(nu.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:nu.recurrentActivation),this.useBias=nu.useBias==null?!0:nu.useBias,this.kernelInitializer=D0(nu.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=D0(nu.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=D0(nu.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=nu.unitForgetBias,this.kernelRegularizer=F0(nu.kernelRegularizer),this.recurrentRegularizer=F0(nu.recurrentRegularizer),this.biasRegularizer=F0(nu.biasRegularizer),this.kernelConstraint=iy(nu.kernelConstraint),this.recurrentConstraint=iy(nu.recurrentConstraint),this.biasConstraint=iy(nu.biasConstraint),this.dropout=nC([1,Rv([0,nu.dropout==null?0:nu.dropout])]),this.recurrentDropout=nC([1,Rv([0,nu.recurrentDropout==null?0:nu.recurrentDropout])]),this.dropoutFunc=nu.dropoutFunc,this.implementation=nu.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(nu){var ru;nu=p0(nu);const lu=nu[nu.length-1];this.kernel=this.addWeight("kernel",[lu,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let cu;if(this.useBias){if(this.unitForgetBias){const hu=this.biasInitializer,pu=this.units;cu=new(ru=class extends hx{apply(mu,Au){const bu=hu.apply([pu]),Cu=new eT().apply([pu]),wu=hu.apply([pu*2]);return TB(TB(bu,Cu),wu)}},ru.className="CustomInit",ru)}else cu=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,cu,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(nu,ru){return Op(()=>{const lu=ru.training==null?!1:ru.training;if(nu=nu,nu.length!==3)throw new Ep(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${nu.length}.`);let cu=nu[1];const hu=nu[2];nu=nu[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Dv({ones:()=>ax(nu),rate:this.dropout,training:lu,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Dv({ones:()=>ax(cu),rate:this.recurrentDropout,training:lu,count:4,dropoutFunc:this.dropoutFunc}));const pu=this.dropoutMask,mu=this.recurrentDropoutMask;let Au,bu,Cu,wu;0<this.dropout&&this.dropout<1&&(nu=_p(nu,pu[0]));let Eu=Wx(nu,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(cu=_p(cu,mu[0])),Eu=Am(Eu,Wx(cu,this.recurrentKernel.read())),this.useBias&&(Eu=Ix(Eu,this.bias.read()));const[Tu,Ru,Nu,Pu]=qy(Eu,4,Eu.rank-1);Au=this.recurrentActivation.apply(Tu),bu=this.recurrentActivation.apply(Ru),Cu=Am(_p(bu,hu),_p(Au,this.activation.apply(Nu))),wu=this.recurrentActivation.apply(Pu);const Fu=_p(wu,this.activation.apply(Cu));return[Fu,Fu,Cu]})}getConfig(){const nu=super.getConfig(),ru={units:this.units,activation:Bv(this.activation),recurrentActivation:Bv(this.recurrentActivation),useBias:this.useBias,kernelInitializer:O0(this.kernelInitializer),recurrentInitializer:O0(this.recurrentInitializer),biasInitializer:O0(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:v0(this.kernelRegularizer),recurrentRegularizer:v0(this.recurrentRegularizer),biasRegularizer:v0(this.biasRegularizer),activityRegularizer:v0(this.activityRegularizer),kernelConstraint:ny(this.kernelConstraint),recurrentConstraint:ny(this.recurrentConstraint),biasConstraint:ny(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},nu),ru)}}y2.className="LSTMCell",hm(y2);class JL extends Nv{constructor(nu){nu.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),nu.cell=new y2(nu),super(nu)}call(nu,ru){return Op(()=>{this.cell.dropoutMask!=null&&(o0(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o0(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const lu=ru==null?null:ru.mask,cu=ru==null?null:ru.training,hu=ru==null?null:ru.initialState;return super.call(nu,{mask:lu,training:cu,initialState:hu})})}static fromConfig(nu,ru){return ru.implmentation===0&&(ru.implementation=1),new nu(ru)}}JL.className="LSTM",hm(JL);class IT extends A2{constructor(nu){super(nu),this.cells=nu.cells}get stateSize(){const nu=[];for(const ru of this.cells.slice().reverse())Array.isArray(ru.stateSize)?nu.push(...ru.stateSize):nu.push(ru.stateSize);return nu}call(nu,ru){return Op(()=>{nu=nu;let lu=nu.slice(1);const cu=[];for(const mu of this.cells.slice().reverse())Array.isArray(mu.stateSize)?cu.push(lu.splice(0,mu.stateSize.length)):cu.push(lu.splice(0,1));cu.reverse();const hu=[];let pu;for(let mu=0;mu<this.cells.length;++mu){const Au=this.cells[mu];lu=cu[mu],mu===0?pu=[nu[0]].concat(lu):pu=[pu[0]].concat(lu),pu=Au.call(pu,ru),hu.push(pu.slice(1))}lu=[];for(const mu of hu.slice().reverse())lu.push(...mu);return[pu[0]].concat(lu)})}build(nu){aT(nu)&&(nu=nu[0]),nu=nu;let ru;this.cells.forEach((lu,cu)=>{A1(`RNNCell_${cu}`,()=>{lu.build(nu),Array.isArray(lu.stateSize)?ru=lu.stateSize[0]:ru=lu.stateSize,nu=[nu[0],ru]})}),this.built=!0}getConfig(){const nu=super.getConfig(),ru=cu=>({className:cu.getClassName(),config:cu.getConfig()}),lu={cells:this.cells.map(ru)};return Object.assign(Object.assign({},nu),lu)}static fromConfig(nu,ru,lu={}){const cu=[];for(const hu of ru.cells)cu.push(cv(hu,lu));return new nu({cells:cu})}get trainableWeights(){if(!this.trainable)return[];const nu=[];for(const ru of this.cells)nu.push(...ru.trainableWeights);return nu}get nonTrainableWeights(){const nu=[];for(const ru of this.cells)nu.push(...ru.nonTrainableWeights);if(!this.trainable){const ru=[];for(const lu of this.cells)ru.push(...lu.trainableWeights);return ru.concat(nu)}return nu}getWeights(){const nu=[];for(const ru of this.cells)nu.push(...ru.weights);return lT(nu)}setWeights(nu){const ru=[];for(const lu of this.cells){const cu=lu.weights.length,hu=nu.splice(cu);for(let pu=0;pu<lu.weights.length;++pu)ru.push([lu.weights[pu],hu[pu]])}cT(ru)}}IT.className="StackedRNNCells",hm(IT);function Dv(ou){const{ones:nu,rate:ru,training:lu=!1,count:cu=1,dropoutFunc:hu}=ou,pu=()=>hu!=null?hu(nu(),ru):MB(nu(),ru),mu=()=>vw(pu,nu,lu);return!cu||cu<=1?Zy(mu().clone()):Array(cu).fill(void 0).map(mu).map(Au=>Zy(Au.clone()))}/**
* @license
* Copyright 2020 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/var p4=function(ou,nu){var ru={};for(var lu in ou)Object.prototype.hasOwnProperty.call(ou,lu)&&nu.indexOf(lu)<0&&(ru[lu]=ou[lu]);if(ou!=null&&typeof Object.getOwnPropertySymbols=="function")for(var cu=0,lu=Object.getOwnPropertySymbols(ou);cu<lu.length;cu++)nu.indexOf(lu[cu])<0&&Object.prototype.propertyIsEnumerable.call(ou,lu[cu])&&(ru[lu[cu]]=ou[lu[cu]]);return ru};class eN extends Nv{constructor(nu){if(nu.unroll)throw new e0("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(nu.cell))throw new e0("It is not possible at the moment to stack convolutional cells.");super(nu),this.inputSpec=[new ty({ndim:5})]}call(nu,ru){return Op(()=>{if(this.cell.dropoutMask!=null&&(o0(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o0(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),ru&&ru.constants)throw new Ep("ConvRNN2D cell does not support constants");const lu=ru==null?null:ru.mask,cu=ru==null?null:ru.training,hu=ru==null?null:ru.initialState;return super.call(nu,{mask:lu,training:cu,initialState:hu})})}computeOutputShape(nu){let ru=this.computeSingleOutputShape(nu);return this.returnSequences||(ru=[ru[0],...ru.slice(2)]),this.returnState&&(ru=[ru,...Array(2).fill([nu[0],...ru.slice(-3)])]),ru}getInitialState(nu){return Op(()=>{const{stateSize:ru}=this.cell,lu=nu.shape,cu=this.computeSingleOutputShape(lu),hu=[cu[0],...cu.slice(2)],pu=ay(hu);return Array.isArray(ru)?Array(ru.length).fill(pu):[pu]})}resetStates(nu,ru=!1){Op(()=>{if(!this.stateful)throw new Vx("Cannot call resetStates() on an RNN Layer that is not stateful.");const lu=this.inputSpec[0].shape,cu=this.computeSingleOutputShape(lu),hu=[cu[0],...cu.slice(2)];if(lu[0]==null)throw new Ep("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ay(hu)):this.states_=[ay(hu)];else if(nu==null)o0(this.states_),this.keptStates!=null&&(o0(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ay(hu)):this.states_[0]=ay(hu);else{if(Array.isArray(nu)||(nu=[nu]),nu.length!==this.states_.length)throw new Ep(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${nu.length} state value(s). Input received: ${nu}`);ru?this.keptStates.push(this.states_.slice()):o0(this.states_);for(let pu=0;pu<this.states_.length;++pu){const mu=nu[pu],Au=hu;if(!ku(mu.shape,Au))throw new Ep(`State ${pu} is incompatible with layer ${this.name}: expected shape=${Au}, received shape=${mu.shape}`);this.states_[pu]=mu}}this.states_=this.states_.map(pu=>Zy(pu.clone()))})}computeSingleOutputShape(nu){const{dataFormat:ru,filters:lu,kernelSize:cu,padding:hu,strides:pu,dilationRate:mu}=this.cell,Au=ru==="channelsFirst",bu=nu[Au?3:2],Cu=nu[Au?4:3],wu=Rx(bu,cu[0],hu,pu[0],mu[0]),Eu=Rx(Cu,cu[1],hu,pu[1],mu[1]);return[...nu.slice(0,2),...Au?[lu,wu,Eu]:[wu,Eu,lu]]}}eN.className="ConvRNN2D";class TT extends y2{constructor(nu){const{filters:ru,kernelSize:lu,strides:cu,padding:hu,dataFormat:pu,dilationRate:mu}=nu;super(Object.assign(Object.assign({},nu),{units:ru})),this.filters=ru,ly(this.filters,"filters"),this.kernelSize=rC(lu,2,"kernelSize"),this.kernelSize.forEach(Au=>ly(Au,"kernelSize")),this.strides=rC(cu||1,2,"strides"),this.strides.forEach(Au=>ly(Au,"strides")),this.padding=hu||"valid",Jy(this.padding),this.dataFormat=pu||"channelsLast",Q0(this.dataFormat),this.dilationRate=rC(mu||1,2,"dilationRate"),this.dilationRate.forEach(Au=>ly(Au,"dilationRate"))}build(nu){var ru;nu=p0(nu);const lu=this.dataFormat==="channelsFirst"?1:nu.length-1;if(nu[lu]==null)throw new Ep(`The channel dimension of the input should be defined. Found ${nu[lu]}`);const cu=nu[lu],hu=4,pu=this.kernelSize.concat([cu,this.filters*hu]);this.kernel=this.addWeight("kernel",pu,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const mu=this.kernelSize.concat([this.filters,this.filters*hu]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",mu,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let Au;if(this.unitForgetBias){const bu=this.biasInitializer,Cu=this.filters;Au=new(ru=class extends hx{apply(wu,Eu){const Tu=bu.apply([Cu]),Ru=Iv([Cu]),Nu=bu.apply([Cu*2]);return YI([Tu,Ru,Nu])}},ru.className="CustomInit",ru)}else Au=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*hu],null,Au,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(nu,ru){return Op(()=>{if(nu.length!==3)throw new Ep(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${nu.length}.`);const lu=ru.training||!1,cu=nu[0],hu=nu[1],pu=nu[2],mu=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Dv({ones:()=>ax(cu),rate:this.dropout,training:lu,count:mu,dropoutFunc:this.dropoutFunc}));const Au=this.dropoutMask,bu=(ym,pm,bm)=>!pm||!pm[bm]?ym:_p(pm[bm],ym);let Cu=bu(cu,Au,0),wu=bu(cu,Au,1),Eu=bu(cu,Au,2),Tu=bu(cu,Au,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Dv({ones:()=>ax(hu),rate:this.recurrentDropout,training:lu,count:mu,dropoutFunc:this.dropoutFunc}));const Ru=this.recurrentDropoutMask;let Nu=bu(hu,Ru,0),Pu=bu(hu,Ru,1),Fu=bu(hu,Ru,2),Gu=bu(hu,Ru,3);const Xu=3,[Qu,Ju,ip,rp]=qy(this.kernel.read(),mu,Xu),[op,hp,Ap,Up]=this.useBias?qy(this.bias.read(),mu):[null,null,null,null];Cu=this.inputConv(Cu,Qu,op,this.padding),wu=this.inputConv(wu,Ju,hp,this.padding),Eu=this.inputConv(Eu,ip,Ap,this.padding),Tu=this.inputConv(Tu,rp,Up,this.padding);const[Vp,zp,qp,Yp]=qy(this.recurrentKernel.read(),mu,Xu);Nu=this.recurrentConv(Nu,Vp),Pu=this.recurrentConv(Pu,zp),Fu=this.recurrentConv(Fu,qp),Gu=this.recurrentConv(Gu,Yp);const em=this.recurrentActivation.apply(Am(Cu,Nu)),am=this.recurrentActivation.apply(Am(wu,Pu)),im=Am(_p(am,pu),_p(em,this.activation.apply(Am(Eu,Fu)))),um=_p(this.recurrentActivation.apply(Am(Tu,Gu)),this.activation.apply(im));return[um,um,im]})}getConfig(){const nu=super.getConfig(),ru=p4(nu,["units"]),lu={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},ru),lu)}inputConv(nu,ru,lu,cu){const hu=o1(nu,ru,this.strides,cu||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return lu?Ix(hu,lu,this.dataFormat):hu}recurrentConv(nu,ru){return o1(nu,ru,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}TT.className="ConvLSTM2DCell",hm(TT);class tN extends eN{constructor(nu){const ru=new TT(nu);super(Object.assign(Object.assign({},nu),{cell:ru}))}static fromConfig(nu,ru){return new nu(ru)}}tN.className="ConvLSTM2D",hm(tN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class _T extends n0{constructor(nu){super(nu),this.rate=Math.max(Math.min(nu.rate,1),0),this.noiseShape=nu.noiseShape,this.seed=nu.seed,this.supportsMasking=!0}getNoiseShape(nu){if(this.noiseShape==null)return this.noiseShape;const ru=nu.shape,lu=[];for(let cu=0;cu<this.noiseShape.length;++cu)lu.push(this.noiseShape[cu]==null?ru[cu]:this.noiseShape[cu]);return lu}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu);if(0<this.rate&&this.rate<1){const cu=ru.training==null?!1:ru.training,hu=this.getNoiseShape(lu);return vw(()=>MB(lu,this.rate,hu,this.seed),()=>lu,cu)}return nu})}getConfig(){const nu={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},ru=super.getConfig();return Object.assign(nu,ru),nu}dispose(){return super.dispose()}}_T.className="Dropout",hm(_T);class nN extends _T{constructor(nu){super(nu),this.inputSpec=[{ndim:3}]}getNoiseShape(nu){const ru=nu.shape;return[ru[0],1,ru[2]]}}nN.className="SpatialDropout1D",hm(nN);class iN extends n0{constructor(nu){if(super(nu),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",nu.batchInputShape==null&&nu.inputShape==null&&nu.inputDim!=null){let ru=null;nu.batchSize!=null&&(ru=nu.batchSize),this.batchInputShape=[ru,nu.inputDim]}this.units=nu.units,ly(this.units,"units"),this.activation=Lv(nu.activation),nu.useBias!=null&&(this.useBias=nu.useBias),this.kernelInitializer=D0(nu.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=D0(nu.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=iy(nu.kernelConstraint),this.biasConstraint=iy(nu.biasConstraint),this.kernelRegularizer=F0(nu.kernelRegularizer),this.biasRegularizer=F0(nu.biasRegularizer),this.activityRegularizer=F0(nu.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(nu){nu=p0(nu);const ru=nu[nu.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[ru,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:ru}}],this.built=!0}computeOutputShape(nu){nu=p0(nu);const ru=nu.slice();return ru[ru.length-1]=this.units,ru}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu),cu=xB(this.activation.getClassName());let hu;return cu!=null?hu=Wx(lu,this.kernel.read(),cu,this.bias?this.bias.read():null):(hu=Wx(lu,this.kernel.read()),this.bias!=null&&(hu=Ix(hu,this.bias.read())),this.activation!=null&&(hu=this.activation.apply(hu))),hu})}getConfig(){const nu={units:this.units,activation:Bv(this.activation),useBias:this.useBias,kernelInitializer:O0(this.kernelInitializer),biasInitializer:O0(this.biasInitializer),kernelRegularizer:v0(this.kernelRegularizer),biasRegularizer:v0(this.biasRegularizer),activityRegularizer:v0(this.activityRegularizer),kernelConstraint:ny(this.kernelConstraint),biasConstraint:ny(this.biasConstraint)},ru=super.getConfig();return Object.assign(nu,ru),nu}}iN.className="Dense",hm(iN);class rN extends n0{constructor(nu){nu=nu||{},super(nu),this.inputSpec=[{minNDim:3}],this.dataFormat=nu.dataFormat}computeOutputShape(nu){nu=p0(nu);for(const ru of nu.slice(1))if(ru==null)throw new Ep(`The shape of the input to "Flatten" is not fully defined (got ${nu.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[nu[0],Mv(nu,1)]}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);let lu=jm(nu);if(this.dataFormat==="channelsFirst"&&lu.rank>1){const cu=[0];for(let hu=2;hu<lu.rank;++hu)cu.push(hu);cu.push(1),lu=c0(lu,cu)}return K5(lu)})}getConfig(){const nu={};this.dataFormat!=null&&(nu.dataFormat=this.dataFormat);const ru=super.getConfig();return Object.assign(nu,ru),nu}}rN.className="Flatten",hm(rN);class sN extends n0{constructor(nu){super(nu),this.supportsMasking=!0,this.activation=Lv(nu.activation)}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu);return this.activation.apply(lu)})}getConfig(){const nu={activation:Bv(this.activation)},ru=super.getConfig();return Object.assign(nu,ru),nu}}sN.className="Activation",hm(sN);class oN extends n0{constructor(nu){super(nu),this.n=nu.n,this.inputSpec=[{ndim:2}]}computeOutputShape(nu){return[nu[0],this.n,nu[1]]}call(nu,ru){return Op(()=>(nu=jm(nu),X5(nu,this.n)))}getConfig(){const nu={n:this.n},ru=super.getConfig();return Object.assign(nu,ru),nu}}oN.className="RepeatVector",hm(oN);class aN extends n0{constructor(nu){super(nu),this.targetShape=nu.targetShape;for(let ru=0;ru<this.targetShape.length;++ru)this.isUnknown(this.targetShape[ru])&&(this.targetShape[ru]=null)}isUnknown(nu){return nu<0||nu==null}fixUnknownDimension(nu,ru){const lu="Total size of new array must be unchanged.",cu=ru.slice();let hu=1,pu=null;for(let Au=0;Au<cu.length;++Au){const bu=cu[Au];if(this.isUnknown(bu))if(pu===null)pu=Au;else throw new Ep("Can only specifiy one unknown dimension.");else hu*=bu}const mu=Mv(nu);if(pu!==null){if(hu===0||mu%hu!==0)throw new Ep(lu);cu[pu]=mu/hu}else if(mu!==hu)throw new Ep(lu);return cu}computeOutputShape(nu){let ru=!1;for(let lu=0;lu<nu.length;++lu)if(this.isUnknown(nu[lu])){ru=!0;break}return ru?nu.slice(0,1).concat(this.targetShape):nu.slice(0,1).concat(this.fixUnknownDimension(nu.slice(1),this.targetShape))}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu),cu=lu.shape,hu=cu.slice(0,1).concat(this.fixUnknownDimension(cu.slice(1),this.targetShape));return Pp(lu,hu)})}getConfig(){const nu={targetShape:this.targetShape},ru=super.getConfig();return Object.assign(nu,ru),nu}}aN.className="Reshape",hm(aN);class lN extends n0{constructor(nu){if(super(nu),nu.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(nu.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${nu.dims} instead.`);const ru=Ex(1,nu.dims.length+1);if(!ku(nu.dims.slice().sort(),ru))throw new Error("Invalid permutation `dims`: "+JSON.stringify(nu.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=nu.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ty({ndim:this.dims.length+1})]}computeOutputShape(nu){nu=p0(nu);const ru=nu.slice();return this.dims.forEach((lu,cu)=>{ru[cu+1]=nu[lu]}),ru}call(nu,ru){return c0(jm(nu),this.dimsIncludingBatch)}getConfig(){const nu={dims:this.dims},ru=super.getConfig();return Object.assign(nu,ru),nu}}lN.className="Permute",hm(lN);class cN extends n0{constructor(nu){super(nu??{}),this.supportsMasking=!0,nu!=null?this.maskValue=nu.maskValue==null?0:nu.maskValue:this.maskValue=0}computeOutputShape(nu){return nu}getConfig(){const nu=super.getConfig(),ru={maskValue:this.maskValue};return Object.assign(ru,nu),ru}computeMask(nu,ru){const lu=jm(nu);return DS(zE(lu,this.maskValue),-1)}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu),cu=DS(zE(lu,this.maskValue),-1,!0);return _p(lu,km(cu,lu.dtype))})}}cN.className="Masking",hm(cN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class uN extends n0{constructor(nu){if(super(nu),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",nu.batchInputShape==null&&nu.inputShape==null){let ru=null;nu.batchSize!=null&&(ru=nu.batchSize),nu.inputLength==null?this.batchInputShape=[ru,null]:this.batchInputShape=[ru].concat(y0(nu.inputLength))}this.inputDim=nu.inputDim,ly(this.inputDim,"inputDim"),this.outputDim=nu.outputDim,ly(this.outputDim,"outputDim"),this.embeddingsInitializer=D0(nu.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=F0(nu.embeddingsRegularizer),this.activityRegularizer=F0(nu.activityRegularizer),this.embeddingsConstraint=iy(nu.embeddingsConstraint),this.maskZero=nu.maskZero,this.supportsMasking=nu.maskZero,this.inputLength=nu.inputLength}build(nu){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(nu){}computeMask(nu,ru){return Op(()=>this.maskZero?(nu=jm(nu),zE(nu,l0(nu))):null)}computeOutputShape(nu){if(nu=p0(nu),this.inputLength==null)return[...nu,this.outputDim];const ru=y0(this.inputLength);if(ru.length!==nu.length-1)throw new Ep(`"inputLength" is ${this.inputLength}, but received input shape has shape ${nu}`);{let lu=0;for(let cu=0;cu<ru.length;++cu){const hu=ru[cu],pu=nu[cu+1];if(hu!=null&&pu!=null&&hu!==pu)throw new Ep(`"inputLength" is ${this.inputLength}, but received input shape has shape ${nu}`);hu==null&&(ru[lu]=pu),lu++}}return[nu[0],...ru,this.outputDim]}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);let lu=jm(nu);lu.dtype!=="int32"&&(lu=lv(lu,"int32"));const cu=_B(this.embeddings.read(),Pp(lu,[lu.size]));return Pp(cu,p0(this.computeOutputShape(lu.shape)))})}getConfig(){const nu={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:O0(this.embeddingsInitializer),embeddingsRegularizer:v0(this.embeddingsRegularizer),activityRegularizer:v0(this.activityRegularizer),embeddingsConstraint:ny(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},ru=super.getConfig();return Object.assign(nu,ru),nu}}uN.className="Embedding",hm(uN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class x1 extends n0{constructor(nu){super(nu||{}),this.supportsMasking=!0}mergeFunction(nu){throw new e0}computeElementwiseOpOutputShape(nu,ru){if(nu==null||ru==null)return null;if(nu.length<ru.length)return this.computeElementwiseOpOutputShape(ru,nu);if(ru.length===0)return nu;const lu=nu.slice(0,nu.length-ru.length);for(let cu=0;cu<ru.length;++cu){const hu=nu[nu.length-ru.length+cu],pu=ru[cu];if(hu==null||pu==null||hu<0||pu<0)lu.push(null);else if(hu===1)lu.push(pu);else if(pu===1)lu.push(hu);else{if(hu!==pu)throw new Ep("Operands could not be broadcast together with shapes "+JSON.stringify(nu)+" "+JSON.stringify(ru));lu.push(hu)}}return lu}build(nu){if(Array.isArray(nu)&&!Array.isArray(nu[0])&&(nu=[p0(nu)]),nu=nu,nu.length<2)throw new Ep(`A merge layer should be called on an Array of at least 2 inputs. Got ${nu.length} input(s).`);let ru=[];for(const hu of nu)hu!=null&&hu[0]!==null&&ru.push(hu[0]);if(ru=_v(ru),ru.length>1)throw new Ep(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(nu)}.`);let lu=nu[0]==null?null:nu[0].slice(1);for(let hu=1;hu<nu.length;++hu){const pu=nu[hu]==null?null:nu[hu].slice(1);lu=this.computeElementwiseOpOutputShape(lu,pu)}const cu=nu.map(hu=>hu.length);nu.indexOf(null)===-1&&_v(cu).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(nu,ru){return Op(()=>{if(nu=nu,this.reshapeRequired){const lu=[],cu=nu.map(hu=>hu.rank);if(cu.indexOf(null)===-1){const hu=Rv(cu);for(let pu of nu){const mu=pu.rank;for(let Au=0;Au<hu-mu;++Au)pu=bw(pu,1);lu.push(pu)}return this.mergeFunction(lu)}else{let hu=!1;for(const Au of nu){const bu=Au.rank;if(bu==null){const Cu=Au.shape,wu=Cu[0],Eu=Cu.slice(1).concat([wu]);let Tu=Pp(Au,[wu].concat(Mv(Cu.slice(1))));Tu=c0(Tu,[1,0]),Tu=Pp(Tu,Eu),lu.push(Tu),hu=!0}else if(bu>1){const Cu=Ex(1,bu).concat([0]);lu.push(c0(Au,Cu)),hu=!0}else lu.push(Au)}let pu=this.mergeFunction(lu);const mu=pu.rank;if(hu){if(mu==null){const Au=pu.shape,bu=Au.length,Cu=Au[bu-1],wu=[Cu].concat(Au.slice(0,Au.length-1));pu=Pp(c0(Pp(pu,[-1,Cu]),[1,0]),wu)}else if(mu>1){const Au=[mu-1].concat(Ex(0,mu-1));pu=c0(pu,Au)}}return pu}}else return this.mergeFunction(nu)})}computeOutputShape(nu){nu=nu;let ru;nu[0]==null?ru=null:ru=nu[0].slice(1);for(let cu=1;cu<nu.length;++cu){const hu=nu[cu]==null?null:nu[cu].slice(1);ru=this.computeElementwiseOpOutputShape(ru,hu)}let lu=[];for(const cu of nu)cu!=null&&cu[0]!==null&&lu.push(cu[0]);return lu=_v(lu),lu.length===1?ru=lu.concat(ru):ru=[null].concat(ru),ru}computeMask(nu,ru){return Op(()=>{if(ru==null)return null;if(!Array.isArray(ru))throw new Ep("`mask` should be an Array");if(!Array.isArray(nu))throw new Ep("`inputs` should be an Array");if(ru.length!==nu.length)throw new Ep(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${nu.length} vs ${ru.length})`);if(ru.every(cu=>cu==null))return null;ru=ru.map(cu=>cu==null?cu:Ly(cu,0));let lu=ru[0];for(let cu=1;cu<ru.length-1;++cu)lu=iv(lu,ru[cu]);return lu})}}class hN extends x1{constructor(nu){super(nu)}mergeFunction(nu){return Op(()=>{let ru=nu[0].clone();for(let lu=1;lu<nu.length;++lu)ru=Am(ru,nu[lu]);return ru})}}hN.className="Add",hm(hN);class dN extends x1{constructor(nu){super(nu)}mergeFunction(nu){return Op(()=>{let ru=nu[0].clone();for(let lu=1;lu<nu.length;++lu)ru=_p(ru,nu[lu]);return ru})}}dN.className="Multiply",hm(dN);class pN extends x1{constructor(nu){super(nu)}mergeFunction(nu){return Op(()=>{let ru=nu[0].clone();for(let lu=1;lu<nu.length;++lu)ru=Am(ru,nu[lu]);return _p(1/nu.length,ru)})}}pN.className="Average",hm(pN);class fN extends x1{constructor(nu){super(nu)}mergeFunction(nu){return Op(()=>{let ru=nu[0];for(let lu=1;lu<nu.length;++lu)ru=Sv(ru,nu[lu]);return ru})}}fN.className="Maximum",hm(fN);class mN extends x1{constructor(nu){super(nu)}mergeFunction(nu){return Op(()=>{let ru=nu[0];for(let lu=1;lu<nu.length;++lu)ru=cw(ru,nu[lu]);return ru})}}mN.className="Minimum",hm(mN);class gN extends x1{constructor(nu){super(nu),this.DEFAULT_AXIS=-1,nu==null&&(nu={}),this.axis=nu.axis==null?this.DEFAULT_AXIS:nu.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(nu){if(!(Array.isArray(nu)&&Array.isArray(nu[0]))||nu.length===1)throw new Ep("A `Concatenate` layer should be called on a list of at least 2 inputs");nu=nu;let ru=!0;for(const cu of nu)if(cu!=null){ru=!1;break}if(ru)return;const lu=[];for(let cu=0;cu<nu.length;++cu){const hu=nu[cu].slice();hu.splice(this.axis,1);let pu=!1;for(const mu of lu)if(ku(mu,hu)){pu=!0;break}pu||lu.push(hu)}if(lu.length>1)throw new Ep("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(nu))}mergeFunction(nu){return Op(()=>YI(nu,this.axis))}computeOutputShape(nu){if(!(Array.isArray(nu)&&Array.isArray(nu[0])))throw new Ep("A `Concatenate` layer should be called on a list of inputs.");const ru=nu,lu=ru[0].slice(),cu=this.axis<0?lu.length+this.axis:this.axis;for(const hu of ru.slice(1)){if(lu[cu]==null||hu[cu]==null){lu[cu]=null;break}lu[cu]+=hu[cu]}return lu}computeMask(nu,ru){if(ru==null)return null;if(!Array.isArray(ru))throw new Ep("`mask` should be an array for Concatenate");if(!Array.isArray(nu))throw new Ep("`inputs` should be an array for Concatenate");if(ru.length!==nu.length)throw new Ep(`Mismatch in the length of mask (${ru.length}) and the legnth of inputs (${nu.length})`);return Op(()=>{let lu=!0;if(ru.forEach(pu=>{if(pu!=null){lu=!1;return}}),lu)return null;const cu=[];for(let pu=0;pu<nu.length;++pu)ru[pu]==null?cu.push(km(ax(nu[pu]),"bool")):ru[pu].rank<nu[pu].rank?cu.push(Ly(ru[pu],-1)):cu.push(ru[pu]);const hu=By(cu,this.axis);return FM(hu,-1,!1)})}getConfig(){const nu={axis:this.axis},ru=super.getConfig();return Object.assign(nu,ru),nu}}gN.className="Concatenate",hm(gN);function kw(ou,nu){for(;ou<0;)ou+=nu;return ou}function f4(ou,nu,ru){if(ou.shape.length>3||nu.shape.length>3)throw new e0("batchDot is not implemented for tensors of 4D or higher rank yet");if(vu(ou.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${ou.shape.length}`),vu(ou.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${nu.shape.length}`),typeof ru=="number"&&(ru=[ru,ru]),ou.dtype==="complex64"||nu.dtype==="complex64")throw new e0("batchDot is not implemented for complex64-type Tensors yet.");const lu=ou.shape.length,cu=nu.shape.length;ru==null&&(ru=[lu-1,cu-2]);const hu=ru;return Op(()=>{let pu;if(lu>cu){pu=lu-cu;const Au=[];for(let bu=0;bu<pu;++bu)Au.push(1);nu=Pp(nu,nu.shape.concat(Au))}else if(cu>lu){pu=cu-lu;const Au=[];for(let bu=0;bu<pu;++bu)Au.push(1);ou=Pp(ou,ou.shape.concat(Au))}else pu=0;let mu;if(ou.shape.length===2&&nu.shape.length===2)hu[0]===hu[1]?mu=zm(_p(ou,nu),hu[0]):mu=zm(_p(c0(ou,[1,0]),nu),hu[1]);else{const Au=hu[0]!==ou.shape.length-1,bu=hu[1]===nu.shape.length-1;mu=g0(ou,nu,Au,bu)}if(pu>0){let Au;lu>cu?Au=lu+cu-3:Au=lu-1;const bu=[];for(let Cu=Au;Cu<Au+pu;++Cu)bu.push(Cu);mu=dw(mu,bu)}return mu.shape.length===1&&(mu=Ly(mu,1)),mu})}class AN extends x1{constructor(nu){super(nu),this.axes=nu.axes,this.normalize=nu.normalize==null?!1:nu.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(nu){vu(Array.isArray(nu)&&nu.length===2&&Array.isArray(nu[0])&&Array.isArray(nu[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const ru=nu[0],lu=nu[1];if(ru.length>3||lu.length>3)throw new e0("Dot layer does not support tensors of 4D or higher rank yet.");const cu=this.interpretAxes(ru,lu);if(ru[cu[0]]!==lu[cu[1]])throw new Ep(`Dimension incompatibility: ${ru[cu[0]]} !== ${lu[cu[1]]}`)}mergeFunction(nu){if(nu.length!==2)throw new Ep(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${nu.length} input(s).`);let ru=nu[0],lu=nu[1],cu;return Array.isArray(this.axes)?cu=this.axes.map((hu,pu)=>kw(hu,nu[pu].shape.length)):cu=[kw(this.axes,ru.shape.length),kw(this.axes,lu.shape.length)],this.normalize&&(ru=a2(ru,cu[0]),lu=a2(lu,cu[1])),f4(ru,lu,cu)}interpretAxes(nu,ru){let lu;return Array.isArray(this.axes)?lu=this.axes:lu=[kw(this.axes,nu.length),kw(this.axes,ru.length)],lu}computeOutputShape(nu){vu(Array.isArray(nu)&&nu.length===2&&Array.isArray(nu[0])&&Array.isArray(nu[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const ru=nu[0].slice(),lu=nu[1].slice();if(ru.length>3||lu.length>3)throw new e0("Dot layer does not support tensors of 4D or higher rank yet.");const cu=this.interpretAxes(ru,lu);ru.splice(cu[0],1),lu.splice(cu[1],1),lu.splice(0,1);const hu=ru.concat(lu);return hu.length===1&&hu.push(1),hu}computeMask(nu,ru){return null}getConfig(){const nu={axes:this.axes,normalize:this.normalize},ru=super.getConfig();return Object.assign(nu,ru),nu}}AN.className="Dot",hm(AN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class yN extends n0{constructor(nu){super(nu),this.supportsMasking=!0,this.stddev=nu.stddev}computeOutputShape(nu){return nu}getConfig(){const nu=super.getConfig(),ru={stddev:this.stddev};return Object.assign(ru,nu),ru}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu);return vw(()=>Am(t2(lu.shape,0,this.stddev),lu),()=>lu,ru.training||!1)})}}yN.className="GaussianNoise",hm(yN);class bN extends n0{constructor(nu){super(nu),this.supportsMasking=!0,this.rate=nu.rate}computeOutputShape(nu){return nu}getConfig(){const nu=super.getConfig(),ru={rate:this.rate};return Object.assign(ru,nu),ru}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru);const lu=jm(nu);return this.rate>0&&this.rate<1?vw(()=>{const cu=Math.sqrt(this.rate/(1-this.rate));return _p(lu,t2(lu.shape,1,cu))},()=>lu,ru.training||!1):lu})}}bN.className="GaussianDropout",hm(bN);class xN extends n0{constructor(nu){super(nu),this.supportsMasking=!0,this.rate=nu.rate,this.noiseShape=nu.noiseShape}_getNoiseShape(nu){return this.noiseShape||jm(nu).shape}computeOutputShape(nu){return nu}getConfig(){const nu=super.getConfig(),ru={rate:this.rate};return Object.assign(ru,nu),ru}call(nu,ru){return Op(()=>{if(this.rate<1&&this.rate>0){const lu=this._getNoiseShape(nu);return vw(()=>{const cu=jm(nu),hu=-1.6732632423543772*1.0507009873554805;let pu=a1(uw(lu),this.rate);pu=lv(pu,"float32");const mu=((1-this.rate)*(1+this.rate*hu**2))**-.5,Au=-mu*hu*this.rate,bu=Am(_p(cu,pu),_p(Am(pu,-1),hu));return Am(_p(bu,mu),Au)},()=>jm(nu),ru.training||!1)}return nu})}}xN.className="AlphaDropout",hm(xN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Bw(ou,nu,ru,lu,cu,hu=.001){let pu;if(ou.rank===2)pu=HG(ou,nu,ru,lu,cu,hu);else if(ou.rank===3)pu=QG(ou,nu,ru,lu,cu,hu);else if(ou.rank===4)pu=ZG(ou,nu,ru,lu,cu,hu);else throw new e0(`batchNormalization is not implemented for array of rank ${ou.rank} yet`);return pu}function m4(ou,nu,ru,lu,cu=.001){return Op(()=>{const hu=YS(ou,lu),pu=hu.mean,mu=hu.variance;return[Bw(ou,pu,mu,ru,nu,cu),pu,mu]})}function g4(ou,nu,ru,lu,cu=.001){return Op(()=>{const hu=YS(ou,lu),pu=hu.mean,mu=hu.variance,Au=[];for(const Tu of Ex(0,ou.rank))lu.indexOf(Tu)!==-1?Au.push(1):Au.push(ou.shape[Tu]);const bu=Pp(pu,Au),Cu=Pp(mu,Au),wu=nu==null?null:Pp(nu,Au),Eu=ru==null?null:Pp(ru,Au);return[Bw(ou,bu,Cu,Eu,wu,cu),pu,mu]})}function A4(ou,nu,ru,lu,cu=.001){return ku(lu.slice().sort(),Ex(0,ou.rank-1))?m4(ou,nu,ru,lu,cu):g4(ou,nu,ru,lu,cu)}class vN extends n0{constructor(nu){nu==null&&(nu={}),super(nu),this.supportsMasking=!0,this.axis=nu.axis==null?-1:nu.axis,this.momentum=nu.momentum==null?.99:nu.momentum,this.epsilon=nu.epsilon==null?.001:nu.epsilon,this.center=nu.center==null?!0:nu.center,this.scale=nu.scale==null?!0:nu.scale,this.betaInitializer=D0(nu.betaInitializer||"zeros"),this.gammaInitializer=D0(nu.gammaInitializer||"ones"),this.movingMeanInitializer=D0(nu.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=D0(nu.movingVarianceInitializer||"ones"),this.betaConstraint=iy(nu.betaConstraint),this.gammaConstraint=iy(nu.gammaConstraint),this.betaRegularizer=F0(nu.betaRegularizer),this.gammaRegularizer=F0(nu.gammaRegularizer)}build(nu){nu=p0(nu);const ru=this.axis>=0?this.axis:this.axis+nu.length,lu=nu[ru];if(lu==null)throw new Ep(`Axis ${ru} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(nu)}.`);this.inputSpec=[new ty({ndim:nu.length,axes:{[ru]:lu}})];const cu=[lu];this.scale&&(this.gamma=this.addWeight("gamma",cu,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",cu,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",cu,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",cu,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(nu,ru){return Op(()=>{const lu=ru.training==null?!1:ru.training,cu=jm(nu),hu=cu.shape,pu=hu.length,mu=Ex(0,pu),Au=this.axis>=0?this.axis:this.axis+pu;mu.splice(Au,1);const bu=f1(1,pu);bu[Au]=hu[Au];const Cu=mu.slice();Cu.sort();const wu=!ku(Cu,Ex(0,pu).slice(0,pu-1)),Eu=()=>{if(wu){const Fu=Pp(this.movingMean.read(),bu),Gu=Pp(this.movingVariance.read(),bu),Xu=this.center?Pp(this.beta.read(),bu):null,Qu=this.scale?Pp(this.gamma.read(),bu):null;return Bw(cu,Fu,Gu,Xu,Qu,this.epsilon)}else return Bw(cu,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!lu)return Eu();const[Tu,Ru,Nu]=A4(cu,this.gamma.read(),this.beta.read(),mu,this.epsilon),Pu=(Fu,Gu,Xu)=>{Op(()=>{const Qu=1-Xu,Ju=Fu.read(),ip=_p(Qm(Ju,Gu),Qu);Fu.write(Qm(Ju,ip))})};return Pu(this.movingMean,Ru,this.momentum),Pu(this.movingVariance,Nu,this.momentum),Tu})}getConfig(){const nu={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:O0(this.betaInitializer),gammaInitializer:O0(this.gammaInitializer),movingMeanInitializer:O0(this.movingMeanInitializer),movingVarianceInitializer:O0(this.movingVarianceInitializer),betaRegularizer:v0(this.betaRegularizer),gammaRegularizer:v0(this.gammaRegularizer),betaConstraint:ny(this.betaConstraint),gammaConstraint:ny(this.gammaConstraint)},ru=super.getConfig();return Object.assign(nu,ru),nu}}vN.className="BatchNormalization",hm(vN);class CN extends n0{constructor(nu){if(nu==null&&(nu={}),super(nu),this.axis=nu.axis==null?-1:nu.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const ru of this.axis)if(!Number.isInteger(ru))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=nu.epsilon==null?.001:nu.epsilon,this.center=nu.center==null?!0:nu.center,this.scale=nu.scale==null?!0:nu.scale,this.betaInitializer=D0(nu.betaInitializer||"zeros"),this.gammaInitializer=D0(nu.gammaInitializer||"ones"),this.betaRegularizer=F0(nu.betaRegularizer),this.gammaRegularizer=F0(nu.gammaRegularizer),this.supportsMasking=!0}build(nu){nu=p0(nu);const ru=nu.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let hu=0;hu<this.axis.length;++hu)this.axis[hu]<0&&(this.axis[hu]+=ru);for(const hu of this.axis)if(hu<0||hu>=ru)throw new Error(`Invalid axis: ${hu}`);if(this.axis.length!==_v(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const lu=this.axis.map(hu=>nu[hu]),cu=!0;this.scale?this.gamma=this.addWeight("gamma",lu,"float32",this.gammaInitializer,this.gammaRegularizer,cu):this.gamma=null,this.center?this.beta=this.addWeight("beta",lu,"float32",this.betaInitializer,this.betaRegularizer,cu):this.beta=null,this.built=!0}call(nu,ru){const lu=jm(nu),cu=lu.shape,hu=cu.length;return Op(()=>{let{mean:pu,variance:mu}=YS(lu,this.axis,!0);const Au=f1(1,hu);for(const Ru of this.axis)Au[Ru]=cu[Ru];const bu=Ru=>Ru!=null&&Ru.shape.length!==hu?Pp(Ru,Au):Ru;let Cu=this.scale?bu(this.gamma.read()):null,wu=this.center?bu(this.beta.read()):null;const Eu=[],Tu=[];for(let Ru=0;Ru<hu;++Ru)this.axis.indexOf(Ru)!==-1?(Eu.push(cu[Ru]),Tu.push(1)):(Eu.push(1),Tu.push(cu[Ru]));return pu=Cx(pu,Eu),mu=Cx(mu,Eu),Cu!=null&&(Cu=Cx(Cu,Tu)),wu!=null&&(wu=Cx(wu,Tu)),Bw(lu,pu,mu,wu,Cu,this.epsilon)})}getConfig(){const nu={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:O0(this.betaInitializer),gammaInitializer:O0(this.gammaInitializer),betaRegularizer:v0(this.betaRegularizer),gammaRegularizer:v0(this.gammaRegularizer)},ru=super.getConfig();return Object.assign(nu,ru),nu}}CN.className="LayerNormalization",hm(CN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function y4(ou,nu,ru){return Op(()=>{if(ou.rank!==4)throw new Ep(`temporalPadding expects input tensor to be 4-D, but received a ${ou.rank}-D tensor.`);if(nu==null&&(nu=[[1,1],[1,1]]),nu.length!==2||nu[0].length!==2||nu[1].length!==2)throw new Ep("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(ru==null&&(ru=Sx()),ru!=="channelsLast"&&ru!=="channelsFirst")throw new Ep(`Unknown data format: ${ru}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let lu;return ru==="channelsFirst"?lu=[[0,0],[0,0],nu[0],nu[1]]:lu=[[0,0],nu[0],nu[1],[0,0]],qS(ou,lu)})}class wN extends n0{constructor(nu){if(nu==null&&(nu={}),super(nu),this.dataFormat=nu.dataFormat==null?Sx():nu.dataFormat,nu.padding==null)this.padding=[[1,1],[1,1]];else if(typeof nu.padding=="number")this.padding=[[nu.padding,nu.padding],[nu.padding,nu.padding]];else{if(nu.padding=nu.padding,nu.padding.length!==2)throw new Ep(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${nu.padding.length} array.`);let ru,lu;if(typeof nu.padding[0]=="number")ru=[nu.padding[0],nu.padding[0]],lu=[nu.padding[1],nu.padding[1]];else{if(nu.padding=nu.padding,nu.padding[0].length!==2)throw new Ep(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${nu.padding[0].length} array.`);if(ru=nu.padding[0],nu.padding[1].length!==2)throw new Ep(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${nu.padding[1].length} array.`);lu=nu.padding[1]}this.padding=[ru,lu]}this.inputSpec=[new ty({ndim:4})]}computeOutputShape(nu){nu=p0(nu);let ru,lu;return this.dataFormat==="channelsFirst"?(nu[2]!=null&&nu[2]>=0?ru=nu[2]+this.padding[0][0]+this.padding[0][1]:ru=null,nu[3]!=null&&nu[3]>=0?lu=nu[3]+this.padding[1][0]+this.padding[1][1]:lu=null,[nu[0],nu[1],ru,lu]):(nu[1]!=null&&nu[1]>=0?ru=nu[1]+this.padding[0][0]+this.padding[0][1]:ru=null,nu[2]!=null&&nu[2]>=0?lu=nu[2]+this.padding[1][0]+this.padding[1][1]:lu=null,[nu[0],ru,lu,nu[3]])}call(nu,ru){return Op(()=>y4(jm(nu),this.padding,this.dataFormat))}getConfig(){const nu={padding:this.padding,dataFormat:this.dataFormat},ru=super.getConfig();return Object.assign(nu,ru),nu}}wN.className="ZeroPadding2D",hm(wN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function b2(ou,nu,ru,lu,cu,hu){return Op(()=>{Q0(cu),CB(hu),Jy(lu),ru==null&&(ru=[1,1]),lu==null&&(lu="valid"),cu==null&&(cu=Sx()),hu==null&&(hu="max"),ou=wT(ou,cu);let pu;const mu=lu==="same"?"same":"valid";return hu==="max"?pu=jS(ou,nu,ru,mu):pu=GS(ou,nu,ru,mu),cu==="channelsFirst"&&(pu=c0(pu,[0,3,1,2])),pu})}function EN(ou,nu,ru,lu,cu,hu){return Op(()=>{Q0(cu),CB(hu),Jy(lu),ru==null&&(ru=[1,1,1]),lu==null&&(lu="valid"),cu==null&&(cu=Sx()),hu==null&&(hu="max"),ou=UL(ou,cu);let pu;const mu=lu==="same"?"same":"valid";return hu==="max"?pu=NU(ou,nu,ru,mu):pu=DG(ou,nu,ru,mu),cu==="channelsFirst"&&(pu=c0(pu,[0,4,1,2,3])),pu})}class SN extends n0{constructor(nu){if(nu.poolSize==null&&(nu.poolSize=2),super(nu),typeof nu.poolSize=="number")this.poolSize=[nu.poolSize];else if(Array.isArray(nu.poolSize)&&nu.poolSize.length===1&&typeof nu.poolSize[0]=="number")this.poolSize=nu.poolSize;else throw new Ep(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(nu.poolSize)}`);if(ly(this.poolSize,"poolSize"),nu.strides==null)this.strides=this.poolSize;else if(typeof nu.strides=="number")this.strides=[nu.strides];else if(Array.isArray(nu.strides)&&nu.strides.length===1&&typeof nu.strides[0]=="number")this.strides=nu.strides;else throw new Ep(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(nu.strides)}`);ly(this.strides,"strides"),this.padding=nu.padding==null?"valid":nu.padding,Jy(this.padding),this.inputSpec=[new ty({ndim:3})]}computeOutputShape(nu){nu=p0(nu);const ru=Rx(nu[1],this.poolSize[0],this.padding,this.strides[0]);return[nu[0],ru,nu[2]]}call(nu,ru){return Op(()=>{this.invokeCallHook(nu,ru),nu=bw(jm(nu),2);const lu=this.poolingFunction(jm(nu),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return dw(lu,[2])})}getConfig(){const nu={poolSize:this.poolSize,padding:this.padding,strides:this.strides},ru=super.getConfig();return Object.assign(nu,ru),nu}}class IN extends SN{constructor(nu){super(nu)}poolingFunction(nu,ru,lu,cu,hu){return Q0(hu),Jy(cu),b2(nu,ru,lu,cu,hu,"max")}}IN.className="MaxPooling1D",hm(IN);class TN extends SN{constructor(nu){super(nu)}poolingFunction(nu,ru,lu,cu,hu){return Q0(hu),Jy(cu),b2(nu,ru,lu,cu,hu,"avg")}}TN.className="AveragePooling1D",hm(TN);class _N extends n0{constructor(nu){if(nu.poolSize==null&&(nu.poolSize=[2,2]),super(nu),this.poolSize=Array.isArray(nu.poolSize)?nu.poolSize:[nu.poolSize,nu.poolSize],nu.strides==null)this.strides=this.poolSize;else if(Array.isArray(nu.strides)){if(nu.strides.length!==2)throw new Ep(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${nu.strides.length}.`);this.strides=nu.strides}else this.strides=[nu.strides,nu.strides];ly(this.poolSize,"poolSize"),ly(this.strides,"strides"),this.padding=nu.padding==null?"valid":nu.padding,this.dataFormat=nu.dataFormat==null?"channelsLast":nu.dataFormat,Q0(this.dataFormat),Jy(this.padding),this.inputSpec=[new ty({ndim:4})]}computeOutputShape(nu){nu=p0(nu);let ru=this.dataFormat==="channelsFirst"?nu[2]:nu[1],lu=this.dataFormat==="channelsFirst"?nu[3]:nu[2];return ru=Rx(ru,this.poolSize[0],this.padding,this.strides[0]),lu=Rx(lu,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[nu[0],nu[1],ru,lu]:[nu[0],ru,lu,nu[3]]}call(nu,ru){return Op(()=>(this.invokeCallHook(nu,ru),this.poolingFunction(jm(nu),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const nu={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},ru=super.getConfig();return Object.assign(nu,ru),nu}}class MN extends _N{constructor(nu){super(nu)}poolingFunction(nu,ru,lu,cu,hu){return Q0(hu),Jy(cu),b2(nu,ru,lu,cu,hu,"max")}}MN.className="MaxPooling2D",hm(MN);class RN extends _N{constructor(nu){super(nu)}poolingFunction(nu,ru,lu,cu,hu){return Q0(hu),Jy(cu),b2(nu,ru,lu,cu,hu,"avg")}}RN.className="AveragePooling2D",hm(RN);class kN extends n0{constructor(nu){if(nu.poolSize==null&&(nu.poolSize=[2,2,2]),super(nu),this.poolSize=Array.isArray(nu.poolSize)?nu.poolSize:[nu.poolSize,nu.poolSize,nu.poolSize],nu.strides==null)this.strides=this.poolSize;else if(Array.isArray(nu.strides)){if(nu.strides.length!==3)throw new Ep(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${nu.strides.length}.`);this.strides=nu.strides}else this.strides=[nu.strides,nu.strides,nu.strides];ly(this.poolSize,"poolSize"),ly(this.strides,"strides"),this.padding=nu.padding==null?"valid":nu.padding,this.dataFormat=nu.dataFormat==null?"channelsLast":nu.dataFormat,Q0(this.dataFormat),Jy(this.padding),this.inputSpec=[new ty({ndim:5})]}computeOutputShape(nu){nu=p0(nu);let ru=this.dataFormat==="channelsFirst"?nu[2]:nu[1],lu=this.dataFormat==="channelsFirst"?nu[3]:nu[2],cu=this.dataFormat==="channelsFirst"?nu[4]:nu[3];return ru=Rx(ru,this.poolSize[0],this.padding,this.strides[0]),lu=Rx(lu,this.poolSize[1],this.padding,this.strides[1]),cu=Rx(cu,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[nu[0],nu[1],ru,lu,cu]:[nu[0],ru,lu,cu,nu[4]]}call(nu,ru){return Op(()=>(this.invokeCallHook(nu,ru),this.poolingFunction(jm(nu),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const nu={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},ru=super.getConfig();return Object.assign(nu,ru),nu}}class BN extends kN{constructor(nu){super(nu)}poolingFunction(nu,ru,lu,cu,hu){return Q0(hu),Jy(cu),EN(nu,ru,lu,cu,hu,"max")}}BN.className="MaxPooling3D",hm(BN);class LN extends kN{constructor(nu){super(nu)}poolingFunction(nu,ru,lu,cu,hu){return Q0(hu),Jy(cu),EN(nu,ru,lu,cu,hu,"avg")}}LN.className="AveragePooling3D",hm(LN);class NN extends n0{constructor(nu){super(nu),this.inputSpec=[new ty({ndim:3})]}computeOutputShape(nu){return[nu[0],nu[2]]}call(nu,ru){throw new e0}}class DN extends NN{constructor(nu){super(nu||{})}call(nu,ru){return Op(()=>{const lu=jm(nu);return Y0(lu,1)})}}DN.className="GlobalAveragePooling1D",hm(DN);class FN extends NN{constructor(nu){super(nu||{})}call(nu,ru){return Op(()=>{const lu=jm(nu);return vx(lu,1)})}}FN.className="GlobalMaxPooling1D",hm(FN);class PN extends n0{constructor(nu){super(nu),this.dataFormat=nu.dataFormat==null?"channelsLast":nu.dataFormat,Q0(this.dataFormat),this.inputSpec=[new ty({ndim:4})]}computeOutputShape(nu){return nu=nu,this.dataFormat==="channelsLast"?[nu[0],nu[3]]:[nu[0],nu[1]]}call(nu,ru){throw new e0}getConfig(){const nu={dataFormat:this.dataFormat},ru=super.getConfig();return Object.assign(nu,ru),nu}}class GN extends PN{call(nu,ru){return Op(()=>{const lu=jm(nu);return this.dataFormat==="channelsLast"?Y0(lu,[1,2]):Y0(lu,[2,3])})}}GN.className="GlobalAveragePooling2D",hm(GN);class ON extends PN{call(nu,ru){return Op(()=>{const lu=jm(nu);return this.dataFormat==="channelsLast"?vx(lu,[1,2]):vx(lu,[2,3])})}}ON.className="GlobalMaxPooling2D",hm(ON);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class UN extends n0{constructor(nu){super(nu),this.layer=nu.layer}build(nu){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(nu){this.layer!=null&&(this.layer.trainable=nu)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(nu){this.layer.setWeights(nu)}getConfig(){const nu={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},ru=super.getConfig();return Object.assign(nu,ru),nu}setFastWeightInitDuringBuild(nu){super.setFastWeightInitDuringBuild(nu),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(nu)}static fromConfig(nu,ru,lu={}){const cu=ru.layer,hu=cv(cu,lu);delete ru.layer;const pu={layer:hu};return Object.assign(pu,ru),new nu(pu)}}class $N extends UN{constructor(nu){super(nu),this.supportsMasking=!0}build(nu){if(nu=p0(nu),nu.length<3)throw new Ep(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(nu)}`);this.inputSpec=[{shape:nu}];const ru=[nu[0]].concat(nu.slice(2));this.layer.built||(this.layer.build(ru),this.layer.built=!0),super.build(nu)}computeOutputShape(nu){nu=p0(nu);const ru=[nu[0]].concat(nu.slice(2)),lu=this.layer.computeOutputShape(ru),cu=nu[1];return[lu[0],cu].concat(lu.slice(1))}call(nu,ru){return Op(()=>(nu=jm(nu),jL((lu,cu)=>[jm(this.layer.call(lu,ru)),[]],nu,[],!1,null,null,!1,!0)[1]))}}$N.className="TimeDistributed",hm($N);function b4(ou){g1($5,"BidirectionalMergeMode",ou)}const x4="concat";class VN extends UN{constructor(nu){super(nu);const ru=nu.layer.getConfig(),lu={};lu.className=nu.layer.getClassName(),lu.config=ru,this.forwardLayer=cv(lu),ru.goBackwards=ru.goBackwards!==!0;const cu={};if(cu.className=nu.layer.getClassName(),cu.config=ru,this.backwardLayer=cv(cu),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=nu.mergeMode===void 0?x4:nu.mergeMode,b4(this.mergeMode),nu.weights)throw new e0("weights support is not implemented for Bidirectional layer yet.");this._stateful=nu.layer.stateful,this.returnSequences=nu.layer.returnSequences,this.returnState=nu.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=nu.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(nu){this._trainable=nu,this.forwardLayer!=null&&(this.forwardLayer.trainable=nu),this.backwardLayer!=null&&(this.backwardLayer.trainable=nu)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(nu){const ru=nu.length,lu=Math.floor(ru/2);this.forwardLayer.setWeights(nu.slice(0,lu)),this.backwardLayer.setWeights(nu.slice(lu))}computeOutputShape(nu){let ru=this.forwardLayer.computeOutputShape(nu);Array.isArray(ru)&&Array.isArray(ru[0])||(ru=[ru]),ru=ru;let lu,cu,hu;return this.returnState&&(hu=ru.slice(1)),lu=ru[0],lu=lu,this.mergeMode==="concat"?(lu[lu.length-1]*=2,cu=[lu]):this.mergeMode==null?cu=[lu,lu.slice()]:cu=[lu],this.returnState?this.mergeMode==null?cu.concat(hu).concat(hu.slice()):[lu].concat(hu).concat(hu.slice()):Ny(cu)}apply(nu,ru){let lu=ru==null?null:ru.initialState,cu=ru==null?null:ru.constants;ru==null&&(ru={});const hu=ZL(nu,lu,cu,this.numConstants);if(nu=hu.inputs,lu=hu.initialState,cu=hu.constants,Array.isArray(nu)&&(lu=nu.slice(1),nu=nu[0]),(lu==null||lu.length===0)&&cu==null)return super.apply(nu,ru);const pu=[],mu=[];if(lu!=null){const bu=lu.length;if(bu%2>0)throw new Ep("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");ru.initialState=lu,pu.push(...lu);const Cu=lu.map(wu=>new ty({shape:wu.shape}));this.forwardLayer.stateSpec=Cu.slice(0,bu/2),this.backwardLayer.stateSpec=Cu.slice(bu/2),mu.push(...Cu)}if(cu!=null)throw new e0("Support for constants in Bidirectional layers is not implemented yet.");const Au=pu[0]instanceof Hx;for(const bu of pu)if(bu instanceof Hx!==Au)throw new Ep("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(Au){const bu=[nu].concat(pu),Cu=this.inputSpec.concat(mu),wu=this.inputSpec;this.inputSpec=Cu;const Eu=super.apply(bu,ru);return this.inputSpec=wu,Eu}else return super.apply(nu,ru)}call(nu,ru){return Op(()=>{const lu=ru.initialState;let cu,hu;if(lu==null)cu=this.forwardLayer.call(nu,ru),hu=this.backwardLayer.call(nu,ru);else{const Au=lu.slice(0,lu.length/2),bu=lu.slice(lu.length/2);cu=this.forwardLayer.call(nu,Object.assign(ru,{initialState:Au})),hu=this.backwardLayer.call(nu,Object.assign(ru,{initialState:bu}))}let pu;this.returnState&&(Array.isArray(cu)&&(pu=cu.slice(1).concat(hu.slice(1))),cu=cu[0],hu=hu[0]),this.returnSequences&&(hu=u1(hu,1));let mu;return this.mergeMode==="concat"?mu=YI([cu,hu]):this.mergeMode==="sum"?mu=Am(cu,hu):this.mergeMode==="ave"?mu=_p(.5,Am(cu,hu)):this.mergeMode==="mul"?mu=_p(cu,hu):this.mergeMode==null&&(mu=[cu,hu]),this.returnState?this.mergeMode==null?mu.concat(pu):[mu].concat(pu):mu})}resetStates(nu){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(nu){A1(this.forwardLayer.name,()=>{this.forwardLayer.build(nu)}),A1(this.backwardLayer.name,()=>{this.backwardLayer.build(nu)}),this.built=!0}computeMask(nu,ru){Array.isArray(ru)&&(ru=ru[0]);let lu;if(this.returnSequences?this.mergeMode==null?lu=[ru,ru]:lu=ru:this.mergeMode==null?lu=[null,null]:lu=null,this.returnState){const cu=this.forwardLayer.states.map(hu=>null);return Array.isArray(lu)?lu.concat(cu).concat(cu):[lu].concat(cu).concat(cu)}else return lu}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(nu){super.setFastWeightInitDuringBuild(nu),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(nu),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(nu)}getConfig(){const nu={mergeMode:this.mergeMode},ru=super.getConfig();return Object.assign(nu,ru),nu}static fromConfig(nu,ru){const lu=cv(ru.layer);if(delete ru.layer,ru.numConstants!=null)throw new e0("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const cu=ru;return cu.layer=lu,new nu(cu)}}VN.className="Bidirectional",hm(VN);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class zN extends n0{constructor(nu){super(nu),this.scale=nu.scale,nu.offset?this.offset=nu.offset:this.offset=0}getConfig(){const nu={scale:this.scale,offset:this.offset},ru=super.getConfig();return Object.assign(nu,ru),nu}call(nu,ru){return Op(()=>(nu=jm(nu),nu.dtype!=="float32"&&(nu=lv(nu,"float32")),Am(_p(nu,this.scale),this.offset)))}}zN.className="Rescaling",hm(zN);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const{resizeBilinear:v4,cropAndResize:C4}=rv;class WN extends n0{constructor(nu){super(nu),this.height=nu.height,this.width=nu.width}centerCrop(nu,ru,lu,cu,hu,pu,mu,Au){return Op(()=>{let bu,Cu=!1;const wu=ru/pu,Eu=lu/mu,Tu=(cu+ru)/pu,Ru=(hu+lu)/mu,Nu=[wu,Eu,Tu,Ru],Pu=[];nu.rank===3?(Cu=!0,bu=Ux([nu])):bu=nu;for(let Qu=0;Qu<bu.shape[0];Qu++)Pu.push(Nu);const Fu=Ky(Pu,[Pu.length,4]),Gu=hw(0,Pu.length,1,"int32"),Xu=C4(bu,Fu,Gu,[cu,hu],"nearest");return lv(Cu?jm(d1(Xu)):Xu,Au)})}upsize(nu,ru,lu,cu){return Op(()=>{const hu=v4(nu,[ru,lu]);return lv(hu,cu)})}call(nu,ru){return Op(()=>{const lu=jm(nu),cu=lu.dtype,hu=lu.shape,pu=hu[hu.length-3],mu=hu[hu.length-2];let Au=0;pu!==this.height&&(Au=Math.floor((pu-this.height)/2));let bu=0;return mu!==this.width&&(bu=Math.floor((mu-this.width)/2),bu===0&&(bu=1)),Au>=0&&bu>=0?this.centerCrop(lu,Au,bu,this.height,this.width,pu,mu,cu):this.upsize(nu,this.height,this.width,cu)})}getConfig(){const nu={height:this.height,width:this.width},ru=super.getConfig();return Object.assign(nu,ru),nu}computeOutputShape(nu){nu=p0(nu);const ru=nu.length-3,lu=nu.length-2;return nu[ru]=this.height,nu[lu]=this.width,nu}}WN.className="CenterCrop",hm(WN);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function w4(ou,nu,ru,lu){let cu=jm(ou);if(cu.dtype!=="int32"&&(cu=lv(cu,"int32")),nu==="int")return cu;const hu=cu.shape;if(cu.rank===0&&(cu=Ly(cu,-1)),nu==="oneHot"&&cu.shape[cu.shape.length-1]!==1&&(cu=Ly(cu,-1)),cu.rank>2)throw new Ep(`When outputMode is not int, maximum output rank is 2 Received outputMode ${nu} and input shape ${hu} which would result in output rank ${cu.rank}.`);const pu=["multiHot","oneHot"].includes(nu),mu=cu;let Au;if(typeof lu<"u"&&nu==="count"?Au=VM(mu,lu,ru,pu):Au=VM(mu,[],ru,pu),nu!=="tfIdf")return Au;if(lu)return _p(Au,lu);throw new Ep("When outputMode is 'tfIdf', weights must be provided.")}/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class HN extends n0{constructor(nu){super(nu),this.numTokens=nu.numTokens,nu.outputMode?this.outputMode=nu.outputMode:this.outputMode="multiHot"}getConfig(){const nu={numTokens:this.numTokens,outputMode:this.outputMode},ru=super.getConfig();return Object.assign(nu,ru),nu}computeOutputShape(nu){return nu=p0(nu),nu==null?[this.numTokens]:this.outputMode==="oneHot"&&nu[nu.length-1]!==1?(nu.push(this.numTokens),nu):(nu[nu.length-1]=this.numTokens,nu)}call(nu,ru){return Op(()=>{nu=jm(nu),nu.dtype!=="int32"&&(nu=lv(nu,"int32"));let lu;if(typeof ru.countWeights<"u"){if(this.outputMode!=="count")throw new Ep(`countWeights is not used when outputMode !== count.
              Received countWeights=${ru.countWeights}`);lu=jm(ru.countWeights)}const cu=vx(nu),hu=OE(nu),pu=Yy(this.numTokens,cu).bufferSync().get(0),mu=a1(hu,0).bufferSync().get(0);if(!(pu&&mu))throw new Ep(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return w4(nu,this.outputMode,this.numTokens,lu)})}}HN.className="CategoryEncoding",hm(HN);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const E4=["bilinear","nearest"],XN=new Set(E4);class QN extends n0{constructor(nu){if(super(nu),this.height=nu.height,this.width=nu.width,nu.interpolation)if(XN.has(nu.interpolation))this.interpolation=nu.interpolation;else throw new Ep(`Invalid interpolation parameter: ${nu.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!nu.cropToAspectRatio}computeOutputShape(nu){nu=p0(nu);const ru=nu[2];return[this.height,this.width,ru]}getConfig(){const nu={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},ru=super.getConfig();return Object.assign(nu,ru),nu}call(nu,ru){return Op(()=>{const lu=[this.height,this.width];if(this.interpolation==="bilinear")return rv.resizeBilinear(nu,lu,!this.cropToAspectRatio);if(this.interpolation==="nearest")return rv.resizeNearestNeighbor(nu,lu,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...XN]} are supported`)})}}QN.className="Resizing",hm(QN);/**
* @license
* Copyright 2023 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class KN{constructor(nu){this.seed=nu}next(){if(this.seed!==void 0)return this.seed++}}KN.className="RandomSeed";/**
* @license
* Copyright 2023 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class ZN extends n0{constructor(nu){super(nu),this.randomGenerator=new KN(nu.seed)}getConfig(){const nu={seed:this.randomGenerator.seed},ru=super.getConfig();return Object.assign(nu,ru),nu}}ZN.className="BaseRandomLayer";/**
* @license
* Copyright 2023 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const S4=["bilinear","nearest"],jN=new Set(S4);class YN extends ZN{constructor(nu){super(nu);const{factor:ru,interpolation:lu="bilinear"}=nu;if(this.factor=ru,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Ep(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Ep(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Ep(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(lu)if(jN.has(lu))this.interpolation=lu;else throw new Ep(`Invalid interpolation parameter: ${lu} is not implemented`)}getConfig(){const nu={factor:this.factor,interpolation:this.interpolation},ru=super.getConfig();return Object.assign(nu,ru),nu}computeOutputShape(nu){nu=p0(nu);const ru=nu[2];return[this.imgHeight,-1,ru]}call(nu,ru){return Op(()=>{const lu=jm(nu);this.imgHeight=lu.shape[lu.shape.length-3];const cu=lu.shape[lu.shape.length-2];this.widthFactor=uw([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let hu=this.widthFactor.dataSync()[0]*cu;hu=Math.round(hu);const pu=[this.imgHeight,hu];switch(this.interpolation){case"bilinear":return rv.resizeBilinear(nu,pu);case"nearest":return rv.resizeNearestNeighbor(nu,pu);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...jN]} are supported`)}})}}YN.className="RandomWidth",hm(YN);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/cp().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,ou=>{ou&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/var qN;(function(ou){ou[ou.DT_INVALID=0]="DT_INVALID",ou[ou.DT_FLOAT=1]="DT_FLOAT",ou[ou.DT_DOUBLE=2]="DT_DOUBLE",ou[ou.DT_INT32=3]="DT_INT32",ou[ou.DT_UINT8=4]="DT_UINT8",ou[ou.DT_INT16=5]="DT_INT16",ou[ou.DT_INT8=6]="DT_INT8",ou[ou.DT_STRING=7]="DT_STRING",ou[ou.DT_COMPLEX64=8]="DT_COMPLEX64",ou[ou.DT_INT64=9]="DT_INT64",ou[ou.DT_BOOL=10]="DT_BOOL",ou[ou.DT_QINT8=11]="DT_QINT8",ou[ou.DT_QUINT8=12]="DT_QUINT8",ou[ou.DT_QINT32=13]="DT_QINT32",ou[ou.DT_BFLOAT16=14]="DT_BFLOAT16",ou[ou.DT_QINT16=15]="DT_QINT16",ou[ou.DT_QUINT16=16]="DT_QUINT16",ou[ou.DT_UINT16=17]="DT_UINT16",ou[ou.DT_COMPLEX128=18]="DT_COMPLEX128",ou[ou.DT_HALF=19]="DT_HALF",ou[ou.DT_RESOURCE=20]="DT_RESOURCE",ou[ou.DT_VARIANT=21]="DT_VARIANT",ou[ou.DT_UINT32=22]="DT_UINT32",ou[ou.DT_UINT64=23]="DT_UINT64",ou[ou.DT_FLOAT_REF=101]="DT_FLOAT_REF",ou[ou.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",ou[ou.DT_INT32_REF=103]="DT_INT32_REF",ou[ou.DT_UINT8_REF=104]="DT_UINT8_REF",ou[ou.DT_INT16_REF=105]="DT_INT16_REF",ou[ou.DT_INT8_REF=106]="DT_INT8_REF",ou[ou.DT_STRING_REF=107]="DT_STRING_REF",ou[ou.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",ou[ou.DT_INT64_REF=109]="DT_INT64_REF",ou[ou.DT_BOOL_REF=110]="DT_BOOL_REF",ou[ou.DT_QINT8_REF=111]="DT_QINT8_REF",ou[ou.DT_QUINT8_REF=112]="DT_QUINT8_REF",ou[ou.DT_QINT32_REF=113]="DT_QINT32_REF",ou[ou.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",ou[ou.DT_QINT16_REF=115]="DT_QINT16_REF",ou[ou.DT_QUINT16_REF=116]="DT_QUINT16_REF",ou[ou.DT_UINT16_REF=117]="DT_UINT16_REF",ou[ou.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",ou[ou.DT_HALF_REF=119]="DT_HALF_REF",ou[ou.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",ou[ou.DT_VARIANT_REF=121]="DT_VARIANT_REF",ou[ou.DT_UINT32_REF=122]="DT_UINT32_REF",ou[ou.DT_UINT64_REF=123]="DT_UINT64_REF"})(qN||(qN={}));var JN;(function(ou){(function(nu){nu[nu.LEGACY=0]="LEGACY",nu[nu.V1=1]="V1",nu[nu.V2=2]="V2"})(ou.CheckpointFormatVersion||(ou.CheckpointFormatVersion={}))})(JN||(JN={}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/var e3;(function(ou){ou[ou.FAIL=0]="FAIL",ou[ou.SHORTEST=1]="SHORTEST",ou[ou.LONGEST=2]="LONGEST"})(e3||(e3={}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pm(ou,nu){Array.isArray(ou)||(ou=[ou]),ou.forEach(ru=>{ru!=null&&vu(ru.dtype!=="complex64",()=>`${nu} does not support complex64 tensors in the CPU backend.`)})}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const I4=AR;class x2 extends au{nextDataId(){return x2.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new su(this,w0())}write(nu,ru,lu){this.firstUse&&(this.firstUse=!1,cp().get("IS_NODE")&&Xy(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const cu={id:this.nextDataId()};return this.data.set(cu,{values:nu,dtype:lu,refCount:1}),cu}makeTensorInfo(nu,ru,lu){let cu;if(ru==="string"&&lu!=null&&lu.length>0&&Cp(lu[0])){const hu=lu.map(pu=>bv(pu));cu=this.write(hu,nu,ru)}else cu=this.write(lu,nu,ru);return{dataId:cu,shape:nu,dtype:ru}}refCount(nu){return this.data.has(nu)?this.data.get(nu).refCount:0}incRef(nu){const ru=this.data.get(nu);ru.refCount++}decRef(nu){if(this.data.has(nu)){const ru=this.data.get(nu);ru.refCount--}}move(nu,ru,lu,cu,hu){this.data.set(nu,{values:ru,dtype:cu,refCount:hu})}numDataIds(){return this.data.numDataIds()}async read(nu){return this.readSync(nu)}readSync(nu){const{dtype:ru,complexTensorInfos:lu}=this.data.get(nu);if(ru==="complex64"){const cu=this.readSync(lu.real.dataId),hu=this.readSync(lu.imag.dataId);return sv(cu,hu)}return vp(this.data.get(nu).values,ru)}bufferSync(nu){const ru=this.readSync(nu.dataId);if(nu.dtype==="string")try{const lu=ru.map(cu=>xv(cu));return t0(nu.shape,nu.dtype,lu)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return t0(nu.shape,nu.dtype,ru)}makeOutput(nu,ru,lu){return w0().makeTensorFromTensorInfo(this.makeTensorInfo(ru,lu,nu),this)}disposeData(nu,ru=!1){if(this.data.has(nu)){if(this.data.get(nu).refCount--,!ru&&this.data.get(nu).refCount>0)return!1;const{complexTensorInfos:lu}=this.data.get(nu);lu!=null&&(this.disposeData(lu.real.dataId,!0),this.disposeData(lu.imag.dataId,!0)),this.data.delete(nu)}return!0}disposeIntermediateTensorInfo(nu){this.disposeData(nu.dataId)}async time(nu){const ru=My();return nu(),{kernelMs:My()-ru}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(nu){Pm([nu],"where");const ru=this.readSync(nu.dataId);return I4(nu.shape,ru)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}x2.nextDataId=0;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t3(ou){const nu=new Float32Array(ou.length);for(let ru=0;ru<ou.length;++ru)nu[ru]=Math.abs(ou[ru]);return nu}const T4={kernelName:Lp,backendName:"cpu",kernelFunc:ou=>{const{x:nu}=ou.inputs,ru=ou.backend;Pm(nu,"abs");let lu=new Float32Array(Mu(nu.shape));const cu=ru.data.get(nu.dataId).values;return lu=t3(cu),ru.makeOutput(lu,nu.shape,nu.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function K0(ou){return(nu,ru,lu,cu,hu)=>{const pu=_g(nu,ru),mu=pu.length,Au=xp(pu),bu=Mu(pu),Cu=Hu(hu,bu),wu=nu.length,Eu=ru.length,Tu=xp(nu),Ru=xp(ru),Nu=K1(nu,pu),Pu=K1(ru,pu);if(Nu.length+Pu.length===0)for(let Fu=0;Fu<Cu.length;++Fu)Cu[Fu]=ou(lu[Fu%lu.length],cu[Fu%cu.length]);else for(let Fu=0;Fu<Cu.length;++Fu){const Gu=Qp(Fu,mu,Au),Xu=Gu.slice(-wu);Nu.forEach(rp=>Xu[rp]=0);const Qu=Bp(Xu,wu,Tu),Ju=Gu.slice(-Eu);Pu.forEach(rp=>Ju[rp]=0);const ip=Bp(Ju,Eu,Ru);Cu[Fu]=ou(lu[Qu],cu[ip])}return[Cu,pu]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zy(ou){const{inputs:nu,backend:ru}=ou,{real:lu,imag:cu}=nu,hu=ru.data.get(lu.dataId).values,pu=ru.data.get(cu.dataId).values,mu=ru.makeTensorInfo(lu.shape,"complex64"),Au=ru.data.get(mu.dataId);return Au.complexTensorInfos={real:ru.makeTensorInfo(lu.shape,"float32",hu),imag:ru.makeTensorInfo(cu.shape,"float32",pu)},mu}const _4={kernelName:$0,backendName:"cpu",kernelFunc:zy};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v2(ou,nu,ru="float32"){if(ru==="complex64"){const cu=v2(ou,nu,"float32"),hu=v2(ou,nu,"float32");return zy({inputs:{real:cu,imag:hu},backend:ou})}const lu=kp(Mu(nu),ru);return ou.makeTensorInfo(nu,ru,lu)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Qx(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;return ru.incRef(lu.dataId),{dataId:lu.dataId,shape:lu.shape,dtype:lu.dtype}}const M4={kernelName:Hy,backendName:"cpu",kernelFunc:Qx};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v1(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu,cu=ru.data.get(lu.dataId).complexTensorInfos.real,hu=ru.data.get(cu.dataId).values;return ru.makeTensorInfo(cu.shape,cu.dtype,hu)}const R4={kernelName:oS,backendName:"cpu",kernelFunc:v1};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n3(ou,nu,ru,lu){if(lu==="int32"){const cu=Int32Array.from(ou);return[nu,"int32",cu]}if(lu==="bool"){const cu=qv([0],ru),[hu,pu]=K0((mu,Au)=>mu!==Au?1:0)(nu,[],ou,cu,"bool");return[pu,"bool",hu]}throw new Error(`Error in Cast: failed to cast ${ru} to ${lu}`)}function Fv(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{dtype:hu}=lu;if(hu==="complex64"){if(cu.dtype==="complex64")return Qx({inputs:{x:cu},backend:ru});const Cu=v2(ru,cu.shape,cu.dtype),wu=Fv({inputs:{x:cu},backend:ru,attrs:{dtype:"float32"}}),Eu=zy({inputs:{real:wu,imag:Cu},backend:ru});return ru.disposeIntermediateTensorInfo(Cu),ru.disposeIntermediateTensorInfo(wu),Eu}if(cu.dtype==="complex64"){const Cu=v1({inputs:{input:cu},backend:ru}),wu=Fv({inputs:{x:Cu},backend:ru,attrs:{dtype:hu}});return ru.disposeIntermediateTensorInfo(Cu),wu}if(!tp(cu.dtype,hu)){const Cu=Qx({inputs:{x:cu},backend:ru});return{dataId:Cu.dataId,shape:Cu.shape,dtype:hu}}const pu=ru.data.get(cu.dataId).values,[mu,Au,bu]=n3(pu,cu.shape,cu.dtype,hu);return ru.makeTensorInfo(mu,Au,bu)}const k4={kernelName:Sm,backendName:"cpu",kernelFunc:Fv};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ry(ou,nu,ru,lu){return ru==null?({inputs:cu,backend:hu})=>{const{a:pu,b:mu}=cu,Au=hu;Pm([pu,mu],ou);const bu=Au.data.get(pu.dataId).values,Cu=Au.data.get(mu.dataId).values,wu=pu.dtype==="string"?ov(bu):bu,Eu=pu.dtype==="string"?ov(Cu):Cu,Tu=lu||pu.dtype,[Ru,Nu]=nu(pu.shape,mu.shape,wu,Eu,Tu);return Au.makeTensorInfo(Nu,Tu,Ru)}:({inputs:cu,backend:hu})=>{const{a:pu,b:mu}=cu,Au=hu;if(pu.dtype==="complex64"||mu.dtype==="complex64"){const bu=Fv({inputs:{x:pu},backend:Au,attrs:{dtype:"complex64"}}),Cu=Au.data.get(bu.dataId),wu=Cu.complexTensorInfos.real,Eu=Cu.complexTensorInfos.imag,Tu=Au.data.get(wu.dataId).values,Ru=Au.data.get(Eu.dataId).values,Nu=Fv({inputs:{x:mu},backend:Au,attrs:{dtype:"complex64"}}),Pu=Au.data.get(Nu.dataId),Fu=Pu.complexTensorInfos.real,Gu=Pu.complexTensorInfos.imag,Xu=Au.data.get(Fu.dataId).values,Qu=Au.data.get(Gu.dataId).values,[Ju,ip,rp]=ru(pu.shape,mu.shape,Tu,Ru,Xu,Qu),op=Au.makeTensorInfo(rp,"float32",Ju),hp=Au.makeTensorInfo(rp,"float32",ip),Ap=zy({inputs:{real:op,imag:hp},backend:Au});return Au.disposeIntermediateTensorInfo(bu),Au.disposeIntermediateTensorInfo(Nu),Au.disposeIntermediateTensorInfo(op),Au.disposeIntermediateTensorInfo(hp),Ap}else{const bu=Au.data.get(pu.dataId).values,Cu=Au.data.get(mu.dataId).values,wu=lu||pu.dtype,[Eu,Tu]=nu(pu.shape,mu.shape,bu,Cu,wu);return Au.makeTensorInfo(Tu,wu,Eu)}}}function MT(ou){return(nu,ru,lu,cu,hu,pu)=>{const mu=_g(nu,ru),Au=Mu(mu),bu=mu.length,Cu=xp(mu),wu=Hu("float32",Au),Eu=Hu("float32",Au),Tu=K1(nu,mu),Ru=K1(ru,mu),Nu=sv(lu,cu),Pu=sv(hu,pu),Fu=nu.length,Gu=xp(nu),Xu=ru.length,Qu=xp(ru);if(Tu.length+Ru.length===0)for(let Ju=0;Ju<wu.length;Ju++){const ip=Ju%Nu.length,rp=Ju%Pu.length,op=ou(Nu[ip*2],Nu[ip*2+1],Pu[rp*2],Pu[rp*2+1]);wu[Ju]=op.real,Eu[Ju]=op.imag}else for(let Ju=0;Ju<wu.length;Ju++){const ip=Qp(Ju,bu,Cu),rp=ip.slice(-Fu);Tu.forEach(Vp=>rp[Vp]=0);const op=Bp(rp,Fu,Gu),hp=ip.slice(-Xu);Ru.forEach(Vp=>hp[Vp]=0);const Ap=Bp(hp,Xu,Qu),Up=ou(Nu[op*2],Nu[op*2+1],Pu[Ap*2],Pu[Ap*2+1]);wu[Ju]=Up.real,Eu[Ju]=Up.imag}return[wu,Eu,mu]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const i3=K0((ou,nu)=>ou+nu),B4=MT((ou,nu,ru,lu)=>({real:ou+ru,imag:nu+lu})),oC=ry(sp,i3,B4),L4={kernelName:sp,backendName:"cpu",kernelFunc:oC};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RT(ou,nu,ru,lu,cu){const hu=Mu(lu),pu=kp(cu,ru);for(let mu=0;mu<ou.length;mu++){const Au=ou[mu];if(Au<0)throw new Error("Input x must be non-negative!");Au>=cu||(hu>0?pu[Au]+=nu[mu]:pu[Au]+=1)}return pu}function r3(ou,nu,ru,lu=!1){const cu=ou.shape[0],hu=ou.shape[1],pu=t0([cu,ru],nu.dtype);for(let mu=0;mu<cu;mu++)for(let Au=0;Au<hu;Au++){const bu=ou.get(mu,Au);if(bu<0)throw new Error("Input x must be non-negative!");bu>=ru||(lu?pu.set(1,mu,bu):nu.size>0?pu.set(pu.get(mu,bu)+nu.get(mu,Au),mu,bu):pu.set(pu.get(mu,bu)+1,mu,bu))}return pu}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s3=K0((ou,nu)=>ou&nu),N4=ry(Lm,s3),D4={kernelName:Lm,backendName:"cpu",kernelFunc:N4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kx(ou){return(nu,ru,lu)=>{const cu=Yu(ru,nu.length);for(let hu=0;hu<nu.length;++hu)cu[hu]=ou(nu[hu],lu);return cu}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b0(ou,nu,ru){const lu=Kx(nu);return Pv(ou,lu,ru)}function Pv(ou,nu,ru){return({inputs:lu,attrs:cu,backend:hu})=>{const{x:pu}=lu;Pm(pu,ou);const mu=hu,Au=mu.data.get(pu.dataId).values;let bu;if(pu.dtype==="string"){if(!Array.isArray(Au))throw new Error("String tensor's value was not an instance of Array");bu=ov(Au)}else bu=Au;const Cu=ru||pu.dtype,wu=nu(bu,Cu,cu);return mu.makeTensorInfo(pu.shape,Cu,wu)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const o3=Kx(ou=>Math.ceil(ou)),F4=Pv(Fm,o3),P4={kernelName:Fm,backendName:"cpu",kernelFunc:F4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function a3(ou,nu,ru,lu){const cu=Yu(ru,Mu(nu));if(lu&&ru!=="string"){let hu=0;ou.forEach(pu=>{const mu=Mu(pu.shape);cu.set(pu.vals,hu),hu+=mu})}else{let hu=0;ou.forEach(pu=>{const mu=ru==="string"?ov(pu.vals):pu.vals;let Au=0;for(let bu=0;bu<pu.shape[0];++bu){const Cu=bu*nu[1]+hu;for(let wu=0;wu<pu.shape[1];++wu)cu[Cu+wu]=mu[Au++]}hu+=pu.shape[1]})}return cu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const l3=K0((ou,nu)=>ou===nu?1:0),c3=ry(Km,l3,null,"bool"),G4={kernelName:Km,backendName:"cpu",kernelFunc:c3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const u3=Kx(ou=>Math.exp(ou)),h3=Pv(Zm,u3,"float32"),O4={kernelName:Zm,backendName:"cpu",kernelFunc:h3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const d3=Kx(ou=>Math.expm1(ou)),U4=Pv(r0,d3),$4={kernelName:r0,backendName:"cpu",kernelFunc:U4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const p3=Kx(ou=>Math.floor(ou)),V4=Pv(s0,p3),z4={kernelName:s0,backendName:"cpu",kernelFunc:V4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f3=K0((ou,nu)=>Math.floor(ou/nu)),W4=ry(z0,f3,null,"int32"),H4={kernelName:z0,backendName:"cpu",kernelFunc:W4};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function m3(ou,nu,ru,lu,cu,hu,pu,mu,Au){const bu=t0([lu,hu],ru);for(let Cu=0;Cu<lu;Cu++){const wu=[];let Eu=0;for(let Tu=0;Tu<cu;Tu++){const Ru=ou[Cu*cu+Tu];Eu+=Ru*pu[Tu],wu.push(Ru)}if(Eu<0||Eu>=Au/hu)throw new Error(`Invalid indices: ${wu} does not index into ${mu}`);for(let Tu=0;Tu<hu;Tu++)bu.values[Cu*hu+Tu]=nu.get(...nu.indexToLoc(Eu*hu+Tu))}return bu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g3(ou,nu,ru){const lu=t0(ru,ou.dtype);for(let cu=0;cu<lu.size;++cu){const hu=lu.indexToLoc(cu).slice(),pu=hu[0],mu=hu[2],Au=nu.locToIndex([pu,mu]);hu[2]=nu.values[Au];const bu=ou.locToIndex(hu);0<=bu&&bu<ou.values.length&&(lu.values[cu]=ou.values[bu])}return lu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const A3=K0((ou,nu)=>ou>nu?1:0),X4=ry(cy,A3,null,"bool"),Q4={kernelName:cy,backendName:"cpu",kernelFunc:X4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const y3=K0((ou,nu)=>ou>=nu?1:0),K4=ry(yy,y3,null,"bool"),Z4={kernelName:yy,backendName:"cpu",kernelFunc:K4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const b3=K0((ou,nu)=>ou<nu?1:0),j4=ry(yx,b3,null,"bool"),Y4={kernelName:yx,backendName:"cpu",kernelFunc:j4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const x3=K0((ou,nu)=>ou<=nu?1:0),q4=ry(Xv,x3,null,"bool"),J4={kernelName:Xv,backendName:"cpu",kernelFunc:q4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v3(ou,nu,ru){const lu=(nu-ou)/(ru-1),cu=kp(ru,"float32");cu[0]=ou;for(let hu=1;hu<cu.length;hu++)cu[hu]=cu[hu-1]+lu;return cu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const C3=Kx(ou=>Math.log(ou)),eX=Pv(IC,C3),tX={kernelName:IC,backendName:"cpu",kernelFunc:eX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w3(ou,nu,ru,lu){const cu=Hu(lu,Mu(ru));for(let hu=0;hu<cu.length;++hu){const pu=hu*nu;let mu=ou[pu];for(let Au=0;Au<nu;++Au){const bu=ou[pu+Au];(Number.isNaN(bu)||bu>mu)&&(mu=bu)}cu[hu]=mu}return cu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const E3=K0((ou,nu)=>Math.max(ou,nu)),nX=ry(_C,E3),iX={kernelName:_C,backendName:"cpu",kernelFunc:nX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S3=K0((ou,nu)=>Math.min(ou,nu)),rX=ry(MC,S3),sX={kernelName:MC,backendName:"cpu",kernelFunc:rX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kT=K0((ou,nu)=>ou*nu),oX=MT((ou,nu,ru,lu)=>({real:ou*ru-nu*lu,imag:ou*lu+nu*ru})),C2=ry(kC,kT,oX),aX={kernelName:kC,backendName:"cpu",kernelFunc:C2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I3(ou,nu,ru){const lu=yv(-1,ru);return kT([],nu,lu,ou,ru)}function lX(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;Pm(lu,"neg");const cu=ru.data.get(lu.dataId).values,[hu,pu]=I3(cu,lu.shape,lu.dtype);return ru.makeTensorInfo(pu,lu.dtype,hu)}const cX={kernelName:aE,backendName:"cpu",kernelFunc:lX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const T3=K0((ou,nu)=>ou!==nu?1:0),uX=ry(lE,T3,null,"bool"),hX={kernelName:lE,backendName:"cpu",kernelFunc:uX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BT(ou,nu,ru,lu,cu){const hu=nu.length,pu=Mu(nu),mu=xp(nu),Au=xp(cu),bu=Hu(ru,Mu(cu));for(let Cu=0;Cu<pu;++Cu){const wu=Qp(Cu,hu,mu),Eu=new Array(wu.length);for(let Ru=0;Ru<Eu.length;Ru++)Eu[Ru]=wu[lu[Ru]];const Tu=Bp(Eu,hu,Au);bu[Tu]=ou[Cu]}return bu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fy(ou){const{inputs:nu,attrs:ru,backend:lu}=ou,{x:cu}=nu,{perm:hu}=ru;Pm(cu,"transpose");const pu=cu.shape.length,mu=new Array(pu);for(let Cu=0;Cu<mu.length;Cu++)mu[Cu]=cu.shape[hu[Cu]];const Au=lu.data.get(cu.dataId).values,bu=BT(Au,cu.shape,cu.dtype,hu,mu);return{dataId:lu.write(bu,mu,cu.dtype),shape:mu,dtype:cu.dtype}}const dX={kernelName:G1,backendName:"cpu",kernelFunc:Fy};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _3(ou,nu,ru,lu){const[cu,hu]=oy(ou,lu),pu=Uy(nu,"int32"),mu=kp(Mu(cu),pu),Au=Mu(hu);for(let bu=0;bu<mu.length;++bu){const Cu=bu*Au;let wu=1;for(let Eu=0;Eu<Au;++Eu)wu*=ru[Cu+Eu];mu[bu]=wu}return{outVals:mu,outShape:cu,outDtype:pu}}function pX(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu;Pm(cu,"prod");const mu=cu.shape.length,Au=Wu(hu,cu.shape),bu=G0(Au,mu);let Cu=Au,wu=cu;const Eu=[];bu!=null&&(wu=Fy({inputs:{x:cu},backend:ru,attrs:{perm:bu}}),Eu.push(wu),Cu=H0(Cu.length,mu));const Tu=ru.data.get(wu.dataId).values,{outVals:Ru,outShape:Nu,outDtype:Pu}=_3(wu.shape,wu.dtype,Tu,Cu);let Fu=Nu;return pu&&(Fu=j0(Nu,Au)),Eu.forEach(Gu=>ru.disposeIntermediateTensorInfo(Gu)),ru.makeTensorInfo(Fu,Pu,Ru)}const fX={kernelName:fE,backendName:"cpu",kernelFunc:pX};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mX(ou,nu,ru){ou.forEach((lu,cu)=>{if(lu<0||lu>=ru){const hu=Qp(cu,nu.length,xp(nu)).join(",");throw new Error(`indices[${hu}] = ${lu} is not in [0, ${ru})`)}})}function gX(ou,nu){for(let ru=0;ru<ou.length;++ru){const lu=ou[ru],cu=ru===ou.length-1?nu:ou[ru+1].length;if(lu.length===0)throw new Error("Ragged splits may not be empty");if(lu[0]<0)throw new Error("Ragged splits must be non-negative");if(lu[lu.length-1]>cu)throw new Error("Ragged splits must not point past values");for(let hu=1;hu<lu.length;++hu)if(lu[hu-1]>lu[hu])throw new Error("Ragged splits must be sorted in ascending order")}}function AX(ou,nu,ru,lu){const cu=[];let hu=0;const pu=nu.length-1+ru.length,mu=new Array(pu).fill(null).map(()=>[0]);gX(ru,lu);let Au=1;for(let bu=0;bu<nu.length-1;++bu){Au*=nu[bu];const Cu=nu[bu+1];for(let wu=1;wu<Au+1;++wu)mu[bu].push(wu*Cu)}for(let bu=0;bu<ou.length;++bu){let Cu=ou[bu],wu=ou[bu]+1;for(let Eu=0;Eu<ru.length;++Eu){const Tu=ru[Eu],Ru=Eu+nu.length-1;if(Ru>=0){const Nu=mu[Ru],Pu=Nu[Nu.length-1]-Tu[Cu];for(let Fu=Cu;Fu<wu;++Fu)mu[Ru].push(Tu[Fu+1]+Pu)}Cu=Tu[Cu],wu=Tu[wu]}wu!==Cu&&(cu.push([Cu,wu]),hu+=wu-Cu)}return{outSplits:mu,valueSlices:cu,numValues:hu}}function yX(ou){const nu=[];for(let ru=0;ru<ou.length;++ru){const lu=ou[ru].length,cu=Yu("int32",lu);nu.push(cu),ou[ru].forEach((hu,pu)=>cu[pu]=hu)}return nu}function M3(ou,nu){const ru=ou.slice(0,nu);for(;ru.length<nu;)ru.push(1);for(let lu=nu;lu<ou.length;lu++)ru[nu-1]*=ou[lu];return ru}function bX(ou,nu,ru,lu,cu,hu){const pu=M3(nu,2)[1],mu=M3(hu,2)[1];let Au=0;for(const bu of ru)for(let Cu=bu[0];Cu<bu[1];++Cu){for(let wu=0;wu<lu;++wu)cu[Au*mu+wu]=ou[Cu*pu+wu];++Au}}function xX(ou,nu,ru,lu,cu){const hu=nu.slice();hu[0]=cu;const pu=Yu(ru,Mu(hu)),mu=ou.length,Au=mu===0?0:mu/nu[0];return bX(ou,nu,lu,Au,pu,hu),[pu,hu]}function R3(ou,nu,ru,lu,cu,hu,pu,mu){if(ou.length===0)throw new Error("paramsNestedSplits must be non empty");if(nu[0].length===0)throw new Error("Split tensors must not be scalars");const Au=nu[0][0]-1;if(mX(hu,pu,Au),lu.length===0)throw new Error("params.rank must be nonzero");const bu=lu[0],{outSplits:Cu,valueSlices:wu,numValues:Eu}=AX(hu,pu,ou,bu),Tu=yX(Cu),Ru=xX(ru,lu,cu,wu,Eu);return[Tu,Ru[0],Ru[1]]}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const k3=2147483647;function B3(ou,nu,ru,lu,cu,hu,pu){if(nu.length>1)throw new Error("starts must be a scalar or vector");if(cu.length>1)throw new Error("limits must be a scalar or vector");if(pu.length>1)throw new Error("deltas must be a scalar or vector");const mu=nu.length===0,Au=cu.length===0,bu=pu.length===0,Cu=[];mu||Cu.push(nu[0]),Au||Cu.push(cu[0]),bu||Cu.push(pu[0]);for(let Pu=1;Pu<Cu.length;++Pu)if(Cu[Pu]!==Cu[Pu-1])throw new Error("starts, limits, and deltas must have the same shape");const wu=Cu.length===0?1:Cu[0],Eu=Yu("int32",wu+1);Eu[0]=0;for(let Pu=0;Pu<wu;++Pu){const Fu=mu?ou[0]:ou[Pu],Gu=Au?lu[0]:lu[Pu],Xu=bu?hu[0]:hu[Pu];if(Xu===0)throw new Error("Requires delta != 0");let Qu;if(Xu>0&&Gu<Fu||Xu<0&&Gu>Fu)Qu=0;else if(Qu=Math.ceil(Math.abs((Gu-Fu)/Xu)),Qu>k3)throw new Error(`Requires ((limit - start) / delta) <= ${k3}`);Eu[Pu+1]=Eu[Pu]+Qu}const Tu=Eu[wu],Ru=Yu(ru,Tu);let Nu=0;for(let Pu=0;Pu<wu;++Pu){const Fu=Eu[Pu+1]-Eu[Pu];let Gu=mu?ou[0]:ou[Pu];const Xu=bu?hu[0]:hu[Pu];for(let Qu=0;Qu<Fu;++Qu)Ru[Nu++]=Gu,Gu+=Xu}return[Eu,Ru]}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var fx=wx;class w2{constructor(nu,ru,lu,cu,hu,pu,mu,Au,bu,Cu){this.shape=nu,this.shapeShape=ru,this.values=lu,this.valuesShape=cu,this.valuesDType=hu,this.defaultValue=pu,this.defaultValueShape=mu,this.rowPartitionValues=Au,this.rowPartitionValuesShapes=bu,this.rowPartitionTypes=OR(Cu),this.raggedRank=UR(this.rowPartitionTypes)}getRowPartitionTypeByDimension(nu){return this.rowPartitionTypes[0]===fx.FIRST_DIM_SIZE?this.rowPartitionTypes[nu+1]:this.rowPartitionTypes[nu]}getRowPartitionTensor(nu){return this.rowPartitionTypes[0]===fx.FIRST_DIM_SIZE?this.rowPartitionValues[nu+1]:this.rowPartitionValues[nu]}getMaxWidth(nu){const ru=this.getRowPartitionTensor(nu-1);switch(this.getRowPartitionTypeByDimension(nu-1)){case fx.VALUE_ROWIDS:return w2.getMaxWidthValueRowID(ru);case fx.ROW_SPLITS:return w2.getMaxWidthRowSplit(ru);default:throw new Error(`Cannot handle partition type ${fx[this.getRowPartitionTypeByDimension(nu-1)]}`)}}static getMaxWidthRowSplit(nu){const ru=nu.length;if(ru===0||ru===1)return 0;let lu=0;for(let cu=0;cu<ru-1;++cu){const hu=nu[cu+1]-nu[cu];hu>lu&&(lu=hu)}return lu}static getMaxWidthValueRowID(nu){const ru=nu.length;if(ru===0)return 0;let lu=0,cu=nu[0],hu=0;for(let pu=1;pu<ru;++pu){const mu=nu[pu];mu!==cu&&(cu=mu,hu=Math.max(pu-lu,hu),lu=pu)}return Math.max(ru-lu,hu)}tensorShapeFromTensor(nu,ru,lu=!0){if(ru.length===0){if(nu[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return N3(nu,lu)}calculateOutputSize(nu){const ru=this.valuesShape,lu=this.defaultValueShape;$R(lu,ru);const cu=this.tensorShapeFromTensor(this.shape,this.shapeShape),hu=GR(this.raggedRank,cu,ru);hu[0]<0&&(hu[0]=nu);for(let pu=1;pu<=this.raggedRank;++pu)hu[pu]<0&&(hu[pu]=this.getMaxWidth(pu));return hu}calculateFirstParentOutputIndex(nu,ru,lu){const cu=Math.min(nu,lu),hu=[];let pu=0;for(let mu=0;mu<cu;++mu,pu+=ru)hu.push(pu);for(let mu=cu;mu<nu;++mu)hu.push(-1);return vu(hu.length===nu,()=>"Final length of result must be equal to firstDimension."),hu}calculateOutputIndexRowSplit(nu,ru,lu,cu){const hu=nu.length,pu=[];for(let mu=0;mu<hu-1;++mu){const Au=nu[mu+1]-nu[mu];let bu=Math.min(cu,Au),Cu=ru[mu];Cu===-1&&(bu=0);for(let wu=0;wu<bu;++wu)pu.push(Cu),Cu+=lu;for(let wu=0;wu<Au-bu;++wu)pu.push(-1)}if(hu>0&&pu.length!==nu[hu-1])throw new Error("Invalid row split size.");return pu}calculateOutputIndexValueRowID(nu,ru,lu,cu){const hu=nu.length,pu=[];if(hu===0)return[];let mu=0,Au=nu[0];if(Au>=ru.length)throw new Error(`Got currentValueRowId=${Au}, which is not less than ${ru.length}`);let bu=ru[Au];pu.push(bu);for(let Cu=1;Cu<hu;++Cu){const wu=nu[Cu];if(wu===Au)bu>=0&&(++mu,mu<cu?bu+=lu:bu=-1);else{if(mu=0,Au=wu,wu>=ru.length)throw new Error(`Got nextValueRowId=${wu} which is not less than ${ru.length}`);bu=ru[wu]}pu.push(bu)}if(pu.length!==nu.length)throw new Error("Invalid row ids.");return pu}calculateOutputIndex(nu,ru,lu,cu){const hu=this.getRowPartitionTensor(nu),pu=this.getRowPartitionTypeByDimension(nu);switch(pu){case fx.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(hu,ru,lu,cu);case fx.ROW_SPLITS:if(hu.length-1>ru.length)throw new Error(`Row partition size is greater than output size: ${hu.length-1} > ${ru.length}`);return this.calculateOutputIndexRowSplit(hu,ru,lu,cu);default:throw new Error(`Unsupported partition type: ${fx[pu]}`)}}getFirstDimensionSize(){const nu=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const ru=this.rowPartitionTypes[0];switch(ru){case fx.FIRST_DIM_SIZE:return nu[0];case fx.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fx.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fx[ru]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const nu=this.getFirstDimensionSize(),ru=this.calculateOutputSize(nu),lu=new Array(this.raggedRank+1);lu[lu.length-1]=1;for(let pu=lu.length-2;pu>=0;--pu)lu[pu]=lu[pu+1]*ru[pu+1];const cu=N3(ru,!1),hu=Yu(this.valuesDType,Mu(cu));if(lu[0]*ru[0]>0){let pu=this.calculateFirstParentOutputIndex(nu,lu[0],ru[0]);for(let mu=1;mu<=this.raggedRank;++mu)pu=this.calculateOutputIndex(mu-1,pu,lu[mu],ru[mu]);this.setOutput(this.raggedRank,pu,hu,cu)}return[cu,hu]}setOutput(nu,ru,lu,cu){if(lu.length===0)return;const hu=this.values,pu=lu;let mu=cu.slice();mu=mu.slice(nu+1);const Au=Mu(mu),bu=ru.length;let Cu=this.defaultValue;if(Cu.length!==Au&&Cu.length!==1){const Ru=this.defaultValueShape;Op(()=>{const Nu=Pp(Cu,Ru);Cu=ow(Nu,mu).dataSync()})}let wu=0,Eu=0,Tu=0;for(let Ru=0;Ru<=bu;++Ru){let Nu=Ru<bu?ru[Ru]:-1;if(Nu===Tu){++Tu;continue}if(Eu<Tu){const Pu=hu.subarray(wu*Au),Fu=pu.subarray(Eu*Au),Gu=(Tu-Eu)*Au;L3(Fu,Pu,Gu)}if(Ru>=bu){const Pu=lu.length;Nu=Math.floor(Pu/Au)}if(Nu>Tu)if(this.defaultValue.length===1)pu.subarray(Tu*Au,Nu*Au).fill(this.defaultValue[0]),Tu=Nu;else for(;Nu>Tu;){const Pu=pu.slice(Tu*Au);L3(Pu,Cu,Au),++Tu}Nu<0?(wu=Ru+1,Eu=Tu):(wu=Ru,Eu=Tu,Tu=Eu+1)}}}function L3(ou,nu,ru){for(let lu=0;lu<ru;lu++)ou[lu]=nu[lu]}function N3(ou,nu){const ru=[];for(let lu of ou){if(lu<0){if(!nu)throw new Error(`Dimension ${lu} must be >= 0`);if(lu<-1)throw new Error(`Dimension ${lu} must be >= -1`);lu=-1}ru.push(lu)}return ru}function D3(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu){return new w2(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu).compute()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F3(ou,nu,ru,lu){const cu=ou===nu,hu=ou<nu&&ru<0,pu=nu<ou&&ru>1;if(cu||hu||pu)return kp(0,lu);const mu=Math.abs(Math.ceil((nu-ou)/ru)),Au=kp(mu,lu);nu<ou&&ru===1&&(ru=-1),Au[0]=ou;for(let bu=1;bu<Au.length;bu++)Au[bu]=Au[bu-1]+ru;return Au}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const P3=Kx(ou=>1/Math.sqrt(ou)),vX=Pv(PC,P3),CX={kernelName:PC,backendName:"cpu",kernelFunc:vX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function C1(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu){const Cu=[lu/cu,cu],wu=ou.values,Eu=nu.values;if(lu===0)return t0(ru,nu.dtype);const Tu=Au instanceof uy?Au:t0(Cu,nu.dtype);typeof Au=="string"||typeof Au=="number"?Tu.values.fill(Au):typeof Au=="boolean"&&Tu.values.fill(+Au);for(let Ru=0;Ru<hu;Ru++){const Nu=[];let Pu=0;for(let Fu=0;Fu<pu;Fu++){const Gu=wu[Ru*pu+Fu];Nu.push(Gu),Pu+=Gu*mu[Fu]}if(Pu<0||Pu>=lu/cu)throw new Error(`Invalid indices: ${Nu} does not index into ${ru}`);for(let Fu=0;Fu<cu;Fu++)bu?Tu.values[Pu*cu+Fu]+=Eu[Ru*cu+Fu]:Tu.values[Pu*cu+Fu]=nu.rank===0?Eu[0]:Eu[Ru*cu+Fu]}return Tu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wX=Kx(ou=>1/(1+Math.exp(-ou))),G3=b0(VC,ou=>1/(1+Math.exp(-ou))),EX={kernelName:VC,backendName:"cpu",kernelFunc:G3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function O3(ou,nu,ru,lu,cu){const hu=vI(lu,nu,ru),pu=Mu(ru),mu=xp(lu);if(hu){const wu=CI(nu,mu);return cu==="string"?ou.slice(wu,wu+pu):ou.subarray(wu,wu+pu)}const Au=cu==="string"?ov(ou):ou,bu=t0(lu,cu,Au),Cu=t0(ru,cu);for(let wu=0;wu<Cu.size;++wu){const Eu=Cu.indexToLoc(wu),Tu=Eu.map((Ru,Nu)=>Ru+nu[Nu]);Cu.set(bu.get(...Tu),...Eu)}return cu==="string"?lB(Cu.values):Cu.values}function w1(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{begin:hu,size:pu}=lu;Pm(cu,"slice");const[mu,Au]=XE(cu,hu,pu);bI(cu,mu,Au);const bu=ru.data.get(cu.dataId).values,Cu=O3(bu,mu,Au,cu.shape,cu.dtype);return ru.makeTensorInfo(Au,cu.dtype,Cu)}const SX={kernelName:xE,backendName:"cpu",kernelFunc:w1};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function U3(ou,nu,ru,lu,cu,hu,pu){const mu=nu[0],Au=hu[0],bu=new Array(Au),Cu=new Array(mu),wu=nu[1];if(Au===0){if(mu!==0)throw new Error(jR(mu));const Pu=Yu(ru,0),Fu=Yu(cu,0);return[Pu,[0,wu],Fu,bu,Cu]}let Eu=!0,Tu=0;const Ru=new Array(Au).fill(0);for(let Pu=0;Pu<mu;++Pu){const Fu=ou[Pu*wu];if(Fu<0)throw new Error(YR(Pu,Fu));if(Fu>=Au)throw new Error(qR(Pu,Fu,Au));++Ru[Fu],Eu=Eu&&Fu>=Tu,Tu=Fu}let Nu=!0;for(let Pu=0;Pu<Au;++Pu){const Fu=Ru[Pu]===0;bu[Pu]=Fu,Nu=Nu&&!Fu,Ru[Pu]=Math.max(Ru[Pu],1),Pu>0&&(Ru[Pu]+=Ru[Pu-1])}if(Nu&&Eu){const Pu=ou,Fu=lu;for(let Gu=0;Gu<mu;++Gu)Cu[Gu]=Gu;return[Pu,[mu,wu],Fu,bu,Cu]}else{const Pu=Ru[Au-1],Fu=Yu(ru,Pu*wu),Gu=Yu(cu,Pu),Xu=new Array(Au).fill(0);for(let Qu=0;Qu<mu;++Qu){const Ju=ou[Qu*wu],ip=Xu[Ju],rp=(Ju===0?0:Ru[Ju-1])+ip;Xu[Ju]++;for(let op=0;op<wu;++op)Fu[rp*wu+op]=ou[Qu*wu+op];Gu[rp]=lu[Qu],Cu[Qu]=rp}for(let Qu=0;Qu<Au;++Qu)if(Xu[Qu]===0){const Ju=Qu===0?0:Ru[Qu-1];Fu[Ju*wu+0]=Qu;for(let ip=1;ip<wu;++ip)Fu[Ju*wu+ip]=0;Gu[Ju]=pu}return[Fu,[Pu,wu],Gu,bu,Cu]}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $3(ou,nu,ru,lu,cu){const hu=Mu(lu),pu=nu[0],mu=cu.length,Au=[];let bu=1,Cu=-1;for(let Nu=0;Nu<mu;++Nu){const Pu=cu[Nu];if(Pu===-1){if(Cu!==-1)throw new Error(JR(Cu,Nu));Cu=Nu,Au.push(1)}else{if(Pu<0)throw new Error(_k(Nu,Pu));bu*=Pu,Au.push(Pu)}}if(Cu!==-1){if(bu<=0)throw new Error(eB());const Nu=Math.trunc(hu/bu);if(bu*Nu!==hu)throw new Error(tB(lu,Au));Au[Cu]=Nu}if(Mu(Au)!==hu)throw new Error(nB(lu,Au));const wu=lu.length,Eu=[];if(wu>0){Eu[wu-1]=1;for(let Nu=wu-2;Nu>=0;--Nu)Eu[Nu]=Eu[Nu+1]*lu[Nu+1]}const Tu=[];if(mu>0){Tu[mu-1]=1;for(let Nu=mu-2;Nu>=0;--Nu)Tu[Nu]=Tu[Nu+1]*Au[Nu+1]}const Ru=Yu(ru,pu*mu);for(let Nu=0;Nu<pu;++Nu){let Pu=0;for(let Fu=0;Fu<wu;++Fu)Pu+=ou[Nu*wu+Fu]*Eu[Fu];for(let Fu=0;Fu<mu;++Fu)Ru[Nu*mu+Fu]=Math.trunc(Pu/Tu[Fu]),Pu%=Tu[Fu]}return[Ru,[pu,mu],Au]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LT(ou,nu,ru,lu,cu,hu=!1,pu=0){const mu=lu.length,Au=[nu[0],ou.length/nu[0]],bu=Au[1],Cu=mu>0?cu[mu-1]+1:0;if(Cu<0)throw new Error(zI());const wu=nu.slice();wu[0]=Cu;const Eu=wu.reduce((Gu,Xu)=>Gu*Xu,1),Tu=Yu(ru,Eu);if(mu===0)return Cu>0&&Tu.fill(pu),[Tu,wu];if(Cu<=0)throw new Error(zI());let Ru=0,Nu=1,Pu=0,Fu=cu[Ru];for(;;){let Gu=0;if(Nu<mu){if(Gu=cu[Nu],Fu===Gu){++Nu;continue}if(Fu>=Gu)throw new Error(iB())}if(Fu<0||Fu>=Cu)throw new Error(rB(Fu,Cu));Fu>Pu&&Tu.fill(pu,Pu*bu,Fu*bu);for(let Xu=Ru;Xu<Nu;++Xu){const Qu=lu[Xu];if(Qu<0||Qu>=Au[0])throw new Error(sB(Xu,lu[Xu],Au[0]));for(let Ju=0;Ju<bu;Ju++)Tu[Fu*bu+Ju]+=ou[Qu*bu+Ju]}if(hu)for(let Xu=0;Xu<bu;Xu++)Tu[Fu*bu+Xu]/=Nu-Ru;if(Ru=Nu,++Nu,Pu=Fu+1,Fu=Gu,Nu>mu)break}return Pu<Cu&&Tu.fill(pu,Pu*bu,Cu*bu),[Tu,wu]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const IX=Kx(ou=>Math.sqrt(ou)),TX=b0(WC,ou=>Math.sqrt(ou)),_X={kernelName:WC,backendName:"cpu",kernelFunc:TX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V3=K0((ou,nu)=>{const ru=ou-nu;return ru*ru}),MX=ry(HC,V3),RX={kernelName:HC,backendName:"cpu",kernelFunc:MX};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z3=Kx((ou,nu)=>{const{pattern:ru,replaceGlobal:lu,rewrite:cu}=nu;return ou.replace(new RegExp(ru,lu?"g":""),cu)}),kX=Pv(uS,z3),BX={kernelName:uS,backendName:"cpu",kernelFunc:kX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function W3(ou,nu,ru,lu){const cu=t0(ou,nu.dtype);for(let hu=0;hu<cu.size;hu++){const pu=cu.indexToLoc(hu),mu=new Array(pu.length);for(let Au=0;Au<mu.length;Au++)mu[Au]=pu[Au]*ru[Au]+lu[Au];cu.set(nu.get(...mu),...pu)}return cu}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class LX{constructor(nu,ru,lu,cu,hu,pu){this.separator=bv(nu),this.nGramWidths=ru,this.leftPad=bv(lu),this.rightPad=bv(cu),this.padWidth=hu,this.preserveShort=pu}getPadWidth(nu){return Math.min(this.padWidth<0?nu-1:this.padWidth,nu-1)}getNumNGrams(nu,ru){const lu=this.getPadWidth(ru);return Math.max(0,nu+2*lu-ru+1)}createNGrams(nu,ru,lu,cu,hu,pu){for(let mu=0;mu<hu;++mu){const Au=this.getPadWidth(pu),bu=Math.max(0,Au-mu),Cu=Math.max(0,Au-(hu-(mu+1))),wu=pu-(bu+Cu),Eu=ru+(bu>0?0:mu-Au);let Tu=0;Tu+=bu*this.leftPad.length;for(let Gu=0;Gu<wu;++Gu)Tu+=nu[Eu+Gu].length;Tu+=Cu*this.rightPad.length;const Ru=bu+Cu+wu-1;Tu+=Ru*this.separator.length,lu[cu+mu]=new Uint8Array(Tu);const Nu=lu[cu+mu];let Pu=0;const Fu=Gu=>Gu.forEach(Xu=>Nu[Pu++]=Xu);for(let Gu=0;Gu<bu;++Gu)Fu(this.leftPad),Fu(this.separator);for(let Gu=0;Gu<wu-1;++Gu)Fu(nu[Eu+Gu]),Fu(this.separator);if(wu>0){Fu(nu[Eu+wu-1]);for(let Gu=0;Gu<Cu;++Gu)Fu(this.separator),Fu(this.rightPad)}else{for(let Gu=0;Gu<Cu-1;++Gu)Fu(this.rightPad),Fu(this.separator);Fu(this.rightPad)}}}compute(nu,ru){const lu=nu.length,cu=ru.length;if(cu>0){let Au=ru[0];if(Au!==0)throw new Error(`First split value must be 0, got ${Au}`);for(let bu=1;bu<cu;++bu){let Cu=ru[bu]>=Au;if(Cu=Cu&&ru[bu]<=lu,!Cu)throw new Error(`Invalid split value ${ru[bu]}, must be in [${Au}, ${lu}]`);Au=ru[bu]}if(Au!==lu)throw new Error(`Last split value must be data size. Expected ${lu}, got ${Au}`)}const hu=cu-1,pu=Yu("int32",cu);if(lu===0||cu===0){const Au=new Array(lu);for(let bu=0;bu<=hu;++bu)pu[bu]=0;return[Au,pu]}pu[0]=0;for(let Au=1;Au<=hu;++Au){const bu=ru[Au]-ru[Au-1];let Cu=0;this.nGramWidths.forEach(wu=>{Cu+=this.getNumNGrams(bu,wu)}),this.preserveShort&&bu>0&&Cu===0&&(Cu=1),pu[Au]=pu[Au-1]+Cu}const mu=new Array(pu[hu]);for(let Au=0;Au<hu;++Au){const bu=ru[Au];let Cu=pu[Au];if(this.nGramWidths.forEach(wu=>{const Eu=ru[Au+1]-ru[Au],Tu=this.getNumNGrams(Eu,wu);this.createNGrams(nu,bu,mu,Cu,Tu,wu),Cu+=Tu}),this.preserveShort&&Cu===pu[Au]){const wu=ru[Au+1]-ru[Au];if(wu===0)continue;const Eu=wu+2*this.padWidth;this.createNGrams(nu,bu,mu,Cu,1,Eu)}}return[mu,pu]}}function H3(ou,nu,ru,lu,cu,hu,pu,mu){return new LX(ru,lu,cu,hu,pu,mu).compute(ou,nu)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NX(ou,nu,ru,lu){if(!ou.length)return;if(nu.length===0){for(let hu=0;hu<ou.length;++hu)lu.push(ou.subarray(hu,hu+1));return}if(nu.length===1){const hu=nu[0];let pu=ou.indexOf(hu);for(;pu!==-1;){const mu=ou.subarray(0,pu);(!ru||mu.length!==0)&&lu.push(mu),ou=ou.subarray(pu+1),pu=ou.indexOf(hu)}(!ru||ou.length!==0)&&lu.push(ou);return}let cu=0;for(let hu=0;hu<ou.length+1;hu++)if(hu===ou.length||nu.indexOf(ou[hu])!==-1){const pu=ou.subarray(cu,hu);(!ru||pu.length!==0)&&lu.push(pu),cu=hu+1}}function X3(ou,nu,ru){const lu=ou.length,cu=[];let hu=0,pu=0;const mu=new Array(lu);for(let Eu=0;Eu<lu;++Eu){const Tu=cu.length;NX(ou[Eu],nu,ru,cu);const Ru=cu.length-Tu;mu[Eu]=Ru,hu+=Ru,pu=Math.max(pu,Ru)}const Au=Yu("int32",hu*2),bu=new Array(hu),Cu=[lu,pu];let wu=0;for(let Eu=0;Eu<lu;++Eu)for(let Tu=0;Tu<mu[Eu];++Tu)Au[wu*2]=Eu,Au[wu*2+1]=Tu,bu[wu]=cu[wu],++wu;return[Au,bu,Cu]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Q3(ou,nu){const ru=Yu("int32",ou.length);for(let lu=0;lu<ou.length;++lu)ru[lu]=AP(ou[lu]).modulo(nu).getLowBitsUnsigned();return ru}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K3=K0((ou,nu)=>ou-nu),DX=MT((ou,nu,ru,lu)=>({real:ou-ru,imag:nu-lu})),NT=ry(XC,K3,DX),FX={kernelName:XC,backendName:"cpu",kernelFunc:NT};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Z3(ou,nu){const ru=new Array(ou.rank);for(let cu=0;cu<ru.length;cu++)ru[cu]=ou.shape[cu]*nu[cu];const lu=t0(ru,ou.dtype);for(let cu=0;cu<lu.values.length;++cu){const hu=lu.indexToLoc(cu),pu=new Array(ou.rank);for(let Au=0;Au<pu.length;Au++)pu[Au]=hu[Au]%ou.shape[Au];const mu=ou.locToIndex(pu);lu.values[cu]=ou.values[mu]}return lu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Lw=(ou,nu)=>{const ru=nu.value-ou.value;return ru===0?ou.index-nu.index:ru};function j3(ou,nu,ru=0,lu=ou.length-1){for(;lu>ru;){if(lu-ru>600){const mu=lu-ru+1,Au=nu-ru+1,bu=Math.log(mu),Cu=.5*Math.exp(2*bu/3),wu=.5*Math.sqrt(bu*Cu*(mu-Cu)/mu)*Math.sign(Au-mu/2),Eu=Math.max(ru,Math.floor(nu-Au*Cu/mu+wu)),Tu=Math.min(lu,Math.floor(nu+(mu-Au)*Cu/mu+wu));j3(ou,nu,Eu,Tu)}const cu=ou[nu];let hu=ru,pu=lu;for(yu(ou,ru,nu),Lw(ou[lu],cu)>0&&yu(ou,ru,lu);hu<pu;){for(yu(ou,hu,pu),hu++,pu--;Lw(ou[hu],cu)<0;)hu=hu+1;for(;Lw(ou[pu],cu)>0;)pu=pu-1}Lw(ou[ru],cu)===0?yu(ou,ru,pu):(pu=pu+1,yu(ou,pu,lu)),pu<=nu&&(ru=pu+1),nu<=pu&&(lu=pu-1)}}function Y3(ou,nu,ru,lu,cu){const hu=nu[nu.length-1],[pu,mu]=[ou.length/hu,hu],Au=Hu(ru,pu*lu),bu=Hu("int32",pu*lu);for(let wu=0;wu<pu;wu++){const Eu=wu*mu,Tu=ou.subarray(Eu,Eu+mu);let Ru=new Array(Tu.length);Tu.forEach((Gu,Xu)=>Ru[Xu]={value:Gu,index:Xu}),lu<Ru.length&&(j3(Ru,lu),Ru=Ru.slice(0,lu)),cu&&Ru.sort(Lw);const Nu=wu*lu,Pu=Au.subarray(Nu,Nu+lu),Fu=bu.subarray(Nu,Nu+lu);for(let Gu=0;Gu<lu;Gu++)Pu[Gu]=Ru[Gu].value,Fu[Gu]=Ru[Gu].index}const Cu=nu.slice();return Cu[Cu.length-1]=lu,[t0(Cu,ru,Au),t0(Cu,"int32",bu)]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function q3(ou,nu,ru,lu){const cu=Wu(nu,ru)[0],hu=[1,ru[0],1];for(let Ru=0;Ru<cu;Ru++)hu[0]*=ru[Ru];hu[1]=ru[cu];for(let Ru=cu+1;Ru<ru.length;Ru++)hu[2]*=ru[Ru];const pu=new Map,mu=new Int32Array(ru[cu]),Au=new uy(hu,lu,ou),bu=[],Cu=hu[0]===1&&hu[2]===1;for(let Ru=0;Ru<ru[cu];Ru++){let Nu;if(Cu)Nu=ou[Ru].toString();else{const Fu=[];for(let Gu=0;Gu<hu[0];Gu++)for(let Xu=0;Xu<hu[2];Xu++)Fu.push(Au.get(Gu,Ru,Xu));Nu=Fu.join(",")}const Pu=pu.get(Nu);if(Pu!=null)mu[Ru]=Pu;else{const Fu=pu.size;pu.set(Nu,Fu),mu[Ru]=Fu,bu.push(Ru)}}const wu=hu.slice();wu[1]=pu.size;const Eu=new uy(wu,lu);bu.forEach((Ru,Nu)=>{for(let Pu=0;Pu<hu[0];Pu++)for(let Fu=0;Fu<hu[2];Fu++)Eu.set(Au.get(Pu,Ru,Fu),Pu,Nu,Fu)});const Tu=ru.slice();return Tu[cu]=wu[1],{outputValues:Eu.values,outputShape:Tu,indices:mu}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const PX=Object.freeze(Object.defineProperty({__proto__:null,addImpl:i3,bincountImpl:RT,bincountReduceImpl:r3,bitwiseAndImpl:s3,castImpl:n3,ceilImpl:o3,concatImpl:a3,equalImpl:l3,expImpl:u3,expm1Impl:d3,floorDivImpl:f3,floorImpl:p3,gatherNdImpl:m3,gatherV2Impl:g3,greaterEqualImpl:y3,greaterImpl:A3,lessEqualImpl:x3,lessImpl:b3,linSpaceImpl:v3,logImpl:C3,maxImpl:w3,maximumImpl:E3,minimumImpl:S3,multiplyImpl:kT,negImpl:I3,notEqualImpl:T3,prodImpl:_3,raggedGatherImpl:R3,raggedRangeImpl:B3,raggedTensorToTensorImpl:D3,rangeImpl:F3,rsqrtImpl:P3,scatterImpl:C1,sigmoidImpl:wX,simpleAbsImpl:t3,sliceImpl:O3,sparseFillEmptyRowsImpl:U3,sparseReshapeImpl:$3,sparseSegmentReductionImpl:LT,sqrtImpl:IX,squaredDifferenceImpl:V3,staticRegexReplaceImpl:z3,stridedSliceImpl:W3,stringNGramsImpl:H3,stringSplitImpl:X3,stringToHashBucketFastImpl:Q3,subImpl:K3,tileImpl:Z3,topKImpl:Y3,transposeImpl:BT,uniqueImpl:q3},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/wM("cpu",()=>new x2,1);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const J3=b0(_m,ou=>ou>=0?ou:Math.exp(ou)-1),GX={kernelName:_m,backendName:"cpu",kernelFunc:J3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{alpha:hu}=lu;Pm([cu],"leakyRelu");const pu=Mu(cu.shape),mu=ru.data.get(cu.dataId).values,Au=Hu("float32",pu);for(let bu=0;bu<mu.length;bu++)Au[bu]=mu[bu]<0?hu*mu[bu]:mu[bu];return ru.makeTensorInfo(cu.shape,"float32",Au)}const OX={kernelName:Ax,backendName:"cpu",kernelFunc:eD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UX=K0((ou,nu)=>ou<0?nu*ou:ou);function tD(ou){const{inputs:nu,backend:ru}=ou,{x:lu,alpha:cu}=nu;Pm([lu,cu],"prelu");const hu=ru.data.get(lu.dataId).values,pu=ru.data.get(cu.dataId).values,[mu,Au]=UX(lu.shape,cu.shape,hu,pu,"float32");return ru.makeTensorInfo(Au,"float32",mu)}const $X={kernelName:pE,backendName:"cpu",kernelFunc:tD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nD=b0(NC,ou=>Math.max(0,ou)),VX={kernelName:NC,backendName:"cpu",kernelFunc:nD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iD=b0(DC,ou=>Math.min(Math.max(0,ou),6)),zX={kernelName:DC,backendName:"cpu",kernelFunc:iD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function E2(ou,nu,ru,lu,cu){if(ru==="linear")return Qx({inputs:{x:nu},backend:ou});if(ru==="relu")return nD({inputs:{x:nu},backend:ou});if(ru==="elu")return J3({inputs:{x:nu},backend:ou});if(ru==="relu6")return iD({inputs:{x:nu},backend:ou});if(ru==="prelu")return tD({inputs:{x:nu,alpha:lu},backend:ou});if(ru==="leakyrelu")return eD({inputs:{x:nu},backend:ou,attrs:{alpha:cu}});if(ru==="sigmoid")return G3({inputs:{x:nu},backend:ou});throw new Error(`Activation ${ru} has not been implemented for the CPU backend.`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S0(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{shape:hu}=lu,pu=Mu(cu.shape),mu=Ou(hu,pu),Au=Mu(mu);vu(pu===Au,()=>`The new shape (${mu}) has ${Au} elements and the old shape (${cu.shape}) has ${pu} elements. The new shape and old shape must have the same number of elements.`),ru.incRef(cu.dataId);const bu=ru.data.get(cu.dataId);if(bu.complexTensorInfos!=null){const Cu=bu.complexTensorInfos.real,wu=bu.complexTensorInfos.imag;Cu.shape=mu,wu.shape=mu}return{dataId:cu.dataId,shape:mu,dtype:cu.dtype}}const WX={kernelName:mE,backendName:"cpu",kernelFunc:S0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{a:cu,b:hu}=nu,{transposeA:pu,transposeB:mu}=lu;Pm([cu,hu],"matMul");const Au=cu.shape.length,bu=hu.shape.length,Cu=pu?cu.shape[Au-2]:cu.shape[Au-1],wu=mu?hu.shape[bu-1]:hu.shape[bu-2],Eu=pu?cu.shape[Au-1]:cu.shape[Au-2],Tu=mu?hu.shape[bu-2]:hu.shape[bu-1],Ru=cu.shape.slice(0,-2),Nu=hu.shape.slice(0,-2),Pu=Mu(Ru),Fu=Mu(Nu),Gu=_g(cu.shape.slice(0,-2),hu.shape.slice(0,-2)).concat([Eu,Tu]);vu(Cu===wu,()=>`Error in matMul: inner shapes (${Cu}) and (${wu}) of Tensors with shapes ${cu.shape} and ${hu.shape} and transposeA=${pu} and transposeB=${mu} must match.`);const Xu=pu?[Pu,Cu,Eu]:[Pu,Eu,Cu],Qu=mu?[Fu,Tu,wu]:[Fu,wu,Tu],Ju=S0({inputs:{x:cu},backend:ru,attrs:{shape:Xu}}),ip=S0({inputs:{x:hu},backend:ru,attrs:{shape:Qu}}),rp=pu?Ju.shape[1]:Ju.shape[2],op=pu?Ju.shape[2]:Ju.shape[1],hp=mu?ip.shape[1]:ip.shape[2],Ap=Math.max(Pu,Fu),Up=ru.data.get(Ju.dataId).values,Vp=ru.data.get(ip.dataId).values,zp=xp(Ju.shape),qp=xp(ip.shape),[Yp,em,am]=pu?[zp[0],1,zp[1]]:[zp[0],zp[1],1],[im,um,ym]=mu?[1,qp[1],qp[0]]:[qp[1],1,qp[0]],pm=op*hp,bm=t0([Ap,op,hp],Ju.dtype),xm=bm.values,wm=ru.blockSize;for(let Im=0;Im<Ap;Im++){const Wm=Im%Pu,$m=Im%Fu;for(let Hm=0;Hm<op;Hm+=wm){const qm=Math.min(Hm+wm,op);for(let Jm=0;Jm<hp;Jm+=wm){const a0=Math.min(Jm+wm,hp);for(let f0=0;f0<rp;f0+=wm){const U0=Math.min(f0+wm,rp);for(let B0=Hm;B0<qm;B0++)for(let I0=Jm;I0<a0;I0++){let T0=0;for(let L0=f0;L0<U0;L0++){const Z0=Up[Wm*Yp+B0*em+L0*am],hv=Vp[L0*im+I0*um+$m*ym];T0+=Z0*hv}xm[Im*pm+(B0*hp+I0)]+=T0}}}}}return ru.disposeIntermediateTensorInfo(Ju),ru.disposeIntermediateTensorInfo(ip),ru.makeTensorInfo(Gu,bm.dtype,bm.values)}const HX={kernelName:om,backendName:"cpu",kernelFunc:rD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XX(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{a:cu,b:hu,bias:pu,preluActivationWeights:mu}=nu,{transposeA:Au,transposeB:bu,activation:Cu,leakyreluAlpha:wu}=lu;let Eu,Tu,Ru;const Nu=[];Eu=rD({inputs:{a:cu,b:hu},attrs:{transposeA:Au,transposeB:bu},backend:ru}),pu&&(Tu=oC({inputs:{a:Eu,b:pu},backend:ru}),Nu.push(Eu),Eu=Tu),Cu&&(Ru=E2(ru,Eu,Cu,mu,wu),Nu.push(Eu),Eu=Ru);for(const Pu of Nu)ru.disposeIntermediateTensorInfo(Pu);return Eu}const QX={kernelName:_E,backendName:"cpu",kernelFunc:XX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KX=b0(Kp,ou=>Math.acos(ou)),ZX={kernelName:Kp,backendName:"cpu",kernelFunc:KX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jX=b0(vm,ou=>Math.acosh(ou)),YX={kernelName:vm,backendName:"cpu",kernelFunc:jX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qX(ou){const{inputs:nu,backend:ru}=ou,lu=nu;Pm(nu,"addN");const cu=lu.map(mu=>ru.data.get(mu.dataId).values),hu=t0(lu[0].shape,lu[0].dtype),pu=hu.values;for(let mu=0;mu<lu.length;mu++){const Au=cu[mu];for(let bu=0;bu<pu.length;bu++)pu[bu]+=Au[bu]}return ru.makeTensorInfo(hu.shape,hu.dtype,hu.values)}const JX={kernelName:_d,backendName:"cpu",kernelFunc:qX};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function e9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu;Pm(cu,"all");const mu=Wu(hu,cu.shape);let Au=mu;const bu=G0(Au,cu.shape.length);let Cu=cu;bu!=null&&(Cu=Fy({inputs:{x:cu},backend:ru,attrs:{perm:bu}}),Au=H0(Au.length,cu.shape.length)),dy("all",Au,Cu.shape.length);const[wu,Eu]=oy(Cu.shape,Au),Tu=Mu(Eu),Ru=kp(Mu(wu),Cu.dtype),Nu=ru.data.get(Cu.dataId).values;for(let Fu=0;Fu<Ru.length;++Fu){const Gu=Fu*Tu;let Xu=Nu[Gu];for(let Qu=0;Qu<Tu;++Qu){const Ju=Nu[Gu+Qu];Xu=Xu&&Ju}Ru[Fu]=Xu}bu!=null&&ru.disposeIntermediateTensorInfo(Cu);const Pu=ru.makeTensorInfo(wu,Cu.dtype,Ru);if(pu){const Fu=j0(wu,mu),Gu=S0({inputs:{x:Pu},backend:ru,attrs:{shape:Fu}});return ru.disposeIntermediateTensorInfo(Pu),Gu}return Pu}const t9={kernelName:Sp,backendName:"cpu",kernelFunc:e9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu;Pm(cu,"any");const mu=Wu(hu,cu.shape);let Au=mu;const bu=G0(Au,cu.shape.length);let Cu=cu;bu!=null&&(Cu=Fy({inputs:{x:cu},backend:ru,attrs:{perm:bu}}),Au=H0(Au.length,cu.shape.length)),dy("any",Au,Cu.shape.length);const[wu,Eu]=oy(Cu.shape,Au),Tu=Mu(Eu),Ru=kp(Mu(wu),Cu.dtype),Nu=ru.data.get(Cu.dataId).values;for(let Fu=0;Fu<Ru.length;++Fu){const Gu=Fu*Tu;let Xu=Nu[Gu];for(let Qu=0;Qu<Tu;++Qu){const Ju=Nu[Gu+Qu];Xu=Xu||Ju}Ru[Fu]=Xu}bu!=null&&ru.disposeIntermediateTensorInfo(Cu);const Pu=ru.makeTensorInfo(wu,Cu.dtype,Ru);if(pu){const Fu=j0(wu,mu),Gu=S0({inputs:{x:Pu},backend:ru,attrs:{shape:Fu}});return ru.disposeIntermediateTensorInfo(Pu),Gu}return Pu}const i9={kernelName:tm,backendName:"cpu",kernelFunc:n9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function r9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu}=lu;Pm(cu,"argMax");let pu=Wu(hu,cu.shape);const mu=G0(pu,cu.shape.length);let Au=cu;const bu=[];mu!=null&&(Au=Fy({inputs:{x:cu},backend:ru,attrs:{perm:mu}}),bu.push(Au),pu=H0(pu.length,Au.shape.length)),pu=[pu[0]],dy("argMax",pu,Au.shape.length);const[Cu,wu]=oy(Au.shape,pu),Eu=Mu(Cu),Tu=kp(Eu,"int32"),Ru=Mu(wu),Nu=ru.data.get(Au.dataId).values;for(let Pu=0;Pu<Tu.length;++Pu){const Fu=Pu*Ru;let Gu=Nu[Fu],Xu=0;for(let Qu=0;Qu<Ru;++Qu){const Ju=Nu[Fu+Qu];Ju>Gu&&(Gu=Ju,Xu=Qu)}Tu[Pu]=Xu}return bu.forEach(Pu=>ru.disposeIntermediateTensorInfo(Pu)),ru.makeTensorInfo(Cu,"int32",Tu)}const s9={kernelName:qu,backendName:"cpu",kernelFunc:r9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function o9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu}=lu;Pm(cu,"argMin");let pu=Wu(hu,cu.shape);const mu=G0(pu,cu.shape.length);let Au=cu;const bu=[];mu!=null&&(Au=Fy({inputs:{x:cu},backend:ru,attrs:{perm:mu}}),bu.push(Au),pu=H0(pu.length,Au.shape.length)),pu=[pu[0]],dy("argMin",pu,Au.shape.length);const[Cu,wu]=oy(Au.shape,pu),Eu=Mu(Cu),Tu=kp(Eu,"int32"),Ru=Mu(wu),Nu=ru.data.get(Au.dataId).values;for(let Pu=0;Pu<Tu.length;++Pu){const Fu=Pu*Ru;let Gu=Nu[Fu],Xu=0;for(let Qu=0;Qu<Ru;++Qu){const Ju=Nu[Fu+Qu];Ju<Gu&&(Gu=Ju,Xu=Qu)}Tu[Pu]=Xu}return bu.forEach(Pu=>ru.disposeIntermediateTensorInfo(Pu)),ru.makeTensorInfo(Cu,"int32",Tu)}const a9={kernelName:Uu,backendName:"cpu",kernelFunc:o9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const l9=b0(zu,ou=>Math.asin(ou)),c9={kernelName:zu,backendName:"cpu",kernelFunc:l9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const u9=b0(ep,ou=>Math.asinh(ou)),h9={kernelName:ep,backendName:"cpu",kernelFunc:u9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const d9=b0(up,ou=>Math.atan(ou)),p9={kernelName:up,backendName:"cpu",kernelFunc:d9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f9=K0((ou,nu)=>Math.atan2(ou,nu)),m9=ry(Ip,f9),g9={kernelName:Ip,backendName:"cpu",kernelFunc:m9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const A9=b0(Mp,ou=>Math.atanh(ou)),y9={kernelName:Mp,backendName:"cpu",kernelFunc:A9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DT(ou,nu,ru,lu,cu,hu){const pu=cu.strideHeight,mu=cu.strideWidth,Au=cu.dilationHeight,bu=cu.dilationWidth,Cu=cu.effectiveFilterHeight,wu=cu.effectiveFilterWidth,Eu=cu.padInfo.top,Tu=cu.padInfo.left,Ru=hu==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Nu=t0(cu.outShape,ru),Pu=Nu.values,Fu=cu.outShape[1]*cu.outShape[2]*cu.outShape[3],Gu=cu.outShape[2]*cu.outShape[3],Xu=cu.outShape[3];for(let Qu=0;Qu<cu.batchSize;++Qu){const Ju=Qu*Fu,ip=Qu*lu[0];for(let rp=0;rp<cu.inChannels;++rp)for(let op=0;op<cu.outHeight;++op){const hp=op*pu-Eu,Ap=Math.max(0,hp),Up=Math.min(cu.inHeight,Cu+hp),Vp=Ju+op*Gu;for(let zp=0;zp<cu.outWidth;++zp){const qp=zp*mu-Tu,Yp=Math.max(0,qp),em=Math.min(cu.inWidth,wu+qp);let am=Ru,im=0,um=0;for(let pm=Ap;pm<Up;pm+=Au){const bm=ip+pm*lu[1];for(let xm=Yp;xm<em;xm+=bu){const wm=bm+xm*lu[2],Im=ou[wm+rp];hu==="max"&&Im>am?am=Im:hu==="avg"&&(im+=Im,um++)}if(isNaN(am))break}const ym=Vp+zp*Xu+rp;Pu[ym]=hu==="avg"?im/um:am}}}return Nu}function sD(ou,nu,ru,lu,cu=!1,hu=!1){const pu=t0(lu.outShape,"int32"),mu=lu.strideHeight,Au=lu.strideWidth,bu=lu.dilationHeight,Cu=lu.dilationWidth,wu=lu.effectiveFilterHeight,Eu=lu.effectiveFilterWidth,Tu=lu.padInfo.top,Ru=lu.padInfo.left,Nu=t0(nu,ru,ou);for(let Pu=0;Pu<lu.batchSize;++Pu)for(let Fu=0;Fu<lu.inChannels;++Fu)for(let Gu=0;Gu<lu.outHeight;++Gu){const Xu=Gu*mu-Tu;let Qu=Xu;for(;Qu<0;)Qu+=bu;const Ju=Math.min(lu.inHeight,wu+Xu);for(let ip=0;ip<lu.outWidth;++ip){const rp=ip*Au-Ru;let op=rp;for(;op<0;)op+=Cu;const hp=Math.min(lu.inWidth,Eu+rp);let Ap=Number.NEGATIVE_INFINITY,Up=-1;for(let Vp=Qu;Vp<Ju;Vp+=bu){const zp=Vp-Xu;for(let qp=op;qp<hp;qp+=Cu){const Yp=qp-rp,em=Nu.get(Pu,Vp,qp,Fu);em>Ap&&(Ap=em,cu?Up=hu?((Pu*lu.inHeight+Vp)*lu.inWidth+qp)*lu.inChannels+Fu:(Vp*lu.inWidth+qp)*lu.inChannels+Fu:Up=zp*Eu+Yp)}}pu.set(Up,Pu,Gu,ip,Fu)}}return pu}function oD(ou,nu,ru,lu,cu,hu){const pu=cu.strideDepth,mu=cu.strideHeight,Au=cu.strideWidth,bu=cu.dilationDepth,Cu=cu.dilationHeight,wu=cu.dilationWidth,Eu=cu.effectiveFilterDepth,Tu=cu.effectiveFilterHeight,Ru=cu.effectiveFilterWidth,Nu=cu.padInfo.front,Pu=cu.padInfo.top,Fu=cu.padInfo.left,Gu=hu==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Xu=t0(cu.outShape,ru),Qu=Xu.values,Ju=cu.outShape[1]*cu.outShape[2]*cu.outShape[3]*cu.outShape[4],ip=cu.outShape[2]*cu.outShape[3]*cu.outShape[4],rp=cu.outShape[3]*cu.outShape[4],op=cu.outShape[4];for(let hp=0;hp<cu.batchSize;++hp){const Ap=hp*Ju,Up=hp*lu[0];for(let Vp=0;Vp<cu.inChannels;++Vp)for(let zp=0;zp<cu.outDepth;++zp){const qp=zp*pu-Nu;let Yp=qp;for(;Yp<0;)Yp+=bu;const em=Math.min(cu.inDepth,Eu+qp),am=Ap+zp*ip;for(let im=0;im<cu.outHeight;++im){const um=im*mu-Pu;let ym=um;for(;ym<0;)ym+=Cu;const pm=Math.min(cu.inHeight,Tu+um),bm=am+im*rp;for(let xm=0;xm<cu.outWidth;++xm){const wm=xm*Au-Fu;let Im=wm;for(;Im<0;)Im+=wu;const Wm=Math.min(cu.inWidth,Ru+wm),$m=bm+xm*op;let Hm=Gu,qm=0,Jm=0;for(let f0=Yp;f0<em;f0+=bu){const U0=Up+f0*lu[1];for(let B0=ym;B0<pm;B0+=Cu){const I0=U0+B0*lu[2];for(let T0=Im;T0<Wm;T0+=wu){const L0=I0+T0*lu[3],Z0=ou[L0+Vp];if(hu==="max"&&Z0>Hm?Hm=Z0:hu==="avg"&&(qm+=Z0,Jm++),isNaN(Hm))break}if(isNaN(Hm))break}if(isNaN(Hm))break}const a0=$m+Vp;Qu[a0]=hu==="avg"?qm/Math.max(Jm,1):Hm}}}}return Xu}function b9(ou,nu){const ru=t0(nu.outShape,"int32"),lu=nu.strideDepth,cu=nu.strideHeight,hu=nu.strideWidth,pu=nu.dilationDepth,mu=nu.dilationHeight,Au=nu.dilationWidth,bu=nu.effectiveFilterDepth,Cu=nu.effectiveFilterHeight,wu=nu.effectiveFilterWidth,Eu=nu.padInfo.front,Tu=nu.padInfo.top,Ru=nu.padInfo.left;for(let Nu=0;Nu<nu.batchSize;++Nu)for(let Pu=0;Pu<nu.inChannels;++Pu)for(let Fu=0;Fu<nu.outDepth;++Fu){const Gu=Fu*lu-Eu;let Xu=Gu;for(;Xu<0;)Xu+=pu;const Qu=Math.min(nu.inDepth,bu+Gu);for(let Ju=0;Ju<nu.outHeight;++Ju){const ip=Ju*cu-Tu;let rp=ip;for(;rp<0;)rp+=mu;const op=Math.min(nu.inHeight,Cu+ip);for(let hp=0;hp<nu.outWidth;++hp){const Ap=hp*hu-Ru;let Up=Ap;for(;Up<0;)Up+=Au;const Vp=Math.min(nu.inWidth,wu+Ap);let zp=Number.NEGATIVE_INFINITY,qp=-1;for(let Yp=Xu;Yp<Qu;Yp+=pu){const em=Yp-Gu;for(let am=rp;am<op;am+=mu){const im=am-ip;for(let um=Up;um<Vp;um+=Au){const ym=um-Ap,pm=ou.get(Nu,Yp,am,um,Pu);pm>=zp&&(zp=pm,qp=em*Cu*wu+im*Cu+ym)}}}ru.set(qp,Nu,Fu,Ju,hp,Pu)}}}return ru}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function x9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu;Pm(cu,"avgPool");const{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au}=lu,bu=1;vu(gy(pu,bu),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${pu} and dilations '${bu}'`);const Cu=ox(cu.shape,hu,pu,bu,mu,Au);let wu;if(Cu.filterWidth===1&&Cu.filterHeight===1&&ku(Cu.inShape,Cu.outShape))wu=Qx({inputs:{x:cu},backend:ru});else{const Eu=ru.data.get(cu.dataId).values,Tu=xp(cu.shape),Ru=DT(Eu,cu.shape,cu.dtype,Tu,Cu,"avg");wu=ru.makeTensorInfo(Cu.outShape,cu.dtype,Ru.values)}return wu}const v9={kernelName:fm,backendName:"cpu",kernelFunc:x9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function C9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au,dataFormat:bu}=lu;Pm(cu,"avgPool3d");const Cu=tv(cu.shape,hu,pu,1,mu,Au,bu),wu=ru.data.get(cu.dataId).values,Eu=oD(wu,cu.shape,cu.dtype,xp(cu.shape),Cu,"avg");return ru.makeTensorInfo(Eu.shape,"float32",Eu.values)}const w9={kernelName:pp,backendName:"cpu",kernelFunc:C9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function E9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu}=nu,{filterSize:pu,strides:mu,pad:Au,dimRoundingMode:bu}=lu;Pm([cu,hu],"avgPool3DGrad");const Cu=tv(hu.shape,pu,mu,1,Au,bu),wu=Cu.strideDepth,Eu=Cu.strideHeight,Tu=Cu.strideWidth,Ru=Cu.filterDepth,Nu=Cu.filterHeight,Pu=Cu.filterWidth,Fu=Cu.dilationDepth,Gu=Cu.dilationHeight,Xu=Cu.dilationWidth,Qu=Cu.effectiveFilterDepth,Ju=Cu.effectiveFilterHeight,ip=Cu.effectiveFilterWidth,rp=Qu-1-Cu.padInfo.front,op=ip-1-Cu.padInfo.left,hp=Ju-1-Cu.padInfo.top,Ap=t0(hu.shape,"float32"),Up=1/(Ru*Nu*Pu),Vp=ru.bufferSync(cu);for(let zp=0;zp<Cu.batchSize;++zp)for(let qp=0;qp<Cu.inChannels;++qp)for(let Yp=0;Yp<Cu.inDepth;++Yp)for(let em=0;em<Cu.inHeight;++em)for(let am=0;am<Cu.inWidth;++am){const im=Yp-rp,um=em-hp,ym=am-op;let pm=0;for(let bm=0;bm<Qu;bm+=Fu){const xm=(im+bm)/wu;if(!(xm<0||xm>=Cu.outDepth||Math.floor(xm)!==xm))for(let wm=0;wm<Ju;wm+=Gu){const Im=(um+wm)/Eu;if(!(Im<0||Im>=Cu.outHeight||Math.floor(Im)!==Im))for(let Wm=0;Wm<ip;Wm+=Xu){const $m=(ym+Wm)/Tu;if($m<0||$m>=Cu.outWidth||Math.floor($m)!==$m)continue;const Hm=Vp.get(zp,xm,Im,$m,qp);pm+=Hm}}}Ap.set(pm*Up,zp,Yp,em,am,qp)}return ru.makeTensorInfo(Ap.shape,Ap.dtype,Ap.values)}const S9={kernelName:Zp,backendName:"cpu",kernelFunc:E9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu}=nu,pu=hu;Pm([cu,hu],"avgPoolGrad");const{filterSize:mu,strides:Au,pad:bu}=lu,Cu=ox(pu.shape,mu,Au,1,bu),wu=Cu.strideHeight,Eu=Cu.strideWidth,Tu=Cu.filterHeight,Ru=Cu.filterWidth,Nu=Cu.dilationHeight,Pu=Cu.dilationWidth,Fu=Cu.effectiveFilterHeight,Gu=Cu.effectiveFilterWidth,Xu=Gu-1-Cu.padInfo.left,Qu=Fu-1-Cu.padInfo.top,Ju=t0(pu.shape,"float32"),ip=1/(Tu*Ru),rp=ru.data.get(cu.dataId).values,op=t0(cu.shape,"float32",rp);for(let hp=0;hp<Cu.batchSize;++hp)for(let Ap=0;Ap<Cu.inChannels;++Ap)for(let Up=0;Up<Cu.inHeight;++Up)for(let Vp=0;Vp<Cu.inWidth;++Vp){const zp=Up-Qu,qp=Vp-Xu;let Yp=0;for(let em=0;em<Fu;em+=Nu){const am=(zp+em)/wu;if(!(am<0||am>=Cu.outHeight||Math.floor(am)!==am))for(let im=0;im<Gu;im+=Pu){const um=(qp+im)/Eu;if(um<0||um>=Cu.outWidth||Math.floor(um)!==um)continue;const ym=op.get(hp,am,um,Ap);Yp+=ym}}Ju.set(Yp*ip,hp,Up,Vp,Ap)}return ru.makeTensorInfo(Ju.shape,Ju.dtype,Ju.values)}const T9={kernelName:Gm,backendName:"cpu",kernelFunc:I9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,scale:hu,offset:pu,mean:mu,variance:Au}=nu;vu(mu.shape.length===Au.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),vu(pu==null||mu.shape.length===pu.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),vu(hu==null||mu.shape.length===hu.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Pm([cu,mu,Au,hu,pu],"batchNorm");let{varianceEpsilon:bu}=lu;bu==null&&(bu=.001);const Cu=ru.data.get(cu.dataId).values,wu=ru.data.get(mu.dataId).values,Eu=ru.data.get(Au.dataId).values,Tu=hu?ru.data.get(hu.dataId).values:new Float32Array([1]),Ru=pu?ru.data.get(pu.dataId).values:new Float32Array([0]),Nu=new Float32Array(Cu.length),Pu=Ru.length,Fu=Tu.length,Gu=Eu.length,Xu=wu.length;let Qu=0,Ju=0,ip=0,rp=0;for(let op=0;op<Cu.length;++op)Nu[op]=Ru[Qu++]+(Cu[op]-wu[Ju++])*Tu[ip++]/Math.sqrt(Eu[rp++]+bu),Qu>=Pu&&(Qu=0),Ju>=Xu&&(Ju=0),ip>=Fu&&(ip=0),rp>=Gu&&(rp=0);return ru.makeTensorInfo(cu.shape,cu.dtype,Nu)}const M9={kernelName:Um,backendName:"cpu",kernelFunc:_9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function R9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{blockShape:hu,crops:pu}=lu;Pm([cu],"batchToSpaceND");const mu=hu.reduce((Fu,Gu)=>Fu*Gu),Au=fw(cu.shape,hu,mu),bu=mw(Au.length,hu.length),Cu=gw(cu.shape,hu,mu),wu=TI(pu,hu.length),Eu=_I(Cu,pu,hu.length),Tu=S0({inputs:{x:cu},backend:ru,attrs:{shape:Au}}),Ru=Fy({inputs:{x:Tu},backend:ru,attrs:{perm:bu}}),Nu=S0({inputs:{x:Ru},backend:ru,attrs:{shape:Cu}}),Pu=w1({inputs:{x:Nu},backend:ru,attrs:{begin:wu,size:Eu}});return ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),ru.disposeIntermediateTensorInfo(Nu),Pu}const k9={kernelName:Mm,backendName:"cpu",kernelFunc:R9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function B9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,weights:hu}=nu,{size:pu}=lu,mu=ru.data.get(cu.dataId).values,Au=ru.data.get(hu.dataId).values,bu=RT(mu,Au,hu.dtype,hu.shape,pu);return ru.makeTensorInfo([pu],hu.dtype,bu)}const L9={kernelName:Tm,backendName:"cpu",kernelFunc:B9};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N9(ou){const{inputs:nu,backend:ru}=ou,{s0:lu,s1:cu}=nu,hu=ru.data.get(lu.dataId).values,pu=ru.data.get(cu.dataId).values,mu=_g(Array.from(hu),Array.from(pu));return ru.makeTensorInfo([mu.length],"int32",Int32Array.from(mu))}const D9={kernelName:Rm,backendName:"cpu",kernelFunc:N9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const F9=b0(i0,(ou,nu)=>{const ru=nu;return ou>ru.clipValueMax?ru.clipValueMax:ou<ru.clipValueMin?ru.clipValueMin:ou}),P9={kernelName:i0,backendName:"cpu",kernelFunc:F9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G9={kernelName:pv,backendName:"cpu",kernelFunc:ou=>{const{x:nu}=ou.inputs,ru=ou.backend,lu=new Float32Array(Mu(nu.shape)),cu=ru.data.get(nu.dataId),hu=cu.complexTensorInfos.real,pu=cu.complexTensorInfos.imag,mu=ru.data.get(hu.dataId).values,Au=ru.data.get(pu.dataId).values;for(let bu=0;bu<mu.length;bu++){const Cu=mu[bu],wu=Au[bu];lu[bu]=Math.hypot(Cu,wu)}return ru.makeOutput(lu,nu.shape,"float32")}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aC(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu,cu=ru.data.get(lu.dataId).complexTensorInfos.imag,hu=ru.data.get(cu.dataId).values;return ru.makeTensorInfo(cu.shape,cu.dtype,hu)}const O9={kernelName:m0,backendName:"cpu",kernelFunc:aC};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lC(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{axis:cu}=lu,hu=Wu(cu,nu[0].shape)[0],pu=nu.map(Nu=>Nu.shape);EI(pu,hu);let mu=$x(nu.map(Nu=>Nu.shape),hu);if(Mu(mu)===0)return ru.makeTensorInfo(mu,nu[0].dtype,[]);const Au=nu.filter(Nu=>Mu(Nu.shape)>0);if(Au.length===1)return Qx({inputs:{x:Au[0]},backend:ru});if(Au[0].dtype==="complex64"){const Nu=Au.map(Qu=>v1({inputs:{input:Qu},backend:ru})),Pu=Au.map(Qu=>aC({inputs:{input:Qu},backend:ru})),Fu=lC({inputs:Nu,backend:ru,attrs:{axis:hu}}),Gu=lC({inputs:Pu,backend:ru,attrs:{axis:hu}}),Xu=zy({inputs:{real:Fu,imag:Gu},backend:ru});return Nu.forEach(Qu=>ru.disposeIntermediateTensorInfo(Qu)),Pu.forEach(Qu=>ru.disposeIntermediateTensorInfo(Qu)),ru.disposeIntermediateTensorInfo(Fu),ru.disposeIntermediateTensorInfo(Gu),Xu}const bu=Au.map(Nu=>{const Pu=[-1,Mu(Nu.shape.slice(hu))];return S0({inputs:{x:Nu},backend:ru,attrs:{shape:Pu}})}),Cu=bu.map(Nu=>({vals:ru.data.get(Nu.dataId).values,shape:Nu.shape}));mu=$x(bu.map(Nu=>Nu.shape),1);const wu=bu[0].shape[0]===1,Eu=a3(Cu,mu,nu[0].dtype,wu),Tu=$x(Au.map(Nu=>Nu.shape),hu),Ru=ru.makeTensorInfo(Tu,nu[0].dtype,Eu);return bu.forEach(Nu=>ru.disposeIntermediateTensorInfo(Nu)),Ru}const U9={kernelName:L1,backendName:"cpu",kernelFunc:lC};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dataFormat:Au,dilations:bu,dimRoundingMode:Cu}=lu;Pm([cu,hu],"conv2d");const wu=nv(Au),Eu=hy(cu.shape,hu.shape,pu,bu,mu,Cu,!1,wu),Tu=Eu.filterHeight,Ru=Eu.filterWidth,Nu=Eu.dilationHeight,Pu=Eu.dilationWidth,Fu=Eu.padInfo.left,Gu=Eu.padInfo.top,Xu=Eu.dataFormat==="channelsLast",Qu=new uy(Eu.outShape,cu.dtype),Ju=xp(cu.shape),ip=xp(hu.shape),rp=Ju[0],op=Xu?Ju[1]:Ju[2],hp=Xu?Ju[2]:1,Ap=Xu?1:Ju[1],Up=Qu.strides[0],Vp=Xu?Qu.strides[1]:Qu.strides[2],zp=Xu?Qu.strides[2]:1,qp=Xu?1:Qu.strides[1],Yp=ru.data.get(cu.dataId).values,em=ru.data.get(hu.dataId).values,am=Qu.values;for(let im=0;im<Eu.batchSize;++im){const um=im*rp,ym=im*Up;for(let pm=0;pm<Eu.outHeight;++pm){const bm=ym+pm*Vp,xm=pm*Eu.strideHeight-Gu;for(let wm=0;wm<Tu;++wm){const Im=xm+wm*Nu;if(Im<0||Im>=Eu.inHeight)continue;const Wm=wm*ip[0],$m=um+Im*op;for(let Hm=0;Hm<Eu.outWidth;++Hm){const qm=bm+Hm*zp,Jm=Hm*Eu.strideWidth-Fu;for(let a0=0;a0<Ru;++a0){const f0=Jm+a0*Pu;if(f0<0||f0>=Eu.inWidth)continue;const U0=Wm+a0*ip[1],B0=$m+f0*hp;let I0=U0;for(let T0=0;T0<Eu.inChannels;++T0){const L0=Yp[B0+T0*Ap];for(let Z0=0;Z0<Eu.outChannels;++Z0)am[qm+Z0*qp]+=L0*em[I0+Z0];I0+=Eu.outChannels}}}}}}return ru.makeTensorInfo(Qu.shape,Qu.dtype,am)}const $9={kernelName:zv,backendName:"cpu",kernelFunc:aD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function V9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,dy:hu}=nu,{strides:pu,pad:mu,dataFormat:Au,dimRoundingMode:bu,filterShape:Cu}=lu;Pm([cu,hu],"conv2dBackpropFilter");const wu=nv(Au),Eu=hy(cu.shape,Cu,pu,1,mu,bu,!1,wu),{strideHeight:Tu,strideWidth:Ru,filterHeight:Nu,filterWidth:Pu}=Eu,Fu=Eu.dataFormat==="channelsLast",Gu=new uy(Eu.filterShape,"float32"),Xu=Eu.padInfo.left,Qu=Eu.padInfo.top,Ju=ru.data.get(cu.dataId).values,ip=ru.data.get(hu.dataId).values,rp=new uy(cu.shape,cu.dtype,Ju),op=new uy(hu.shape,hu.dtype,ip);for(let hp=0;hp<Nu;++hp){const Ap=Math.max(0,Math.ceil((Qu-hp)/Tu)),Up=Math.min(Eu.outHeight,(Eu.inHeight+Qu-hp)/Tu);for(let Vp=0;Vp<Pu;++Vp){const zp=Math.max(0,Math.ceil((Xu-Vp)/Ru)),qp=Math.min(Eu.outWidth,(Eu.inWidth+Xu-Vp)/Ru);for(let Yp=0;Yp<Eu.inChannels;++Yp)for(let em=0;em<Eu.outChannels;++em){let am=0;for(let im=0;im<Eu.batchSize;++im)for(let um=Ap;um<Up;++um){const ym=hp+um*Tu-Qu;for(let pm=zp;pm<qp;++pm){const bm=Vp+pm*Ru-Xu;Fu?am+=rp.get(im,ym,bm,Yp)*op.get(im,um,pm,em):am+=rp.get(im,Yp,ym,bm)*op.get(im,em,um,pm)}}Gu.set(am,hp,Vp,Yp,em)}}}return ru.makeTensorInfo(Gu.shape,Gu.dtype,Gu.values)}const z9={kernelName:N1,backendName:"cpu",kernelFunc:V9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function W9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,filter:hu}=nu,{inputShape:pu,strides:mu,pad:Au,dataFormat:bu,dimRoundingMode:Cu}=lu;Pm([cu,hu],"conv2dBackpropInput");const wu=xp(hu.shape),Eu=xp(cu.shape);let Tu=nv(bu);const Ru=hy(pu,hu.shape,mu,1,Au,Cu,!1,Tu),Nu=new uy(Ru.inShape,"float32"),Pu=Nu.values,Fu=ru.data.get(cu.dataId).values,Gu=ru.data.get(hu.dataId).values,[Xu,Qu,Ju]=wu,{batchSize:ip,filterHeight:rp,filterWidth:op,inChannels:hp,inHeight:Ap,inWidth:Up,outChannels:Vp,outHeight:zp,outWidth:qp,strideHeight:Yp,strideWidth:em}=Ru;Tu=Ru.dataFormat;const am=rp-1-Ru.padInfo.top,im=op-1-Ru.padInfo.left,um=Tu==="channelsLast",ym=Nu.strides[0],pm=um?Nu.strides[1]:Nu.strides[2],bm=um?Nu.strides[2]:1,xm=um?1:Nu.strides[1],wm=Eu[0],Im=um?Eu[1]:Eu[2],Wm=um?Eu[2]:1,$m=um?1:Eu[1];for(let Hm=0;Hm<ip;++Hm)for(let qm=0;qm<hp;++qm)for(let Jm=0;Jm<Ap;++Jm){const a0=Jm-am,f0=Math.max(0,Math.ceil(a0/Yp)),U0=Math.min(zp,(rp+a0)/Yp);for(let B0=0;B0<Up;++B0){const I0=B0-im,T0=Math.max(0,Math.ceil(I0/em)),L0=Math.min(qp,(op+I0)/em);let Z0=0;for(let Ty=f0;Ty<U0;++Ty){const dv=Ty*Yp-a0;for(let ex=T0;ex<L0;++ex){const qx=ex*em-I0,$v=wm*Hm+Im*Ty+Wm*ex,Jx=Xu*(rp-1-dv)+Qu*(op-1-qx)+Ju*qm;for(let Bx=0;Bx<Vp;++Bx){const Vv=Fu[$v+$m*Bx],Zw=Gu[Jx+Bx];Z0+=Vv*Zw}}}const hv=ym*Hm+pm*Jm+bm*B0+xm*qm;Pu[hv]=Z0}}return ru.makeTensorInfo(Nu.shape,Nu.dtype,Nu.values)}const H9={kernelName:tx,backendName:"cpu",kernelFunc:W9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function X9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dilations:Au}=lu;Pm([cu,hu],"conv3d");const bu=wv(cu.shape,hu.shape,pu,Au,mu),{filterDepth:Cu,filterHeight:wu,filterWidth:Eu,dilationDepth:Tu,dilationHeight:Ru,dilationWidth:Nu,padInfo:Pu}=bu,Fu=Pu.front,Gu=Pu.left,Xu=Pu.top,Qu=new uy(bu.outShape,cu.dtype),Ju=ru.data.get(cu.dataId).values,ip=ru.data.get(hu.dataId).values,rp=Qu.values,op=xp(cu.shape),hp=xp(hu.shape);for(let Ap=0;Ap<bu.batchSize;++Ap){const Up=Ap*op[0],Vp=Ap*Qu.strides[0];for(let zp=0;zp<bu.outDepth;++zp){const qp=Vp+zp*Qu.strides[1],Yp=zp*bu.strideDepth-Fu;for(let em=0;em<Cu;++em){const am=Yp+em*Tu;if(am<0||am>=bu.inDepth)continue;const im=em*hp[0],um=Up+am*op[1];for(let ym=0;ym<bu.outHeight;++ym){const pm=qp+ym*Qu.strides[2],bm=ym*bu.strideHeight-Xu;for(let xm=0;xm<wu;++xm){const wm=bm+xm*Ru;if(wm<0||wm>=bu.inHeight)continue;const Im=im+xm*hp[1],Wm=um+wm*op[2];for(let $m=0;$m<bu.outWidth;++$m){const Hm=pm+$m*bu.outChannels,qm=$m*bu.strideWidth-Gu;for(let Jm=0;Jm<Eu;++Jm){const a0=qm+Jm*Nu;if(a0<0||a0>=bu.inWidth)continue;const f0=Im+Jm*hp[2],U0=Wm+a0*bu.inChannels;let B0=f0;for(let I0=0;I0<bu.inChannels;++I0){const T0=Ju[U0+I0];for(let L0=0;L0<bu.outChannels;++L0)rp[Hm+L0]+=T0*ip[B0+L0];B0+=bu.outChannels}}}}}}}}return ru.makeTensorInfo(Qu.shape,Qu.dtype,Qu.values)}const Q9={kernelName:fv,backendName:"cpu",kernelFunc:X9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function K9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,dy:hu}=nu,{strides:pu,pad:mu,filterShape:Au}=lu;Pm([cu,hu],"conv3dBackpropFilterV2");const bu=xp(cu.shape),Cu=xp(hu.shape),wu=wv(cu.shape,Au,pu,1,mu),Eu=wu.strideDepth,Tu=wu.strideHeight,Ru=wu.strideWidth,Nu=wu.filterDepth,Pu=wu.filterHeight,Fu=wu.filterWidth,Gu=new uy(wu.filterShape,"float32"),Xu=Gu.values,[Qu,Ju,ip,rp]=Gu.strides,op=ru.data.get(hu.dataId).values,[hp,Ap,Up,Vp]=Cu,zp=ru.data.get(cu.dataId).values,[qp,Yp,em,am]=bu,im=wu.padInfo.front,um=wu.padInfo.left,ym=wu.padInfo.top;for(let pm=0;pm<Nu;++pm){const bm=Math.max(0,Math.ceil((im-pm)/Eu)),xm=Math.min(wu.outDepth,(wu.inDepth+im-pm)/Eu),wm=pm*Qu;for(let Im=0;Im<Pu;++Im){const Wm=Math.max(0,Math.ceil((ym-Im)/Tu)),$m=Math.min(wu.outHeight,(wu.inHeight+ym-Im)/Tu),Hm=Im*Ju+wm;for(let qm=0;qm<Fu;++qm){const Jm=Math.max(0,Math.ceil((um-qm)/Ru)),a0=Math.min(wu.outWidth,(wu.inWidth+um-qm)/Ru),f0=qm*ip+Hm;for(let U0=0;U0<wu.inChannels;++U0){const B0=U0*rp+f0;for(let I0=0;I0<wu.outChannels;++I0){let T0=0;for(let L0=0;L0<wu.batchSize;++L0){const Z0=L0*qp,hv=L0*hp;for(let Ty=bm;Ty<xm;++Ty){const dv=(pm+Ty*Eu-im)*Yp+Z0,ex=Ty*Ap+hv;for(let qx=Wm;qx<$m;++qx){const $v=(Im+qx*Tu-ym)*em+dv,Jx=qx*Up+ex;for(let Bx=Jm;Bx<a0;++Bx){const Vv=(qm+Bx*Ru-um)*am+$v,Zw=Bx*Vp+Jx;T0+=zp[Vv+U0]*op[Zw+I0]}}}}Xu[B0+I0]=T0}}}}}return ru.makeTensorInfo(Gu.shape,Gu.dtype,Gu.values)}const Z9={kernelName:Wv,backendName:"cpu",kernelFunc:K9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function j9(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,filter:hu}=nu,{pad:pu,strides:mu,inputShape:Au}=lu;Pm([cu],"conv3dBackpropInputV2");const bu=xp(cu.shape),Cu=xp(hu.shape),wu=wv(Au,hu.shape,mu,1,pu),Eu=new uy(wu.inShape,"float32"),Tu=Eu.values,[Ru,Nu,Pu,Fu]=Eu.strides,Gu=ru.data.get(cu.dataId).values,[Xu,Qu,Ju,ip]=bu,rp=ru.data.get(hu.dataId).values,[op,hp,Ap,Up]=Cu,{batchSize:Vp,filterDepth:zp,filterHeight:qp,filterWidth:Yp,inChannels:em,inDepth:am,inHeight:im,inWidth:um,outChannels:ym,outDepth:pm,outHeight:bm,outWidth:xm,strideDepth:wm,strideHeight:Im,strideWidth:Wm}=wu,$m=zp-1-wu.padInfo.front,Hm=qp-1-wu.padInfo.top,qm=Yp-1-wu.padInfo.left;for(let Jm=0;Jm<Vp;++Jm)for(let a0=0;a0<em;++a0)for(let f0=0;f0<am;++f0){const U0=f0-$m,B0=Math.max(0,Math.ceil(U0/wm)),I0=Math.min(pm,(zp+U0)/wm);for(let T0=0;T0<im;++T0){const L0=T0-Hm,Z0=Math.max(0,Math.ceil(L0/Im)),hv=Math.min(bm,(qp+L0)/Im);for(let Ty=0;Ty<um;++Ty){const dv=Ty-qm,ex=Math.max(0,Math.ceil(dv/Wm)),qx=Math.min(xm,(Yp+dv)/Wm);let $v=0;for(let Jx=B0;Jx<I0;++Jx){const Bx=Jx*wm-U0;for(let Vv=Z0;Vv<hv;++Vv){const Zw=Vv*Im-L0;for(let Y2=ex;Y2<qx;++Y2){const Gae=Y2*Wm-dv,Oae=Xu*Jm+Qu*Jx+Ju*Vv+ip*Y2,Uae=op*(zp-1-Bx)+hp*(qp-1-Zw)+Ap*(Yp-1-Gae)+Up*a0;for(let q2=0;q2<ym;++q2){const $ae=Gu[Oae+q2],Vae=rp[Uae+q2];$v+=$ae*Vae}}}}Tu[Ru*Jm+Nu*f0+Pu*T0+Fu*Ty+a0]=$v}}}return ru.makeTensorInfo(Eu.shape,Eu.dtype,Eu.values)}const Y9={kernelName:D1,backendName:"cpu",kernelFunc:j9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const q9=b0(Lx,ou=>Math.cos(ou)),J9={kernelName:Lx,backendName:"cpu",kernelFunc:q9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eQ=b0(mv,ou=>Math.cosh(ou)),tQ={kernelName:mv,backendName:"cpu",kernelFunc:eQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{image:cu,boxes:hu,boxInd:pu}=nu,{cropSize:mu,method:Au,extrapolationValue:bu}=lu,[Cu,wu,Eu,Tu]=cu.shape,Ru=hu.shape[0],[Nu,Pu]=mu,Fu=t0([Ru,Nu,Pu,Tu],"float32"),Gu=ru.data.get(hu.dataId).values,Xu=ru.data.get(pu.dataId).values,Qu=ru.data.get(cu.dataId).values,Ju=xp(cu.shape),ip=xp(Fu.shape);for(let rp=0;rp<Ru;rp++){const op=rp*4,hp=Gu[op],Ap=Gu[op+1],Up=Gu[op+2],Vp=Gu[op+3],zp=Xu[rp];if(zp>=Cu)continue;const qp=Nu>1?(Up-hp)*(wu-1)/(Nu-1):0,Yp=Pu>1?(Vp-Ap)*(Eu-1)/(Pu-1):0;for(let em=0;em<Nu;em++){const am=Nu>1?hp*(wu-1)+em*qp:.5*(hp+Up)*(wu-1);if(am<0||am>wu-1){for(let im=0;im<Pu;im++)for(let um=0;um<Tu;um++){const ym=um+im*ip[2]+em*ip[1]+rp*ip[0];Fu.values[ym]=bu}continue}if(Au==="bilinear"){const im=Math.floor(am),um=Math.ceil(am),ym=am-im;for(let pm=0;pm<Pu;pm++){const bm=Pu>1?Ap*(Eu-1)+pm*Yp:.5*(Ap+Vp)*(Eu-1);if(bm<0||bm>Eu-1){for(let Wm=0;Wm<Tu;Wm++){const $m=Wm+pm*ip[2]+em*ip[1]+rp*ip[0];Fu.values[$m]=bu}continue}const xm=Math.floor(bm),wm=Math.ceil(bm),Im=bm-xm;for(let Wm=0;Wm<Tu;Wm++){let $m=Wm+xm*Ju[2]+im*Ju[1]+zp*Ju[0];const Hm=Qu[$m];$m=Wm+wm*Ju[2]+im*Ju[1]+zp*Ju[0];const qm=Qu[$m];$m=Wm+xm*Ju[2]+um*Ju[1]+zp*Ju[0];const Jm=Qu[$m];$m=Wm+wm*Ju[2]+um*Ju[1]+zp*Ju[0];const a0=Qu[$m],f0=Hm+(qm-Hm)*Im,U0=Jm+(a0-Jm)*Im;$m=Wm+pm*ip[2]+em*ip[1]+rp*ip[0],Fu.values[$m]=f0+(U0-f0)*ym}}}else for(let im=0;im<Pu;++im){const um=Pu>1?Ap*(Eu-1)+im*Yp:.5*(Ap+Vp)*(Eu-1);if(um<0||um>Eu-1){for(let bm=0;bm<Tu;bm++){const xm=bm+im*ip[2]+em*ip[1]+rp*ip[0];Fu.values[xm]=bu}continue}const ym=Math.round(um),pm=Math.round(am);for(let bm=0;bm<Tu;bm++){const xm=bm+ym*Ju[2]+pm*Ju[1]+zp*Ju[0],wm=bm+im*ip[2]+em*ip[1]+rp*ip[0];Fu.values[wm]=Qu[xm]}}}}return ru.makeTensorInfo(Fu.shape,Fu.dtype,Fu.values)}const iQ={kernelName:F1,backendName:"cpu",kernelFunc:nQ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,exclusive:pu,reverse:mu}=lu;Pm(cu,"cumprod");const Au=G0([hu],cu.shape.length);let bu=cu;Au!=null&&(bu=Fy({inputs:{x:cu},backend:ru,attrs:{perm:Au}}));const Cu=H0(1,cu.shape.length)[0];if(Cu!==bu.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${bu.shape.length-1} but got axis=${Cu}`);const wu=Uy(bu.dtype,"int32"),Eu=bp(Mu(bu.shape),wu),Tu=ru.data.get(bu.dataId).values,Ru=bu.shape[bu.shape.length-1],Nu=mu?(Fu,Gu)=>Fu+Ru-Gu-1:(Fu,Gu)=>Fu+Gu;for(let Fu=0;Fu<Tu.length;Fu+=Ru)for(let Gu=0;Gu<Ru;Gu++){const Xu=Nu(Fu,Gu);if(Gu===0)Eu[Xu]=pu?1:Tu[Xu];else{const Qu=Nu(Fu,Gu-1);Eu[Xu]=pu?Tu[Qu]*Eu[Qu]:Tu[Xu]*Eu[Qu]}}const Pu=ru.makeTensorInfo(bu.shape,wu,Eu);if(Au!=null){const Fu=Ev(Au),Gu=Fy({inputs:{x:Pu},backend:ru,attrs:{perm:Fu}});return ru.disposeIntermediateTensorInfo(Pu),ru.disposeIntermediateTensorInfo(bu),Gu}return Pu}const sQ={kernelName:gv,backendName:"cpu",kernelFunc:rQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,exclusive:pu,reverse:mu}=lu;Pm(cu,"cumsum");const Au=G0([hu],cu.shape.length);let bu=cu;Au!=null&&(bu=Fy({inputs:{x:cu},backend:ru,attrs:{perm:Au}}));const Cu=H0(1,cu.shape.length)[0];if(Cu!==bu.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${bu.shape.length-1} but got axis=${Cu}`);const wu=Uy(bu.dtype,"int32"),Eu=kp(Mu(bu.shape),wu),Tu=ru.data.get(bu.dataId).values,Ru=bu.shape[bu.shape.length-1],Nu=mu?(Fu,Gu)=>Fu+Ru-Gu-1:(Fu,Gu)=>Fu+Gu;for(let Fu=0;Fu<Tu.length;Fu+=Ru)for(let Gu=0;Gu<Ru;Gu++){const Xu=Nu(Fu,Gu);if(Gu===0)Eu[Xu]=pu?0:Tu[Xu];else{const Qu=Nu(Fu,Gu-1);Eu[Xu]=pu?Tu[Qu]+Eu[Qu]:Tu[Xu]+Eu[Qu]}}const Pu=ru.makeTensorInfo(bu.shape,wu,Eu);if(Au!=null){const Fu=Ev(Au),Gu=Fy({inputs:{x:Pu},backend:ru,attrs:{perm:Fu}});return ru.disposeIntermediateTensorInfo(Pu),ru.disposeIntermediateTensorInfo(bu),Gu}return Pu}const aQ={kernelName:Hv,backendName:"cpu",kernelFunc:oQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,weights:hu}=nu,{size:pu,binaryOutput:mu}=lu;if(cu.shape.length===1){const Au=ru.data.get(cu.dataId).values,bu=ru.data.get(hu.dataId).values,Cu=RT(Au,bu,hu.dtype,hu.shape,pu);return ru.makeTensorInfo([pu],hu.dtype,Cu)}else if(cu.shape.length===2){const Au=ru.bufferSync(cu),bu=ru.bufferSync(hu),Cu=r3(Au,bu,pu,mu);return ru.makeTensorInfo(Cu.shape,hu.dtype,Cu.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${cu.shape.length}.`)}const cQ={kernelName:CC,backendName:"cpu",kernelFunc:lQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{blockSize:hu,dataFormat:pu}=lu;vu(pu==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${pu}`);const mu=cu.shape[0],Au=cu.shape[1],bu=cu.shape[2],Cu=cu.shape[3],wu=Au*hu,Eu=bu*hu,Tu=Cu/(hu*hu),Ru=ru.data.get(cu.dataId).values,Nu=new Float32Array(mu*wu*Eu*Tu);let Pu=0;for(let Fu=0;Fu<mu;++Fu)for(let Gu=0;Gu<wu;++Gu){const Xu=Math.floor(Gu/hu),Qu=Gu%hu;for(let Ju=0;Ju<Eu;++Ju){const ip=Math.floor(Ju/hu),rp=Ju%hu,op=(Qu*hu+rp)*Tu;for(let hp=0;hp<Tu;++hp){const Ap=hp+op+Cu*(ip+bu*(Xu+Au*Fu));Nu[Pu++]=Ru[Ap]}}}return ru.makeTensorInfo([mu,wu,Eu,Tu],cu.dtype,Nu)}const hQ={kernelName:wC,backendName:"cpu",kernelFunc:uQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dilations:Au,dimRoundingMode:bu}=lu;Pm([cu,hu],"depthwiseConv2DNative");const Cu=xp(cu.shape),wu=xp(hu.shape);let Eu=Au;Eu==null&&(Eu=[1,1]),vu(gy(pu,Eu),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${pu} and dilations '${Eu}'`);const Tu=hy(cu.shape,hu.shape,pu,Eu,mu,bu,!0),{filterHeight:Ru,filterWidth:Nu,dilationHeight:Pu,dilationWidth:Fu,padInfo:Gu}=Tu,Xu=Gu.left,Qu=Gu.top,Ju=Tu.outChannels/Tu.inChannels,ip=new uy(Tu.outShape,cu.dtype),rp=ru.data.get(cu.dataId).values,op=ru.data.get(hu.dataId).values,hp=ip.values;for(let Ap=0;Ap<Tu.batchSize;++Ap){const Up=Ap*Cu[0],Vp=Ap*ip.strides[0];for(let zp=0;zp<Tu.outHeight;++zp){const qp=Vp+zp*ip.strides[1],Yp=zp*Tu.strideHeight-Qu;for(let em=0;em<Ru;++em){const am=Yp+em*Pu;if(am<0||am>=Tu.inHeight)continue;const im=em*wu[0],um=Up+am*Cu[1];for(let ym=0;ym<Tu.outWidth;++ym){const pm=qp+ym*ip.strides[2],bm=ym*Tu.strideWidth-Xu;for(let xm=0;xm<Nu;++xm){const wm=bm+xm*Fu;if(wm<0||wm>=Tu.inWidth)continue;const Im=im+xm*wu[1],Wm=um+wm*Tu.inChannels;let $m=pm,Hm=Im;for(let qm=0;qm<Tu.inChannels;++qm){const Jm=rp[Wm+qm];for(let a0=0;a0<Ju;++a0)hp[$m+a0]+=Jm*op[Hm+a0];$m+=Ju,Hm+=Ju}}}}}}return ru.makeTensorInfo(ip.shape,ip.dtype,ip.values)}const dQ={kernelName:P1,backendName:"cpu",kernelFunc:lD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,dy:hu}=nu,{strides:pu,dilations:mu,pad:Au,dimRoundingMode:bu,filterShape:Cu}=lu;Pm([cu,hu],"depthwiseConv2dNativeBackpropFilter");const wu=hy(cu.shape,Cu,pu,mu,Au,bu,!0),{strideHeight:Eu,strideWidth:Tu,filterHeight:Ru,filterWidth:Nu}=wu,Pu=new uy(wu.filterShape,"float32"),Fu=wu.padInfo.left,Gu=wu.padInfo.top,Xu=wu.outChannels/wu.inChannels,Qu=ru.data.get(cu.dataId).values,Ju=new uy(cu.shape,cu.dtype,Qu),ip=ru.data.get(hu.dataId).values,rp=new uy(hu.shape,hu.dtype,ip);for(let op=0;op<Ru;++op){const hp=Math.max(0,Math.ceil((Gu-op)/Eu)),Ap=Math.min(wu.outHeight,(wu.inHeight+Gu-op)/Eu);for(let Up=0;Up<Nu;++Up){const Vp=Math.max(0,Math.ceil((Fu-Up)/Tu)),zp=Math.min(wu.outWidth,(wu.inWidth+Fu-Up)/Tu);for(let qp=0;qp<wu.outChannels;++qp){const Yp=Math.trunc(qp/Xu),em=qp%Xu;let am=0;for(let im=0;im<wu.batchSize;++im)for(let um=hp;um<Ap;++um){const ym=op+um*Eu-Gu;for(let pm=Vp;pm<zp;++pm){const bm=Up+pm*Tu-Fu;am+=Ju.get(im,ym,bm,Yp)*rp.get(im,um,pm,qp)}}Pu.set(am,op,Up,Yp,em)}}}return ru.makeTensorInfo(Pu.shape,Pu.dtype,Pu.values)}const fQ={kernelName:EC,backendName:"cpu",kernelFunc:pQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,filter:hu}=nu,{strides:pu,dilations:mu,pad:Au,dimRoundingMode:bu,inputShape:Cu}=lu;Pm([cu,hu],"depthwiseConv2DNativeBackpropInput");const wu=xp(cu.shape),Eu=xp(hu.shape),Tu=hy(Cu,hu.shape,pu,mu,Au,bu,!0),Ru=new uy(Tu.inShape,"float32"),Nu=Ru.values,[Pu,Fu,Gu]=Ru.strides,Xu=ru.data.get(cu.dataId).values,[Qu,Ju,ip]=wu,rp=ru.data.get(hu.dataId).values,[op,hp,Ap]=Eu,{batchSize:Up,filterHeight:Vp,filterWidth:zp,inChannels:qp,inHeight:Yp,inWidth:em,outChannels:am,outHeight:im,outWidth:um,strideHeight:ym,strideWidth:pm}=Tu,bm=Vp-1-Tu.padInfo.top,xm=zp-1-Tu.padInfo.left,wm=am/qp;for(let Im=0;Im<Up;++Im)for(let Wm=0;Wm<qp;++Wm)for(let $m=0;$m<Yp;++$m){const Hm=$m-bm,qm=Math.max(0,Math.ceil(Hm/ym)),Jm=Math.min(im,(Vp+Hm)/ym);for(let a0=0;a0<em;++a0){const f0=a0-xm,U0=Math.max(0,Math.ceil(f0/pm)),B0=Math.min(um,(zp+f0)/pm);let I0=0;for(let T0=qm;T0<Jm;++T0){const L0=T0*ym-Hm;for(let Z0=U0;Z0<B0;++Z0){const hv=Z0*pm-f0,Ty=Qu*Im+Ju*T0+ip*Z0,dv=op*(Vp-1-L0)+hp*(zp-1-hv)+Ap*Wm;for(let ex=0;ex<wm;++ex){const qx=Wm*wm+ex,$v=Xu[Ty+qx],Jx=rp[dv+ex];I0+=$v*Jx}}}Nu[Pu*Im+Fu*$m+Gu*a0+Wm]=I0}}return ru.makeTensorInfo(Ru.shape,Ru.dtype,Ru.values)}const gQ={kernelName:SC,backendName:"cpu",kernelFunc:mQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AQ(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu,cu=Mu(lu.shape),hu=ru.data.get(lu.dataId).values,pu=t0([cu,cu],lu.dtype),mu=pu.values;for(let bu=0;bu<hu.length;bu++)mu[bu*cu+bu]=hu[bu];const Au=[...lu.shape,...lu.shape];return ru.makeTensorInfo(Au,pu.dtype,pu.values)}const yQ={kernelName:jw,backendName:"cpu",kernelFunc:AQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bQ={kernelName:np,backendName:"cpu",kernelFunc:({inputs:ou,backend:nu,attrs:ru})=>{const{x:lu,filter:cu}=ou,{strides:hu,pad:pu,dilations:mu}=ru,Au=nu,bu=Au.data.get(lu.dataId).values,Cu=lu.shape.length,wu=Au.data.get(cu.dataId).values,Eu=cu.shape.length,{batchSize:Tu,inHeight:Ru,inWidth:Nu,inChannels:Pu,outHeight:Fu,outWidth:Gu,padInfo:Xu,strideHeight:Qu,strideWidth:Ju,filterHeight:ip,filterWidth:rp,dilationHeight:op,dilationWidth:hp,outShape:Ap}=iw(lu.shape,cu.shape,hu,pu,"NHWC",mu),Up=Mu(Ap),Vp=Ap.length,zp=Yu(lu.dtype,Up);for(let qp=0;qp<Tu;++qp)for(let Yp=0;Yp<Fu;++Yp){const em=Yp*Qu-Xu.top;for(let am=0;am<Gu;++am){const im=am*Ju-Xu.left;for(let um=0;um<Pu;++um){let ym=Number.MIN_SAFE_INTEGER;for(let bm=0;bm<ip;++bm){const xm=em+bm*op;if(xm>=0&&xm<Ru)for(let wm=0;wm<rp;++wm){const Im=im+wm*hp;if(Im>=0&&Im<Nu){const Wm=Bp([qp,xm,Im,um],Cu,xp(lu.shape)),$m=Bp([bm,wm,um],Eu,xp(cu.shape)),Hm=bu[Wm]+wu[$m];Hm>ym&&(ym=Hm)}}}const pm=Bp([qp,Yp,am,um],Vp,xp(Ap));zp[pm]=ym}}}return{dataId:Au.write(qv(zp,lu.dtype),Ap,lu.dtype),shape:Ap,dtype:lu.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xQ={kernelName:Wp,backendName:"cpu",kernelFunc:({inputs:ou,backend:nu,attrs:ru})=>{const{x:lu,filter:cu,dy:hu}=ou,{strides:pu,pad:mu,dilations:Au}=ru,bu=nu,Cu=lm(lu.shape,bu.data.get(lu.dataId).values),wu=lm(cu.shape,bu.data.get(cu.dataId).values),{batchSize:Eu,inHeight:Tu,inWidth:Ru,inChannels:Nu,outHeight:Pu,outWidth:Fu,padInfo:Gu,strideHeight:Xu,strideWidth:Qu,filterHeight:Ju,filterWidth:ip,dilationHeight:rp,dilationWidth:op,outShape:hp}=iw(lu.shape,cu.shape,pu,mu,"NHWC",Au);vu(hu.rank===hp.length,()=>`Error in ${Wp}, dy must have the same rank as output ${hp.length}, but got ${hu.rank}`);const Ap=lm(hp,bu.data.get(hu.dataId).values),Up=dm(cu.shape,cu.dtype);for(let Vp=0;Vp<Eu;++Vp)for(let zp=0;zp<Pu;++zp){const qp=zp*Xu-Gu.top;for(let Yp=0;Yp<Fu;++Yp){const em=Yp*Qu-Gu.left;for(let am=0;am<Nu;++am){let im=Number.MIN_SAFE_INTEGER,um=0,ym=0;for(let pm=0;pm<Ju;++pm){const bm=qp+pm*rp;if(bm>=0&&bm<Tu)for(let xm=0;xm<ip;++xm){const wm=em+xm*op;if(wm>=0&&wm<Ru){const Im=Cu[Vp][bm][wm][am]+wu[pm][xm][am];Im>im&&(im=Im,um=pm,ym=xm)}}}Up[um][ym][am]+=Ap[Vp][zp][Yp][am]}}}return{dataId:bu.write(qv(Up,lu.dtype),cu.shape,cu.dtype),shape:cu.shape,dtype:cu.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vQ={kernelName:Np,backendName:"cpu",kernelFunc:({inputs:ou,backend:nu,attrs:ru})=>{const{x:lu,filter:cu,dy:hu}=ou,{strides:pu,pad:mu,dilations:Au}=ru,bu=nu,Cu=lm(lu.shape,bu.data.get(lu.dataId).values),wu=lm(cu.shape,bu.data.get(cu.dataId).values),{batchSize:Eu,inHeight:Tu,inWidth:Ru,inChannels:Nu,outHeight:Pu,outWidth:Fu,padInfo:Gu,strideHeight:Xu,strideWidth:Qu,filterHeight:Ju,filterWidth:ip,dilationHeight:rp,dilationWidth:op,outShape:hp}=iw(lu.shape,cu.shape,pu,mu,"NHWC",Au);vu(hu.rank===hp.length,()=>`Error in ${Np}, dy must have the same rank as output ${hp.length}, but got ${hu.rank}`);const Ap=lm(hp,bu.data.get(hu.dataId).values),Up=dm(lu.shape,lu.dtype);for(let Vp=0;Vp<Eu;++Vp)for(let zp=0;zp<Pu;++zp){const qp=zp*Xu-Gu.top;for(let Yp=0;Yp<Fu;++Yp){const em=Yp*Qu-Gu.left;for(let am=0;am<Nu;++am){let im=Number.MIN_SAFE_INTEGER,um=qp<0?0:qp,ym=em<0?0:em;for(let pm=0;pm<Ju;++pm){const bm=qp+pm*rp;if(bm>=0&&bm<Tu)for(let xm=0;xm<ip;++xm){const wm=em+xm*op;if(wm>=0&&wm<Ru){const Im=Cu[Vp][bm][wm][am]+wu[pm][xm][am];Im>im&&(im=Im,um=bm,ym=wm)}}}Up[Vp][um][ym][am]+=Ap[Vp][zp][Yp][am]}}}return{dataId:bu.write(qv(Up,lu.dtype),lu.shape,lu.dtype),shape:lu.shape,dtype:lu.dtype}}};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{image:cu}=nu,{canvas:hu,options:pu}=lu,{contextOptions:mu,imageOptions:Au}=pu||{},bu=(Au==null?void 0:Au.alpha)||1,Cu=(mu==null?void 0:mu.contextType)||"2d";if(Cu!=="2d")throw new Error(`Context type ${mu.contextType} is not supported by the CPU backend.`);const wu=hu.getContext(Cu,(mu==null?void 0:mu.contextAttributes)||{});if(wu==null)throw new Error(`Could not get the context with ${Cu} type.`);const[Eu,Tu]=cu.shape.slice(0,2),Ru=cu.shape.length===2?1:cu.shape[2],Nu=ru.data.get(cu.dataId).values,Pu=cu.dtype==="float32"?255:1,Fu=new Uint8ClampedArray(Tu*Eu*4);for(let Xu=0;Xu<Eu*Tu;++Xu){const Qu=[0,0,0,255*bu];for(let ip=0;ip<Ru;ip++){const rp=Nu[Xu*Ru+ip];if(cu.dtype==="float32"){if(rp<0||rp>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${rp}.`)}else if(cu.dtype==="int32"&&(rp<0||rp>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${rp}.`);Ru===1?(Qu[0]=rp*Pu,Qu[1]=rp*Pu,Qu[2]=rp*Pu):Qu[ip]=rp*Pu}const Ju=Xu*4;Fu[Ju+0]=Math.round(Qu[0]),Fu[Ju+1]=Math.round(Qu[1]),Fu[Ju+2]=Math.round(Qu[2]),Fu[Ju+3]=Math.round(Qu[3])}hu.width=Tu,hu.height=Eu;const Gu=new ImageData(Fu,Tu,Eu);return wu.putImageData(Gu,0,0),cu}const wQ={kernelName:jp,backendName:"cpu",kernelFunc:CQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nw(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu;Pm(cu,"sum");let mu;cu.dtype==="bool"?mu=Fv({inputs:{x:cu},backend:ru,attrs:{dtype:"int32"}}):mu=Qx({inputs:{x:cu},backend:ru});const Au=mu.shape.length,bu=Wu(hu,mu.shape),Cu=G0(bu,Au);let wu=bu,Eu=mu;Cu!=null&&(Eu=Fy({inputs:{x:mu},backend:ru,attrs:{perm:Cu}}),wu=H0(wu.length,Au)),dy("sum",wu,Eu.shape.length);const[Tu,Ru]=oy(Eu.shape,wu),Nu=Uy(Eu.dtype,"int32");let Pu=v2(ru,Tu,Nu);const Fu=Mu(Ru),Gu=ru.data.get(Pu.dataId).values,Xu=ru.data.get(Eu.dataId).values;for(let Qu=0;Qu<Gu.length;++Qu){const Ju=Qu*Fu;let ip=0;for(let rp=0;rp<Fu;++rp)ip+=Xu[Ju+rp];Gu[Qu]=ip}if(pu){const Qu=j0(Pu.shape,bu),Ju=Pu;Pu=S0({inputs:{x:Pu},backend:ru,attrs:{shape:Qu}}),ru.disposeIntermediateTensorInfo(Ju)}return ru.disposeIntermediateTensorInfo(mu),Cu!=null&&ru.disposeIntermediateTensorInfo(Eu),Pu}const EQ={kernelName:vE,backendName:"cpu",kernelFunc:Nw};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{equation:cu}=lu,hu=nu,{allDims:pu,summedDims:mu,idDims:Au}=PI(cu,hu.length);OI(pu.length,Au,hu);const{path:bu,steps:Cu}=UI(mu,Au),wu=Cu.length;let Eu=null,Tu=pu.length;const Ru=[];for(let Nu=0;Nu<wu;++Nu){for(const Pu of Cu[Nu]){const{permutationIndices:Fu,expandDims:Gu}=GI(Tu,Au[Pu]);let Xu;$I(Fu)?Xu=hu[Pu]:(Xu=Fy({inputs:{x:hu[Pu]},backend:ru,attrs:{perm:Fu}}),Ru.push(Xu));const Qu=Xu.shape.slice();for(let Ju=0;Ju<Gu.length;++Ju)Qu.splice(Gu[Ju],0,1);ku(Xu.shape,Qu)||(Xu=S0({inputs:{x:Xu},backend:ru,attrs:{shape:Qu}}),Ru.push(Xu)),Eu===null?Eu=Xu:(Eu=C2({inputs:{a:Xu,b:Eu},backend:ru}),Ru.push(Eu))}Nu<wu-1&&(bu[Nu]>=0&&(Eu=Nw({inputs:{x:Eu},backend:ru,attrs:{axis:bu[Nu]-(pu.length-Tu),keepDims:!1}}),Ru.push(Eu)),Tu--)}for(const Nu of Ru)Nu!==Eu&&ru.disposeIntermediateTensorInfo(Nu);return Eu}const IQ={kernelName:gm,backendName:"cpu",kernelFunc:SQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TQ(ou){const{inputs:nu,backend:ru}=ou,{dy:lu,y:cu}=nu;Pm([lu,cu],"eluGrad");const hu=new Float32Array(Mu(cu.shape)),pu=ru.data.get(cu.dataId).values,mu=ru.data.get(lu.dataId).values;for(let Au=0;Au<pu.length;++Au){const bu=pu[Au];bu>=0?hu[Au]=mu[Au]:hu[Au]=mu[Au]*(bu+1)}return ru.makeTensorInfo(cu.shape,"float32",hu)}const _Q={kernelName:Nm,backendName:"cpu",kernelFunc:TQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MQ=MI,RQ=RI,kQ=kI,BQ=BI,LQ=LI,NQ=NI,DQ=b0(Dm,ou=>{const nu=Math.sign(ou),ru=Math.abs(ou),lu=1/(1+MQ*ru);return nu*(1-((((NQ*lu+LQ)*lu+BQ)*lu+kQ)*lu+RQ)*lu*Math.exp(-ru*ru))}),FQ={kernelName:Dm,backendName:"cpu",kernelFunc:DQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S2(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{input:cu}=nu,{dim:hu}=lu,pu=cu.shape.length,mu=cu.shape.slice();let Au=hu;return hu<0&&(vu(-(pu+1)<=hu,()=>`Axis must be in the interval [${-(pu+1)}, ${pu}]`),Au=pu+hu+1),mu.splice(Au,0,1),S0({inputs:{x:cu},backend:ru,attrs:{shape:mu}})}const PQ={kernelName:Vm,backendName:"cpu",kernelFunc:S2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const GQ=K0((ou,nu)=>ou/nu),FT=ry(Gp,GQ),PT={kernelName:Gp,backendName:"cpu",kernelFunc:FT};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cD(ou,nu,ru){const lu=ou.shape,cu=lu[0],hu=lu[1],pu=ru.data.get(ou.dataId),mu=pu.complexTensorInfos.real,Au=pu.complexTensorInfos.imag,bu=[cu,hu],Cu=Mu(bu),wu=Hu("float32",Cu),Eu=Hu("float32",Cu);for(let Pu=0;Pu<cu;Pu++){const Fu=w1({inputs:{x:mu},backend:ru,attrs:{begin:[Pu,0],size:[1,hu]}}),Gu=w1({inputs:{x:Au},backend:ru,attrs:{begin:[Pu,0],size:[1,hu]}}),Xu=zy({inputs:{real:Fu,imag:Gu},backend:ru}),{real:Qu,imag:Ju}=OQ(Xu,nu,ru),ip=sv(Qu,Ju);for(let rp=0;rp<hu;rp++){const op=DI(ip,rp);wu[Pu*hu+rp]=op.real,Eu[Pu*hu+rp]=op.imag}ru.disposeIntermediateTensorInfo(Fu),ru.disposeIntermediateTensorInfo(Gu),ru.disposeIntermediateTensorInfo(Xu)}const Tu=ru.makeTensorInfo(bu,"float32",wu),Ru=ru.makeTensorInfo(bu,"float32",Eu),Nu=zy({inputs:{real:Tu,imag:Ru},backend:ru});return ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),Nu}function OQ(ou,nu,ru){const lu=Mu(ou.shape),cu=ru.data.get(ou.dataId),hu=ru.data.get(cu.complexTensorInfos.real.dataId).values,pu=ru.data.get(cu.complexTensorInfos.imag.dataId).values;if(UQ(lu)){const mu=GT(hu,pu,lu,nu,ru),Au=[ou.shape[0],ou.shape[1]];if(nu){const bu=ru.makeTensorInfo(Au,"float32",mu.real),Cu=ru.makeTensorInfo(Au,"float32",mu.imag),wu=ru.makeTensorInfo([],"float32",yv(lu,"float32")),Eu=Qx({inputs:{x:wu},backend:ru}),Tu=PT.kernelFunc({inputs:{a:bu,b:wu},backend:ru}),Ru=PT.kernelFunc({inputs:{a:Cu,b:Eu},backend:ru}),Nu=ru.data.get(Tu.dataId).values,Pu=ru.data.get(Ru.dataId).values;return ru.disposeIntermediateTensorInfo(bu),ru.disposeIntermediateTensorInfo(Cu),ru.disposeIntermediateTensorInfo(wu),ru.disposeIntermediateTensorInfo(Eu),ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),{real:Nu,imag:Pu}}return mu}else{const mu=sv(hu,pu),Au=$Q(mu,lu,nu);return VR(Au)}}function UQ(ou){return(ou&ou-1)===0}function GT(ou,nu,ru,lu,cu){if(ru===1)return{real:ou,imag:nu};const hu=sv(ou,nu),pu=ru/2,mu=zR(hu),Au=mu.real,bu=mu.imag,Cu=[Au.length],wu=cu.makeTensorInfo(Cu,"float32",Au),Eu=cu.makeTensorInfo(Cu,"float32",bu),Tu=zy({inputs:{real:wu,imag:Eu},backend:cu}),Ru=WR(hu),Nu=Ru.real,Pu=Ru.imag,Fu=[Nu.length],Gu=cu.makeTensorInfo(Fu,"float32",Nu),Xu=cu.makeTensorInfo(Fu,"float32",Pu),Qu=zy({inputs:{real:Gu,imag:Xu},backend:cu}),Ju=GT(Au,bu,pu,lu,cu),ip=Ju.real,rp=Ju.imag,op=[ip.length],hp=cu.makeTensorInfo(op,"float32",ip),Ap=cu.makeTensorInfo(op,"float32",rp),Up=zy({inputs:{real:hp,imag:Ap},backend:cu}),Vp=GT(Nu,Pu,pu,lu,cu),zp=Vp.real,qp=Vp.imag,Yp=[zp.length],em=cu.makeTensorInfo(Yp,"float32",zp),am=cu.makeTensorInfo(Yp,"float32",qp),im=zy({inputs:{real:em,imag:am},backend:cu}),um=XR(ru,lu),ym=[um.real.length],pm=cu.makeTensorInfo(ym,"float32",um.real),bm=cu.makeTensorInfo(ym,"float32",um.imag),xm=zy({inputs:{real:pm,imag:bm},backend:cu}),wm=C2({inputs:{a:xm,b:im},backend:cu}),Im=oC({inputs:{a:Up,b:wm},backend:cu}),Wm=NT({inputs:{a:Up,b:wm},backend:cu}),$m=v1({inputs:{input:Im},backend:cu}),Hm=v1({inputs:{input:Wm},backend:cu}),qm=aC({inputs:{input:Im},backend:cu}),Jm=aC({inputs:{input:Wm},backend:cu}),a0=lC({inputs:[$m,Hm],backend:cu,attrs:{axis:0}}),f0=lC({inputs:[qm,Jm],backend:cu,attrs:{axis:0}}),U0=cu.data.get(a0.dataId).values,B0=cu.data.get(f0.dataId).values;return cu.disposeIntermediateTensorInfo(wu),cu.disposeIntermediateTensorInfo(Eu),cu.disposeIntermediateTensorInfo(Tu),cu.disposeIntermediateTensorInfo(Gu),cu.disposeIntermediateTensorInfo(Xu),cu.disposeIntermediateTensorInfo(Qu),cu.disposeIntermediateTensorInfo(hp),cu.disposeIntermediateTensorInfo(Ap),cu.disposeIntermediateTensorInfo(Up),cu.disposeIntermediateTensorInfo(em),cu.disposeIntermediateTensorInfo(am),cu.disposeIntermediateTensorInfo(im),cu.disposeIntermediateTensorInfo(pm),cu.disposeIntermediateTensorInfo(bm),cu.disposeIntermediateTensorInfo(xm),cu.disposeIntermediateTensorInfo(wm),cu.disposeIntermediateTensorInfo(Im),cu.disposeIntermediateTensorInfo(Wm),cu.disposeIntermediateTensorInfo($m),cu.disposeIntermediateTensorInfo(qm),cu.disposeIntermediateTensorInfo(Hm),cu.disposeIntermediateTensorInfo(Jm),cu.disposeIntermediateTensorInfo(a0),cu.disposeIntermediateTensorInfo(f0),{real:U0,imag:B0}}function $Q(ou,nu,ru){const lu=new Float32Array(nu*2);for(let cu=0;cu<nu;cu++){let hu=0,pu=0;for(let mu=0;mu<nu;mu++){const Au=QR(cu*mu,nu,ru),bu=DI(ou,mu);hu+=bu.real*Au.real-bu.imag*Au.imag,pu+=bu.real*Au.imag+bu.imag*Au.real}ru&&(hu/=nu,pu/=nu),HR(lu,hu,pu,cu)}return lu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VQ(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu,cu=Mu(lu.shape),hu=lu.shape[lu.shape.length-1],pu=cu/hu,mu=S0({inputs:{x:lu},backend:ru,attrs:{shape:[pu,hu]}}),Au=cD(mu,!1,ru),bu=S0({inputs:{x:Au},backend:ru,attrs:{shape:lu.shape}});return ru.disposeIntermediateTensorInfo(mu),ru.disposeIntermediateTensorInfo(Au),bu}const zQ={kernelName:h0,backendName:"cpu",kernelFunc:VQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OT(ou){const{backend:nu,attrs:ru}=ou,{shape:lu,value:cu,dtype:hu}=ru,pu=hu||Dp(cu),mu=Yu(pu,Mu(lu));return HQ(mu,cu),nu.makeTensorInfo(lu,pu,mu)}const WQ={kernelName:P0,backendName:"cpu",kernelFunc:OT};function HQ(ou,nu,ru){ou.fill(nu)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XQ={kernelName:N0,backendName:"cpu",kernelFunc:({inputs:ou,attrs:nu,backend:ru})=>{const{image:lu}=ou,cu=ru,hu=Hu(lu.dtype,Mu(lu.shape)),[pu,mu,Au,bu]=lu.shape,Cu=cu.data.get(lu.dataId).values;for(let wu=0;wu<pu;wu++){const Eu=wu*Au*mu*bu;for(let Tu=0;Tu<mu;Tu++){const Ru=Tu*(Au*bu);for(let Nu=0;Nu<Au;Nu++){const Pu=Nu*bu;for(let Fu=0;Fu<bu;Fu++){const Gu=Math.round(Au-Nu-1),Xu=Eu+Ru+Pu+Fu;let Qu=Cu[Xu];if(Gu>=0&&Gu<Au){const Ju=Gu*bu,ip=Eu+Ru+Ju+Fu;Qu=Cu[ip]}hu[Xu]=Qu}}}}return{dataId:cu.write(hu,lu.shape,lu.dtype),shape:lu.shape,dtype:lu.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu,bias:pu,preluActivationWeights:mu}=nu,{strides:Au,pad:bu,dataFormat:Cu,dilations:wu,dimRoundingMode:Eu,activation:Tu,leakyreluAlpha:Ru}=lu;let Nu=aD({inputs:{x:cu,filter:hu},backend:ru,attrs:{strides:Au,pad:bu,dataFormat:Cu,dilations:wu,dimRoundingMode:Eu}});if(pu){const Pu=Nu;if(Cu==="NCHW"&&pu.shape.length===1&&pu.shape[0]!==1){const Fu=S0({inputs:{x:pu},backend:ru,attrs:{shape:[pu.shape[0],1,1]}});Nu=oC({inputs:{a:Nu,b:Fu},backend:ru}),ru.disposeIntermediateTensorInfo(Fu)}else Nu=oC({inputs:{a:Nu,b:pu},backend:ru});ru.disposeIntermediateTensorInfo(Pu)}if(Tu){const Pu=Nu;if(Cu==="NCHW"&&Tu==="prelu"&&mu.shape.length===1&&mu.shape[0]!==1){const Fu=S0({inputs:{x:mu},backend:ru,attrs:{shape:[mu.shape[0],1,1]}});Nu=E2(ru,Nu,Tu,Fu,Ru),ru.disposeIntermediateTensorInfo(Fu)}else Nu=E2(ru,Nu,Tu,mu,Ru);ru.disposeIntermediateTensorInfo(Pu)}return Nu}const KQ={kernelName:ME,backendName:"cpu",kernelFunc:QQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu,bias:pu,preluActivationWeights:mu}=nu,{strides:Au,pad:bu,dataFormat:Cu,dilations:wu,dimRoundingMode:Eu,activation:Tu,leakyreluAlpha:Ru}=lu;let Nu=lD({inputs:{x:cu,filter:hu},backend:ru,attrs:{strides:Au,pad:bu,dataFormat:Cu,dilations:wu,dimRoundingMode:Eu}});if(pu){const Pu=Nu;Nu=oC({inputs:{a:Nu,b:pu},backend:ru}),ru.disposeIntermediateTensorInfo(Pu)}if(Tu){const Pu=Nu;Nu=E2(ru,Nu,Tu,mu,Ru),ru.disposeIntermediateTensorInfo(Pu)}return Nu}const jQ={kernelName:W_,backendName:"cpu",kernelFunc:ZQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YQ(ou){const{inputs:nu,backend:ru}=ou,{params:lu,indices:cu}=nu,hu=Mu(lu.shape),pu=cu.shape,mu=pu[pu.length-1],[Au,bu,Cu,wu]=AI(lu,cu);if(bu===0)return ru.makeTensorInfo(Au,lu.dtype,[]);const Eu=ru.data.get(cu.dataId).values,Tu=ru.bufferSync(lu),Ru=m3(Eu,Tu,lu.dtype,bu,mu,Cu,wu,lu.shape,hu);return ru.makeTensorInfo(Au,lu.dtype,Ru.values)}const qQ={kernelName:d0,backendName:"cpu",kernelFunc:YQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JQ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,indices:hu}=nu,{axis:pu,batchDims:mu}=lu;Pm([cu,hu],"gatherV2");const Au=Wu(pu,cu.shape)[0],bu=ru.data.get(hu.dataId).values,Cu=cu.shape[Au];for(let Qu=0;Qu<bu.length;++Qu){const Ju=bu[Qu];vu(Ju<=Cu-1&&Ju>=0,()=>`GatherV2: the index value ${Ju} is not in [0, ${Cu-1}]`)}let wu=mu;mu==null&&(wu=0);const Eu=Mu(hu.shape),Tu=WI(cu,hu,Au,wu),Ru=S0({inputs:{x:cu},backend:ru,attrs:{shape:[Tu.batchSize,Tu.outerSize,Tu.dimSize,Tu.sliceSize]}}),Nu=S0({inputs:{x:hu},backend:ru,attrs:{shape:[Tu.batchSize,Eu/Tu.batchSize]}}),Pu=[Tu.batchSize,Tu.outerSize,Eu/Tu.batchSize,Tu.sliceSize],Fu=ru.bufferSync(Nu),Gu=ru.bufferSync(Ru),Xu=g3(Gu,Fu,Pu);return ru.disposeIntermediateTensorInfo(Ru),ru.disposeIntermediateTensorInfo(Nu),ru.makeTensorInfo(Tu.outputShape,Xu.dtype,Xu.values)}const eK={kernelName:Nx,backendName:"cpu",kernelFunc:JQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tK(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu,cu=Mu(lu.shape),hu=lu.shape[lu.shape.length-1],pu=cu/hu,mu=S0({inputs:{x:lu},backend:ru,attrs:{shape:[pu,hu]}}),Au=cD(mu,!0,ru),bu=S0({inputs:{x:Au},backend:ru,attrs:{shape:lu.shape}});return ru.disposeIntermediateTensorInfo(mu),ru.disposeIntermediateTensorInfo(Au),bu}const nK={kernelName:Dx,backendName:"cpu",kernelFunc:tK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iK=b0(V0,ou=>Number.isFinite(ou)?1:0,"bool"),rK={kernelName:V0,backendName:"cpu",kernelFunc:iK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sK=b0(Py,ou=>Math.abs(ou)===1/0?1:0,"bool"),oK={kernelName:Py,backendName:"cpu",kernelFunc:sK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aK=b0(_0,ou=>Number.isNaN(ou)?1:0,"bool"),lK={kernelName:_0,backendName:"cpu",kernelFunc:aK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cK(ou){const{backend:nu,attrs:ru}=ou,{start:lu,stop:cu,num:hu}=ru,pu=v3(lu,cu,hu);return nu.makeTensorInfo([pu.length],"float32",pu)}const uK={kernelName:T_,backendName:"cpu",kernelFunc:cK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hK=b0(TC,ou=>Math.log1p(ou)),dK={kernelName:TC,backendName:"cpu",kernelFunc:hK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pK=K0((ou,nu)=>ou&&nu),fK=ry(Yw,pK,null,"bool"),mK={kernelName:Yw,backendName:"cpu",kernelFunc:fK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gK=b0(qw,ou=>ou?0:1,"bool"),AK={kernelName:qw,backendName:"cpu",kernelFunc:gK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yK=K0((ou,nu)=>ou||nu),bK=ry(Jw,yK,null,"bool"),xK={kernelName:Jw,backendName:"cpu",kernelFunc:bK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{depthRadius:hu,bias:pu,alpha:mu,beta:Au}=lu;Pm(cu,"LRN");const bu=cu.shape[3],Cu=bu-1,wu=ru.data.get(cu.dataId).values,Eu=Mu(cu.shape),Tu=new Float32Array(Eu);function Ru(Nu){const Pu=Nu%bu;let Fu=Nu-Pu+Math.max(0,Pu-hu);const Gu=Nu-Pu+Math.min(Pu+hu,Cu);let Xu=0;for(;Fu<=Gu;Fu++){const Qu=wu[Fu];Xu+=Qu*Qu}return Xu}for(let Nu=0;Nu<Eu;Nu++){const Pu=Ru(Nu),Fu=wu[Nu]*Math.pow(pu+mu*Pu,-Au);Tu[Nu]=Fu}return ru.makeTensorInfo(cu.shape,cu.dtype,Tu)}const CK={kernelName:eE,backendName:"cpu",kernelFunc:vK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,y:hu,dy:pu}=nu,{depthRadius:mu,bias:Au,alpha:bu,beta:Cu}=lu;Pm(pu,"LRNGrad");const wu=Mu(pu.shape),Eu=pu.shape[3],Tu=ru.data.get(pu.dataId).values,Ru=ru.data.get(cu.dataId).values,Nu=ru.data.get(hu.dataId).values,Pu=new Float32Array(wu),Fu=wu;for(let Gu=0;Gu<Fu;Gu++){const Xu=Gu%Eu,Qu=Gu-Xu+Math.max(0,Xu-mu),Ju=Gu-Xu+Math.min(Eu,Xu+mu+1);let ip=0;for(let rp=Qu;rp<Ju;rp++)ip+=Math.pow(Ru[rp],2);ip=bu*ip+Au;for(let rp=Qu;rp<Ju;rp++){let op=-2*bu*Cu*Ru[rp]*Nu[Gu]/ip;Gu===rp&&(op+=Math.pow(ip,-Cu)),op*=Tu[Gu],Pu[rp]+=op}}return ru.makeTensorInfo(pu.shape,cu.dtype,Pu)}const EK={kernelName:J2,backendName:"cpu",kernelFunc:wK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{reductionIndices:hu,keepDims:pu}=lu,mu=ru;let Au=cu.shape;const bu=Au.length,Cu=Wu(hu,Au);let wu=Cu;const Eu=G0(wu,bu);let Tu=mu.data.get(cu.dataId).values;if(Eu!=null){const Qu=new Array(bu);for(let Ju=0;Ju<Qu.length;Ju++)Qu[Ju]=Au[Eu[Ju]];Tu=BT(Tu,Au,cu.dtype,Eu,Qu),wu=H0(wu.length,bu),Au=Qu}Pm(cu,"max"),dy("max",wu,bu);const[Ru,Nu]=oy(Au,wu),Pu=Mu(Nu),Fu=w3(Tu,Pu,Ru,cu.dtype),Gu=mu.write(Fu,Ru,cu.dtype);let Xu=Ru;return pu&&(Xu=j0(Ru,Cu)),{dataId:Gu,shape:Xu,dtype:cu.dtype}}const SK={kernelName:tE,backendName:"cpu",kernelFunc:uD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu;Pm(cu,"maxPool");const{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au}=lu,bu=1;vu(gy(pu,bu),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${pu} and dilations '${bu}'`);const Cu=ox(cu.shape,hu,pu,bu,mu,Au);let wu;if(Cu.filterWidth===1&&Cu.filterHeight===1&&ku(Cu.inShape,Cu.outShape))wu=Qx({inputs:{x:cu},backend:ru});else{const Eu=ru.data.get(cu.dataId).values,Tu=xp(cu.shape),Ru=DT(Eu,cu.shape,cu.dtype,Tu,Cu,"max");wu=ru.makeTensorInfo(Cu.outShape,cu.dtype,Ru.values)}return wu}const TK={kernelName:nE,backendName:"cpu",kernelFunc:IK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _K(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au,dataFormat:bu}=lu;Pm(cu,"maxPool3d");const Cu=tv(cu.shape,hu,pu,1,mu,Au,bu),wu=ru.data.get(cu.dataId).values,Eu=oD(wu,cu.shape,cu.dtype,xp(cu.shape),Cu,"max");return ru.makeTensorInfo(Eu.shape,"float32",Eu.values)}const MK={kernelName:iE,backendName:"cpu",kernelFunc:_K};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu}=nu,{filterSize:pu,strides:mu,pad:Au,dimRoundingMode:bu}=lu;Pm([cu,hu],"maxPool3DGrad");const Cu=tv(hu.shape,pu,mu,1,Au,bu),wu=ru.bufferSync(hu),Eu=b9(wu,Cu),Tu=Cu.strideDepth,Ru=Cu.strideHeight,Nu=Cu.strideWidth,Pu=Cu.dilationDepth,Fu=Cu.dilationHeight,Gu=Cu.dilationWidth,Xu=Cu.effectiveFilterDepth,Qu=Cu.effectiveFilterHeight,Ju=Cu.effectiveFilterWidth,ip=Xu-1-Cu.padInfo.front,rp=Ju-1-Cu.padInfo.left,op=Qu-1-Cu.padInfo.top,hp=t0(hu.shape,"float32"),Ap=ru.bufferSync(cu);for(let Up=0;Up<Cu.batchSize;++Up)for(let Vp=0;Vp<Cu.inChannels;++Vp)for(let zp=0;zp<Cu.inDepth;++zp)for(let qp=0;qp<Cu.inHeight;++qp)for(let Yp=0;Yp<Cu.inWidth;++Yp){const em=zp-ip,am=qp-op,im=Yp-rp;let um=0;for(let ym=0;ym<Xu;ym+=Pu){const pm=(em+ym)/Tu;if(!(pm<0||pm>=Cu.outDepth||Math.floor(pm)!==pm))for(let bm=0;bm<Qu;bm+=Fu){const xm=(am+bm)/Ru;if(!(xm<0||xm>=Cu.outHeight||Math.floor(xm)!==xm))for(let wm=0;wm<Ju;wm+=Gu){const Im=(im+wm)/Nu;if(Im<0||Im>=Cu.outWidth||Math.floor(Im)!==Im)continue;const Wm=Xu*Qu*Ju-1-Eu.get(Up,pm,xm,Im,Vp),$m=ym*Qu*Ju+bm*Ju+wm,Hm=Wm===$m?1:0;if(Hm===0)continue;const qm=Ap.get(Up,pm,xm,Im,Vp);um+=qm*Hm}}}hp.set(um,Up,zp,qp,Yp,Vp)}return ru.makeTensorInfo(hp.shape,hp.dtype,hp.values)}const kK={kernelName:tS,backendName:"cpu",kernelFunc:RK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu,output:pu}=nu,mu=hu;Pm([hu,pu],"maxPoolGrad");const{filterSize:Au,strides:bu,pad:Cu,dimRoundingMode:wu}=lu,Eu=ox(mu.shape,Au,bu,1,Cu,wu),Tu=ru.data.get(mu.dataId).values,Ru=t0(Eu.outShape,mu.dtype,sD(Tu,mu.shape,mu.dtype,Eu).values),Nu=Eu.strideHeight,Pu=Eu.strideWidth,Fu=Eu.dilationHeight,Gu=Eu.dilationWidth,Xu=Eu.effectiveFilterHeight,Qu=Eu.effectiveFilterWidth,Ju=Qu-1-Eu.padInfo.left,ip=Xu-1-Eu.padInfo.top,rp=t0(mu.shape,"float32"),op=ru.data.get(cu.dataId).values,hp=t0(cu.shape,"float32",op);for(let Ap=0;Ap<Eu.batchSize;++Ap)for(let Up=0;Up<Eu.inChannels;++Up)for(let Vp=0;Vp<Eu.inHeight;++Vp)for(let zp=0;zp<Eu.inWidth;++zp){const qp=Vp-ip,Yp=zp-Ju;let em=0;for(let am=0;am<Xu;am+=Fu){const im=(qp+am)/Nu;if(!(im<0||im>=Eu.outHeight||Math.floor(im)!==im))for(let um=0;um<Qu;um+=Gu){const ym=(Yp+um)/Pu;if(ym<0||ym>=Eu.outWidth||Math.floor(ym)!==ym)continue;const pm=Xu*Qu-1-Ru.get(Ap,im,ym,Up),bm=am*Qu+um,xm=pm===bm?1:0;if(xm===0)continue;const wm=hp.get(Ap,im,ym,Up);em+=wm*xm}}rp.set(em,Ap,Vp,zp,Up)}return ru.makeTensorInfo(rp.shape,rp.dtype,rp.values)}const LK={kernelName:eS,backendName:"cpu",kernelFunc:BK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NK(ou,nu,ru,lu,cu){const hu=xp(nu),pu=DT(ou,nu,ru,hu,cu,"max"),mu=sD(ou,nu,ru,cu,!0,lu);return[pu.values,mu.values]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const DK={kernelName:__,backendName:"cpu",kernelFunc:({inputs:ou,attrs:nu,backend:ru})=>{const{x:lu}=ou,{filterSize:cu,strides:hu,pad:pu,includeBatchInIndex:mu}=nu,Au=ru;Pm(lu,"MaxPoolWithArgmax");const bu=Au.data.get(lu.dataId).values,Cu=ox(lu.shape,cu,hu,[1,1],pu),[wu,Eu]=NK(bu,lu.shape,lu.dtype,mu,Cu),Tu=Au.write(wu,Cu.outShape,lu.dtype),Ru=Au.write(Eu,Cu.outShape,lu.dtype);return[{dataId:Tu,shape:Cu.outShape,dtype:lu.dtype},{dataId:Ru,shape:Cu.outShape,dtype:"int32"}]}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu,mu=Wu(hu,cu.shape),Au=oy(cu.shape,mu)[1],bu=Mu(Au),Cu=[],wu=ru.makeTensorInfo([],"float32",new Float32Array([bu]));Cu.push(wu);const Eu=Fv({inputs:{x:cu},backend:ru,attrs:{dtype:"float32"}});Cu.push(Eu);const Tu=FT({inputs:{a:Eu,b:wu},backend:ru});Cu.push(Tu);const Ru=Nw({inputs:{x:Tu},backend:ru,attrs:{axis:hu,keepDims:pu}});return Cu.forEach(Nu=>ru.disposeIntermediateTensorInfo(Nu)),Ru}const PK={kernelName:rE,backendName:"cpu",kernelFunc:FK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu;Pm(cu,"min");const mu=Wu(hu,cu.shape);let Au=mu;const bu=G0(Au,cu.shape.length);let Cu=cu;bu!=null&&(Cu=Fy({inputs:{x:cu},backend:ru,attrs:{perm:bu}}),Au=H0(Au.length,cu.shape.length)),dy("min",Au,Cu.shape.length);const[wu,Eu]=oy(Cu.shape,Au),Tu=Mu(Eu),Ru=kp(Mu(wu),Cu.dtype),Nu=ru.data.get(Cu.dataId).values;for(let Fu=0;Fu<Ru.length;++Fu){const Gu=Fu*Tu;let Xu=Nu[Gu];for(let Qu=0;Qu<Tu;++Qu){const Ju=Nu[Gu+Qu];(Number.isNaN(Ju)||Ju<Xu)&&(Xu=Ju)}Ru[Fu]=Xu}bu!=null&&ru.disposeIntermediateTensorInfo(Cu);const Pu=ru.makeTensorInfo(wu,Cu.dtype,Ru);if(pu){const Fu=j0(wu,mu),Gu=S0({inputs:{x:Pu},backend:ru,attrs:{shape:Fu}});return ru.disposeIntermediateTensorInfo(Pu),Gu}return Pu}const OK={kernelName:sE,backendName:"cpu",kernelFunc:GK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{paddings:hu,mode:pu}=lu;Pm(cu,"mirrorPad");const mu=hu.map((Gu,Xu)=>Gu[0]+cu.shape[Xu]+Gu[1]),Au=hu.map(Gu=>Gu[0]),bu=hu.map((Gu,Xu)=>Gu[0]+cu.shape[Xu]),Cu=pu==="reflect"?0:1,wu=ru.data.get(cu.dataId).values,Eu=cu.shape.length,Tu=xp(cu.shape),Ru=Mu(mu),Nu=mu.length,Pu=xp(mu),Fu=Hu(cu.dtype,Ru);for(let Gu=0;Gu<Ru;Gu++){let Xu=Qp(Gu,Nu,Pu);for(let Ju=0;Ju<Nu;Ju++)Xu[Ju]<Au[Ju]?Xu[Ju]=Au[Ju]*2-Xu[Ju]-Cu:Xu[Ju]>=bu[Ju]&&(Xu[Ju]=(bu[Ju]-1)*2-Xu[Ju]+Cu);Xu=Xu.map((Ju,ip)=>Ju-Au[ip]);const Qu=Bp(Xu,Eu,Tu);Fu[Gu]=wu[Qu]}return{dataId:ru.write(Fu,mu,cu.dtype),shape:mu,dtype:cu.dtype}}const $K={kernelName:oE,backendName:"cpu",kernelFunc:UK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const VK=K0((ou,nu)=>{const ru=ou%nu;return ou<0&&nu<0||ou>=0&&nu>=0?ru:(ru+nu)%nu}),zK=ry(RC,VK),WK={kernelName:RC,backendName:"cpu",kernelFunc:zK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{logits:cu}=nu,{dim:hu}=lu,pu=cu.shape.length;let mu=hu;if(mu===-1&&(mu=pu-1),mu!==pu-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${pu} and dim was ${mu}`);const Au=Wu([mu],cu.shape),bu=uD({inputs:{x:cu},backend:ru,attrs:{reductionIndices:Au,keepDims:!1}}),Cu=j0(bu.shape,Au),wu=S0({inputs:{x:bu},backend:ru,attrs:{shape:Cu}}),Eu=NT({inputs:{a:cu,b:wu},backend:ru}),Tu=h3({inputs:{x:Eu},backend:ru}),Ru=Nw({inputs:{x:Tu},backend:ru,attrs:{axis:Au,keepDims:!1}}),Nu=S0({inputs:{x:Ru},backend:ru,attrs:{shape:Cu}}),Pu=FT({inputs:{a:Tu,b:Nu},backend:ru});return ru.disposeIntermediateTensorInfo(bu),ru.disposeIntermediateTensorInfo(wu),ru.disposeIntermediateTensorInfo(Eu),ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),ru.disposeIntermediateTensorInfo(Nu),Pu}const HK={kernelName:EE,backendName:"cpu",kernelFunc:hD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{logits:cu}=nu,{numSamples:hu,seed:pu,normalized:mu}=lu;Pm(cu,"multinomial");const Au=mu?cu:hD({inputs:{logits:cu},backend:ru,attrs:{dim:-1}}),bu=Au.shape[0],Cu=Au.shape[1],wu=ru.data.get(Au.dataId).values,Eu=[bu,hu],Tu=kp(Mu(Eu),"int32");for(let Ru=0;Ru<bu;++Ru){const Nu=Ru*Cu,Pu=new Float32Array(Cu-1);Pu[0]=wu[Nu];for(let Xu=1;Xu<Pu.length;++Xu)Pu[Xu]=Pu[Xu-1]+wu[Nu+Xu];const Fu=tI.alea(pu.toString()),Gu=Ru*hu;for(let Xu=0;Xu<hu;++Xu){const Qu=Fu();Tu[Gu+Xu]=Pu.length;for(let Ju=0;Ju<Pu.length;Ju++)if(Qu<Pu[Ju]){Tu[Gu+Xu]=Ju;break}}}return mu||ru.disposeIntermediateTensorInfo(Au),ru.makeTensorInfo(Eu,"int32",Tu)}const QK={kernelName:M_,backendName:"cpu",kernelFunc:XK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KK=dI;function ZK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{boxes:cu,scores:hu}=nu,{maxOutputSize:pu,iouThreshold:mu,scoreThreshold:Au}=lu;Pm(cu,"NonMaxSuppression");const bu=ru.data.get(cu.dataId).values,Cu=ru.data.get(hu.dataId).values,{selectedIndices:wu}=KK(bu,Cu,pu,mu,Au);return ru.makeTensorInfo([wu.length],"int32",new Int32Array(wu))}const jK={kernelName:nS,backendName:"cpu",kernelFunc:ZK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const YK=pI;function qK(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{boxes:cu,scores:hu}=nu,{maxOutputSize:pu,iouThreshold:mu,scoreThreshold:Au,padToMaxOutputSize:bu}=lu;Pm(cu,"NonMaxSuppressionPadded");const Cu=ru.data.get(cu.dataId).values,wu=ru.data.get(hu.dataId).values,{selectedIndices:Eu,validOutputs:Tu}=YK(Cu,wu,pu,mu,Au,bu);return[ru.makeTensorInfo([Eu.length],"int32",new Int32Array(Eu)),ru.makeTensorInfo([],"int32",new Int32Array([Tu]))]}const JK={kernelName:iS,backendName:"cpu",kernelFunc:qK};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eZ=fI;function tZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{boxes:cu,scores:hu}=nu,{maxOutputSize:pu,iouThreshold:mu,scoreThreshold:Au,softNmsSigma:bu}=lu;Pm(cu,"NonMaxSuppressionWithScore");const Cu=ru.data.get(cu.dataId).values,wu=ru.data.get(hu.dataId).values,Eu=pu,Tu=mu,Ru=Au,Nu=bu,{selectedIndices:Pu,selectedScores:Fu}=eZ(Cu,wu,Eu,Tu,Ru,Nu);return[ru.makeTensorInfo([Pu.length],"int32",new Int32Array(Pu)),ru.makeTensorInfo([Fu.length],"float32",new Float32Array(Fu))]}const nZ={kernelName:rS,backendName:"cpu",kernelFunc:tZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{indices:cu}=nu,{dtype:hu,depth:pu,onValue:mu,offValue:Au}=lu;Pm(cu,"oneHot");const bu=Mu(cu.shape),Cu=new Float32Array(bu*pu);Cu.fill(Au);const wu=ru.data.get(cu.dataId).values;for(let Eu=0;Eu<bu;++Eu)wu[Eu]>=0&&wu[Eu]<pu&&(Cu[Eu*pu+wu[Eu]]=mu);return ru.makeTensorInfo([...cu.shape,pu],hu,Cu)}const rZ={kernelName:uE,backendName:"cpu",kernelFunc:iZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I2(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;if(lu.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(lu.dtype==="complex64"){const cu=v1({inputs:{input:lu},backend:ru}),hu=I2({inputs:{x:cu},backend:ru}),pu=aC({inputs:{input:lu},backend:ru}),mu=I2({inputs:{x:pu},backend:ru}),Au=zy({inputs:{real:hu,imag:mu},backend:ru});return ru.disposeIntermediateTensorInfo(cu),ru.disposeIntermediateTensorInfo(hu),ru.disposeIntermediateTensorInfo(pu),ru.disposeIntermediateTensorInfo(mu),Au}else return OT({backend:ru,attrs:{shape:lu.shape,value:0,dtype:lu.dtype}})}const sZ={kernelName:TE,backendName:"cpu",kernelFunc:I2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dD(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;if(lu.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(lu.dtype==="complex64"){const cu=v1({inputs:{input:lu},backend:ru}),hu=dD({inputs:{x:cu},backend:ru}),pu=aC({inputs:{input:lu},backend:ru}),mu=I2({inputs:{x:pu},backend:ru}),Au=zy({inputs:{real:hu,imag:mu},backend:ru});return ru.disposeIntermediateTensorInfo(cu),ru.disposeIntermediateTensorInfo(hu),ru.disposeIntermediateTensorInfo(pu),ru.disposeIntermediateTensorInfo(mu),Au}else return OT({backend:ru,attrs:{shape:lu.shape,value:1,dtype:lu.dtype}})}const oZ={kernelName:cE,backendName:"cpu",kernelFunc:dD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pD(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{axis:cu}=lu;if(nu.length===1)return S2({inputs:{input:nu[0]},backend:ru,attrs:{dim:cu}});const hu=nu[0].shape,pu=nu[0].dtype;nu.forEach(Cu=>{Su(hu,Cu.shape,"All tensors passed to stack must have matching shapes"),vu(pu===Cu.dtype,()=>"All tensors passed to stack must have matching dtypes")});const mu=[],Au=nu.map(Cu=>{const wu=S2({inputs:{input:Cu},backend:ru,attrs:{dim:cu}});return mu.push(wu),wu}),bu=lC({inputs:Au,backend:ru,attrs:{axis:cu}});return mu.forEach(Cu=>ru.disposeIntermediateTensorInfo(Cu)),bu}const aZ={kernelName:hE,backendName:"cpu",kernelFunc:pD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{paddings:hu,constantValue:pu}=lu;Pm(cu,"pad");const mu=hu.map((Fu,Gu)=>Fu[0]+cu.shape[Gu]+Fu[1]),Au=hu.map(Fu=>Fu[0]),bu=ru.data.get(cu.dataId).values,Cu=Mu(cu.shape),wu=cu.shape.length,Eu=xp(cu.shape),Tu=Mu(mu),Ru=mu.length,Nu=xp(mu),Pu=Hu(cu.dtype,Tu);pu!==0&&Pu.fill(pu);for(let Fu=0;Fu<Cu;Fu++){const Gu=Qp(Fu,wu,Eu).map((Qu,Ju)=>Qu+Au[Ju]),Xu=Bp(Gu,Ru,Nu);Pu[Xu]=bu[Fu]}return{dataId:ru.write(Pu,mu,cu.dtype),shape:mu,dtype:cu.dtype}}const fD={kernelName:dE,backendName:"cpu",kernelFunc:lZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cZ=K0((ou,nu)=>Math.pow(ou,nu)),uZ=ry(BC,cZ),hZ={kernelName:BC,backendName:"cpu",kernelFunc:uZ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{paramsNestedSplits:cu,paramsDenseValues:hu,indices:pu}=nu,mu=cu.map(Pu=>ru.data.get(Pu.dataId).values),Au=cu.map(Pu=>Pu.shape),bu=ru.data.get(hu.dataId).values,Cu=ru.data.get(pu.dataId).values,[wu,Eu,Tu]=R3(mu,Au,bu,hu.shape,hu.dtype,Cu,pu.shape),Ru=wu.map(Pu=>ru.makeTensorInfo([Pu.length],"int32",Pu)),Nu=ru.makeTensorInfo(Tu,hu.dtype,Eu);return Ru.concat([Nu])}const pZ={kernelName:R_,backendName:"cpu",kernelFunc:dZ};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fZ(ou){const{inputs:nu,backend:ru}=ou,{starts:lu,limits:cu,deltas:hu}=nu,pu=ru.data.get(lu.dataId).values,mu=ru.data.get(cu.dataId).values,Au=ru.data.get(hu.dataId).values,[bu,Cu]=B3(pu,lu.shape,lu.dtype,mu,cu.shape,Au,hu.shape),wu=ru.makeTensorInfo([bu.length],"int32",bu),Eu=ru.makeTensorInfo([Cu.length],lu.dtype,Cu);return[wu,Eu]}const mZ={kernelName:k_,backendName:"cpu",kernelFunc:fZ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{shape:cu,values:hu,defaultValue:pu,rowPartitionTensors:mu}=nu,{rowPartitionTypes:Au}=lu,bu=ru.data.get(cu.dataId).values,Cu=ru.data.get(hu.dataId).values,wu=ru.data.get(pu.dataId).values,Eu=mu.map(Pu=>ru.data.get(Pu.dataId).values),Tu=mu.map(Pu=>Pu.shape),[Ru,Nu]=D3(bu,cu.shape,Cu,hu.shape,hu.dtype,wu,pu.shape,Eu,Tu,Au);return ru.makeTensorInfo(Ru,hu.dtype,Nu)}const AZ={kernelName:B_,backendName:"cpu",kernelFunc:gZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yZ(ou){const{backend:nu,attrs:ru}=ou,{start:lu,stop:cu,dtype:hu,step:pu}=ru,mu=F3(lu,cu,pu,hu);return nu.makeTensorInfo([mu.length],hu,mu)}const bZ={kernelName:sS,backendName:"cpu",kernelFunc:yZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xZ=b0(LC,ou=>1/ou),vZ={kernelName:LC,backendName:"cpu",kernelFunc:xZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu}=nu,{alignCorners:hu,halfPixelCenters:pu,size:mu}=lu;Pm(cu,"resizeBilinear");const Au=xp(cu.shape),[bu,Cu]=mu,[wu,Eu,Tu,Ru]=cu.shape,Nu=ru.data.get(cu.dataId).values,Pu=new Float32Array(Mu([wu,bu,Cu,Ru])),Fu=[hu&&bu>1?Eu-1:Eu,hu&&Cu>1?Tu-1:Tu],Gu=[hu&&bu>1?bu-1:bu,hu&&Cu>1?Cu-1:Cu];let Xu=0;const Qu=Fu[0]/Gu[0],Ju=Fu[1]/Gu[1];for(let ip=0;ip<wu;ip++)for(let rp=0;rp<bu;rp++){let op;pu?op=Qu*(rp+.5)-.5:op=Qu*rp;const hp=Math.max(0,Math.floor(op)),Ap=op-hp,Up=Math.min(Eu-1,Math.ceil(op)),Vp=ip*Au[0]+hp*Au[1],zp=ip*Au[0]+Up*Au[1];for(let qp=0;qp<Cu;qp++){let Yp;pu?Yp=Ju*(qp+.5)-.5:Yp=Ju*qp;const em=Math.max(0,Math.floor(Yp)),am=Yp-em,im=Math.min(Tu-1,Math.ceil(Yp)),um=Vp+em*Au[2],ym=zp+em*Au[2],pm=Vp+im*Au[2],bm=zp+im*Au[2];for(let xm=0;xm<Ru;xm++){const wm=Nu[um+xm],Im=Nu[ym+xm],Wm=Nu[pm+xm],$m=Nu[bm+xm],Hm=wm+(Wm-wm)*am,qm=Im+($m-Im)*am,Jm=Hm+(qm-Hm)*Ap;Pu[Xu++]=Jm}}}return ru.makeTensorInfo([wu,bu,Cu,Ru],"float32",Pu)}const wZ={kernelName:AE,backendName:"cpu",kernelFunc:CZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu,dy:hu}=nu,{alignCorners:pu}=lu;Pm([hu,cu],"resizeBilinearGrad");const mu=xp(cu.shape),[Au,bu,Cu,wu]=cu.shape,[,Eu,Tu]=hu.shape,Ru=new Float32Array(Au*bu*Cu*wu),Nu=[pu&&Eu>1?bu-1:bu,pu&&Tu>1?Cu-1:Cu],Pu=[pu&&Eu>1?Eu-1:Eu,pu&&Tu>1?Tu-1:Tu],Fu=Nu[0]/Pu[0],Gu=Nu[1]/Pu[1],Xu=ru.data.get(hu.dataId).values;let Qu=0;for(let Ju=0;Ju<Au;Ju++){const ip=Ju*mu[0];for(let rp=0;rp<Eu;rp++){const op=rp*Fu,hp=Math.floor(op),Ap=Math.min(Math.ceil(op),bu-1),Up=ip+hp*mu[1],Vp=ip+Ap*mu[1],zp=op-hp,qp=1-zp;for(let Yp=0;Yp<Tu;Yp++){const em=Yp*Gu,am=Math.floor(em),im=Math.min(Math.ceil(em),Cu-1),um=em-am,ym=1-um,pm=Up+am*mu[2],bm=Up+im*mu[2],xm=Vp+am*mu[2],wm=Vp+im*mu[2],Im=qp*ym,Wm=qp*um,$m=zp*ym,Hm=zp*um;for(let qm=0;qm<wu;qm++){const Jm=Xu[Qu++];Ru[pm+qm]+=Jm*Im,Ru[bm+qm]+=Jm*Wm,Ru[xm+qm]+=Jm*$m,Ru[wm+qm]+=Jm*Hm}}}}return ru.makeTensorInfo([Au,Cu,bu,wu],"float32",Ru)}const SZ={kernelName:lS,backendName:"cpu",kernelFunc:EZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu}=nu,{alignCorners:hu,halfPixelCenters:pu,size:mu}=lu;Pm(cu,"resizeNearestNeighbor");const Au=xp(cu.shape),[bu,Cu]=mu,[wu,Eu,Tu,Ru]=cu.shape,Nu=ru.data.get(cu.dataId).values,Pu=new Float32Array(wu*bu*Cu*Ru),Fu=[hu&&bu>1?Eu-1:Eu,hu&&Cu>1?Tu-1:Tu],Gu=[hu&&bu>1?bu-1:bu,hu&&Cu>1?Cu-1:Cu],Xu=Fu[0]/Gu[0],Qu=Fu[1]/Gu[1];let Ju=0;for(let ip=0;ip<wu;ip++){const rp=ip*Au[0];for(let op=0;op<bu;op++){const hp=pu?Xu*(op+.5):Xu*op;let Ap=Math.min(Eu-1,hu?Math.round(hp):Math.floor(hp));pu&&(Ap=Math.max(0,Ap));const Up=rp+Ap*Au[1];for(let Vp=0;Vp<Cu;Vp++){const zp=pu?Qu*(Vp+.5):Qu*Vp;let qp=Math.min(Tu-1,hu?Math.round(zp):Math.floor(zp));pu&&(qp=Math.max(0,qp));const Yp=Up+qp*Au[2];for(let em=0;em<Ru;em++){const am=Nu[Yp+em];Pu[Ju++]=am}}}}return ru.makeTensorInfo([wu,bu,Cu,Ru],cu.dtype,Pu)}const TZ={kernelName:gE,backendName:"cpu",kernelFunc:IZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _Z(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu,dy:hu}=nu,{alignCorners:pu}=lu;Pm([hu,cu],"resizeNearestNeighborGrad");const mu=xp(cu.shape),Au=xp(hu.shape),[bu,Cu,wu,Eu]=cu.shape,[,Tu,Ru]=hu.shape,Nu=new Float32Array(bu*Cu*wu*Eu),Pu=ru.data.get(hu.dataId).values,Fu=[pu&&Tu>1?Cu-1:Cu,pu&&Ru>1?wu-1:wu],Gu=[pu&&Tu>1?Tu-1:Tu,pu&&Ru>1?Ru-1:Ru],Xu=Fu[0]/Gu[0],Qu=Fu[1]/Gu[1],Ju=1/Xu,ip=1/Qu,rp=Math.ceil(Ju)*2+2,op=Math.ceil(ip)*2+2;for(let hp=0;hp<bu;hp++){const Ap=hp*mu[0];for(let Up=0;Up<Cu;Up++){const Vp=Ap+Up*mu[1],zp=Math.floor(Up*Ju),qp=Math.floor(zp-rp/2);for(let Yp=0;Yp<wu;Yp++){const em=Vp+Yp*mu[2],am=Math.floor(Yp*ip),im=Math.floor(am-op/2);for(let um=0;um<Eu;um++){let ym=0;for(let pm=0;pm<rp;pm++){const bm=pm+qp;if(bm<0||bm>=Tu)continue;const xm=Ap+bm*Au[1],wm=bm*Xu,Im=Math.min(Cu-1,pu?Math.round(wm):Math.floor(wm));if(Up===Im)for(let Wm=0;Wm<op;Wm++){const $m=Wm+im;if($m<0||$m>=Ru)continue;const Hm=xm+$m*Au[2],qm=$m*Qu,Jm=Math.min(wu-1,pu?Math.round(qm):Math.floor(qm));Yp===Jm&&(ym+=Pu[Hm+um])}}Nu[em+um]=ym}}}}return ru.makeTensorInfo(cu.shape,cu.dtype,Nu)}const MZ={kernelName:aS,backendName:"cpu",kernelFunc:_Z};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{dims:hu}=lu;Pm(cu,"reverse");const pu=cu.shape.length,mu=Wu(hu,cu.shape);if(pu===0)return Qx({inputs:{x:cu},backend:ru});const Au=new uy(cu.shape,cu.dtype),bu=ru.bufferSync(cu);for(let Cu=0;Cu<Au.size;Cu++){const wu=Au.indexToLoc(Cu),Eu=wu.slice();mu.forEach(Tu=>Eu[Tu]=cu.shape[Tu]-1-Eu[Tu]),Au.set(bu.get(...Eu),...wu)}return ru.makeTensorInfo(Au.shape,Au.dtype,Au.values)}const kZ={kernelName:yE,backendName:"cpu",kernelFunc:RZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BZ={kernelName:gS,backendName:"cpu",kernelFunc:({inputs:ou,attrs:nu,backend:ru})=>{const{image:lu}=ou,{radians:cu,fillValue:hu,center:pu}=nu,mu=ru,Au=Hu(lu.dtype,Mu(lu.shape)),[bu,Cu,wu,Eu]=lu.shape,[Tu,Ru]=II(pu,Cu,wu),Nu=255,Pu=Math.sin(cu),Fu=Math.cos(cu),Gu=mu.data.get(lu.dataId).values;for(let Xu=0;Xu<bu;Xu++){const Qu=Xu*wu*Cu*Eu;for(let Ju=0;Ju<Cu;Ju++){const ip=Ju*(wu*Eu);for(let rp=0;rp<wu;rp++){const op=rp*Eu;for(let hp=0;hp<Eu;hp++){const Ap=[bu,Ju,rp,hp],Up=Ap[2],Vp=Ap[1];let zp=(Up-Tu)*Fu-(Vp-Ru)*Pu,qp=(Up-Tu)*Pu+(Vp-Ru)*Fu;zp=Math.round(zp+Tu),qp=Math.round(qp+Ru);let Yp=hu;if(typeof hu!="number"&&(hp===3?Yp=Nu:Yp=hu[hp]),zp>=0&&zp<wu&&qp>=0&&qp<Cu){const am=qp*(wu*Eu),im=zp*Eu,um=Qu+am+im+hp;Yp=Gu[um]}const em=Qu+ip+op+hp;Au[em]=Yp}}}}return{dataId:mu.write(Au,lu.shape,lu.dtype),shape:lu.shape,dtype:lu.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const LZ=b0(FC,ou=>{const nu=Math.floor(ou);return ou-nu<.5?Math.floor(ou):ou-nu>.5?Math.ceil(ou):nu%2===0?nu:nu+1}),NZ={kernelName:FC,backendName:"cpu",kernelFunc:LZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{indices:cu,updates:hu}=nu,{shape:pu}=lu,{sliceRank:mu,numUpdates:Au,sliceSize:bu,strides:Cu,outputSize:wu}=h1(hu,cu,pu),Eu=!0,Tu=ru.bufferSync(cu),Ru=ru.bufferSync(hu),Nu=C1(Tu,Ru,pu,wu,bu,Au,mu,Cu,0,Eu);return ru.makeTensorInfo(pu,Nu.dtype,Nu.values)}const FZ={kernelName:L_,backendName:"cpu",kernelFunc:DZ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PZ(ou,nu){let ru=0,lu=ou.length,cu=0;for(;ru<lu;)cu=Math.floor((ru+lu)/2),ou[cu]<nu?ru=cu+1:lu=cu;return lu}function GZ(ou,nu){let ru=0,lu=ou.length,cu=0;for(;ru<lu;)cu=Math.floor((ru+lu)/2),ou[cu]<=nu?ru=cu+1:lu=cu;return lu}function OZ(ou,nu,ru,lu,cu,hu){const pu=Yu("int32",ru*cu);for(let mu=0;mu<ru;++mu){const Au=ou.slice(mu*lu,(mu+1)*lu),bu=mu*cu;for(let Cu=0;Cu<cu;++Cu)pu[bu+Cu]=hu==="left"?PZ(Au,nu[Cu+bu]):GZ(Au,nu[Cu+bu])}return pu}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UZ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{sortedSequence:cu,values:hu}=nu,{side:pu}=lu,mu=ru.data.get(cu.dataId).values,Au=ru.data.get(hu.dataId).values,bu=OZ(mu,Au,cu.shape[0],cu.shape[1],hu.shape[1],pu);return ru.makeTensorInfo(hu.shape,"int32",bu)}const $Z={kernelName:D_,backendName:"cpu",kernelFunc:UZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VZ(ou){const{inputs:nu,backend:ru}=ou,{condition:lu,t:cu,e:hu}=nu;Pm([lu,cu,hu],"select");const pu=lu.shape.length,mu=ru.data.get(lu.dataId).values,Au=ru.data.get(cu.dataId).values,bu=ru.data.get(hu.dataId).values,Cu=Uy(cu.dtype,hu.dtype),wu=kp(Mu(cu.shape),Cu);let Eu=0;const Tu=pu===0||pu>1||cu.shape.length===1?1:Mu(cu.shape.slice(1));for(let Ru=0;Ru<mu.length;Ru++)for(let Nu=0;Nu<Tu;Nu++)mu[Ru]===1?wu[Eu++]=Au[Ru]:wu[Eu++]=bu[Ru];return ru.makeTensorInfo(cu.shape,Cu,wu)}const zZ={kernelName:bE,backendName:"cpu",kernelFunc:VZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WZ=ZE,HZ=jE,XZ=b0(GC,ou=>ou>=0?HZ*ou:WZ*(Math.exp(ou)-1)),QZ={kernelName:GC,backendName:"cpu",kernelFunc:XZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KZ=b0($C,ou=>ou<0?-1:ou>0?1:0),ZZ={kernelName:$C,backendName:"cpu",kernelFunc:KZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jZ=b0(OC,ou=>Math.sin(ou)),YZ={kernelName:OC,backendName:"cpu",kernelFunc:jZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qZ=b0(UC,ou=>Math.sinh(ou)),JZ={kernelName:UC,backendName:"cpu",kernelFunc:qZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mD=Math.log(11920928955078125e-23)+2,e8=b0(zC,ou=>{const nu=ou>-mD,ru=ou<mD,lu=Math.exp(ou);let cu;return ru?cu=lu:nu?cu=ou:cu=Math.log(1+lu),cu}),t8={kernelName:zC,backendName:"cpu",kernelFunc:e8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{blockShape:hu,paddings:pu}=lu;Pm([cu],"spaceToBatchND");const mu=Mu(hu),Au=[[0,0]];Au.push(...pu);for(let Pu=1+hu.length;Pu<cu.shape.length;++Pu)Au.push([0,0]);const bu=fD.kernelFunc({inputs:{x:cu},backend:ru,attrs:{paddings:Au,constantValue:0}}),Cu=fw(bu.shape,hu,mu,!1),wu=mw(Cu.length,hu.length,!1),Eu=gw(bu.shape,hu,mu,!1),Tu=S0({inputs:{x:bu},backend:ru,attrs:{shape:Cu}}),Ru=Fy({inputs:{x:Tu},backend:ru,attrs:{perm:wu}}),Nu=S0({inputs:{x:Ru},backend:ru,attrs:{shape:Eu}});return ru.disposeIntermediateTensorInfo(bu),ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),Nu}const i8={kernelName:CE,backendName:"cpu",kernelFunc:n8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function r8(ou){const{inputs:nu,backend:ru}=ou,{indices:lu,values:cu,denseShape:hu,defaultValue:pu}=nu;if(hu.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${hu.shape}`);if(lu.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${lu.shape}`);if(cu.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${cu.shape}`);if(pu.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${pu.shape}`);const mu=ru.data.get(lu.dataId).values,Au=ru.data.get(cu.dataId).values,bu=ru.data.get(hu.dataId).values,Cu=ru.data.get(pu.dataId).values[0],[wu,Eu,Tu,Ru,Nu]=U3(mu,lu.shape,lu.dtype,Au,cu.dtype,bu,Cu);return[ru.makeTensorInfo(Eu,lu.dtype,wu),ru.makeTensorInfo([Eu[0]],cu.dtype,Tu),ru.makeTensorInfo([Ru.length],"bool",new Uint8Array(Ru.map(Pu=>Number(Pu)))),ru.makeTensorInfo([Nu.length],lu.dtype,new Int32Array(Nu))]}const s8={kernelName:F_,backendName:"cpu",kernelFunc:r8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function o8(ou){const{inputs:nu,backend:ru}=ou,{inputIndices:lu,inputShape:cu,newShape:hu}=nu;if(lu.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${lu.shape}`);if(cu.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${cu.shape}`);if(hu.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${hu.shape}`);const pu=Array.from(ru.data.get(cu.dataId).values),mu=ru.data.get(lu.dataId).values,Au=Array.from(ru.data.get(hu.dataId).values),[bu,Cu,wu]=$3(mu,lu.shape,lu.dtype,pu,Au);return[ru.makeTensorInfo(Cu,lu.dtype,bu),ru.makeTensorInfo([wu.length],hu.dtype,new Int32Array(wu))]}const a8={kernelName:P_,backendName:"cpu",kernelFunc:o8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function l8(ou){const{inputs:nu,backend:ru}=ou,{data:lu,indices:cu,segmentIds:hu}=nu;if(lu.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(cu.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${cu.shape}`);if(hu.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${hu.shape}`);if(cu.shape[0]!==hu.shape[0])throw new Error("segmentIds and indices should have same size.");const pu=ru.data.get(lu.dataId).values,mu=ru.data.get(cu.dataId).values,Au=ru.data.get(hu.dataId).values,[bu,Cu]=LT(pu,lu.shape,lu.dtype,mu,Au,!0);return ru.makeTensorInfo(Cu,lu.dtype,bu)}const c8={kernelName:G_,backendName:"cpu",kernelFunc:l8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function u8(ou){const{inputs:nu,backend:ru}=ou,{data:lu,indices:cu,segmentIds:hu}=nu;if(lu.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(cu.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${cu.shape}`);if(hu.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${hu.shape}`);if(cu.shape[0]!==hu.shape[0])throw new Error("segmentIds and indices should have same size.");const pu=ru.data.get(lu.dataId).values,mu=ru.data.get(cu.dataId).values,Au=ru.data.get(hu.dataId).values,[bu,Cu]=LT(pu,lu.shape,lu.dtype,mu,Au);return ru.makeTensorInfo(Cu,lu.dtype,bu)}const h8={kernelName:O_,backendName:"cpu",kernelFunc:u8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function d8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{sparseIndices:cu,sparseValues:hu,defaultValue:pu}=nu,{outputShape:mu}=lu,{sliceRank:Au,numUpdates:bu,sliceSize:Cu,strides:wu,outputSize:Eu}=h1(hu,cu,mu),Tu=!1,Ru=ru.bufferSync(cu);let Nu;switch(hu.dtype){case"bool":{const Pu=ru.bufferSync(hu),Fu=!!ru.data.get(pu.dataId).values[0];Nu=C1(Ru,Pu,mu,Eu,Cu,bu,Au,wu,Fu,Tu);break}case"float32":{const Pu=ru.bufferSync(hu),Fu=ru.data.get(pu.dataId).values[0];Nu=C1(Ru,Pu,mu,Eu,Cu,bu,Au,wu,Fu,Tu);break}case"int32":{const Pu=ru.bufferSync(hu),Fu=ru.data.get(pu.dataId).values[0];Nu=C1(Ru,Pu,mu,Eu,Cu,bu,Au,wu,Fu,Tu);break}case"string":{const Pu=ru.bufferSync(hu),Fu=xv(ru.data.get(pu.dataId).values[0]);Nu=C1(Ru,Pu,mu,Eu,Cu,bu,Au,wu,Fu,Tu);break}default:throw new Error(`Unsupported type ${hu.dtype}`)}return ru.makeTensorInfo(mu,Nu.dtype,Nu.values)}const p8={kernelName:U_,backendName:"cpu",kernelFunc:d8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function f8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{numOrSizeSplits:hu,axis:pu}=lu,mu=Wu(pu,cu.shape)[0],Au=VI(cu,hu,mu),bu=new Array(cu.shape.length).fill(0),Cu=cu.shape.slice();return Au.map(wu=>{const Eu=[...Cu];Eu[mu]=wu;const Tu=w1({inputs:{x:cu},backend:ru,attrs:{begin:bu,size:Eu}});return bu[mu]+=wu,Tu})}const m8={kernelName:wE,backendName:"cpu",kernelFunc:f8};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const g8={kernelName:cS,backendName:"cpu",kernelFunc:({inputs:ou,backend:nu})=>{const{x:ru}=ou,lu=nu;Pm(ru,"square");const cu=lu.data.get(ru.dataId).values,hu=new Float32Array(cu.length);for(let pu=0;pu<cu.length;++pu){const mu=cu[pu];hu[pu]=mu*mu}return{dataId:lu.write(hu,ru.shape,ru.dtype),shape:ru.shape,dtype:ru.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const A8=b0(jC,(ou,nu)=>{const ru=nu;return isNaN(ou)?NaN:ou>0?1:ru.alpha}),y8={kernelName:jC,backendName:"cpu",kernelFunc:A8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{begin:hu,end:pu,strides:mu,beginMask:Au,endMask:bu,ellipsisMask:Cu,newAxisMask:wu,shrinkAxisMask:Eu}=lu;Pm(cu,"stridedSlice");const{finalShapeSparse:Tu,finalShape:Ru,isIdentity:Nu,sliceDim0:Pu,isSimpleSlice:Fu,begin:Gu,end:Xu,strides:Qu}=wI(cu.shape,hu,pu,mu,Au,bu,Cu,wu,Eu);let Ju;if(Nu)Ju=S0({inputs:{x:cu},backend:ru,attrs:{shape:Ru}});else if(Pu||Fu){vu(cu.shape.length>=1,()=>`Input must have rank at least 1, got: ${cu.shape.length}`);const ip=xI(Gu,Xu,Qu),rp=w1({inputs:{x:cu},backend:ru,attrs:{begin:Gu,size:ip}});Ju=S0({inputs:{x:rp},backend:ru,attrs:{shape:Ru}}),ru.disposeIntermediateTensorInfo(rp)}else{const ip=ru.bufferSync(cu),rp=W3(Tu,ip,Qu,Gu);Ju=ru.makeTensorInfo(Ru,rp.dtype,rp.values)}return Ju}const x8={kernelName:hS,backendName:"cpu",kernelFunc:b8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{separator:cu,nGramWidths:hu,leftPad:pu,rightPad:mu,padWidth:Au,preserveShortSequences:bu}=lu,{data:Cu,dataSplits:wu}=nu,Eu=ru.data.get(Cu.dataId).values,Tu=ru.data.get(wu.dataId).values,[Ru,Nu]=H3(Eu,Tu,cu,hu,pu,mu,Au,bu);return[ru.makeTensorInfo([Ru.length],"string",Ru),ru.makeTensorInfo(wu.shape,"int32",Nu)]}const C8={kernelName:$_,backendName:"cpu",kernelFunc:v8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{skipEmpty:cu}=lu,{input:hu,delimiter:pu}=nu;if(hu.dtype!=="string")throw new Error("Input must be of datatype string");if(hu.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${hu.shape}`);if(pu.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${pu.shape}`);const mu=ru.data.get(hu.dataId).values,Au=ru.data.get(pu.dataId).values[0],[bu,Cu,wu]=X3(mu,Au,cu),Eu=Cu.length;return[ru.makeTensorInfo([Eu,2],"int32",bu),ru.makeTensorInfo([Eu],"string",Cu),ru.makeTensorInfo([2],"int32",new Int32Array(wu))]}const E8={kernelName:V_,backendName:"cpu",kernelFunc:w8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{numBuckets:cu}=lu,{input:hu}=nu;if(hu.dtype!=="string")throw new Error("Input must be of datatype string");if(cu<=0)throw new Error("Number of buckets must be at least 1");const pu=ru.data.get(hu.dataId).values,mu=Q3(pu,cu);return ru.makeTensorInfo(hu.shape,"int32",mu)}const I8={kernelName:z_,backendName:"cpu",kernelFunc:S8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const T8=b0(QC,ou=>Math.tan(ou)),_8={kernelName:QC,backendName:"cpu",kernelFunc:T8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const M8=b0(KC,ou=>Math.tanh(ou)),R8={kernelName:KC,backendName:"cpu",kernelFunc:M8};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k8(ou){const{inputs:nu,backend:ru}=ou,{tensor:lu,indices:cu,updates:hu}=nu,{sliceRank:pu,numUpdates:mu,sliceSize:Au,strides:bu,outputSize:Cu}=h1(hu,cu,lu.shape),wu=!1,Eu=ru.bufferSync(cu),Tu=ru.bufferSync(hu),Ru=ru.bufferSync(lu),Nu=C1(Eu,Tu,lu.shape,Cu,Au,mu,pu,bu,Ru,wu);return ru.makeTensorInfo(lu.shape,Nu.dtype,Nu.values)}const B8={kernelName:N_,backendName:"cpu",kernelFunc:k8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{reps:hu}=lu;Pm(cu,"tile");const pu=Z3(ru.bufferSync(cu),hu);return ru.makeTensorInfo(pu.shape,pu.dtype,pu.values)}const N8={kernelName:ZC,backendName:"cpu",kernelFunc:L8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function D8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{k:hu,sorted:pu}=lu;Pm(cu,"topk");const mu=ru.data.get(cu.dataId).values,[Au,bu]=Y3(mu,cu.shape,cu.dtype,hu,pu);return[ru.makeTensorInfo(Au.shape,Au.dtype,Au.values),ru.makeTensorInfo(bu.shape,bu.dtype,bu.values)]}const F8={kernelName:dS,backendName:"cpu",kernelFunc:D8};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P8(ou){const{inputs:nu,attrs:ru,backend:lu}=ou,{image:cu,transforms:hu}=nu,{interpolation:pu,fillMode:mu,fillValue:Au,outputShape:bu}=ru,[Cu,wu,Eu,Tu]=cu.shape,[Ru,Nu]=bu??[wu,Eu],Pu=[Cu,Ru,Nu,Tu],Fu=xp(cu.shape),Gu=Fu[0],Xu=Fu[1],Qu=Fu[2],Ju=xp(Pu),ip=Ju[0],rp=Ju[1],op=Ju[2],hp=Hu(cu.dtype,Mu(Pu));hp.fill(Au);const Ap=lu.data.get(cu.dataId).values,Up=lu.data.get(hu.dataId).values;for(let Vp=0;Vp<Cu;++Vp){const zp=hu.shape[0]===1?Up:Up.subarray(Vp*8,Vp*8+8);for(let qp=0;qp<Ru;++qp)for(let Yp=0;Yp<Nu;++Yp)for(let em=0;em<Tu;++em){let am;const im=zp[6]*Yp+zp[7]*qp+1;if(im===0)continue;const um=(zp[0]*Yp+zp[1]*qp+zp[2])/im,ym=(zp[3]*Yp+zp[4]*qp+zp[5])/im,pm=gD(um,Eu,mu),bm=gD(ym,wu,mu);switch(pu){case"nearest":am=z8(Ap,wu,Eu,Gu,Xu,Qu,Vp,bm,pm,em,Au);break;case"bilinear":am=W8(Ap,wu,Eu,Gu,Xu,Qu,Vp,bm,pm,em,Au);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${pu}`)}const xm=Vp*ip+qp*rp+Yp*op+em;hp[xm]=am}return lu.makeTensorInfo(Pu,cu.dtype,hp)}return{dataId:lu.write(hp,Pu,cu.dtype),shape:cu.shape,dtype:cu.dtype}}const G8={kernelName:pS,backendName:"cpu",kernelFunc:P8};function gD(ou,nu,ru){switch(ru){case"reflect":return O8(ou,nu);case"wrap":return U8(ou,nu);case"nearest":return V8(ou,nu);case"constant":default:return $8(ou)}}function O8(ou,nu){let ru=ou;if(ru<0)if(nu<=1)ru=0;else{const lu=2*nu;ru<lu&&(ru=lu*Math.trunc(-ru/lu)+ru),ru=ru<-nu?ru+lu:-ru-1}else if(ru>nu-1)if(nu<=1)ru=0;else{const lu=2*nu;ru-=lu*Math.trunc(ru/lu),ru>=nu&&(ru=lu-ru-1)}return fu(0,ru,nu-1)}function U8(ou,nu){let ru=ou;if(ru<0)if(nu<=1)ru=0;else{const lu=nu-1;ru+=nu*(Math.trunc(-ru/lu)+1)}else if(ru>nu-1)if(nu<=1)ru=0;else{const lu=nu-1;ru-=nu*Math.trunc(ru/lu)}return fu(0,ru,nu-1)}function $8(ou,nu){return ou}function V8(ou,nu){return fu(0,ou,nu-1)}function Dw(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu,Cu){const wu=pu*lu+mu*cu+Au*hu+bu;return 0<=mu&&mu<nu&&0<=Au&&Au<ru?ou[wu]:Cu}function z8(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu,Cu){const wu=Math.round(mu),Eu=Math.round(Au);return Dw(ou,nu,ru,lu,cu,hu,pu,wu,Eu,bu,Cu)}function W8(ou,nu,ru,lu,cu,hu,pu,mu,Au,bu,Cu){const wu=Math.floor(mu),Eu=Math.floor(Au),Tu=wu+1,Ru=Eu+1,Nu=(Ru-Au)*Dw(ou,nu,ru,lu,cu,hu,pu,wu,Eu,bu,Cu)+(Au-Eu)*Dw(ou,nu,ru,lu,cu,hu,pu,wu,Ru,bu,Cu),Pu=(Ru-Au)*Dw(ou,nu,ru,lu,cu,hu,pu,Tu,Eu,bu,Cu)+(Au-Eu)*Dw(ou,nu,ru,lu,cu,hu,pu,Tu,Ru,bu,Cu);return(Tu-mu)*Nu+(mu-wu)*Pu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function H8(ou){const{inputs:nu,attrs:ru,backend:lu}=ou,{axis:cu}=ru,{x:hu}=nu;Pm(hu,"unique");const pu=lu.data.get(hu.dataId).values,{outputValues:mu,outputShape:Au,indices:bu}=q3(pu,cu,hu.shape,hu.dtype);return[lu.makeTensorInfo(Au,hu.dtype,mu),lu.makeTensorInfo([bu.length],"int32",bu)]}const X8={kernelName:fS,backendName:"cpu",kernelFunc:H8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Q8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{value:cu}=nu;let{axis:hu}=lu;hu<0&&(hu+=cu.shape.length);const pu=cu.shape.length,mu=cu.shape[hu],Au=new Array(pu-1);let bu=0;for(let Tu=0;Tu<pu;Tu++)Tu!==hu&&(Au[bu++]=cu.shape[Tu]);const Cu=new Array(pu).fill(0),wu=cu.shape.slice();wu[hu]=1;const Eu=new Array(mu);for(let Tu=0;Tu<Eu.length;Tu++){Cu[hu]=Tu;const Ru=w1({inputs:{x:cu},backend:ru,attrs:{begin:Cu,size:wu}});Eu[Tu]=S0({inputs:{x:Ru},backend:ru,attrs:{shape:Au}}),ru.disposeIntermediateTensorInfo(Ru)}return Eu}const K8={kernelName:SE,backendName:"cpu",kernelFunc:Q8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Z8(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,segmentIds:hu}=nu,{numSegments:pu}=lu;Pm(cu,"unsortedSegmentSum");const mu=cu.shape.length,Au=hu.shape.length,bu=[],Cu=[],wu=mu-Au;let Eu=hu;for(let Ru=0;Ru<wu;++Ru){const Nu=S2({inputs:{input:Eu},backend:ru,attrs:{dim:Ru+1}});Eu=Nu,Cu.push(Nu)}for(let Ru=0;Ru<pu;++Ru){const Nu=yv(Ru,"int32"),Pu=ru.makeTensorInfo([],"int32",Nu),Fu=c3({inputs:{a:Pu,b:Eu},backend:ru}),Gu=Fv({inputs:{x:Fu},backend:ru,attrs:{dtype:"float32"}}),Xu=C2({inputs:{a:Gu,b:cu},backend:ru}),Qu=Nw({inputs:{x:Xu},backend:ru,attrs:{axis:0,keepDims:!1}});bu.push(Qu),Cu.push(Pu),Cu.push(Fu),Cu.push(Gu),Cu.push(Xu),Cu.push(Qu)}const Tu=pD({inputs:bu,backend:ru,attrs:{axis:0}});return Cu.forEach(Ru=>ru.disposeIntermediateTensorInfo(Ru)),Tu}const j8={kernelName:IE,backendName:"cpu",kernelFunc:Z8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y8=[QX,T4,ZX,YX,L4,JX,t9,i9,s9,a9,c9,h9,p9,g9,y9,v9,w9,S9,T9,HX,M9,k9,L9,D4,D9,k4,P4,P9,_4,G9,U9,$9,z9,H9,Q9,Z9,Y9,J9,tQ,iQ,sQ,aQ,cQ,hQ,dQ,fQ,gQ,yQ,bQ,xQ,vQ,wQ,IQ,GX,_Q,G4,FQ,O4,PQ,$4,zQ,WQ,XQ,z4,H4,KQ,jQ,qQ,eK,Q4,Z4,M4,nK,O9,rK,oK,lK,OX,Y4,J4,uK,tX,dK,mK,AK,xK,CK,EK,SK,iX,TK,MK,kK,LK,DK,PK,OK,sX,$K,WK,QK,aX,cX,jK,JK,nZ,hX,rZ,oZ,aZ,fD,hZ,$X,fX,pZ,mZ,AZ,bZ,R4,PT,vZ,VX,zX,WX,wZ,SZ,TZ,MZ,kZ,BZ,NZ,CX,FZ,$Z,zZ,QZ,EX,ZZ,YZ,JZ,SX,HK,t8,i8,s8,a8,c8,h8,p8,m8,_X,g8,RX,BX,y8,x8,C8,E8,I8,FX,EQ,_8,R8,B8,N8,F8,G8,dX,X8,K8,j8,sZ];for(const ou of Y8)Qy(ou);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const E1={},T2={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function q8(ou,nu){E1[ou]=nu}function kx(ou,nu){if(!(ou in E1)||nu!=null){const lu=_j(ou,nu);if(lu!==null)E1[ou]=lu;else return console.log("Could not get context for WebGL version",ou),null}const ru=E1[ou];return ru==null||ru.isContextLost()?(delete E1[ou],kx(ou)):(ru.disable(ru.DEPTH_TEST),ru.disable(ru.STENCIL_TEST),ru.disable(ru.BLEND),ru.disable(ru.DITHER),ru.disable(ru.POLYGON_OFFSET_FILL),ru.disable(ru.SAMPLE_COVERAGE),ru.enable(ru.SCISSOR_TEST),ru.enable(ru.CULL_FACE),ru.cullFace(ru.BACK),E1[ou])}function J8(ou){if(!cp().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&ou===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function _j(ou,nu){if(ou!==1&&ou!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const ru=nu??J8(ou);return ru.addEventListener("webglcontextlost",lu=>{lu.preventDefault(),delete E1[ou]},!1),cp().getBool("SOFTWARE_WEBGL_ENABLED")&&(T2.failIfMajorPerformanceCaveat=!1),ou===1?ru.getContext("webgl",T2)||ru.getContext("experimental-webgl",T2):ru.getContext("webgl2",T2)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Fw;(function(ou){ou[ou.DENSE=0]="DENSE",ou[ou.SHARED_BATCH=1]="SHARED_BATCH"})(Fw||(Fw={}));var _b;(function(ou){ou[ou.RENDER=0]="RENDER",ou[ou.UPLOAD=1]="UPLOAD",ou[ou.PIXELS=2]="PIXELS",ou[ou.DOWNLOAD=3]="DOWNLOAD"})(_b||(_b={}));var fy;(function(ou){ou[ou.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",ou[ou.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",ou[ou.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",ou[ou.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",ou[ou.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(fy||(fy={}));function Pw(ou,nu){return[nu,ou]}function $j(ou,nu){return ou*nu}function _2(ou){const nu=Mu(ou),ru=Math.ceil(nu/4);return _u(ru)}function cC(ou,nu){return[Math.max(1,Math.ceil(nu/2)),Math.max(1,Math.ceil(ou/2))]}function e6(ou,nu){const[ru,lu]=cC(ou,nu);return ru*lu*4}function UT(ou,nu){const ru=ou;let lu,cu,hu,pu,mu,Au,bu,Cu,wu,Eu;return cp().getNumber("WEBGL_VERSION")===2?(lu=ru.R32F,cu=ru.R16F,hu=ru.RGBA16F,pu=ru.RGBA32F,mu=ru.RED,bu=4,Cu=1,wu=ru.HALF_FLOAT,Eu=ru.FLOAT,Au=ru.RGBA8):(lu=ou.RGBA,cu=ou.RGBA,hu=ou.RGBA,pu=ru.RGBA,mu=ou.RGBA,bu=4,Cu=4,wu=nu!=null?nu.HALF_FLOAT_OES:null,Eu=ou.FLOAT,Au=ou.RGBA),{internalFormatFloat:lu,internalFormatHalfFloat:cu,internalFormatPackedHalfFloat:hu,internalFormatPackedFloat:pu,textureFormatFloat:mu,downloadTextureFormat:Au,downloadUnpackNumChannels:bu,defaultNumChannels:Cu,textureTypeHalfFloat:wu,textureTypeFloat:Eu}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bm(ou,nu){const ru=nu();return cp().getBool("DEBUG")&&t6(ou),ru}function t6(ou){const nu=ou.getError();if(nu!==ou.NO_ERROR)throw new Error("WebGL Error: "+s6(ou,nu))}const n6=596e-10,i6=65504;function r6(ou){return!!(cp().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||ou===0||n6<Math.abs(ou)&&Math.abs(ou)<i6)}function s6(ou,nu){switch(nu){case ou.NO_ERROR:return"NO_ERROR";case ou.INVALID_ENUM:return"INVALID_ENUM";case ou.INVALID_VALUE:return"INVALID_VALUE";case ou.INVALID_OPERATION:return"INVALID_OPERATION";case ou.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case ou.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case ou.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${nu}`}}function M2(ou,nu){return uv(ou,()=>ou.getExtension(nu),'Extension "'+nu+'" not supported on this browser.')}function o6(ou,nu){const ru=uv(ou,()=>ou.createShader(ou.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bm(ou,()=>ou.shaderSource(ru,nu)),Bm(ou,()=>ou.compileShader(ru)),ou.getShaderParameter(ru,ou.COMPILE_STATUS)===!1)throw console.log(ou.getShaderInfoLog(ru)),new Error("Failed to compile vertex shader.");return ru}function a6(ou,nu){const ru=uv(ou,()=>ou.createShader(ou.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bm(ou,()=>ou.shaderSource(ru,nu)),Bm(ou,()=>ou.compileShader(ru)),cp().get("ENGINE_COMPILE_ONLY"))return ru;if(ou.getShaderParameter(ru,ou.COMPILE_STATUS)===!1)throw AD(nu,ou.getShaderInfoLog(ru)),new Error("Failed to compile fragment shader.");return ru}const l6=/ERROR: [0-9]+:([0-9]+):/g;function AD(ou,nu){const ru=l6.exec(nu);if(ru==null){console.log(`Couldn't parse line number in error: ${nu}`),console.log(ou);return}const lu=+ru[1],cu=ou.split(`
`),hu=cu.length.toString().length+2,pu=cu.map((wu,Eu)=>Lu((Eu+1).toString(),hu)+wu);let mu=0;for(let wu=0;wu<pu.length;wu++)mu=Math.max(pu[wu].length,mu);const Au=pu.slice(0,lu-1),bu=pu.slice(lu-1,lu),Cu=pu.slice(lu);console.log(Au.join(`
`)),console.log(nu.split(`
`)[0]),console.log(`%c ${Lu(bu[0],mu)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(Cu.join(`
`))}function c6(ou){return uv(ou,()=>ou.createProgram(),"Unable to create WebGLProgram.")}function u6(ou,nu){if(Bm(ou,()=>ou.linkProgram(nu)),!cp().get("ENGINE_COMPILE_ONLY")&&ou.getProgramParameter(nu,ou.LINK_STATUS)===!1)throw console.log(ou.getProgramInfoLog(nu)),new Error("Failed to link vertex and fragment shaders.")}function $T(ou,nu){if(Bm(ou,()=>ou.validateProgram(nu)),ou.getProgramParameter(nu,ou.VALIDATE_STATUS)===!1)throw console.log(ou.getProgramInfoLog(nu)),new Error("Shader program validation failed.")}function h6(ou,nu){const ru=uv(ou,()=>ou.createBuffer(),"Unable to create WebGLBuffer");return Bm(ou,()=>ou.bindBuffer(ou.ARRAY_BUFFER,ru)),Bm(ou,()=>ou.bufferData(ou.ARRAY_BUFFER,nu,ou.STATIC_DRAW)),ru}function d6(ou,nu){const ru=uv(ou,()=>ou.createBuffer(),"Unable to create WebGLBuffer");return Bm(ou,()=>ou.bindBuffer(ou.ELEMENT_ARRAY_BUFFER,ru)),Bm(ou,()=>ou.bufferData(ou.ELEMENT_ARRAY_BUFFER,nu,ou.STATIC_DRAW)),ru}function p6(ou){return uv(ou,()=>ou.createTexture(),"Unable to create WebGLTexture.")}function f6(ou,nu){const ru=cp().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(ou<=0||nu<=0){const lu=`[${ou}x${nu}]`;throw new Error("Requested texture size "+lu+" is invalid.")}if(ou>ru||nu>ru){const lu=`[${ou}x${nu}]`,cu=`[${ru}x${ru}]`;throw new Error("Requested texture size "+lu+" greater than WebGL maximum on this browser / GPU "+cu+".")}}function m6(ou){return uv(ou,()=>ou.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function yD(ou,nu,ru,lu,cu,hu,pu){const mu=ou.getAttribLocation(nu,ru);return mu===-1?!1:(Bm(ou,()=>ou.bindBuffer(ou.ARRAY_BUFFER,lu)),Bm(ou,()=>ou.vertexAttribPointer(mu,cu,ou.FLOAT,!1,hu,pu)),Bm(ou,()=>ou.enableVertexAttribArray(mu)),!0)}function g6(ou,nu,ru){v6(ou,ru),Bm(ou,()=>ou.activeTexture(ou.TEXTURE0+ru)),Bm(ou,()=>ou.bindTexture(ou.TEXTURE_2D,nu))}function A6(ou,nu,ru){return uv(ou,()=>ou.getUniformLocation(nu,ru),'uniform "'+ru+'" not present in program.')}function y6(ou,nu,ru){return ou.getUniformLocation(nu,ru)}function b6(ou,nu,ru,lu){Bm(ou,()=>g6(ou,nu,lu)),Bm(ou,()=>ou.uniform1i(ru,lu))}function VT(ou,nu,ru){Bm(ou,()=>ou.bindFramebuffer(ou.FRAMEBUFFER,ru)),Bm(ou,()=>ou.framebufferTexture2D(ou.FRAMEBUFFER,ou.COLOR_ATTACHMENT0,ou.TEXTURE_2D,nu,0))}function bD(ou,nu){Bm(ou,()=>ou.bindFramebuffer(ou.FRAMEBUFFER,nu)),Bm(ou,()=>ou.framebufferTexture2D(ou.FRAMEBUFFER,ou.COLOR_ATTACHMENT0,ou.TEXTURE_2D,null,0))}function R2(ou){const nu=ou.checkFramebufferStatus(ou.FRAMEBUFFER);if(nu!==ou.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+x6(ou,nu))}function x6(ou,nu){switch(nu){case ou.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case ou.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case ou.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case ou.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${nu}`}}function uv(ou,nu,ru){const lu=Bm(ou,()=>nu());if(lu==null)throw new Error(ru);return lu}function v6(ou,nu){const ru=ou.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,lu=nu+ou.TEXTURE0;if(lu<ou.TEXTURE0||lu>ru){const cu=`[gl.TEXTURE0, gl.TEXTURE${ru}]`;throw new Error(`textureUnit must be in ${cu}.`)}}function uC(ou,nu=2){return Mu(ou.slice(0,ou.length-nu))}function hC(ou){if(ou.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[ou.length>1?ou[ou.length-2]:1,ou[ou.length-1]]}function k2(ou){let nu=[1,1,1];return ou.length===0||ou.length===1&&ou[0]===1||(nu=[uC(ou),...hC(ou)]),nu}function C6(ou,nu=!1){let ru=cp().getNumber("WEBGL_MAX_TEXTURE_SIZE"),lu=cp().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");lu===1/0&&cp().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(lu=ru/2),nu&&(ru=ru*2,lu=lu*2,ou=ou.map((mu,Au)=>Au>=ou.length-2?gu(ou[Au]):ou[Au]),ou.length===1&&(ou=[2,ou[0]])),ou.length!==2&&(ou=Zu(ou).newShape);let cu=Mu(ou),hu=null;ou.length<=1&&cu<=ru?hu=[1,cu]:ou.length===2&&ou[0]<=ru&&ou[1]<=ru?hu=ou:ou.length===3&&ou[0]*ou[1]<=ru&&ou[2]<=ru?hu=[ou[0]*ou[1],ou[2]]:ou.length===3&&ou[0]<=ru&&ou[1]*ou[2]<=ru?hu=[ou[0],ou[1]*ou[2]]:ou.length===4&&ou[0]*ou[1]*ou[2]<=ru&&ou[3]<=ru?hu=[ou[0]*ou[1]*ou[2],ou[3]]:ou.length===4&&ou[0]<=ru&&ou[1]*ou[2]*ou[3]<=ru&&(hu=[ou[0],ou[1]*ou[2]*ou[3]]);const pu=hu!=null&&Math.max(...hu)>lu&&Math.min(...hu)<=(nu?2:1)&&Math.min(...hu)>0;if(hu==null||pu)if(nu){const mu=uC(ou);let Au=2,bu=2;ou.length&&([Au,bu]=hC(ou)),cu=mu*(Au/2)*(bu/2),hu=_u(cu).map(Cu=>Cu*2)}else hu=_u(cu);return hu}function B2(ou){return ou%2===0}function L2(ou,nu){if(ou=ou.slice(-2),nu=nu.slice(-2),ku(ou,nu)||!ou.length||!nu.length||ou[0]===0||ou[1]===0||nu[0]===0||nu[1]===0)return!0;if(ou.length!==nu.length){const ru=ou[ou.length-1],lu=nu[nu.length-1];if(ru===lu||B2(ru)&&B2(lu)&&(ou[0]===1||nu[0]===1))return!0}return ou[1]===nu[1]&&B2(ou[0])&&B2(nu[0])}let zT,WT;function w6(ou){if(zT==null){const nu=kx(ou);zT=nu.getParameter(nu.MAX_TEXTURE_SIZE)}return zT}function E6(ou){if(WT==null){const nu=kx(ou);WT=nu.getParameter(nu.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,WT)}function S6(ou){if(ou===0)return 0;let nu;const ru=kx(ou);return mx(ru,"EXT_disjoint_timer_query_webgl2")&&ou===2?nu=2:mx(ru,"EXT_disjoint_timer_query")?nu=1:nu=0,nu}function mx(ou,nu){return ou.getExtension(nu)!=null}function xD(ou){try{if(kx(ou)!=null)return!0}catch(nu){return console.log("Error when getting WebGL context: ",nu),!1}return!1}function I6(ou){if(ou===0)return!1;const nu=kx(ou);if(ou===1){if(!mx(nu,"OES_texture_float"))return!1}else if(!mx(nu,"EXT_color_buffer_float"))return!1;return HT(nu)}function T6(ou){if(ou===0)return!1;const nu=kx(ou);if(ou===1){if(!mx(nu,"OES_texture_float")||!mx(nu,"WEBGL_color_buffer_float"))return!1}else{if(mx(nu,"EXT_color_buffer_float"))return HT(nu);const ru="EXT_color_buffer_half_float";if(mx(nu,ru)){const lu=nu.getExtension(ru);return _6(nu,lu)}return!1}return HT(nu)}function HT(ou){const nu=UT(ou),ru=ou.createTexture();ou.bindTexture(ou.TEXTURE_2D,ru),ou.texImage2D(ou.TEXTURE_2D,0,nu.internalFormatFloat,1,1,0,nu.textureFormatFloat,nu.textureTypeFloat,null);const lu=ou.createFramebuffer();ou.bindFramebuffer(ou.FRAMEBUFFER,lu),ou.framebufferTexture2D(ou.FRAMEBUFFER,ou.COLOR_ATTACHMENT0,ou.TEXTURE_2D,ru,0);const cu=ou.checkFramebufferStatus(ou.FRAMEBUFFER)===ou.FRAMEBUFFER_COMPLETE;return ou.bindTexture(ou.TEXTURE_2D,null),ou.bindFramebuffer(ou.FRAMEBUFFER,null),ou.deleteTexture(ru),ou.deleteFramebuffer(lu),cu}function _6(ou,nu){const ru=UT(ou,nu),lu=ou.createTexture();ou.bindTexture(ou.TEXTURE_2D,lu),ou.texImage2D(ou.TEXTURE_2D,0,ru.internalFormatHalfFloat,1,1,0,ru.textureFormatFloat,ru.textureTypeHalfFloat,null);const cu=ou.createFramebuffer();ou.bindFramebuffer(ou.FRAMEBUFFER,cu),ou.framebufferTexture2D(ou.FRAMEBUFFER,ou.COLOR_ATTACHMENT0,ou.TEXTURE_2D,lu,0);const hu=ou.checkFramebufferStatus(ou.FRAMEBUFFER)===ou.FRAMEBUFFER_COMPLETE;return ou.bindTexture(ou.TEXTURE_2D,null),ou.bindFramebuffer(ou.FRAMEBUFFER,null),ou.deleteTexture(lu),ou.deleteFramebuffer(cu),hu}function M6(ou){return ou!==2?!1:kx(ou).fenceSync!=null}function Gw(ou,nu){Array.isArray(ou)||(ou=[ou]),ou.forEach(ru=>{ru!=null&&vu(ru.dtype!=="complex64",()=>`${nu} does not support complex64 tensors in the WebGL backend.`)})}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Om=cp();Om.registerFlag("HAS_WEBGL",()=>Om.getNumber("WEBGL_VERSION")>0),Om.registerFlag("WEBGL_VERSION",()=>xD(2)?2:xD(1)?1:0),Om.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Om.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Om.get("WEBGL_VERSION")===2),Om.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Om.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Om.registerFlag("WEBGL_PACK",()=>Om.getBool("HAS_WEBGL")),Om.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_CLIP",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_REDUCE",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_LAZILY_UNPACK",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_CONV_IM2COL",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Om.getBool("WEBGL_PACK")),Om.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>w6(Om.getNumber("WEBGL_VERSION"))),Om.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>E6(Om.getNumber("WEBGL_VERSION"))),Om.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const ou=Om.getNumber("WEBGL_VERSION");return ou===0?0:S6(ou)}),Om.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Om.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!yM()),Om.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>I6(Om.getNumber("WEBGL_VERSION"))),Om.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Om.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Om.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Om.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>T6(Om.getNumber("WEBGL_VERSION"))),Om.registerFlag("WEBGL_FENCE_API_ENABLED",()=>M6(Om.getNumber("WEBGL_VERSION"))),Om.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Om.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Om.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,ou=>{if(typeof ou!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${ou}.`);if(ou<0&&ou!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${ou}.`)}),Om.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>yM()?1:-1,ou=>{if(typeof ou!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${ou}.`);if(ou<0&&ou!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${ou}.`)}),Om.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Om.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Om.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Om.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Om.registerFlag("WEBGL_EXP_CONV",()=>!1),Om.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Om.getBool("IS_TEST")),Om.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Om.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Om.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Om.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ey(){let ou,nu,ru,lu,cu,hu,pu,mu,Au,bu;return cp().getNumber("WEBGL_VERSION")===2?(ou="#version 300 es",nu="in",ru="out",lu="in",cu="texture",hu="outputColor",pu="out vec4 outputColor;",mu=cp().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",Au="",bu=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(ou="",nu="attribute",ru="varying",lu="varying",cu="texture2D",hu="gl_FragColor",pu="",mu=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,Au=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,bu=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:ou,attribute:nu,varyingVs:ru,varyingFs:lu,texture2D:cu,output:hu,defineOutput:pu,defineSpecialNaN:mu,defineSpecialInf:Au,defineRound:bu}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S1(ou,nu,ru="index"){const lu=xp(nu);return lu.map((cu,hu)=>{const pu=`int ${ou[hu]} = ${ru} / ${cu}`,mu=hu===lu.length-1?`int ${ou[hu+1]} = ${ru} - ${ou[hu]} * ${cu}`:`index -= ${ou[hu]} * ${cu}`;return`${pu}; ${mu};`}).join("")}function N2(ou,nu,ru="index"){const lu=xp(nu);return lu.map((cu,hu)=>{const pu=`int ${ou[hu]} = ${ru} / outShapeStrides[${hu}]`,mu=hu===lu.length-1?`int ${ou[hu+1]} = ${ru} - ${ou[hu]} * outShapeStrides[${hu}]`:`index -= ${ou[hu]} * outShapeStrides[${hu}]`;return`${pu}; ${mu};`}).join("")}function R6(ou,nu){const ru=ou.length,lu=ou.map(hu=>`${nu}[${hu}]`),cu=new Array(ru-1);cu[ru-2]=lu[ru-1];for(let hu=ru-3;hu>=0;--hu)cu[hu]=`(${cu[hu+1]} * ${lu[hu+1]})`;return cu}function k6(ou,nu,ru="index"){const lu=ou.map((hu,pu)=>pu),cu=R6(lu,nu);return cu.map((hu,pu)=>{const mu=`int ${ou[pu]} = ${ru} / ${cu[pu]}`,Au=pu===cu.length-1?`int ${ou[pu+1]} = ${ru} - ${ou[pu]} * ${cu[pu]}`:`index -= ${ou[pu]} * ${cu[pu]}`;return`${mu}; ${Au};`}).join("")}function XT(ou){const nu=xp(ou).map(ru=>ru.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${nu[0]} + coords.y * ${nu[1]} + coords.z;
  }
`}function QT(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const vD=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{getBroadcastDims:CD}=Tz;function B6(ou,nu,ru){const lu=[];if(ou.forEach(Eu=>{const Tu=Mu(Eu.shapeInfo.logicalShape);if(Eu.shapeInfo.isUniform?lu.push(`uniform float ${Eu.name}${Tu>1?`[${Tu}]`:""};`):(lu.push(`uniform sampler2D ${Eu.name};`),lu.push(`uniform int offset${Eu.name};`)),ru.enableShapeUniforms){const{uniformShape:Ru}=KT(ru.packedInputs,Eu.shapeInfo.logicalShape,Eu.shapeInfo.texShape);switch(Ru.length){case 1:lu.push(`uniform int ${Eu.name}Shape;`);break;case 2:lu.push(`uniform ivec2 ${Eu.name}Shape;`);break;case 3:lu.push(`uniform ivec3 ${Eu.name}Shape;`);break;case 4:lu.push(`uniform ivec4 ${Eu.name}Shape;`);break}lu.push(`uniform ivec2 ${Eu.name}TexShape;`)}}),ru.enableShapeUniforms){switch(nu.logicalShape.length){case 1:lu.push("uniform int outShape;");break;case 2:lu.push("uniform ivec2 outShape;"),lu.push("uniform int outShapeStrides;");break;case 3:lu.push("uniform ivec3 outShape;"),lu.push("uniform ivec2 outShapeStrides;");break;case 4:lu.push("uniform ivec4 outShape;"),lu.push("uniform ivec3 outShapeStrides;");break}lu.push("uniform ivec2 outTexShape;")}ru.customUniforms&&ru.customUniforms.forEach(Eu=>{lu.push(`uniform ${Eu.type} ${Eu.name}${Eu.arrayIndex?`[${Eu.arrayIndex}]`:""};`)});const cu=lu.join(`
`),hu=ou.map(Eu=>L6(Eu,nu,ru.packedInputs,ru.enableShapeUniforms)).join(`
`),pu=nu.texShape,mu=Ey(),Au=F6(mu);let bu,Cu,wu=O6(mu);return nu.isPacked?(bu=N6(nu.logicalShape,pu,ru.enableShapeUniforms),Cu=G6(mu)):(bu=D6(nu.logicalShape,pu,ru.enableShapeUniforms),Cu=P6(mu)),ru.packedInputs&&(wu+=z6),[wu,Au,Cu,cu,bu,hu,ru.userCode].join(`
`)}function dC(ou,nu=!1){const ru=ou.shapeInfo.logicalShape;switch(ru.length){case 0:return t7(ou,nu);case 1:return i7(ou,nu);case 2:return s7(ou,nu);case 3:return a7(ou,nu);case 4:return c7(ou,nu);case 5:return u7(ou);case 6:return h7(ou);default:throw new Error(`${ru.length}-D input sampling is not yet supported`)}}function wD(ou,nu){switch(ou.shapeInfo.logicalShape.length){case 0:return e7(ou);case 1:return n7(ou,nu);case 2:return r7(ou,nu);case 3:return o7(ou,nu);default:return l7(ou,nu)}}function L6(ou,nu,ru=!1,lu){let cu="";ru?cu+=wD(ou,lu):cu+=dC(ou,lu);const hu=ou.shapeInfo.logicalShape,pu=nu.logicalShape;return hu.length<=pu.length&&(ru?cu+=d7(ou,nu):cu+=p7(ou,nu)),cu}function N6(ou,nu,ru){switch(ou.length){case 0:return ED();case 1:return W6(ou,nu,ru);case 2:return q6(ou,nu,ru);case 3:return X6(ou,nu,ru);default:return K6(ou,nu,ru)}}function D6(ou,nu,ru){switch(ou.length){case 0:return ED();case 1:return H6(ou,nu,ru);case 2:return J6(ou,nu,ru);case 3:return Q6(ou,nu,ru);case 4:return Z6(ou,nu,ru);case 5:return j6(ou,nu);case 6:return Y6(ou,nu);default:throw new Error(`${ou.length}-D output sampling is not yet supported`)}}function F6(ou){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${ou.texture2D}(textureSampler, uv).r;
    }
  `}function P6(ou){return`
    void setOutput(float val) {
      ${ou.output} = vec4(val, 0, 0, 0);
    }
  `}function G6(ou){return`
    void setOutput(vec4 val) {
      ${ou.output} = val;
    }
  `}function O6(ou){return`${ou.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${ou.varyingFs} vec2 resultUV;
    ${ou.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${ou.defineSpecialNaN}
    ${ou.defineSpecialInf}
    ${ou.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${U6}
    ${$6}
    ${V6}
  `}const U6=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$6=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,V6=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,z6=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function ED(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function W6(ou,nu,ru){const lu=[Math.ceil(nu[0]/2),Math.ceil(nu[1]/2)];return lu[0]===1?ru?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${lu[1]}.0);
      }
    `:lu[1]===1?ru?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${lu[0]}.0);
      }
    `:ru?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${lu[0]}, ${lu[1]}));
      return 2 * (resTexRC.x * ${lu[1]} + resTexRC.y);
    }
  `}function H6(ou,nu,ru){return nu[0]===1?ru?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${nu[1]}.0);
      }
    `:nu[1]===1?ru?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${nu[0]}.0);
      }
    `:ru?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${nu[0]}, ${nu[1]}));
      return resTexRC.x * ${nu[1]} + resTexRC.y;
    }
  `}function X6(ou,nu,ru){if(ru)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const lu=[Math.ceil(nu[0]/2),Math.ceil(nu[1]/2)],cu=Math.ceil(ou[2]/2),hu=cu*Math.ceil(ou[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${lu[0]}, ${lu[1]}));
      int index = resTexRC.x * ${lu[1]} + resTexRC.y;

      int b = index / ${hu};
      index -= b * ${hu};

      int r = 2 * (index / ${cu});
      int c = imod(index, ${cu}) * 2;

      return ivec3(b, r, c);
    }
  `}function Q6(ou,nu,ru){if(ru)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${N2(["r","c","d"],ou)}
    return ivec3(r, c, d);
  }
`;const lu=S1(["r","c","d"],ou);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${nu[0]}, ${nu[1]}));
      int index = resTexRC.x * ${nu[1]} + resTexRC.y;
      ${lu}
      return ivec3(r, c, d);
    }
  `}function K6(ou,nu,ru){if(ru)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const lu=[Math.ceil(nu[0]/2),Math.ceil(nu[1]/2)],cu=Math.ceil(ou[ou.length-1]/2),hu=cu*Math.ceil(ou[ou.length-2]/2);let pu=hu,mu="",Au="b, r, c";for(let bu=2;bu<ou.length-1;bu++)pu*=ou[ou.length-bu-1],mu=`
      int b${bu} = index / ${pu};
      index -= b${bu} * ${pu};
    `+mu,Au=`b${bu}, `+Au;return`
    ivec${ou.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${lu[0]}, ${lu[1]}));
      int index = resTexRC.x * ${lu[1]} + resTexRC.y;

      ${mu}

      int b = index / ${hu};
      index -= b * ${hu};

      int r = 2 * (index / ${cu});
      int c = imod(index, ${cu}) * 2;

      return ivec${ou.length}(${Au});
    }
  `}function Z6(ou,nu,ru){if(ru)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${N2(["r","c","d","d2"],ou)}
      return ivec4(r, c, d, d2);
    }
  `;const lu=S1(["r","c","d","d2"],ou);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${nu[0]}, ${nu[1]}));
      int index = resTexRC.x * ${nu[1]} + resTexRC.y;
      ${lu}
      return ivec4(r, c, d, d2);
    }
  `}function j6(ou,nu){const ru=S1(["r","c","d","d2","d3"],ou);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${nu[0]},
                             ${nu[1]}));

      int index = resTexRC.x * ${nu[1]} + resTexRC.y;

      ${ru}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Y6(ou,nu){const ru=S1(["r","c","d","d2","d3","d4"],ou);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${nu[0]}, ${nu[1]}));
      int index = resTexRC.x * ${nu[1]} + resTexRC.y;

      ${ru}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function q6(ou,nu,ru){const lu=[Math.ceil(nu[0]/2),Math.ceil(nu[1]/2)];if(ku(ou,nu))return ru?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${lu[0]}, ${lu[1]}));
      }
    `;const cu=Math.ceil(ou[1]/2);return ru?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${lu[0]}, ${lu[1]}));

      int index = resTexRC.x * ${lu[1]} + resTexRC.y;
      int r = 2 * (index / ${cu});
      int c = imod(index, ${cu}) * 2;

      return ivec2(r, c);
    }
  `}function J6(ou,nu,ru){return ku(ou,nu)?ru?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${nu[0]}, ${nu[1]}));
      }
    `:ou[1]===1?ru?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${nu[0]}, ${nu[1]}));
        int index = resTexRC.x * ${nu[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:ou[0]===1?ru?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${nu[0]}, ${nu[1]}));
        int index = resTexRC.x * ${nu[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:ru?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${nu[0]}, ${nu[1]}));
      int index = resTexRC.x * ${nu[1]} + resTexRC.y;
      int r = index / ${ou[1]};
      int c = index - r * ${ou[1]};
      return ivec2(r, c);
    }
  `}function I1(ou){return`offset${ou}`}function e7(ou){const nu=ou.name,ru="get"+nu.charAt(0).toUpperCase()+nu.slice(1),lu=Ey();return`
    vec4 ${ru}() {
      return ${lu.texture2D}(${nu}, halfCR);
    }
  `}function t7(ou,nu){const ru=ou.name,lu="get"+ru.charAt(0).toUpperCase()+ru.slice(1);if(ou.shapeInfo.isUniform)return`float ${lu}() {return ${ru};}`;const[cu,hu]=ou.shapeInfo.texShape;if(cu===1&&hu===1)return`
      float ${lu}() {
        return sampleTexture(${ru}, halfCR);
      }
    `;const pu=I1(ru);if(nu)return`
    float ${lu}() {
      vec2 uv = uvFromFlat(${ru}TexShape[0], ${ru}TexShape[1], ${pu});
      return sampleTexture(${ru}, uv);
    }
  `;const[mu,Au]=ou.shapeInfo.texShape;return`
    float ${lu}() {
      vec2 uv = uvFromFlat(${mu}, ${Au}, ${pu});
      return sampleTexture(${ru}, uv);
    }
  `}function n7(ou,nu){const ru=ou.name,lu="get"+ru.charAt(0).toUpperCase()+ru.slice(1),cu=ou.shapeInfo.texShape,hu=Ey();if(nu)return`
    vec4 ${lu}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${ru}TexShape[0]) / 2.0), ceil(float(${ru}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${hu.texture2D}(${ru}, uv);
    }
  `;const pu=[Math.ceil(cu[0]/2),Math.ceil(cu[1]/2)];return`
    vec4 ${lu}(int index) {
      vec2 uv = packedUVfrom1D(
        ${pu[0]}, ${pu[1]}, index);
      return ${hu.texture2D}(${ru}, uv);
    }
  `}function i7(ou,nu){const ru=ou.name,lu="get"+ru.charAt(0).toUpperCase()+ru.slice(1);if(ou.shapeInfo.isUniform)return`
      float ${lu}(int index) {
        ${pC(ou)}
      }
    `;const cu=ou.shapeInfo.texShape,hu=cu[0],pu=cu[1];if(pu===1&&hu===1)return`
      float ${lu}(int index) {
        return sampleTexture(${ru}, halfCR);
      }
    `;const mu=I1(ru);return pu===1?nu?`
      float ${lu}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${mu}) + 0.5) / float(${ru}TexShape[0]));
        return sampleTexture(${ru}, uv);
      }
    `:`
      float ${lu}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${mu}) + 0.5) / ${hu}.0);
        return sampleTexture(${ru}, uv);
      }
    `:hu===1?nu?`
      float ${lu}(int index) {
        vec2 uv = vec2((float(index + ${mu}) + 0.5) / float(${ru}TexShape[1]), 0.5);
        return sampleTexture(${ru}, uv);
      }
    `:`
      float ${lu}(int index) {
        vec2 uv = vec2((float(index + ${mu}) + 0.5) / ${pu}.0, 0.5);
        return sampleTexture(${ru}, uv);
      }
    `:nu?`
    float ${lu}(int index) {
      vec2 uv = uvFromFlat(${ru}TexShape[0], ${ru}TexShape[1], index + ${mu});
      return sampleTexture(${ru}, uv);
    }
  `:`
    float ${lu}(int index) {
      vec2 uv = uvFromFlat(${hu}, ${pu}, index + ${mu});
      return sampleTexture(${ru}, uv);
    }
  `}function r7(ou,nu){const ru=ou.shapeInfo.logicalShape,lu=ou.name,cu="get"+lu.charAt(0).toUpperCase()+lu.slice(1),hu=ou.shapeInfo.texShape,pu=hu[0],mu=hu[1],Au=Ey();if(hu!=null&&ku(ru,hu))return nu?`
      vec4 ${cu}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${lu}TexShape[1], ${lu}TexShape[0]);

        return ${Au.texture2D}(${lu}, uv);
      }
    `:`
      vec4 ${cu}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${mu}.0, ${pu}.0);

        return ${Au.texture2D}(${lu}, uv);
      }
    `;if(nu)return`
    vec4 ${cu}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${lu}TexShape[0]) / 2.0), ceil(float(${lu}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${lu}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${Au.texture2D}(${lu}, uv);
    }
  `;const bu=[Math.ceil(hu[0]/2),Math.ceil(hu[1]/2)],Cu=Math.ceil(ru[1]/2);return`
    vec4 ${cu}(int row, int col) {
      vec2 uv = packedUVfrom2D(${Cu}, ${bu[0]}, ${bu[1]}, row, col);
      return ${Au.texture2D}(${lu}, uv);
    }
  `}function s7(ou,nu){const ru=ou.shapeInfo.logicalShape,lu=ou.name,cu="get"+lu.charAt(0).toUpperCase()+lu.slice(1),hu=ou.shapeInfo.texShape;if(hu!=null&&ku(ru,hu)){if(nu)return`
      float ${cu}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${lu}TexShape[1], ${lu}TexShape[0]);
        return sampleTexture(${lu}, uv);
      }
    `;const Eu=hu[0],Tu=hu[1];return`
    float ${cu}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${Tu}.0, ${Eu}.0);
      return sampleTexture(${lu}, uv);
    }
  `}const{newShape:pu,keptDims:mu}=Zu(ru),Au=pu;if(Au.length<ru.length){const Eu=fC(ou,Au),Tu=["row","col"];return`
      ${dC(Eu,nu)}
      float ${cu}(int row, int col) {
        return ${cu}(${mC(Tu,mu)});
      }
    `}if(ou.shapeInfo.isUniform)return`
      float ${cu}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${ru[1]}, 1)));
        ${pC(ou)}
      }
    `;const bu=hu[0],Cu=hu[1],wu=I1(lu);return Cu===1?nu?`
      float ${cu}(int row, int col) {
        float index = dot(vec3(row, col, ${wu}), vec3(${lu}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${lu}TexShape[0]));
        return sampleTexture(${lu}, uv);
      }
    `:`
    float ${cu}(int row, int col) {
      float index = dot(vec3(row, col, ${wu}), vec3(${ru[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${bu}.0);
      return sampleTexture(${lu}, uv);
    }
  `:bu===1?nu?`
      float ${cu}(int row, int col) {
        float index = dot(vec3(row, col, ${wu}), vec3(${lu}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${lu}TexShape[1]), 0.5);
        return sampleTexture(${lu}, uv);
      }
    `:`
    float ${cu}(int row, int col) {
      float index = dot(vec3(row, col, ${wu}), vec3(${ru[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${Cu}.0, 0.5);
      return sampleTexture(${lu}, uv);
    }
  `:nu?`
      float ${cu}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${lu}Shape[1] + col + ${wu};
        vec2 uv = uvFromFlat(${lu}TexShape[0], ${lu}TexShape[1], index);
        return sampleTexture(${lu}, uv);
      }
    `:`
  float ${cu}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${ru[1]} + col + ${wu};
    vec2 uv = uvFromFlat(${bu}, ${Cu}, index);
    return sampleTexture(${lu}, uv);
  }
`}function o7(ou,nu){const ru=ou.shapeInfo.logicalShape,lu=ou.name,cu="get"+lu.charAt(0).toUpperCase()+lu.slice(1),hu=ou.shapeInfo.texShape,pu=[Math.ceil(hu[0]/2),Math.ceil(hu[1]/2)];if(ru[0]===1){const Eu=ru.slice(1),Tu=[1,2],Ru=fC(ou,Eu),Nu=["b","row","col"];return`
        ${wD(Ru,nu)}
        vec4 ${cu}(int b, int row, int col) {
          return ${cu}(${mC(Nu,Tu)});
        }
      `}const mu=Ey();if(nu)return`
    vec4 ${cu}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${lu}TexShape[0]) / 2.0), ceil(float(${lu}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${lu}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${lu}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${mu.texture2D}(${lu}, uv);
    }
  `;const Au=pu[0],bu=pu[1],Cu=Math.ceil(ru[2]/2),wu=Cu*Math.ceil(ru[1]/2);return`
    vec4 ${cu}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${Au}, ${bu}, ${wu}, ${Cu}, b, row, col);
      return ${mu.texture2D}(${lu}, uv);
    }
  `}function a7(ou,nu){const ru=ou.shapeInfo.logicalShape,lu=ou.name,cu="get"+lu.charAt(0).toUpperCase()+lu.slice(1),hu=ru[1]*ru[2],pu=ru[2],{newShape:mu,keptDims:Au}=Zu(ru),bu=mu;if(bu.length<ru.length){const Nu=fC(ou,bu),Pu=["row","col","depth"];return`
        ${dC(Nu,nu)}
        float ${cu}(int row, int col, int depth) {
          return ${cu}(${mC(Pu,Au)});
        }
      `}if(ou.shapeInfo.isUniform)return`
      float ${cu}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${hu}, ${pu}, 1)));
        ${pC(ou)}
      }
    `;const Cu=ou.shapeInfo.texShape,wu=Cu[0],Eu=Cu[1],Tu=ou.shapeInfo.flatOffset;if(Eu===hu&&Tu==null)return nu?`
      float ${cu}(int row, int col, int depth) {
        int stride1 = ${lu}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${lu}TexShape[1], ${lu}TexShape[0]);
        return sampleTexture(${lu}, uv);
      }
    `:`
        float ${cu}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${pu}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${Eu}.0, ${wu}.0);
          return sampleTexture(${lu}, uv);
        }
      `;if(Eu===pu&&Tu==null)return nu?`
      float ${cu}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${lu}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${lu}TexShape[1], ${lu}TexShape[0]);
        return sampleTexture(${lu}, uv);
      }
    `:`
    float ${cu}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${ru[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Eu}.0, ${wu}.0);
      return sampleTexture(${lu}, uv);
    }
  `;const Ru=I1(lu);return nu?`
    float ${cu}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${lu}Shape[1] * ${lu}Shape[2];
      int stride1 = ${lu}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${Ru};
      vec2 uv = uvFromFlat(${lu}TexShape[0], ${lu}TexShape[1], index);
      return sampleTexture(${lu}, uv);
    }
    `:`
      float ${cu}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${hu} + col * ${pu} + depth + ${Ru};
        vec2 uv = uvFromFlat(${wu}, ${Eu}, index);
        return sampleTexture(${lu}, uv);
      }
  `}function l7(ou,nu){const ru=ou.name,lu="get"+ru.charAt(0).toUpperCase()+ru.slice(1),cu=Ey();if(nu)return`
    vec4 ${lu}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${ru}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${ru}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${ru}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${ru}TexShape[0]) / 2.0), ceil(float(${ru}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${cu.texture2D}(${ru}, uv);
    }
  `;const hu=ou.shapeInfo.logicalShape,pu=hu.length,mu=ou.shapeInfo.texShape,Au=[Math.ceil(mu[0]/2),Math.ceil(mu[1]/2)],bu=Au[0],Cu=Au[1],wu=Math.ceil(hu[pu-1]/2);let Eu=wu*Math.ceil(hu[pu-2]/2),Tu="int b, int row, int col",Ru=`b * ${Eu} + (row / 2) * ${wu} + (col / 2)`;for(let Nu=2;Nu<pu-1;Nu++)Tu=`int b${Nu}, `+Tu,Eu*=hu[pu-Nu-1],Ru=`b${Nu} * ${Eu} + `+Ru;return`
    vec4 ${lu}(${Tu}) {
      int index = ${Ru};
      int texR = index / ${Cu};
      int texC = index - texR * ${Cu};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Cu}, ${bu});
      return ${cu.texture2D}(${ru}, uv);
    }
  `}function c7(ou,nu){const ru=ou.shapeInfo.logicalShape,lu=ou.name,cu="get"+lu.charAt(0).toUpperCase()+lu.slice(1),hu=ru[3],pu=ru[2]*hu,mu=ru[1]*pu,{newShape:Au,keptDims:bu}=Zu(ru);if(Au.length<ru.length){const Gu=fC(ou,Au),Xu=["row","col","depth","depth2"];return`
      ${dC(Gu,nu)}
      float ${cu}(int row, int col, int depth, int depth2) {
        return ${cu}(${mC(Xu,bu)});
      }
    `}if(ou.shapeInfo.isUniform)return`
      float ${cu}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${mu}, ${pu}, ${hu}, 1)));
        ${pC(ou)}
      }
    `;const Cu=ou.shapeInfo.flatOffset,wu=ou.shapeInfo.texShape,Eu=wu[0],Tu=wu[1],Ru=`int stride2 = ${lu}Shape[3];`,Nu=`int stride1 = ${lu}Shape[2] * stride2;`,Pu=`int stride0 = ${lu}Shape[1] * stride1;`;if(Tu===mu&&Cu==null)return nu?`
      float ${cu}(int row, int col, int depth, int depth2) {
        ${Ru}
        ${Nu}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${lu}TexShape[1], ${lu}TexShape[0]);
        return sampleTexture(${lu}, uv);
      }
    `:`
      float ${cu}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${pu}, ${hu}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${Tu}.0, ${Eu}.0);
        return sampleTexture(${lu}, uv);
      }
    `;if(Tu===hu&&Cu==null)return nu?`
      float ${cu}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${lu}Shape[1] * ${lu}Shape[2], ${lu}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${lu}TexShape[1], ${lu}TexShape[0]);
        return sampleTexture(${lu}, uv);
      }
    `:`
      float ${cu}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${ru[1]*ru[2]}, ${ru[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${Tu}.0, ${Eu}.0);
        return sampleTexture(${lu}, uv);
      }
    `;const Fu=I1(lu);return nu?`
    float ${cu}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${Ru}
      ${Nu}
      ${Pu}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${lu}TexShape[0], ${lu}TexShape[1], index + ${Fu});
      return sampleTexture(${lu}, uv);
    }
  `:`
    float ${cu}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${mu} + col * ${pu} +
          depth * ${hu} + depth2;
      vec2 uv = uvFromFlat(${Eu}, ${Tu}, index + ${Fu});
      return sampleTexture(${lu}, uv);
    }
  `}function u7(ou){const nu=ou.shapeInfo.logicalShape,ru=ou.name,lu="get"+ru.charAt(0).toUpperCase()+ru.slice(1),cu=nu[4],hu=nu[3]*cu,pu=nu[2]*hu,mu=nu[1]*pu,{newShape:Au,keptDims:bu}=Zu(nu);if(Au.length<nu.length){const Nu=fC(ou,Au),Pu=["row","col","depth","depth2","depth3"];return`
      ${dC(Nu)}
      float ${lu}(int row, int col, int depth, int depth2, int depth3) {
        return ${lu}(${mC(Pu,bu)});
      }
    `}if(ou.shapeInfo.isUniform)return`
      float ${lu}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${mu}, ${pu}, ${hu}, ${cu})) +
          depth3;
        ${pC(ou)}
      }
    `;const Cu=ou.shapeInfo.flatOffset,wu=ou.shapeInfo.texShape,Eu=wu[0],Tu=wu[1];if(Tu===mu&&Cu==null)return`
      float ${lu}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${pu}, ${hu}, ${cu}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${Tu}.0, ${Eu}.0);
        return sampleTexture(${ru}, uv);
      }
    `;if(Tu===cu&&Cu==null)return`
      float ${lu}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${nu[1]*nu[2]*nu[3]},
               ${nu[2]*nu[3]}, ${nu[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${Tu}.0, ${Eu}.0);
        return sampleTexture(${ru}, uv);
      }
    `;const Ru=I1(ru);return`
    float ${lu}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${mu} + col * ${pu} + depth * ${hu} +
          depth2 * ${cu} + depth3 + ${Ru};
      vec2 uv = uvFromFlat(${Eu}, ${Tu}, index);
      return sampleTexture(${ru}, uv);
    }
  `}function h7(ou){const nu=ou.shapeInfo.logicalShape,ru=ou.name,lu="get"+ru.charAt(0).toUpperCase()+ru.slice(1),{newShape:cu,keptDims:hu}=Zu(nu);if(cu.length<nu.length){const Pu=fC(ou,cu),Fu=["row","col","depth","depth2","depth3","depth4"];return`
      ${dC(Pu)}
      float ${lu}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${lu}(${mC(Fu,hu)});
      }
    `}const pu=nu[5],mu=nu[4]*pu,Au=nu[3]*mu,bu=nu[2]*Au,Cu=nu[1]*bu;if(ou.shapeInfo.isUniform)return`
      float ${lu}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${Cu}, ${bu}, ${Au}, ${mu})) +
          dot(
            vec2(depth3, depth4),
            vec2(${pu}, 1)));
        ${pC(ou)}
      }
    `;const wu=ou.shapeInfo.flatOffset,Eu=ou.shapeInfo.texShape,Tu=Eu[0],Ru=Eu[1];if(Ru===Cu&&wu==null)return`
      float ${lu}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${bu}, ${Au}, ${mu}, ${pu})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${Ru}.0, ${Tu}.0);
        return sampleTexture(${ru}, uv);
      }
    `;if(Ru===pu&&wu==null)return`
      float ${lu}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${nu[1]*nu[2]*nu[3]*nu[4]},
               ${nu[2]*nu[3]*nu[4]},
               ${nu[3]*nu[4]},
               ${nu[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${Ru}.0, ${Tu}.0);
        return sampleTexture(${ru}, uv);
      }
    `;const Nu=I1(ru);return`
    float ${lu}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${Cu} + col * ${bu} + depth * ${Au} +
          depth2 * ${mu} + depth3 * ${pu} + depth4 + ${Nu};
      vec2 uv = uvFromFlat(${Tu}, ${Ru}, index);
      return sampleTexture(${ru}, uv);
    }
  `}function pC(ou){const nu=ou.name,ru=Mu(ou.shapeInfo.logicalShape);return ru<2?`return ${nu};`:`
    for (int i = 0; i < ${ru}; i++) {
      if (i == index) {
        return ${nu}[i];
      }
    }
  `}function d7(ou,nu){const ru=ou.name,lu=ru.charAt(0).toUpperCase()+ru.slice(1),cu="get"+lu+"AtOutCoords",hu=ou.shapeInfo.logicalShape.length,pu=nu.logicalShape.length,mu=CD(ou.shapeInfo.logicalShape,nu.logicalShape),Au=x0(pu),bu=pu-hu;let Cu;const wu=["x","y","z","w","u","v"];hu===0?Cu="":pu<2&&mu.length>=1?Cu="coords = 0;":Cu=mu.map(Pu=>`coords.${wu[Pu+bu]} = 0;`).join(`
`);let Eu="";pu<2&&hu>0?Eu="coords":Eu=ou.shapeInfo.logicalShape.map((Pu,Fu)=>`coords.${wu[Fu+bu]}`).join(", ");let Tu="return outputValue;";const Ru=Mu(ou.shapeInfo.logicalShape)===1,Nu=Mu(nu.logicalShape)===1;if(hu===1&&!Ru&&!Nu)Tu=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(Ru&&!Nu)pu===1?Tu=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:Tu=`
        return vec4(outputValue.x);
      `;else if(mu.length){const Pu=hu-2,Fu=hu-1;mu.indexOf(Pu)>-1&&mu.indexOf(Fu)>-1?Tu="return vec4(outputValue.x);":mu.indexOf(Pu)>-1?Tu="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":mu.indexOf(Fu)>-1&&(Tu="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${cu}() {
      ${Au} coords = getOutputCoords();
      ${Cu}
      vec4 outputValue = get${lu}(${Eu});
      ${Tu}
    }
  `}function p7(ou,nu){const ru=ou.name,lu=ru.charAt(0).toUpperCase()+ru.slice(1),cu="get"+lu+"AtOutCoords",hu=nu.texShape,pu=ou.shapeInfo.texShape,mu=ou.shapeInfo.logicalShape.length,Au=nu.logicalShape.length;if(!ou.shapeInfo.isUniform&&mu===Au&&ou.shapeInfo.flatOffset==null&&ku(pu,hu))return`
      float ${cu}() {
        return sampleTexture(${ru}, resultUV);
      }
    `;const bu=x0(Au),Cu=CD(ou.shapeInfo.logicalShape,nu.logicalShape),wu=Au-mu;let Eu;const Tu=["x","y","z","w","u","v"];mu===0?Eu="":Au<2&&Cu.length>=1?Eu="coords = 0;":Eu=Cu.map(Nu=>`coords.${Tu[Nu+wu]} = 0;`).join(`
`);let Ru="";return Au<2&&mu>0?Ru="coords":Ru=ou.shapeInfo.logicalShape.map((Nu,Pu)=>`coords.${Tu[Pu+wu]}`).join(", "),`
    float ${cu}() {
      ${bu} coords = getOutputCoords();
      ${Eu}
      return get${lu}(${Ru});
    }
  `}function x0(ou){if(ou<=1)return"int";if(ou===2)return"ivec2";if(ou===3)return"ivec3";if(ou===4)return"ivec4";if(ou===5)return"ivec5";if(ou===6)return"ivec6";throw Error(`GPU for rank ${ou} is not yet supported`)}function KT(ou,nu,ru){const{newShape:lu,keptDims:cu}=Zu(nu),hu=nu.length,pu=ou&&hu===3&&nu[0]===1,mu=pu?nu.slice(1):lu,Au=!ou&&hu>1&&!ku(nu,ru)&&lu.length<hu||pu;return{useSqueezeShape:Au,uniformShape:Au?mu:nu,keptDims:cu}}function fC(ou,nu){const ru=JSON.parse(JSON.stringify(ou));return ru.shapeInfo.logicalShape=nu,ru}function mC(ou,nu){return nu.map(ru=>ou[ru]).join(", ")}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function f7(ou,nu,ru,lu){const cu=ru.map((Cu,wu)=>{const Eu={logicalShape:Cu.shape,texShape:Cu.isUniform?null:Cu.texData.texShape,isUniform:Cu.isUniform,isPacked:Cu.isUniform?!1:Cu.texData.isPacked,flatOffset:null};return Cu.texData!=null&&Cu.texData.slice!=null&&Cu.texData.slice.flatOffset>0&&(Eu.flatOffset=Cu.texData.slice.flatOffset),{name:nu.variableNames[wu],shapeInfo:Eu}}),hu=cu.map(Cu=>Cu.shapeInfo),pu={logicalShape:lu.shape,texShape:lu.texData.texShape,isUniform:!1,isPacked:lu.texData.isPacked,flatOffset:null},mu=B6(cu,pu,nu),Au=a6(ou.gl,mu),bu=ou.createProgram(Au);return cp().get("ENGINE_COMPILE_ONLY")?{program:nu,fragmentShader:Au,source:mu,webGLProgram:bu,inShapeInfos:hu,outShapeInfo:pu,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(ou.buildVao(bu),Object.assign({program:nu,fragmentShader:Au,source:mu,webGLProgram:bu,inShapeInfos:hu,outShapeInfo:pu},SD(ou,nu,bu)))}function SD(ou,nu,ru){const lu=[],cu=[];let hu,pu,mu,Au=null,bu=null;bu=ou.getUniformLocation(ru,"NAN",!1),cp().getNumber("WEBGL_VERSION")===1&&(Au=ou.getUniformLocation(ru,"INFINITY",!1));const Cu=!1;for(const wu of nu.variableNames){const Eu={name:wu,uniform:ou.getUniformLocation(ru,wu,Cu),offset:ou.getUniformLocation(ru,`offset${wu}`,Cu)};nu.enableShapeUniforms&&(Eu.shape=ou.getUniformLocation(ru,`${wu}Shape`,Cu),Eu.texShape=ou.getUniformLocation(ru,`${wu}TexShape`,Cu)),lu.push(Eu)}if(nu.enableShapeUniforms&&(hu=ou.getUniformLocation(ru,"outShape",Cu),mu=ou.getUniformLocation(ru,"outShapeStrides",Cu),pu=ou.getUniformLocation(ru,"outTexShape",Cu)),nu.customUniforms)for(const wu of nu.customUniforms)cu.push(ou.getUniformLocation(ru,wu.name,Cu));return{variablesLocations:lu,customUniformLocations:cu,infLoc:Au,nanLoc:bu,outShapeLocation:hu,outShapeStridesLocation:mu,outTexShapeLocation:pu}}function ID(ou,nu){if(ou.length!==nu.length)throw Error(`Binary was compiled with ${ou.length} inputs, but was executed with ${nu.length} inputs`);ou.forEach((ru,lu)=>{const cu=ru.logicalShape,hu=nu[lu],pu=hu.shape;if(!ku(cu,pu))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${cu} and ${pu} must match`);if(ru.isUniform&&hu.isUniform)return;const mu=ru.texShape,Au=hu.isUniform?null:hu.texData.texShape;if(!ku(mu,Au))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${mu} and ${Au} must match`)})}function m7(ou,nu,ru,lu,cu){nu.program.enableShapeUniforms||(ID(nu.inShapeInfos,ru),ID([nu.outShapeInfo],[lu]));const hu=lu.texData.texture,pu=lu.texData.texShape;lu.texData.isPacked?ou.setOutputPackedMatrixTexture(hu.texture,pu[0],pu[1]):ou.setOutputMatrixTexture(hu.texture,pu[0],pu[1]),ou.setProgram(nu.webGLProgram),ou.bindVertexArray(nu.webGLProgram.vao),cp().getNumber("WEBGL_VERSION")===1&&nu.infLoc!==null&&ou.gl.uniform1f(nu.infLoc,1/0),nu.nanLoc!==null&&ou.gl.uniform1f(nu.nanLoc,NaN);for(let Au=0;Au<ru.length;++Au){const bu=ru[Au],{uniform:Cu,offset:wu,shape:Eu,texShape:Tu}=nu.variablesLocations[Au];if(Eu){const{uniformShape:Ru}=KT(nu.program.packedInputs,bu.shape,bu.texData.texShape);switch(Ru.length){case 1:ou.gl.uniform1iv(Eu,new Int32Array(Ru));break;case 2:ou.gl.uniform2iv(Eu,new Int32Array(Ru));break;case 3:ou.gl.uniform3iv(Eu,new Int32Array(Ru));break;case 4:ou.gl.uniform4iv(Eu,new Int32Array(Ru));break}}if(Tu&&ou.gl.uniform2i(Tu,bu.texData.texShape[0],bu.texData.texShape[1]),Cu!=null){if(bu.isUniform){if(Mu(bu.shape)<2)ou.gl.uniform1f(Cu,bu.uniformValues[0]);else{let Ru=bu.uniformValues;Ru instanceof Float32Array||(Ru=new Float32Array(Ru)),ou.gl.uniform1fv(Cu,Ru)}continue}bu.texData.slice!=null&&wu!=null&&ou.gl.uniform1i(wu,bu.texData.slice.flatOffset),ou.setInputMatrixTexture(bu.texData.texture.texture,Cu,Au)}}const mu=nu.outShapeLocation;if(mu)switch(lu.shape.length){case 1:ou.gl.uniform1iv(mu,new Int32Array(lu.shape));break;case 2:ou.gl.uniform2iv(mu,new Int32Array(lu.shape));break;case 3:ou.gl.uniform3iv(mu,new Int32Array(lu.shape));break;case 4:ou.gl.uniform4iv(mu,new Int32Array(lu.shape));break}if(nu.outShapeStridesLocation){const Au=xp(lu.shape);switch(lu.shape.length){case 2:ou.gl.uniform1iv(nu.outShapeStridesLocation,new Int32Array(Au));break;case 3:ou.gl.uniform2iv(nu.outShapeStridesLocation,new Int32Array(Au));break;case 4:ou.gl.uniform3iv(nu.outShapeStridesLocation,new Int32Array(Au));break}}if(nu.outTexShapeLocation&&ou.gl.uniform2i(nu.outTexShapeLocation,lu.texData.texShape[0],lu.texData.texShape[1]),nu.program.customUniforms&&cu)for(let Au=0;Au<nu.program.customUniforms.length;++Au){const bu=nu.program.customUniforms[Au],Cu=nu.customUniformLocations[Au],wu=cu[Au];if(bu.type==="float")ou.gl.uniform1fv(Cu,wu);else if(bu.type==="vec2")ou.gl.uniform2fv(Cu,wu);else if(bu.type==="vec3")ou.gl.uniform3fv(Cu,wu);else if(bu.type==="vec4")ou.gl.uniform4fv(Cu,wu);else if(bu.type==="int")ou.gl.uniform1iv(Cu,wu);else if(bu.type==="ivec2")ou.gl.uniform2iv(Cu,wu);else if(bu.type==="ivec3")ou.gl.uniform3iv(Cu,wu);else if(bu.type==="ivec4")ou.gl.uniform4iv(Cu,wu);else throw Error(`uniform type ${bu.type} is not supported yet.`)}ou.executeProgram()}function g7(ou,nu,ru){let lu="";nu.concat(ru).forEach(pu=>{const mu=pu.texData!=null&&pu.texData.slice!=null&&pu.texData.slice.flatOffset>0;if(ou.enableShapeUniforms&&!pu.isUniform){const Au=pu.texData.texShape,{useSqueezeShape:bu,uniformShape:Cu,keptDims:wu}=KT(ou.packedInputs,pu.shape,Au);let Eu="",Tu="",Ru="";if(Cu.length===1&&ou.packedInputs){const Ju=[Math.ceil(Au[0]/2),Math.ceil(Au[1]/2)];Eu=`${Ju[0]>1}_${Ju[1]>1}`}else if(Cu.length===2&&!ou.packedInputs)Tu=`${Cu[0]>1}_${Cu[1]>1}`;else if(Cu.length>2&&!ou.packedInputs){const Ju=xp(Cu);Ru=`${Ju[0]===Au[1]}_${Ju[Ju.length-1]===Au[1]}`}const Nu=pu.shape.length,Pu=Cu.length===2&&ku(pu.shape,Au),Fu=Mu(pu.shape)===1,Gu=K1(pu.shape,ru.shape),Xu=!ou.packedInputs&&Nu===ru.shape.length&&ku(Au,ru.texData.texShape),Qu=ou.packedInputs||Cu.length>2?"":`${Au[0]>1}_${Au[1]>1}`;lu+=`${Nu}_${Xu}_${bu?wu:""}_${Cu.length}_${Fu}_${Gu}_${Pu}_${Eu}_${Tu}_${Ru}_${Qu}_${mu}`}else{const Au=pu.isUniform?"uniform":pu.texData.texShape;lu+=`${pu.shape}_${Au}_${mu}`}});const cu=ou.userCode;let hu=ou.constructor.name;return hu+="_"+lu+"_"+cu+`${cp().getNumber("WEBGL_VERSION")}`,hu}function Ay(ou){return cp().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&ou<=4}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class A7{constructor(nu){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Fw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const ru=Ey();this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?N2(["r","c","d"],nu):S1(["r","c","d"],nu)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${ru.output} = result;
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class y7{constructor(nu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Fw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const ru=Ey();this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?N2(["r","c","d"],nu):S1(["r","c","d"],nu)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${ru.output} = result;
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class b7{constructor(nu){this.variableNames=["A"],this.outTexUsage=_b.DOWNLOAD;const ru=Ey();this.outputShape=nu,this.userCode=`
      ${vD}

      void main() {
        float x = getAAtOutCoords();
        ${ru.output} = encode_float(x);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class x7{constructor(nu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=_b.DOWNLOAD;const ru=Ey();this.outputShape=nu,this.userCode=`
      ${vD}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${ru.output} = encode_float(x);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const v7={R:0,G:1,B:2,A:3};class TD{constructor(nu,ru=!1,lu="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const cu=Ey();this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length);let hu="result";ru&&(hu="floor(result * 255. + 0.5)");let pu="";for(let mu=0;mu<lu.length;mu++){const Au=lu[mu];pu+=`
          if(offset == ${mu}) {
            result = values[${v7[Au]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?QT():XT(nu)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${lu.length});

        flatIndex = idiv(flatIndex, ${lu.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${cu.texture2D}(A, uv);
          ${pu}
        }
        ${cu.output} = vec4(${hu}, 0., 0., 0.);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class C7{constructor(nu,ru=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const lu=Ey();this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length);let cu="",hu="result";ru&&(hu="floor(result * 255. + 0.5)");for(let pu=0;pu<=1;pu++)for(let mu=0;mu<=1;mu++){const Au=pu*2+mu;cu+=`
          localCoords = coords;
          if(localCoords[2] + ${mu} < ${this.enableShapeUniforms?"outShape[2]":`${nu[2]}`}) {
          localCoords[2] += ${mu};
          if (localCoords[1] + ${pu} < ${this.enableShapeUniforms?"outShape[1]":`${nu[1]}`}) {
            localCoords[1] += ${pu};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${lu.texture2D}(A, uv);

            if (offset == 0) {
              result[${Au}] = values[0];
            } else if (offset == 1) {
              result[${Au}] = values[1];
            } else if (offset == 2) {
              result[${Au}] = values[2];
            } else {
              result[${Au}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?QT():XT(nu)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${cu}

          ${lu.output} = ${hu};
        }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w7(ou){const nu=Ey(),ru=`${nu.version}
    precision highp float;
    ${nu.attribute} vec3 clipSpacePos;
    ${nu.attribute} vec2 uv;
    ${nu.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return o6(ou,ru)}function E7(ou){const nu=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return h6(ou,nu)}function S7(ou){const nu=new Uint16Array([0,1,2,2,1,3]);return d6(ou,nu)}function Ow(ou,nu,ru,lu,cu,hu){f6(nu,ru);const pu=p6(ou),mu=ou.TEXTURE_2D;return Bm(ou,()=>ou.bindTexture(mu,pu)),Bm(ou,()=>ou.texParameteri(mu,ou.TEXTURE_WRAP_S,ou.CLAMP_TO_EDGE)),Bm(ou,()=>ou.texParameteri(mu,ou.TEXTURE_WRAP_T,ou.CLAMP_TO_EDGE)),Bm(ou,()=>ou.texParameteri(mu,ou.TEXTURE_MIN_FILTER,ou.NEAREST)),Bm(ou,()=>ou.texParameteri(mu,ou.TEXTURE_MAG_FILTER,ou.NEAREST)),cp().getNumber("WEBGL_VERSION")===1?Bm(ou,()=>ou.texImage2D(mu,0,lu,nu,ru,0,cu,hu,null)):Bm(ou,()=>ou.texStorage2D(mu,1,lu,nu,ru)),Bm(ou,()=>ou.bindTexture(ou.TEXTURE_2D,null)),{texture:pu,texShape:[ru,nu]}}function _D(ou){return ou.internalFormatFloat}function I7(ou,nu,ru,lu){const[cu,hu]=Pw(nu,ru);return Ow(ou,cu,hu,_D(lu),lu.textureFormatFloat,ou.FLOAT)}function MD(ou){return ou.internalFormatHalfFloat}function T7(ou,nu,ru,lu){const[cu,hu]=Pw(nu,ru);return Ow(ou,cu,hu,MD(lu),lu.textureFormatFloat,lu.textureTypeHalfFloat)}function RD(ou){return ou.downloadTextureFormat}function _7(ou,nu,ru,lu){const[cu,hu]=Pw(nu,ru);return Ow(ou,cu,hu,RD(lu),ou.RGBA,ou.UNSIGNED_BYTE)}function kD(ou){return ou.internalFormatPackedFloat}function M7(ou,nu,ru,lu){const[cu,hu]=cC(nu,ru);return Ow(ou,cu,hu,kD(lu),ou.RGBA,ou.FLOAT)}function BD(ou){return ou.internalFormatPackedHalfFloat}function R7(ou,nu,ru,lu){const[cu,hu]=cC(nu,ru);return Ow(ou,cu,hu,BD(lu),ou.RGBA,lu.textureTypeHalfFloat)}function k7(ou,nu,ru){return Bm(ou,()=>ou.bindBuffer(ou.ARRAY_BUFFER,ru)),yD(ou,nu,"clipSpacePos",ru,3,20,0)&&yD(ou,nu,"uv",ru,2,20,12)}function B7(ou,nu,ru,lu,cu,hu){Bm(ou,()=>ou.bindTexture(ou.TEXTURE_2D,nu));let pu,mu,Au;cu instanceof Uint8Array?(pu=new Uint8Array(ru*lu*4),mu=ou.UNSIGNED_BYTE,Au=ou.RGBA):(pu=new Float32Array(ru*lu*4),mu=ou.FLOAT,Au=hu.internalFormatPackedFloat),pu.set(cu),cp().getNumber("WEBGL_VERSION")===2?Bm(ou,()=>ou.texSubImage2D(ou.TEXTURE_2D,0,0,0,ru,lu,ou.RGBA,mu,pu)):Bm(ou,()=>ou.texImage2D(ou.TEXTURE_2D,0,Au,ru,lu,0,ou.RGBA,mu,pu)),Bm(ou,()=>ou.bindTexture(ou.TEXTURE_2D,null))}function L7(ou,nu,ru){Bm(ou,()=>ou.bindTexture(ou.TEXTURE_2D,nu)),ru.data instanceof Uint8Array?cp().getNumber("WEBGL_VERSION")===2?Bm(ou,()=>ou.texSubImage2D(ou.TEXTURE_2D,0,0,0,ru.width,ru.height,ou.RGBA,ou.UNSIGNED_BYTE,ru.data)):Bm(ou,()=>ou.texImage2D(ou.TEXTURE_2D,0,ou.RGBA,ru.width,ru.height,0,ou.RGBA,ou.UNSIGNED_BYTE,ru.data)):cp().getNumber("WEBGL_VERSION")===2?Bm(ou,()=>ou.texSubImage2D(ou.TEXTURE_2D,0,0,0,ou.RGBA,ou.UNSIGNED_BYTE,ru)):Bm(ou,()=>ou.texImage2D(ou.TEXTURE_2D,0,ou.RGBA,ou.RGBA,ou.UNSIGNED_BYTE,ru)),Bm(ou,()=>ou.bindTexture(ou.TEXTURE_2D,null))}function N7(ou,nu,ru,lu){const cu=ou.createBuffer();Bm(ou,()=>ou.bindBuffer(ou.PIXEL_PACK_BUFFER,cu));const hu=4*4*nu*ru;return Bm(ou,()=>ou.bufferData(ou.PIXEL_PACK_BUFFER,hu,ou.STREAM_READ)),Bm(ou,()=>ou.readPixels(0,0,ru,nu,ou.RGBA,ou.FLOAT,0)),Bm(ou,()=>ou.bindBuffer(ou.PIXEL_PACK_BUFFER,null)),cu}function D7(ou,nu,ru){const lu=ou,cu=new Float32Array(ru);return lu.bindBuffer(lu.PIXEL_PACK_BUFFER,nu),lu.getBufferSubData(lu.PIXEL_PACK_BUFFER,0,cu),lu.bindBuffer(lu.PIXEL_PACK_BUFFER,null),cu}function F7(ou,nu,ru,lu){const[cu,hu]=Pw(nu,ru),pu=4,mu=new Uint8Array($j(nu*ru,pu));return Bm(ou,()=>ou.readPixels(0,0,cu,hu,lu.downloadTextureFormat,ou.UNSIGNED_BYTE,mu)),new Float32Array(mu.buffer)}function P7(ou,nu,ru,lu,cu,hu,pu,mu){const Au=ou,bu=new Float32Array(e6(hu,pu));return Au.bindBuffer(Au.PIXEL_PACK_BUFFER,nu),Au.getBufferSubData(Au.PIXEL_PACK_BUFFER,0,bu),Au.bindBuffer(Au.PIXEL_PACK_BUFFER,null),bu}function G7(ou,nu,ru){const lu=new Float32Array(nu*ru*4);return Bm(ou,()=>ou.readPixels(0,0,ru,nu,ou.RGBA,ou.FLOAT,lu)),lu}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ZT{constructor(nu){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const ru=cp().getNumber("WEBGL_VERSION");if(nu!=null?(this.gl=nu,q8(ru,nu)):this.gl=kx(ru),nu=this.gl,cp().getNumber("WEBGL_VERSION")===2){const hu=nu;this.createVertexArray=()=>Bm(hu,()=>hu.createVertexArray()),this.bindVertexArray=pu=>Bm(hu,()=>hu.bindVertexArray(pu)),this.deleteVertexArray=pu=>Bm(hu,()=>hu.deleteVertexArray(pu)),this.getVertexArray=()=>Bm(hu,()=>hu.getParameter(hu.VERTEX_ARRAY_BINDING))}else if(nu!=null){const hu=nu.getExtension("OES_vertex_array_object");if(hu==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bm(nu,()=>hu.createVertexArrayOES()),this.bindVertexArray=pu=>Bm(nu,()=>hu.bindVertexArrayOES(pu)),this.deleteVertexArray=pu=>Bm(nu,()=>hu.deleteVertexArrayOES(pu)),this.getVertexArray=()=>Bm(nu,()=>nu.getParameter(hu.VERTEX_ARRAY_BINDING_OES))}let lu="WEBGL_color_buffer_float";const cu="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),cp().getNumber("WEBGL_VERSION")===1){const hu="OES_texture_float",pu="OES_texture_half_float";if(this.textureFloatExtension=M2(this.gl,hu),mx(this.gl,pu))this.textureHalfFloatExtension=M2(this.gl,pu);else if(cp().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(lu),mx(this.gl,cu))this.colorBufferHalfFloatExtension=M2(this.gl,cu);else if(cp().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(lu="EXT_color_buffer_float",mx(this.gl,lu))this.colorBufferFloatExtension=this.gl.getExtension(lu);else if(mx(this.gl,cu))this.colorBufferHalfFloatExtension=this.gl.getExtension(cu);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=E7(this.gl),this.indexBuffer=S7(this.gl),this.framebuffer=m6(this.gl),this.textureConfig=UT(this.gl,this.textureHalfFloatExtension)}get debug(){return cp().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const nu=this.gl;Bm(nu,()=>nu.finish()),Bm(nu,()=>nu.bindFramebuffer(nu.FRAMEBUFFER,null)),Bm(nu,()=>nu.deleteFramebuffer(this.framebuffer)),Bm(nu,()=>nu.bindBuffer(nu.ARRAY_BUFFER,null)),Bm(nu,()=>nu.bindBuffer(nu.ELEMENT_ARRAY_BUFFER,null)),Bm(nu,()=>nu.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(nu,ru){return this.throwIfDisposed(),I7(this.gl,nu,ru,this.textureConfig)}createFloat16MatrixTexture(nu,ru){return this.throwIfDisposed(),T7(this.gl,nu,ru,this.textureConfig)}createUnsignedBytesMatrixTexture(nu,ru){return this.throwIfDisposed(),_7(this.gl,nu,ru,this.textureConfig)}uploadPixelDataToTexture(nu,ru){this.throwIfDisposed(),L7(this.gl,nu,ru)}uploadDenseMatrixToTexture(nu,ru,lu,cu){this.throwIfDisposed(),B7(this.gl,nu,ru,lu,cu,this.textureConfig)}createFloat16PackedMatrixTexture(nu,ru){return this.throwIfDisposed(),R7(this.gl,nu,ru,this.textureConfig)}createPackedMatrixTexture(nu,ru){return this.throwIfDisposed(),M7(this.gl,nu,ru,this.textureConfig)}deleteMatrixTexture(nu){this.throwIfDisposed(),this.outputTexture===nu&&(bD(this.gl,this.framebuffer),this.outputTexture=null),Bm(this.gl,()=>this.gl.deleteTexture(nu))}downloadByteEncodedFloatMatrixFromOutputTexture(nu,ru,lu){return this.downloadMatrixDriver(nu,()=>F7(this.gl,ru,lu,this.textureConfig))}downloadPackedMatrixFromBuffer(nu,ru,lu,cu,hu,pu){return P7(this.gl,nu,ru,lu,cu,hu,pu,this.textureConfig)}downloadFloat32MatrixFromBuffer(nu,ru){return D7(this.gl,nu,ru)}createBufferFromTexture(nu,ru,lu){this.bindTextureToFrameBuffer(nu);const cu=N7(this.gl,ru,lu,this.textureConfig);return this.unbindTextureToFrameBuffer(),cu}createAndWaitForFence(){const nu=this.createFence(this.gl);return this.pollFence(nu)}createFence(nu){let ru,lu;if(cp().getBool("WEBGL_FENCE_API_ENABLED")){const cu=nu,hu=cu.fenceSync(cu.SYNC_GPU_COMMANDS_COMPLETE,0);nu.flush(),lu=()=>{const pu=cu.clientWaitSync(hu,0,0);return pu===cu.ALREADY_SIGNALED||pu===cu.CONDITION_SATISFIED},ru=hu}else cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(ru=this.beginQuery(),this.endQuery(),lu=()=>this.isQueryAvailable(ru,cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):lu=()=>!0;return{query:ru,isFencePassed:lu}}downloadMatrixFromPackedTexture(nu,ru,lu){return this.downloadMatrixDriver(nu,()=>G7(this.gl,ru,lu))}createProgram(nu){this.throwIfDisposed();const ru=this.gl;this.vertexShader==null&&(this.vertexShader=w7(ru));const lu=c6(ru);Bm(ru,()=>ru.attachShader(lu,this.vertexShader)),Bm(ru,()=>ru.attachShader(lu,nu)),u6(ru,lu);const cu=Object.assign(lu,{vao:this.createVertexArray()});return this.debug&&$T(ru,cu),cu}buildVao(nu){this.setProgram(nu),this.bindVertexArray(nu.vao);const ru=this.gl;Bm(ru,()=>ru.bindBuffer(ru.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),k7(ru,nu,this.vertexBuffer)}deleteProgram(nu){this.throwIfDisposed(),nu===this.program&&(this.program=null),nu!=null&&(Bm(this.gl,()=>this.gl.deleteProgram(nu)),this.deleteVertexArray(nu.vao))}setProgram(nu){this.throwIfDisposed(),this.program=nu,this.program!=null&&this.debug&&$T(this.gl,this.program),Bm(this.gl,()=>this.gl.useProgram(nu))}getUniformLocation(nu,ru,lu=!0){return this.throwIfDisposed(),lu?A6(this.gl,nu,ru):y6(this.gl,nu,ru)}getAttributeLocation(nu,ru){return this.throwIfDisposed(),Bm(this.gl,()=>this.gl.getAttribLocation(nu,ru))}getUniformLocationNoThrow(nu,ru){return this.throwIfDisposed(),this.gl.getUniformLocation(nu,ru)}setInputMatrixTexture(nu,ru,lu){this.throwIfDisposed(),this.throwIfNoProgram(),b6(this.gl,nu,ru,lu)}setOutputMatrixTexture(nu,ru,lu){this.setOutputMatrixTextureDriver(nu,lu,ru)}setOutputPackedMatrixTexture(nu,ru,lu){this.throwIfDisposed();const[cu,hu]=cC(ru,lu);this.setOutputMatrixTextureDriver(nu,cu,hu)}setOutputMatrixWriteRegion(nu,ru,lu,cu){this.setOutputMatrixWriteRegionDriver(lu,nu,cu,ru)}setOutputPackedMatrixWriteRegion(nu,ru,lu,cu){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&$T(this.gl,this.program),R2(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const nu=this.gl;if(this.debug){const ru=this.getVertexArray();console.assert(ru===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bm(nu,()=>nu.drawElements(nu.TRIANGLES,6,nu.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bm(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=M2(this.gl,cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const lu=this.gl,cu=this.getQueryTimerExtensionWebGL2(),hu=lu.createQuery();return lu.beginQuery(cu.TIME_ELAPSED_EXT,hu),hu}const nu=this.getQueryTimerExtensionWebGL1(),ru=nu.createQueryEXT();return nu.beginQueryEXT(nu.TIME_ELAPSED_EXT,ru),ru}endQuery(){if(cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const ru=this.gl,lu=this.getQueryTimerExtensionWebGL2();ru.endQuery(lu.TIME_ELAPSED_EXT);return}const nu=this.getQueryTimerExtensionWebGL1();nu.endQueryEXT(nu.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(nu){return await Du(()=>this.disposed||this.isQueryAvailable(nu,cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(nu,cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(nu,ru){if(ru===0)return null;if(ru===2){const lu=this.gl;return lu.getQueryParameter(nu,lu.QUERY_RESULT)/1e6}else{const lu=this.getQueryTimerExtensionWebGL1();return lu.getQueryObjectEXT(nu,lu.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(nu,ru){if(ru===0)return!0;if(ru===2){const lu=this.gl,cu=this.getQueryTimerExtensionWebGL2(),hu=lu.getQueryParameter(nu,lu.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(cu.GPU_DISJOINT_EXT)),hu&&!this.disjoint}else{const lu=this.getQueryTimerExtensionWebGL1(),cu=lu.getQueryObjectEXT(nu,lu.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(lu.GPU_DISJOINT_EXT)),cu&&!this.disjoint}}pollFence(nu){return new Promise(ru=>{this.addItemToPoll(()=>nu.isFencePassed(),()=>ru())})}pollItems(){const nu=O7(this.itemsToPoll.map(ru=>ru.isDoneFn));for(let ru=0;ru<=nu;++ru){const{resolveFn:lu}=this.itemsToPoll[ru];lu()}this.itemsToPoll=this.itemsToPoll.slice(nu+1)}addItemToPoll(nu,ru){if(this.itemsToPoll.push({isDoneFn:nu,resolveFn:ru}),this.itemsToPoll.length>1)return;let lu;"setTimeoutCustom"in cp().platform&&(lu=cp().platform.setTimeoutCustom.bind(cp().platform)),Du(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,lu)}bindTextureToFrameBuffer(nu){this.throwIfDisposed(),VT(this.gl,nu,this.framebuffer),this.debug&&R2(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(VT(this.gl,this.outputTexture,this.framebuffer),this.debug&&R2(this.gl)):bD(this.gl,this.framebuffer)}downloadMatrixDriver(nu,ru){this.bindTextureToFrameBuffer(nu);const lu=ru();return this.unbindTextureToFrameBuffer(),lu}setOutputMatrixTextureDriver(nu,ru,lu){this.throwIfDisposed();const cu=this.gl;VT(cu,nu,this.framebuffer),this.debug&&R2(cu),this.outputTexture=nu,Bm(cu,()=>cu.viewport(0,0,ru,lu)),Bm(cu,()=>cu.scissor(0,0,ru,lu))}setOutputMatrixWriteRegionDriver(nu,ru,lu,cu){this.throwIfDisposed(),Bm(this.gl,()=>this.gl.scissor(nu,ru,lu,cu))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function O7(ou){let nu=0;for(;nu<ou.length&&ou[nu]();++nu);return nu-1}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{addImpl:U7,bincountImpl:LD,bincountReduceImpl:$7,bitwiseAndImpl:V7,castImpl:z7,ceilImpl:W7,concatImpl:H7,equalImpl:X7,expImpl:Q7,expm1Impl:K7,floorImpl:Z7,gatherNdImpl:j7,gatherV2Impl:Y7,greaterImpl:q7,greaterEqualImpl:J7,lessImpl:eY,lessEqualImpl:tY,linSpaceImpl:nY,logImpl:iY,maxImpl:rY,maximumImpl:sY,minimumImpl:oY,multiplyImpl:aY,negImpl:lY,notEqualImpl:cY,prodImpl:uY,raggedGatherImpl:hY,raggedRangeImpl:dY,raggedTensorToTensorImpl:pY,rangeImpl:fY,rsqrtImpl:mY,scatterImpl:gY,sigmoidImpl:AY,simpleAbsImpl:ND,sliceImpl:yY,sparseFillEmptyRowsImpl:bY,sparseReshapeImpl:xY,sparseSegmentReductionImpl:DD,sqrtImpl:vY,staticRegexReplaceImpl:CY,stridedSliceImpl:wY,stringNGramsImpl:EY,stringSplitImpl:SY,stringToHashBucketFastImpl:IY,subImpl:TY,tileImpl:_Y,topKImpl:MY,transposeImpl:jT,uniqueImpl:RY}=PX;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FD(ou,nu){return["x","y","z","w","u","v"].slice(0,nu).map(ru=>`${ou}.${ru}`)}function Sy(ou,nu){return nu===1?[ou]:FD(ou,nu)}function kY(ou,nu){if(ou===1)return"rc";let ru="";for(let lu=0;lu<ou;lu++)ru+=nu[lu],lu<ou-1&&(ru+=",");return ru}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class BY{constructor(nu){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=nu,this.rank=nu.length,this.enableShapeUniforms=Ay(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const ru=Sy("rc",this.rank),lu=x0(this.rank),cu=this.getOutOfBoundsCondition(ru),hu=this.getSetup(ru),pu=this.getOutput(ru);this.userCode=`
        void main() {
          ${lu} rc = getOutputCoords();

          if(${cu}) {
            setOutput(vec4(0));
          } else {
            ${hu}

            setOutput(vec4(${pu}));
          }
        }
      `}}getSourceCoordsArr(nu){const ru=[];for(let lu=0;lu<=1;lu++)for(let cu=0;cu<=1;cu++){let hu=`${lu===0?"r":"rp1"}, ${cu===0?"c":"cp1"}`;for(let pu=2;pu<this.rank;pu++)hu=`${nu[nu.length-1-pu]},`+hu;ru.push(hu)}return ru}getOutOfBoundsCondition(nu){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let ru="";for(let lu=this.rank-2;lu<this.rank;lu++)ru+=`${nu[lu]} >= ${this.enableShapeUniforms?`outShape[${lu}]`:this.outputShape[lu]}`,lu<this.rank-1&&(ru+="||");return ru}getSetup(nu){if(this.rank===1)return"";const ru=nu.slice(-2),lu=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],cu=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${ru[0]};
      int c = ${ru[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${lu};
      bool rEdge = rp1 >= ${cu};
    `}getOutput(nu){const ru=this.getSourceCoordsArr(nu);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${ru[0]}),
            cEdge ? 0. : getA(${ru[1]}),
            rEdge ? 0. : getA(${ru[2]}),
            rEdge || cEdge ? 0. : getA(${ru[3]})`}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class PD{constructor(nu,ru){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length);let lu="";for(let cu=0;cu<4;cu++){let hu="thisRC = rc;";cu%2===1&&(hu+="thisRC.z += 1;"),cu>1&&(hu+="thisRC.y += 1;"),lu+=`
        ${hu}
        ${cu>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${cu}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${cu>0?"}":""}
      `}this.userCode=`
      ${LY(ru,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?QT():XT(nu)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":nu[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":nu[2]};

        ${lu}

        setOutput(result);
      }
    `}}function LY(ou,nu){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${nu?k6(["r","c","d"],"inputShape"):S1(["r","c","d"],ou)}
      return ivec3(r, c, d);
    }
  `}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class NY{constructor(nu){this.gpgpu=nu,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(nu,ru,lu){const cu=OD(ru,lu),hu=UD(nu,cu,lu);hu in this.freeTextures||(this.freeTextures[hu]=[]),hu in this.usedTextures||(this.usedTextures[hu]=[]);const pu=GD(nu,cu,this.gpgpu.gl,this.gpgpu.textureConfig,lu);if(this.freeTextures[hu].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=pu,this.log();const Au=this.freeTextures[hu].pop();return this.usedTextures[hu].push(Au),Au}let mu;return cu===fy.PACKED_2X2_FLOAT32?mu=this.gpgpu.createPackedMatrixTexture(nu[0],nu[1]):cu===fy.PACKED_2X2_FLOAT16?mu=this.gpgpu.createFloat16PackedMatrixTexture(nu[0],nu[1]):cu===fy.UNPACKED_FLOAT32?mu=this.gpgpu.createFloat32MatrixTexture(nu[0],nu[1]):cu===fy.UNPACKED_FLOAT16?mu=this.gpgpu.createFloat16MatrixTexture(nu[0],nu[1]):cu===fy.PACKED_4X1_UNSIGNED_BYTE&&(mu=this.gpgpu.createUnsignedBytesMatrixTexture(nu[0],nu[1])),this.usedTextures[hu].push(mu),this.numUsedTextures++,this._numBytesAllocated+=pu,this.log(),mu}releaseTexture(nu,ru,lu,cu){if(this.freeTextures==null)return;const hu=OD(lu,cu),pu=UD(ru,hu,cu);pu in this.freeTextures||(this.freeTextures[pu]=[]);const mu=GD(ru,hu,this.gpgpu.gl,this.gpgpu.textureConfig,cu),Au=cp().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");Au!==-1&&this._numBytesAllocated>Au?(this.gpgpu.deleteMatrixTexture(nu.texture),this._numBytesAllocated-=mu):(this.freeTextures[pu].push(nu),this.numFreeTextures++,this._numBytesFree+=mu),this.numUsedTextures--;const bu=this.usedTextures[pu],Cu=bu&&bu.indexOf(nu);if(Cu==null||Cu<0)throw new Error("Cannot release a texture that was never provided by this texture manager");bu[Cu]=bu[bu.length-1],bu.pop(),this.log()}log(){if(!this.logEnabled)return;const nu=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${nu})`);const ru=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*ru)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const nu in this.freeTextures)this.freeTextures[nu].forEach(ru=>{this.gpgpu.deleteMatrixTexture(ru.texture)});for(const nu in this.usedTextures)this.usedTextures[nu].forEach(ru=>{this.gpgpu.deleteMatrixTexture(ru.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function DY(ou,nu){const ru=ou;if(nu===ru.R32F)return 4;if(nu===ru.R16F)return 2;if(nu===ru.RGBA32F||nu===ou.RGBA)return 16;if(nu===ru.RGBA16F)return 8;if(nu===ru.RGBA8)return 4;throw new Error(`Unknown internal format ${nu}`)}function GD(ou,nu,ru,lu,cu){const hu=FY(nu,lu);let pu;if(cu){const[Au,bu]=cC(ou[0],ou[1]);pu=Au*bu}else{const[Au,bu]=Pw(ou[0],ou[1]);pu=Au*bu}const mu=DY(ru,hu);return pu*mu}function FY(ou,nu){switch(ou){case fy.PACKED_2X2_FLOAT32:return kD(nu);case fy.PACKED_2X2_FLOAT16:return BD(nu);case fy.UNPACKED_FLOAT32:return _D(nu);case fy.UNPACKED_FLOAT16:return MD(nu);case fy.PACKED_4X1_UNSIGNED_BYTE:return RD(nu);default:throw new Error(`Unknown physical texture type ${ou}`)}}function PY(ou){return cp().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?ou?fy.PACKED_2X2_FLOAT32:fy.UNPACKED_FLOAT32:ou?fy.PACKED_2X2_FLOAT16:fy.UNPACKED_FLOAT16}function OD(ou,nu){if(ou===_b.UPLOAD)return fy.PACKED_2X2_FLOAT32;if(ou===_b.RENDER||ou==null)return PY(nu);if(ou===_b.DOWNLOAD||ou===_b.PIXELS)return fy.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${ou}`)}function UD(ou,nu,ru){return`${ou[0]}_${ou[1]}_${nu}_${ru}`}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Zx{constructor(nu,ru){this.variableNames=["A"],this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${ru}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const gx="if (isnan(x)) return x;",GY="return x;",$D="return abs(x);",OY="return (x >= 0.0) ? x : (exp(x) - 1.0);",UY=gx+`
  return (x < 0.0) ? 0.0 : x;
`,$Y=gx+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Gv="return x;",VY="return 1.0 / (1.0 + exp(-1.0 * x));";/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zY="return x;",WY=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,HY=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,XY=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QY="return 1.0 / (1.0 + exp(-1.0 * x));";class Ov{constructor(nu,ru){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${ru}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class KY{constructor(nu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length);const ru=nu.length,lu=Sy("rc",ru),cu=x0(ru),hu=kY(ru,lu),pu=lu.slice(-2),mu=ru<=1?"rc":`vec2(${pu.join(",")})`;this.userCode=`
      void main() {
        ${cu} rc = getOutputCoords();
        vec4 packedInput = getA(${hu});

        setOutput(getChannel(packedInput, ${mu}));
      }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZY=AR,jY=1e-7,YY=1e-4,YT={};function qY(ou){return ou in YT||(YT[ou]={}),YT[ou]}const JY=cp().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),eq=600;function tq(){return cp().global.screen==null?1024:cp().global.screen.height*cp().global.screen.width*window.devicePixelRatio*eq/1024/1024}class D2 extends au{nextDataId(){return D2.nextDataId++}constructor(nu){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!cp().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let ru;if(nu!=null){if(nu instanceof ZT)ru=nu;else{const lu=kx(cp().getNumber("WEBGL_VERSION"),nu);ru=new ZT(lu)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const lu=kx(cp().getNumber("WEBGL_VERSION"));ru=new ZT(lu),this.binaryCache=qY(cp().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=ru,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new NY(this.gpgpu),this.numMBBeforeWarning=tq(),this.texData=new su(this,w0())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(nu,ru,lu,cu,hu,pu){const mu=this.makeTensorInfo(ru,lu),Au=this.texData.get(mu.dataId);Au.isPacked=!1,Au.texture={texture:nu,texShape:[cu,hu]},Au.texShape=[cu,hu];const bu=k2(ru),Cu=new TD(bu,!1,pu),wu=this.runWebGLProgram(Cu,[mu],lu,[[cu,hu]]);return wu.shape=ru,Au.texture=null,this.disposeIntermediateTensorInfo(mu),wu.dataId}write(nu,ru,lu){if((cp().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||cp().getBool("DEBUG"))&&this.checkNumericalProblems(nu),lu==="complex64"&&nu!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const cu={id:this.nextDataId()};return this.texData.set(cu,{shape:ru,dtype:lu,values:nu,usage:_b.UPLOAD,refCount:1}),cu}refCount(nu){return this.texData.has(nu)?this.texData.get(nu).refCount:0}incRef(nu){const ru=this.texData.get(nu);ru.refCount++}decRef(nu){if(this.texData.has(nu)){const ru=this.texData.get(nu);ru.refCount--}}move(nu,ru,lu,cu,hu){if(cp().getBool("DEBUG")&&this.checkNumericalProblems(ru),cu==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(nu,{shape:lu,dtype:cu,values:ru,usage:_b.UPLOAD,refCount:hu})}disposeIntermediateTensorInfo(nu){this.disposeData(nu.dataId)}readSync(nu){const ru=this.texData.get(nu),{values:lu,dtype:cu,complexTensorInfos:hu,slice:pu,shape:mu,isPacked:Au}=ru;if(pu!=null){let Eu;Au?Eu=new Ov(mu,Gv):Eu=new Zx(mu,Gv);const Tu=this.runWebGLProgram(Eu,[{dataId:nu,shape:mu,dtype:cu}],cu),Ru=this.readSync(Tu.dataId);return this.disposeIntermediateTensorInfo(Tu),Ru}if(lu!=null)return this.convertAndCacheOnCPU(nu);if(cu==="string")return lu;const bu=this.activeTimers!=null;let Cu;bu&&(Cu=My());let wu;if(cu==="complex64"){const Eu=this.readSync(hu.real.dataId),Tu=this.readSync(hu.imag.dataId);wu=sv(Eu,Tu)}else wu=this.getValuesFromTexture(nu);return bu&&(this.downloadWaitMs+=My()-Cu),this.convertAndCacheOnCPU(nu,wu)}async read(nu){if(this.pendingRead.has(nu)){const Ru=this.pendingRead.get(nu);return new Promise(Nu=>Ru.push(Nu))}const ru=this.texData.get(nu),{values:lu,shape:cu,slice:hu,dtype:pu,complexTensorInfos:mu,isPacked:Au}=ru;if(hu!=null){let Ru;Au?Ru=new Ov(cu,Gv):Ru=new Zx(cu,Gv);const Nu=this.runWebGLProgram(Ru,[{dataId:nu,shape:cu,dtype:pu}],pu),Pu=this.read(Nu.dataId);return this.disposeIntermediateTensorInfo(Nu),Pu}if(lu!=null)return this.convertAndCacheOnCPU(nu);if(cp().getBool("DEBUG")&&!cp().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&cp().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let bu=null,Cu;if(pu!=="complex64"&&cp().get("WEBGL_BUFFER_SUPPORTED")){Cu=this.decode(nu);const Ru=this.texData.get(Cu.dataId);bu=this.gpgpu.createBufferFromTexture(Ru.texture.texture,..._2(cu))}this.pendingRead.set(nu,[]),pu!=="complex64"&&await this.gpgpu.createAndWaitForFence();let wu;if(pu==="complex64"){const Ru=await Promise.all([this.read(mu.real.dataId),this.read(mu.imag.dataId)]),Nu=Ru[0],Pu=Ru[1];wu=sv(Nu,Pu)}else if(bu==null)wu=this.getValuesFromTexture(nu);else{const Ru=Mu(cu);wu=this.gpgpu.downloadFloat32MatrixFromBuffer(bu,Ru)}if(Cu!=null&&this.disposeIntermediateTensorInfo(Cu),bu!=null){const Ru=this.gpgpu.gl;Bm(Ru,()=>Ru.deleteBuffer(bu))}const Eu=this.convertAndCacheOnCPU(nu,wu),Tu=this.pendingRead.get(nu);return this.pendingRead.delete(nu),Tu.forEach(Ru=>Ru(Eu)),this.pendingDisposal.has(nu)&&(this.pendingDisposal.delete(nu),this.disposeData(nu)&&w0().removeDataId(nu,this),this.pendingDeletes--),Eu}readToGPU(nu,ru={}){const lu=this.texData.get(nu),{values:cu,shape:hu,slice:pu,dtype:mu,isPacked:Au,texture:bu}=lu;if(mu==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(pu!=null){let Tu;Au?Tu=new Ov(hu,Gv):Tu=new Zx(hu,Gv);const Ru=this.runWebGLProgram(Tu,[{dataId:nu,shape:hu,dtype:mu}],mu),Nu=this.readToGPU(Ru,ru);return this.disposeIntermediateTensorInfo(Ru),Nu}if(bu==null)throw cu!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const Cu=this.decode(nu,ru.customTexShape),wu=w0().makeTensorFromTensorInfo(Cu),Eu=this.texData.get(Cu.dataId);return Object.assign({tensorRef:wu},Eu.texture)}bufferSync(nu){const ru=this.readSync(nu.dataId);if(nu.dtype==="string")try{const lu=ru.map(cu=>xv(cu));return t0(nu.shape,nu.dtype,lu)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return t0(nu.shape,nu.dtype,ru)}checkNumericalProblems(nu){if(nu!=null)for(let ru=0;ru<nu.length;ru++){const lu=nu[ru];if(!r6(lu))throw cp().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${lu} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${lu} cannot be represented on this device.`)}}getValuesFromTexture(nu){const{shape:ru,dtype:lu,isPacked:cu}=this.texData.get(nu),hu=Mu(ru);if(cp().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const Eu=this.decode(nu),Tu=this.texData.get(Eu.dataId),Ru=this.gpgpu.downloadMatrixFromPackedTexture(Tu.texture.texture,..._2(ru)).subarray(0,hu);return this.disposeIntermediateTensorInfo(Eu),Ru}const pu=cp().getBool("WEBGL_PACK")&&cu===!0,mu=pu?k2(ru):ru,Au=pu?new x7(mu):new b7(mu),bu=this.runWebGLProgram(Au,[{shape:mu,dtype:lu,dataId:nu}],"float32"),Cu=this.texData.get(bu.dataId),wu=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(Cu.texture.texture,Cu.texShape[0],Cu.texShape[1]).subarray(0,hu);return this.disposeIntermediateTensorInfo(bu),wu}timerAvailable(){return cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(nu){const ru=this.activeTimers,lu=[];let cu=!1;this.programTimersStack==null?(this.programTimersStack=lu,cu=!0):this.activeTimers.push(lu),this.activeTimers=lu,nu();const hu=Jv(this.activeTimers.map(Au=>Au.query)).filter(Au=>Au!=null),pu=Jv(this.activeTimers.map(Au=>Au.name)).filter(Au=>Au!=null);this.activeTimers=ru,cu&&(this.programTimersStack=null);const mu={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const Au=await Promise.all(hu);mu.kernelMs=xu(Au),mu.getExtraProfileInfo=()=>Au.map((bu,Cu)=>({name:pu[Cu],ms:bu})).map(bu=>`${bu.name}: ${bu.ms}`).join(", ")}else mu.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,mu})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:My(),endMs:null}}endTimer(nu){return cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),nu):(nu.endMs=My(),nu)}async getQueryTime(nu){if(cp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(nu);const ru=nu;return ru.endMs-ru.startMs}disposeData(nu,ru=!1){if(this.pendingDisposal.has(nu))return!1;if(!this.texData.has(nu))return!0;if(ru?this.texData.get(nu).refCount=0:this.texData.get(nu).refCount--,!ru&&this.texData.get(nu).refCount>0)return!1;if(this.pendingRead.has(nu))return this.pendingDisposal.add(nu),this.pendingDeletes++,!1;this.releaseGPUData(nu);const{complexTensorInfos:lu}=this.texData.get(nu);return lu!=null&&(this.disposeData(lu.real.dataId,ru),this.disposeData(lu.imag.dataId,ru)),this.texData.delete(nu),!0}releaseGPUData(nu){const{texture:ru,dtype:lu,texShape:cu,usage:hu,isPacked:pu,slice:mu}=this.texData.get(nu),Au=mu&&mu.origDataId||nu,bu=this.dataRefCount.get(Au);bu>1?this.dataRefCount.set(Au,bu-1):(this.dataRefCount.delete(Au),ru!=null&&(this.numBytesInGPU-=this.computeBytes(cu,lu),this.textureManager.releaseTexture(ru,cu,hu,pu)));const Cu=this.texData.get(nu);Cu.texture=null,Cu.texShape=null,Cu.isPacked=!1,Cu.slice=null}getTexture(nu){return this.uploadToGPU(nu),this.texData.get(nu).texture.texture}getDataInfo(nu){return this.texData.get(nu)}shouldExecuteOnCPU(nu,ru=JY){return cp().getBool("WEBGL_CPU_FORWARD")&&nu.every(lu=>this.texData.get(lu.dataId).texture==null&&Mu(lu.shape)<ru)}getGPGPUContext(){return this.gpgpu}where(nu){Xy("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const ru=nu.dataSync();return ZY(nu.shape,ru)}packedUnaryOp(nu,ru,lu){const cu=new Ov(nu.shape,ru),hu=this.compileAndRun(cu,[nu],lu);return w0().makeTensorFromTensorInfo(hu)}abs(nu){if(this.shouldExecuteOnCPU([nu])&&nu.dtype!=="complex64"){const cu=ND(this.texData.get(nu.dataId).values);return this.makeOutput(nu.shape,nu.dtype,cu)}if(cp().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(nu,$D,nu.dtype);const ru=new Zx(nu.shape,$D),lu=this.compileAndRun(ru,[nu]);return w0().makeTensorFromTensorInfo(lu)}makeTensorInfo(nu,ru,lu){let cu;if(ru==="string"&&lu!=null&&lu.length>0&&Cp(lu[0])){const hu=lu.map(pu=>bv(pu));cu=this.write(hu,nu,ru)}else cu=this.write(lu,nu,ru);return this.texData.get(cu).usage=null,{dataId:cu,shape:nu,dtype:ru}}makeOutput(nu,ru,lu){return w0().makeTensorFromTensorInfo(this.makeTensorInfo(nu,ru,lu),this)}unpackTensor(nu){const ru=new KY(nu.shape);return this.runWebGLProgram(ru,[nu],nu.dtype)}packTensor(nu){const ru=new BY(nu.shape);return this.runWebGLProgram(ru,[nu],nu.dtype,null,!0)}packedReshape(nu,ru){const lu=[uC(nu.shape),...hC(nu.shape)],cu={dtype:nu.dtype,shape:lu,dataId:nu.dataId},hu=[uC(ru),...hC(ru)],pu=new PD(hu,lu),mu=!0,Au=[lu],bu=this.runWebGLProgram(pu,[cu],nu.dtype,Au,mu);return{dataId:bu.dataId,shape:ru,dtype:bu.dtype}}decode(nu,ru){const lu=this.texData.get(nu),{isPacked:cu,shape:hu,dtype:pu}=lu;if(ru!=null){const Eu=Mu(hu),Tu=ru[0]*ru[1]*4;vu(Eu<=Tu,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const mu=k2(hu);let Au;cu?Au=new y7(mu):Au=new A7(mu);const bu=!0,Cu=[ru??_2(mu)],wu=this.runWebGLProgram(Au,[{shape:mu,dtype:pu,dataId:nu}],pu,Cu,bu,ru);return{dtype:pu,shape:hu,dataId:wu.dataId}}runWebGLProgram(nu,ru,lu,cu,hu=!1,pu){const mu=this.makeTensorInfo(nu.outputShape,lu),Au=this.texData.get(mu.dataId);if(nu.packedOutput&&(Au.isPacked=!0),nu.outPackingScheme===Fw.DENSE){const Fu=pu??_2(nu.outputShape);Au.texShape=Fu.map(Gu=>Gu*2)}if(nu.outTexUsage!=null&&(Au.usage=nu.outTexUsage),Mu(mu.shape)===0)return Au.values=Hu(mu.dtype,0),mu;const bu=[],Cu=ru.map(Fu=>{if(Fu.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Gu=this.texData.get(Fu.dataId);if(Gu.texture==null){if(!nu.packedInputs&&Mu(Fu.shape)<=cp().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:Fu.shape,texData:null,isUniform:!0,uniformValues:Gu.values};nu.packedInputs&&(Gu.isPacked=!0,Gu.shape=Fu.shape)}if(this.uploadToGPU(Fu.dataId),!!Gu.isPacked!=!!nu.packedInputs)Fu=Gu.isPacked?this.unpackTensor(Fu):this.packTensor(Fu),bu.push(Fu),Gu=this.texData.get(Fu.dataId);else if(Gu.isPacked&&!L2(Gu.shape,Fu.shape)){const Xu=Fu,Qu=Fu.shape;Fu.shape=Gu.shape,Fu=this.packedReshape(Fu,Qu),bu.push(Fu),Gu=this.texData.get(Fu.dataId),Xu.shape=Qu}return{shape:Fu.shape,texData:Gu,isUniform:!1}});this.uploadToGPU(mu.dataId);const wu={shape:mu.shape,texData:Au,isUniform:!1},Eu=g7(nu,Cu,wu),Tu=this.getAndSaveBinary(Eu,()=>f7(this.gpgpu,nu,Cu,wu)),Ru=this.activeTimers!=null;let Nu;Ru&&(Nu=this.startTimer()),cp().get("ENGINE_COMPILE_ONLY")||m7(this.gpgpu,Tu,Cu,wu,cu),bu.forEach(Fu=>this.disposeIntermediateTensorInfo(Fu)),Ru&&(Nu=this.endTimer(Nu),this.activeTimers.push({name:nu.constructor.name,query:this.getQueryTime(Nu)}));const Pu=cp().getNumber("WEBGL_FLUSH_THRESHOLD");if(Pu>0){const Fu=My();Fu-this.lastGlFlushTime>Pu&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=Fu)}if(!cp().getBool("WEBGL_LAZILY_UNPACK")&&Au.isPacked&&hu===!1){const Fu=this.unpackTensor(mu);return this.disposeIntermediateTensorInfo(mu),Fu}return mu}compileAndRun(nu,ru,lu,cu,hu=!1){return lu=lu||ru[0].dtype,this.runWebGLProgram(nu,ru,lu,cu,hu)}getAndSaveBinary(nu,ru){return nu in this.binaryCache||(this.binaryCache[nu]=ru()),this.binaryCache[nu]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(cp().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(nu=>{this.gpgpu.deleteProgram(this.binaryCache[nu].webGLProgram),delete this.binaryCache[nu]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Op(()=>{if(!cp().get("WEBGL_RENDER_FLOAT32_ENABLED")){const nu=cp().getBool("DEBUG");cp().set("DEBUG",!1);const ru=this.abs(A0(1e-8)).dataSync()[0];if(cp().set("DEBUG",nu),ru>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?jY:YY}uploadToGPU(nu){const ru=this.texData.get(nu),{shape:lu,dtype:cu,values:hu,texture:pu,usage:mu,isPacked:Au}=ru;if(pu!=null)return;const bu=this.activeTimers!=null;let Cu;bu&&(Cu=My());let wu=ru.texShape;if(wu==null&&(wu=C6(lu,Au),ru.texShape=wu),hu!=null){const Eu=k2(lu);let Tu,Ru=wu[1],Nu=wu[0];const Pu=hu instanceof Uint8Array||hu instanceof Uint8ClampedArray;(Au||!Pu)&&([Ru,Nu]=cC(wu[0],wu[1])),Au?Tu=new C7(Eu,Pu):Tu=new TD(Eu,Pu);const Fu=Pu?[Nu,Ru]:wu,Gu=this.makeTensorInfo(Fu,cu),Xu=this.texData.get(Gu.dataId);Pu?Xu.usage=_b.PIXELS:Xu.usage=_b.UPLOAD,Xu.texShape=Fu,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Gu.dataId),Ru,Nu,hu);const Qu=[[Nu,Ru]],Ju=this.runWebGLProgram(Tu,[Gu],cu,Qu,!0),ip=this.texData.get(Ju.dataId);ru.texShape=ip.texShape,ru.isPacked=ip.isPacked,ru.usage=ip.usage,cp().get("ENGINE_COMPILE_ONLY")?this.disposeData(Ju.dataId):(ru.texture=ip.texture,ru.values=null,this.texData.delete(Ju.dataId)),this.disposeIntermediateTensorInfo(Gu),bu&&(this.uploadWaitMs+=My()-Cu)}else{const Eu=this.acquireTexture(wu,mu,cu,Au);ru.texture=Eu}}convertAndCacheOnCPU(nu,ru){const lu=this.texData.get(nu),{dtype:cu}=lu;return ru!=null&&(lu.values=nq(ru,cu)),lu.values}acquireTexture(nu,ru,lu,cu){if(this.numBytesInGPU+=this.computeBytes(nu,lu),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const hu=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${hu} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(nu,ru,cu)}computeBytes(nu,ru){return nu[0]*nu[1]*gp(ru)}checkCompileCompletion(){for(const[,nu]of Object.entries(this.binaryCache))this.checkCompletion_(nu)}async checkCompileCompletionAsync(){const nu=[];if(this.gpgpu.parallelCompilationExtension){for(const[,ru]of Object.entries(this.binaryCache))nu.push(this.checkCompletionAsync_(ru));return Promise.all(nu)}else{for(const[,ru]of Object.entries(this.binaryCache)){const lu=new Promise(cu=>{try{this.checkCompletion_(ru),cu(!0)}catch(hu){throw hu}});nu.push(lu)}return Promise.all(nu)}}async checkCompletionAsync_(nu){return this.gpgpu.gl.getProgramParameter(nu.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(nu):(await QE(),this.checkCompletionAsync_(nu))}checkCompletion_(nu){if(this.gpgpu.gl.getProgramParameter(nu.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(nu.webGLProgram)),this.gpgpu.gl.getShaderParameter(nu.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(AD(nu.source,this.gpgpu.gl.getShaderInfoLog(nu.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const nu of Object.values(this.binaryCache)){this.gpgpu.buildVao(nu.webGLProgram);const{variablesLocations:ru,customUniformLocations:lu,infLoc:cu,nanLoc:hu,outShapeLocation:pu,outShapeStridesLocation:mu,outTexShapeLocation:Au}=SD(this.gpgpu,nu.program,nu.webGLProgram);nu.variablesLocations=ru,nu.customUniformLocations=lu,nu.infLoc=cu,nu.nanLoc=hu,nu.outShapeLocation=pu,nu.outShapeStridesLocation=mu,nu.outTexShapeLocation=Au}}createTensorFromGPUData(nu,ru,lu){nu.channels=nu.channels||"RGBA";const{texture:cu,height:hu,width:pu,channels:mu}=nu,Au=w0().backend;if(!Au.gpgpu.gl.isTexture(cu))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const bu=Au.writeTexture(cu,ru,lu,hu,pu,mu);return w0().makeTensorFromDataId(bu,ru,lu,Au)}}D2.nextDataId=0;function nq(ou,nu){if(nu==="float32"||nu==="complex64")return ou;if(nu==="int32"||nu==="bool"){const ru=nu==="int32"?new Int32Array(ou.length):new Uint8Array(ou.length);for(let lu=0;lu<ru.length;++lu)ru[lu]=Math.round(ou[lu]);return ru}else throw new Error(`Unknown dtype ${nu}`)}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/bM()&&wM("webgl",()=>new D2,2);/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qT=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class T1{constructor(nu,ru,lu){this.variableNames=["A","B"],this.outputShape=_g(ru,lu),this.enableShapeUniforms=Ay(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${nu}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _1=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class gC{constructor(nu,ru,lu,cu=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_g(ru,lu);const hu=this.outputShape.length;this.enableShapeUniforms=Ay(hu);let pu="";if(cu)if(hu===0||Mu(this.outputShape)===1)pu=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(pu=`
          ${x0(hu)} coords = getOutputCoords();
        `,hu===1)this.enableShapeUniforms?pu+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:pu+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const mu=Sy("coords",hu);this.enableShapeUniforms?pu+=`
            bool nextRowOutOfBounds =
              (${mu[hu-2]} + 1) >= outShape[${hu} - 2];
            bool nextColOutOfBounds =
              (${mu[hu-1]} + 1) >= outShape[${hu} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:pu+=`
            bool nextRowOutOfBounds =
              (${mu[hu-2]} + 1) >= ${this.outputShape[hu-2]};
            bool nextColOutOfBounds =
              (${mu[hu-1]} + 1) >= ${this.outputShape[hu-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${nu}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${pu}

        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wy(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;return ru.incRef(lu.dataId),{dataId:lu.dataId,shape:lu.shape,dtype:lu.dtype}}const iq={kernelName:Hy,backendName:"webgl",kernelFunc:Wy};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Uv(ou){const{inputs:nu,backend:ru}=ou,{real:lu,imag:cu}=nu,hu=ru.makeTensorInfo(lu.shape,"complex64"),pu=ru.texData.get(hu.dataId),mu=Wy({inputs:{x:lu},backend:ru}),Au=Wy({inputs:{x:cu},backend:ru});return pu.complexTensorInfos={real:mu,imag:Au},hu}const rq={kernelName:$0,backendName:"webgl",kernelFunc:Uv};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const VD="return (a < 0.) ? b * a : a;",zD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function sq(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{alpha:hu}=lu,pu=ru.makeTensorInfo([],"float32",yv(hu,"float32")),mu=cp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gC(zD,cu.shape,pu.shape):new T1(VD,cu.shape,pu.shape),Au=ru.runWebGLProgram(mu,[cu,pu],"float32");return ru.disposeIntermediateTensorInfo(pu),Au}const oq={kernelName:Ax,backendName:"webgl",kernelFunc:sq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WD="return (a < 0.) ? b * a : a;",HD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function aq(ou){const{inputs:nu,backend:ru}=ou,{x:lu,alpha:cu}=nu,hu=cp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gC(HD,lu.shape,cu.shape):new T1(WD,lu.shape,cu.shape);return ru.runWebGLProgram(hu,[lu,cu],"float32")}const lq={kernelName:pE,backendName:"webgl",kernelFunc:aq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AC="if (isnan(x)) return x;";function u0({opSnippet:ou,packedOpSnippet:nu,cpuKernelImpl:ru,dtype:lu}){return({inputs:cu,backend:hu})=>{const{x:pu}=cu,mu=hu,Au=lu||pu.dtype;if(mu.shouldExecuteOnCPU([pu])&&ru!=null){const wu=mu.texData.get(pu.dataId),Eu=ru(wu.values,Au);return mu.makeTensorInfo(pu.shape,Au,Eu)}const bu=cp().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&nu!=null;let Cu;return bu?Cu=new Ov(pu.shape,nu):Cu=new Zx(pu.shape,ou),mu.runWebGLProgram(Cu,[pu],Au)}}function my({opSnippet:ou,packedOpSnippet:nu,checkOutOfBounds:ru=!1,supportsComplex:lu=!1,cpuKernelImpl:cu,dtype:hu}){return({inputs:pu,backend:mu})=>{const{a:Au,b:bu}=pu,Cu=mu;if(lu&&Au.dtype==="complex64"){const Ru=Cu.texData.get(Au.dataId),Nu=Cu.texData.get(bu.dataId),[Pu,Fu]=[[Ru.complexTensorInfos.real,Nu.complexTensorInfos.real],[Ru.complexTensorInfos.imag,Nu.complexTensorInfos.imag]].map(Xu=>{const[Qu,Ju]=Xu,ip={dataId:Qu.dataId,dtype:Qu.dtype,shape:Au.shape},rp={dataId:Ju.dataId,dtype:Ju.dtype,shape:bu.shape},op=new T1(ou,Au.shape,bu.shape);return Cu.runWebGLProgram(op,[ip,rp],Uy(Qu.dtype,Ju.dtype))}),Gu=Uv({inputs:{real:Pu,imag:Fu},backend:Cu});return Cu.disposeIntermediateTensorInfo(Pu),Cu.disposeIntermediateTensorInfo(Fu),Gu}const wu=hu||Uy(Au.dtype,bu.dtype);if((Au.dtype==="string"||bu.dtype==="string"||Cu.shouldExecuteOnCPU([Au,bu]))&&cu!=null){const Ru=Cu.texData.get(Au.dataId).values,Nu=Cu.texData.get(bu.dataId).values,Pu=Au.dtype==="string"?ov(Ru):Ru,Fu=Au.dtype==="string"?ov(Nu):Nu,[Gu,Xu]=cu(Au.shape,bu.shape,Pu,Fu,wu),Qu=Cu.makeTensorInfo(Xu,wu),Ju=Cu.texData.get(Qu.dataId);return Ju.values=Gu,Qu}const Eu=cp().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&nu!=null;let Tu;return Eu?Tu=new gC(nu,Au.shape,bu.shape,ru):Tu=new T1(ou,Au.shape,bu.shape),Cu.runWebGLProgram(Tu,[Au,bu],wu)}}function Uw(ou,nu=!1){if(ou==="linear")return nu?zY:GY;if(ou==="relu")return nu?HY:UY;if(ou==="elu")return nu?WY:OY;if(ou==="relu6")return nu?XY:$Y;if(ou==="prelu")return nu?HD:WD;if(ou==="leakyrelu")return nu?zD:VD;if(ou==="sigmoid")return nu?QY:VY;throw new Error(`Activation ${ou} has not been implemented for the WebGL backend.`)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class XD{constructor(nu,ru,lu,cu=!1,hu=!1,pu=!1,mu=null,Au=!1,bu=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=lu,this.enableShapeUniforms=Ay(this.outputShape.length);const Cu=cu?nu[1]:nu[2],wu=Math.ceil(Cu/2),Eu=cu?"i * 2, rc.y":"rc.y, i * 2",Tu=hu?"rc.z, i * 2":"i * 2, rc.z",Ru=cu?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Nu=hu?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let Pu="",Fu="";mu&&(Au?Pu=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${mu}
        }`:bu?Pu=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${mu}
        }`:Pu=`vec4 activation(vec4 x) {
          ${mu}
        }`,Fu="result = activation(result);");const Gu=pu?"result += getBiasAtOutCoords();":"";pu&&this.variableNames.push("bias"),Au&&this.variableNames.push("preluActivationWeights"),bu&&this.variableNames.push("leakyreluAlpha");let Xu="rc.x",Qu="rc.x";nu[0]<ru[0]?Xu=`imod(rc.x, ${nu[0]})`:ru[0]<nu[0]&&(Qu=`imod(rc.x, ${ru[0]})`),this.userCode=`
      ${Pu}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${wu}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${Xu};
        int batchB = ${Qu};
        for (int i = 0; i < ${wu}; i++) {
          vec4 a = getMatrixA(batchA, ${Eu});
          vec4 b = getMatrixB(batchB, ${Tu});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${Ru[0]} * ${Nu[0]});
          result += (${Ru[1]} * ${Nu[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${Gu}

        ${Fu}

        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const QD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class KD{constructor(nu,ru,lu){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=_g(ru,lu),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${nu}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZD="return a * b;";function JT(ou){const{inputs:nu,backend:ru}=ou,{a:lu,b:cu}=nu,hu=Uy(lu.dtype,cu.dtype);if(lu.dtype==="complex64"){const mu=ru.texData.get(lu.dataId),Au=ru.texData.get(cu.dataId),bu=new KD(QD.REAL,lu.shape,cu.shape),Cu=new KD(QD.IMAG,lu.shape,cu.shape),wu=[{dataId:mu.complexTensorInfos.real.dataId,dtype:mu.complexTensorInfos.real.dtype,shape:lu.shape},{dataId:mu.complexTensorInfos.imag.dataId,dtype:mu.complexTensorInfos.imag.dtype,shape:lu.shape},{dataId:Au.complexTensorInfos.real.dataId,dtype:Au.complexTensorInfos.real.dtype,shape:cu.shape},{dataId:Au.complexTensorInfos.imag.dataId,dtype:Au.complexTensorInfos.imag.dtype,shape:cu.shape}],Eu=ru.runWebGLProgram(bu,wu,"float32"),Tu=ru.runWebGLProgram(Cu,wu,"float32"),Ru=Uv({inputs:{real:Eu,imag:Tu},backend:ru});return ru.disposeIntermediateTensorInfo(Eu),ru.disposeIntermediateTensorInfo(Tu),Ru}if(ru.shouldExecuteOnCPU([lu,cu])){const mu=ru.texData.get(lu.dataId),Au=ru.texData.get(cu.dataId),[bu,Cu]=aY(lu.shape,cu.shape,mu.values,Au.values,hu),wu=ru.makeTensorInfo(Cu,hu),Eu=ru.texData.get(wu.dataId);return Eu.values=bu,wu}let pu;return cp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?pu=new gC(ZD,lu.shape,cu.shape):pu=new T1(ZD,lu.shape,cu.shape),ru.runWebGLProgram(pu,[lu,cu],hu)}const cq={kernelName:kC,backendName:"webgl",kernelFunc:JT};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uq(ou,nu,ru){const lu=[uC(ou.shape),...hC(ou.shape)],cu={dtype:ou.dtype,shape:lu,dataId:ou.dataId},hu=[uC(nu),...hC(nu)],pu=new PD(hu,lu),mu=!0,Au=[lu],bu=ru.runWebGLProgram(pu,[cu],ou.dtype,Au,mu);return{dataId:bu.dataId,shape:nu,dtype:bu.dtype}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Cm(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{shape:hu}=lu,pu=ru,mu=Mu(cu.shape),Au=Ou(hu,mu),bu=Mu(Au);vu(mu===bu,()=>`The new shape (${Au}) has ${bu} elements and the old shape (${cu.shape}) has ${mu} elements. The new shape and old shape must have the same number of elements.`);const Cu=pu.texData.get(cu.dataId);return Cu.isPacked&&!L2(cu.shape,Au)&&!(Cu.texture!==null&&L2(Cu.shape,Au))?uq(cu,Au,pu):(pu.incRef(cu.dataId),{dataId:cu.dataId,shape:Au,dtype:cu.dtype})}const hq={kernelName:mE,backendName:"webgl",kernelFunc:Cm};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jD{constructor(nu,ru){this.variableNames=["x"];const{windowSize:lu,batchSize:cu,inSize:hu,outSize:pu}=nu;this.outputShape=[cu,pu];const mu=Math.floor(lu/4)*4,Au=lu%4;let bu="sumValue += dot(values, ones);";if(ru!=null){const wu=1/ru;bu=`sumValue += dot(values * ${Bu(wu)?wu.toPrecision(2):wu}, ones);`}let Cu="";hu%lu>0&&(Cu=`
        if (inIdx < 0 || inIdx >= ${hu}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${Cu}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${lu};

        float sumValue = 0.0;

        for (int i = 0; i < ${mu}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${bu}
        }

        int inIdx = inOffset + ${mu};
        if (${Au===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${bu}
        } else if (${Au===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${bu}
        } else if (${Au===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${bu}
        }
        setOutput(sumValue);
      }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class dq{constructor(nu,ru){this.variableNames=["x"];const{windowSize:lu,batchSize:cu,inSize:hu,outSize:pu}=nu;this.outputShape=[cu,pu];let mu="0.0",Au="";ru==="prod"?mu="1.0":ru==="min"?(mu="1.0 / 1e-20",Au="min"):ru==="max"&&(mu="-1.0 / 1e-20",Au="max");let bu=`${ru}(${ru}(${ru}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;ru==="sum"?bu="sumValue":ru==="prod"?bu="prodValue":ru==="all"?bu="allValue":ru==="any"&&(bu="anyValue");const Cu=Math.floor(lu/4)*4,wu=lu%4;let Eu=`
      if (${ru==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${ru==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${Au}(values, minMaxValue);
        if (${ru==="min"} || ${ru==="max"}) {
          minMaxValue = ${Au}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,Tu="vec4";ru==="all"?(mu="1.0",Eu=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,Tu="bvec4"):ru==="any"&&(mu="0.0",Eu=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,Tu="bvec4");let Ru="";hu%lu>0&&(Ru=`
        if (inIdx < 0 || inIdx >= ${hu}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${mu};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${Ru}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${lu};

        vec4 minMaxValue = vec4(${mu});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${Cu}; i += 4) {
          int inIdx = inOffset + i;
          ${Tu} values = ${Tu}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${Eu}
        }

        int inIdx = inOffset + ${Cu};
        if (${wu===1}) {
          ${Tu} values = ${Tu}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${Eu}
        } else if (${wu===2}) {
          ${Tu} values = ${Tu}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${Eu}
        } else if (${wu===3}) {
          ${Tu} values = ${Tu}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${Eu}
        }
        setOutput(${bu});
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pq(ou){const nu=[];for(;nu.length===0||nu[nu.length-1].outSize!==1;){const ru=nu.length?nu[nu.length-1].outSize:ou[1],lu=KE(ru);nu.push({inSize:ru,windowSize:lu,outSize:Math.ceil(ru/lu)})}return nu}function M1(ou,nu,ru,lu){const cu=pq(ou.shape);let hu=ou;for(let pu=0;pu<cu.length;pu++){const{inSize:mu,windowSize:Au,outSize:bu}=cu[pu];let Cu,wu;ru==="mean"?Cu=pu===0?new jD({windowSize:Au,inSize:mu,batchSize:ou.shape[0],outSize:bu},mu):new jD({windowSize:Au,inSize:mu,batchSize:ou.shape[0],outSize:bu}):Cu=new dq({windowSize:Au,inSize:mu,batchSize:ou.shape[0],outSize:bu},ru),wu=hu,hu=lu.runWebGLProgram(Cu,[hu],nu),wu.dataId!==ou.dataId&&lu.disposeIntermediateTensorInfo(wu)}return hu}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fq{constructor(nu,ru){this.variableNames=["A"];const lu=new Array(nu.length);for(let pu=0;pu<lu.length;pu++)lu[pu]=nu[ru[pu]];this.outputShape=lu,this.rank=lu.length;const cu=x0(this.rank),hu=mq(ru);this.userCode=`
    void main() {
      ${cu} resRC = getOutputCoords();
      setOutput(getA(${hu}));
    }
    `}}function mq(ou){const nu=ou.length;if(nu>6)throw Error(`Transpose for rank ${nu} is not yet supported`);const ru=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],lu=new Array(nu);for(let cu=0;cu<ou.length;cu++)lu[ou[cu]]=ru[cu];return lu.join()}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gq{constructor(nu,ru){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const lu=new Array(nu.length);for(let Cu=0;Cu<lu.length;Cu++)lu[Cu]=nu[ru[Cu]];if(this.outputShape=lu,this.rank=lu.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const cu=x0(this.rank),hu=FD("rc",this.rank),pu=new Array(this.rank);for(let Cu=0;Cu<ru.length;Cu++)pu[ru[Cu]]=hu[Cu];const mu=`vec2(${pu.slice(-2).join()})`,Au=`++${hu[this.rank-1]} < ${lu[this.rank-1]}`,bu=`getChannel(getA(${pu.join()}), ${mu})`;this.userCode=`
    void main() {
      ${cu} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${bu};
      if(${Au}) {
        result[1] = ${bu};
      }
      --${hu[this.rank-1]};
      if(++${hu[this.rank-2]} < ${lu[this.rank-2]}) {
        result[2] = ${bu};
        if(${Au}) {
          result[3] = ${bu};
        }
      }
      setOutput(result);
    }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F2(ou,nu,ru){const lu=cp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gq(ou.shape,nu):new fq(ou.shape,nu);return ru.runWebGLProgram(lu,[ou],ou.dtype)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aq(ou,nu,ru,lu){const cu=nu,hu=ou.shape.length,pu=Wu(cu,ou.shape);let mu=pu;const Au=G0(mu,hu),bu=Au!=null;let Cu=ou;bu&&(Cu=F2(ou,Au,lu),mu=H0(mu.length,hu)),dy("sum",mu,hu);const[wu,Eu]=oy(Cu.shape,mu);let Tu=wu;ru&&(Tu=j0(wu,pu));const Ru=Mu(Eu),Nu=Mu(ou.shape)/Ru,Pu=Cm({inputs:{x:Cu},attrs:{shape:[Nu,Ru]},backend:lu}),Fu=TS(ou.dtype),Gu=M1(Pu,Fu,"sum",lu),Xu=Cm({inputs:{x:Gu},attrs:{shape:Tu},backend:lu});return lu.disposeIntermediateTensorInfo(Pu),lu.disposeIntermediateTensorInfo(Gu),bu&&lu.disposeIntermediateTensorInfo(Cu),Xu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P2(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu;return Aq(cu,hu,pu,ru)}const yq={kernelName:vE,backendName:"webgl",kernelFunc:P2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Iy(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{perm:hu}=lu,pu=ru,mu=cu.shape.length,Au=new Array(mu);for(let Cu=0;Cu<Au.length;Cu++)Au[Cu]=cu.shape[hu[Cu]];let bu;if(pu.shouldExecuteOnCPU([cu])){const Cu=pu.texData.get(cu.dataId).values,wu=jT(Cu,cu.shape,cu.dtype,hu,Au);bu=pu.makeTensorInfo(Au,cu.dtype);const Eu=pu.texData.get(bu.dataId);Eu.values=wu}else bu=F2(cu,hu,pu);return bu}const bq={kernelName:G1,backendName:"webgl",kernelFunc:Iy};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const YD=1e3;function G2({a:ou,b:nu,transposeA:ru,transposeB:lu,backend:cu,bias:hu=null,preluActivationWeights:pu=null,leakyreluAlpha:mu=0,activation:Au=null}){const bu=ou.shape.length,Cu=nu.shape.length,wu=ru?ou.shape[bu-2]:ou.shape[bu-1],Eu=lu?nu.shape[Cu-1]:nu.shape[Cu-2],Tu=ru?ou.shape[bu-1]:ou.shape[bu-2],Ru=lu?nu.shape[Cu-2]:nu.shape[Cu-1],Nu=ou.shape.slice(0,-2),Pu=nu.shape.slice(0,-2),Fu=Mu(Nu),Gu=Mu(Pu),Xu=_g(ou.shape.slice(0,-2),nu.shape.slice(0,-2)).concat([Tu,Ru]);vu(wu===Eu,()=>`Error in matMul: inner shapes (${wu}) and (${Eu}) of Tensors with shapes ${ou.shape} and ${nu.shape} and transposeA=${ru} and transposeB=${lu} must match.`);const Qu=ru?[Fu,wu,Tu]:[Fu,Tu,wu],Ju=lu?[Gu,Ru,Eu]:[Gu,Eu,Ru],ip=Cm({inputs:{x:ou},backend:cu,attrs:{shape:Qu}}),rp=Cm({inputs:{x:nu},backend:cu,attrs:{shape:Ju}}),op=[ip,rp],hp=Math.max(Fu,Gu),Ap=ru?ip.shape[1]:ip.shape[2],Up=hu!=null,Vp=pu!=null,zp=Au==="leakyrelu",qp=Au!=null?Uw(Au,!0):null,Yp=Up||Vp||zp||qp!=null;let em;if((Tu===1||Ru===1)&&Ap>YD&&Yp===!1){let im=ip,um=rp;ru&&(im=Iy({inputs:{x:ip},backend:cu,attrs:{perm:[0,2,1]}}),op.push(im)),lu&&(um=Iy({inputs:{x:rp},backend:cu,attrs:{perm:[0,2,1]}}),op.push(um));const ym=Ru!==1,pm=Ru===1;let bm=im;ym&&(bm=Cm({inputs:{x:im},backend:cu,attrs:{shape:[hp,Ap,1]}}),op.push(bm));const xm=Ru===1?2:1;let wm=um;pm&&(wm=Cm({inputs:{x:um},backend:cu,attrs:{shape:[hp,1,Ap]}}),op.push(wm));const Im=JT({inputs:{a:bm,b:wm},backend:cu});em=P2({inputs:{x:Im},backend:cu,attrs:{axis:xm,keepDims:!0}}),op.push(Im)}else{const im=Uy(ou.dtype,nu.dtype),um=new XD(Qu,Ju,[hp,Tu,Ru],ru,lu,Up,qp,Vp,zp),ym=[ip,rp];if(hu!=null&&ym.push(hu),Vp&&ym.push(pu),zp){const pm=cu.makeTensorInfo([],"float32",yv(mu,"float32"));ym.push(pm),op.push(pm)}em=cu.runWebGLProgram(um,ym,im)}const am=Cm({inputs:{x:em},backend:cu,attrs:{shape:Xu}});op.push(em);for(const im of op)cu.disposeIntermediateTensorInfo(im);return am}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xq(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{a:cu,b:hu,bias:pu,preluActivationWeights:mu}=nu,{transposeA:Au,transposeB:bu,activation:Cu,leakyreluAlpha:wu}=lu;return G2({a:cu,b:hu,transposeA:Au,transposeB:bu,backend:ru,bias:pu,preluActivationWeights:mu,leakyreluAlpha:wu,activation:Cu})}const vq={kernelName:_E,backendName:"webgl",kernelFunc:xq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qD="return abs(x);";function Cq(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;if(ru.shouldExecuteOnCPU([lu])&&lu.dtype!=="complex64"){const hu=ru.texData.get(lu.dataId),pu=ND(hu.values);return ru.makeTensorInfo(lu.shape,lu.dtype,pu)}let cu;return cp().getBool("WEBGL_PACK_UNARY_OPERATIONS")?cu=new Ov(lu.shape,qD):cu=new Zx(lu.shape,qD),ru.runWebGLProgram(cu,[lu],lu.dtype)}const wq={kernelName:Lp,backendName:"webgl",kernelFunc:Cq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Eq=gx+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Sq=u0({opSnippet:Eq}),Iq={kernelName:Kp,backendName:"webgl",kernelFunc:Sq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Tq=gx+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,_q=u0({opSnippet:Tq}),Mq={kernelName:vm,backendName:"webgl",kernelFunc:_q};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const JD="return a + b;",Rq=my({opSnippet:JD,packedOpSnippet:JD,supportsComplex:!0,cpuKernelImpl:U7}),kq={kernelName:sp,backendName:"webgl",kernelFunc:Rq};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Bq{constructor(nu,ru){this.outputShape=[],this.outputShape=nu,this.variableNames=ru.map((hu,pu)=>`T${pu}`);const lu=[];this.variableNames.forEach(hu=>{lu.push(`float v${hu} = get${hu}AtOutCoords();`)});const cu=this.variableNames.map(hu=>`v${hu}`).join(" + ");this.userCode=`
      void main() {
        ${lu.join(`
        `)}

        float result = ${cu};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Lq{constructor(nu,ru){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nu,this.variableNames=ru.map((hu,pu)=>`T${pu}`);const lu=[];this.variableNames.forEach(hu=>{lu.push(`vec4 v${hu} = get${hu}AtOutCoords();`)});const cu=this.variableNames.map(hu=>`v${hu}`).join(" + ");this.userCode=`
      void main() {
        ${lu.join(`
        `)}

        vec4 result = ${cu};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function O2(ou){const{inputs:nu,backend:ru}=ou,lu=nu;if(lu.length===1)return Wy({inputs:{x:lu[0]},backend:ru});if(lu.length>cp().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const mu=Math.floor(lu.length/2),Au=O2({inputs:lu.slice(0,mu),backend:ru}),bu=O2({inputs:lu.slice(mu),backend:ru});return O2({inputs:[Au,bu],backend:ru})}const cu=lu.map(mu=>mu.dtype).reduce((mu,Au)=>Uy(mu,Au)),hu=lu.map(mu=>mu.shape),pu=cp().getBool("WEBGL_PACK")?new Lq(lu[0].shape,hu):new Bq(lu[0].shape,hu);return ru.runWebGLProgram(pu,lu,cu)}const Nq={kernelName:_d,backendName:"webgl",kernelFunc:O2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dq(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu,mu=cu.shape.length,Au=Wu(hu,cu.shape);let bu=Au;const Cu=G0(bu,mu);let wu=cu;Cu!=null&&(wu=Iy({inputs:{x:cu},backend:ru,attrs:{perm:Cu}}),bu=H0(bu.length,mu)),dy("all",bu,mu);const[Eu,Tu]=oy(wu.shape,bu),Ru=Mu(Tu),Nu=Cm({inputs:{x:wu},backend:ru,attrs:{shape:[-1,Ru]}}),Pu=M1(Nu,Nu.dtype,"all",ru);let Fu;if(pu){const Gu=j0(Eu,Au);Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:Gu}})}else Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:Eu}});return ru.disposeIntermediateTensorInfo(Nu),ru.disposeIntermediateTensorInfo(Pu),Cu!=null&&ru.disposeIntermediateTensorInfo(wu),Fu}const Fq={kernelName:Sp,backendName:"webgl",kernelFunc:Dq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pq(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu,mu=cu.shape.length,Au=Wu(hu,cu.shape);let bu=Au;const Cu=G0(bu,mu);let wu=cu;Cu!=null&&(wu=Iy({inputs:{x:cu},backend:ru,attrs:{perm:Cu}}),bu=H0(bu.length,mu)),dy("any",bu,mu);const[Eu,Tu]=oy(wu.shape,bu),Ru=Mu(Tu),Nu=Cm({inputs:{x:wu},backend:ru,attrs:{shape:[-1,Ru]}}),Pu=M1(Nu,Nu.dtype,"any",ru);let Fu;if(pu){const Gu=j0(Eu,Au);Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:Gu}})}else Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:Eu}});return ru.disposeIntermediateTensorInfo(Nu),ru.disposeIntermediateTensorInfo(Pu),Cu!=null&&ru.disposeIntermediateTensorInfo(wu),Fu}const Gq={kernelName:tm,backendName:"webgl",kernelFunc:Pq};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Oq{constructor(nu,ru,lu){this.variableNames=["A"];const{windowSize:cu,batchSize:hu,outSize:pu}=nu;lu||this.variableNames.push("bestIndicesA"),this.outputShape=[hu,pu];const mu=ru==="max"?">":"<",Au=lu?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${cu};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${cu}; i++) {
          int inIdx = ${Au};
          float candidate = getA(batch, inIdx);
          if (candidate ${mu} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Uq{constructor(nu,ru,lu,cu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,vu(nu.length>2,()=>`Packed arg${lu.charAt(0).toUpperCase()+lu.slice(1)} supports only inputs with rank above 2.`);const hu=nu[nu.length-1],pu=Math.ceil(hu/ru);this.outputShape=nu.slice(0,-1),pu>1&&this.outputShape.push(pu),cu||this.variableNames.push("bestIndicesA");const mu=this.outputShape,Au=mu.length,bu=x0(Au),Cu=Sy("coords",Au);let wu,Eu;if(pu===1){Eu=Au+1;const op=x0(Eu);wu=`
        ${op} sourceLocR = ${op}(${Cu.join()}, 0);
        ++${Cu[Au-1]};
        ${op} sourceLocG = ${op}(${Cu.join()}, 0);
        ++${Cu[Au-2]};
        ${op} sourceLocA = ${op}(${Cu.join()}, 0);
        --${Cu[Au-1]};
        ${op} sourceLocB = ${op}(${Cu.join()}, 0);
        --${Cu[Au-2]};`}else Eu=Au,wu=`
        ${bu} sourceLocR = coords;
        ++${Cu[Au-1]};
        ${bu} sourceLocG = coords;
        ++${Cu[Au-2]};
        ${bu} sourceLocA = coords;
        --${Cu[Au-1]};
        ${bu} sourceLocB = coords;
        --${Cu[Au-2]};`;const Tu=["x","y","z","w","u","v"].slice(0,Eu),Ru="."+Tu[Eu-1],Nu=Tu.map(op=>"int "+op),Pu=Sy("sourceLocR",Eu-1).concat("inIdx.r"),Fu=Sy("sourceLocG",Eu-1).concat("inIdx.g"),Gu=Sy("sourceLocB",Eu-1).concat("inIdx.b"),Xu=Sy("sourceLocA",Eu-1).concat("inIdx.a"),Qu=lu==="max"?"greaterThan":"lessThan",Ju=cu?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${Pu.join()}),
                             getBestIndicesAChannel(${Fu.join()}),
                             getBestIndicesAChannel(${Gu.join()}),
                             getBestIndicesAChannel(${Xu.join()})));`,ip=`vec4(
            getAChannel(${Pu.join()}),
            hasNextCol ? getAChannel(${Fu.join()}) : 0.,
            hasNextRow ? getAChannel(${Gu.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${Xu.join()}) : 0.)`,rp=cu?"":`
      float getBestIndicesAChannel(${Nu.join()}) {
        return getChannel(getBestIndicesA(${Tu.join()}),
                                          vec2(${Tu.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${Nu.join()}) {
        return getChannel(getA(${Tu.join()}),
                               vec2(${Tu.slice(-2).join()}));
      }
      ${rp}
      void main() {
        ${bu} coords = getOutputCoords();
        bool hasNextCol = ${Cu[Au-1]} < ${mu[Au-1]-1};
        bool hasNextRow = ${Cu[Au-2]} < ${mu[Au-2]-1};
        ${wu}
        ivec4 srcIdx = ivec4(sourceLocR${Ru}, sourceLocG${Ru},
          sourceLocB${Ru}, sourceLocA${Ru}) * ${ru};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${ip};

        for (int i = 0; i < ${ru}; i++) {
          inIdx = srcIdx;
          ${Ju}
          vec4 candidate = ${ip};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${Qu}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eF(ou,nu,ru,lu=null){let cu=nu.shape[0],hu=nu.shape[1];lu!=null&&(cu=lu.shape[0],hu=lu.shape[1]);const pu=KE(hu),mu={windowSize:pu,inSize:hu,batchSize:cu,outSize:Math.ceil(hu/pu)},Au=new Oq(mu,ru,lu==null),bu=[nu];lu!=null&&bu.push(lu);const Cu=ou.runWebGLProgram(Au,bu,"int32");if(Cu.shape[1]===1)return Cu;const wu=eF(ou,nu,ru,Cu);return ou.disposeIntermediateTensorInfo(Cu),wu}function tF(ou,nu,ru,lu=null){const cu=lu!=null?lu.shape:nu.shape,hu=cu[cu.length-1],pu=KE(hu),mu=new Uq(cu,pu,ru,lu==null),Au=lu==null?[nu]:[nu,lu],bu=ou.runWebGLProgram(mu,Au,"int32");if(bu.shape.length===nu.shape.length){const Cu=tF(ou,nu,ru,bu);return ou.disposeIntermediateTensorInfo(bu),Cu}return bu}function nF(ou,nu,ru,lu){const cu=[ru];if(dy("arg"+lu.charAt(0).toUpperCase()+lu.slice(1),cu,nu.shape.length),!cp().getBool("WEBGL_PACK_REDUCE")||nu.shape.length<=2){const hu=[],pu=ou.texData.get(nu.dataId),mu=pu!==null&&pu.isPacked;let Au=nu;mu&&(Au=ou.unpackTensor(nu),hu.push(Au));const[bu,Cu]=oy(Au.shape,cu),wu=Mu(Cu),Eu=Cm({inputs:{x:Au},backend:ou,attrs:{shape:[-1,wu]}});hu.push(Eu);const Tu=eF(ou,Eu,lu);hu.push(Tu);const Ru=Cm({inputs:{x:Tu},backend:ou,attrs:{shape:bu}});return hu.forEach(Nu=>ou.disposeIntermediateTensorInfo(Nu)),Ru}return tF(ou,nu,lu)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $q(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu}=lu;let pu=Wu(hu,cu.shape);const mu=G0(pu,cu.shape.length);let Au=cu;const bu=[];mu!=null&&(Au=Iy({inputs:{x:cu},backend:ru,attrs:{perm:mu}}),bu.push(Au),pu=H0(pu.length,Au.shape.length)),dy("argMax",[pu[0]],Au.shape.length);const Cu=nF(ru,Au,pu[0],"max");return bu.forEach(wu=>ru.disposeIntermediateTensorInfo(wu)),Cu}const Vq={kernelName:qu,backendName:"webgl",kernelFunc:$q};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zq(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu}=lu;let pu=Wu(hu,cu.shape);const mu=G0(pu,cu.shape.length);let Au=cu;const bu=[];mu!=null&&(Au=Iy({inputs:{x:cu},backend:ru,attrs:{perm:mu}}),bu.push(Au),pu=H0(pu.length,Au.shape.length)),dy("argMin",[pu[0]],Au.shape.length);const Cu=nF(ru,Au,pu[0],"min");return bu.forEach(wu=>ru.disposeIntermediateTensorInfo(wu)),Cu}const Wq={kernelName:Uu,backendName:"webgl",kernelFunc:zq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hq=gx+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Xq=u0({opSnippet:Hq}),Qq={kernelName:zu,backendName:"webgl",kernelFunc:Xq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kq=gx+"return log(x + sqrt(x * x + 1.0));",Zq=u0({opSnippet:Kq}),jq={kernelName:ep,backendName:"webgl",kernelFunc:Zq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Yq=gx+`
  return atan(x);
`,qq=u0({opSnippet:Yq}),Jq={kernelName:up,backendName:"webgl",kernelFunc:qq};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eJ=qT+`
  return atan(a, b);
`,tJ=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+_1+`
  return result;
`,nJ=my({opSnippet:eJ,packedOpSnippet:tJ}),iJ={kernelName:Ip,backendName:"webgl",kernelFunc:nJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rJ=gx+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,sJ=u0({opSnippet:rJ}),oJ={kernelName:Mp,backendName:"webgl",kernelFunc:sJ};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class $w{constructor(nu,ru,lu,cu=!1,hu=!1){if(this.variableNames=["x"],ru==="avg"&&lu)throw new Error("Cannot compute positions for average pool.");const pu=nu.filterWidth,mu=nu.strideHeight,Au=nu.strideWidth,bu=nu.dilationHeight,Cu=nu.dilationWidth,wu=nu.effectiveFilterHeight,Eu=nu.effectiveFilterWidth,Tu=nu.padInfo.top,Ru=nu.padInfo.left;this.outputShape=nu.outShape;const Nu=ru==="avg",Pu=`((batch  * ${nu.inHeight} + xR) * ${nu.inWidth} + xC) * ${nu.inChannels} + d`,Fu=`(xR * ${nu.inWidth} + xC) * ${nu.inChannels} + d`;let Gu="0.0";if(Nu||(Gu="-1.0 / 1e-20"),lu){const op=">=";this.userCode=`
        const ivec2 strides = ivec2(${mu}, ${Au});
        const ivec2 pads = ivec2(${Tu}, ${Ru});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${wu};
              wR += ${bu}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${nu.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Eu};
                wC += ${Cu}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${nu.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${op} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${cu?hu?Pu:Fu:`wR * ${Eu} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const Xu="max";let Qu=`${ru}(${ru}(${ru}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;ru==="avg"&&(Qu="avgValue / max(count, 1.0)");const Ju=Math.floor(pu/4)*4,ip=pu%4,rp=`
      if (${Nu}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${Xu}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${mu}, ${Au});
      const ivec2 pads = ivec2(${Tu}, ${Ru});
      const float initializationValue = ${Gu};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${nu.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${Gu});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${wu};
            wR += ${bu}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${nu.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${Ju}; wC += 4) {
            int xC = xCCorner + wC * ${Cu};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${Cu}, d),
              getValue(batch, xR, xC + 2 * ${Cu}, d),
              getValue(batch, xR, xC + 3 * ${Cu}, d)
            );

            ${rp}
          }

          int xC = xCCorner + ${Ju};
          if (${ip===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${rp}
          } else if (${ip===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${Cu}, d),
              initializationValue,
              initializationValue
            );

            ${rp}
          } else if (${ip===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${Cu}, d),
              getValue(batch, xR, xC + 2 * ${Cu}, d),
              initializationValue
            );

            ${rp}
          }
        }
        setOutput(${Qu});
      }
    `}}class e_{constructor(nu,ru,lu,cu=!1,hu=!1){if(this.variableNames=["x"],ru==="avg"&&lu)throw new Error("Cannot compute positions for average pool.");const pu=nu.filterWidth,mu=nu.strideDepth,Au=nu.strideHeight,bu=nu.strideWidth,Cu=nu.dilationDepth,wu=nu.dilationHeight,Eu=nu.dilationWidth,Tu=nu.effectiveFilterDepth,Ru=nu.effectiveFilterHeight,Nu=nu.effectiveFilterWidth,Pu=nu.padInfo.front,Fu=nu.padInfo.top,Gu=nu.padInfo.left;this.outputShape=nu.outShape;const Xu=ru==="avg";let Qu="0.0";if(Xu||(Qu="-1.0 / 1e-20"),lu){const Ap=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${mu}, ${Au}, ${bu});
        const ivec3 pads = ivec3(${Pu}, ${Fu}, ${Gu});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${Tu};
              wD += ${Cu}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${nu.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${Ru};
                wR += ${wu}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${nu.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${Nu};
                  wC += ${Eu}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${nu.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${Ap} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${cu?hu?`(((batch * ${nu.inDepth} + xD) * ${nu.inHeight} + xR) * ${nu.inWidth} + xC) * ${nu.inChannels} + ch`:`((xD * ${nu.inHeight} + xR) * ${nu.inWidth} + xC) * ${nu.inChannels} + ch`:`wD * ${Ru} * ${Nu} +
                      wR * ${Nu} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const Ju="max";let ip=`${ru}(${ru}(${ru}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;ru==="avg"&&(ip="avgValue / max(count, 1.0)");const rp=Math.floor(pu/4)*4,op=pu%4,hp=`
      if (${Xu}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${Ju}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${mu}, ${Au}, ${bu});
      const ivec3 pads = ivec3(${Pu}, ${Fu}, ${Gu});
      const float initializationValue = ${Qu};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${nu.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${Qu});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${Tu};
            wD += ${Cu}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${nu.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${Ru};
            wR += ${wu}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${nu.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${rp}; wC += 4) {
              int xC = xCCorner + wC * ${Eu};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Eu}, ch),
                getValue(batch, xD, xR, xC + 2 * ${Eu}, ch),
                getValue(batch, xD, xR, xC + 3 * ${Eu}, ch)
              );

              ${hp}
            }

            int xC = xCCorner + ${rp};
            if (${op===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${hp}
            } else if (${op===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Eu}, ch),
                initializationValue,
                initializationValue
              );

              ${hp}
            } else if (${op===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Eu}, ch),
                getValue(batch, xD, xR, xC + 2 * ${Eu}, ch),
                initializationValue
              );

              ${hp}
            }
          }
        }
        setOutput(${ip});
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aJ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu;Gw(cu,"avgPool");const{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au}=lu,bu=1;vu(gy(pu,bu),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${pu} and dilations '${bu}'`);const Cu=ox(cu.shape,hu,pu,bu,mu,Au);if(Cu.filterWidth===1&&Cu.filterHeight===1&&ku(Cu.inShape,Cu.outShape))return Wy({inputs:{x:cu},backend:ru});const wu=new $w(Cu,"avg",!1);return ru.runWebGLProgram(wu,[cu],"float32")}const lJ={kernelName:fm,backendName:"webgl",kernelFunc:aJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cJ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au,dataFormat:bu}=lu,Cu=[1,1,1],wu=tv(cu.shape,hu,pu,Cu,mu,Au,bu),Eu=new e_(wu,"avg",!1);return ru.runWebGLProgram(Eu,[cu],"float32")}const uJ={kernelName:pp,backendName:"webgl",kernelFunc:cJ};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hJ{constructor(nu){this.variableNames=["dy"],this.outputShape=nu.inShape;const ru=nu.filterHeight,lu=nu.filterWidth,cu=nu.strideHeight,hu=nu.strideWidth,pu=nu.dilationHeight,mu=nu.dilationWidth,Au=nu.effectiveFilterHeight,bu=nu.effectiveFilterWidth,Cu=Au-1-nu.padInfo.top,wu=bu-1-nu.padInfo.left,Eu=1/(ru*lu);this.userCode=`
      const ivec2 pads = ivec2(${Cu}, ${wu});
      const float avgMultiplier = float(${Eu});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${Au};
            wR += ${pu}) {
          float dyR = float(dyRCorner + wR) / ${cu}.0;

          if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${bu};
            wC+= ${mu}) {
            float dyC = float(dyCCorner + wC) / ${hu}.0;

            if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class dJ{constructor(nu){this.variableNames=["dy"],this.outputShape=nu.inShape;const ru=nu.filterDepth,lu=nu.filterHeight,cu=nu.filterWidth,hu=nu.strideDepth,pu=nu.strideHeight,mu=nu.strideWidth,Au=nu.dilationDepth,bu=nu.dilationHeight,Cu=nu.dilationWidth,wu=nu.effectiveFilterDepth,Eu=nu.effectiveFilterHeight,Tu=nu.effectiveFilterWidth,Ru=wu-1-nu.padInfo.front,Nu=Eu-1-nu.padInfo.top,Pu=Tu-1-nu.padInfo.left,Fu=1/(ru*lu*cu);this.userCode=`
      const ivec3 pads = ivec3(${Ru}, ${Nu}, ${Pu});
      const float avgMultiplier = float(${Fu});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${wu};
            wD += ${Au}) {
          float dyD = float(dyDCorner + wD) / ${hu}.0;

          if (dyD < 0.0 || dyD >= ${nu.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${Eu};
              wR += ${bu}) {
            float dyR = float(dyRCorner + wR) / ${pu}.0;

            if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${Tu};
                wC += ${Cu}) {
              float dyC = float(dyCCorner + wC) / ${mu}.0;

              if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pJ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu}=nu,pu=hu,{filterSize:mu,strides:Au,pad:bu,dimRoundingMode:Cu}=lu,wu=[1,1,1],Eu=tv(pu.shape,mu,Au,wu,bu,Cu),Tu=new dJ(Eu);return ru.runWebGLProgram(Tu,[cu],pu.dtype)}const fJ={kernelName:Zp,backendName:"webgl",kernelFunc:pJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mJ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu}=nu,pu=hu;Gw([cu,hu],"avgPoolGrad");const{filterSize:mu,strides:Au,pad:bu}=lu,Cu=ox(pu.shape,mu,Au,1,bu),wu=new hJ(Cu);return ru.runWebGLProgram(wu,[cu],pu.dtype)}const gJ={kernelName:Gm,backendName:"webgl",kernelFunc:mJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AJ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{a:cu,b:hu}=nu,{transposeA:pu,transposeB:mu}=lu;return G2({a:cu,b:hu,transposeA:pu,transposeB:mu,backend:ru})}const yJ={kernelName:om,backendName:"webgl",kernelFunc:AJ};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class bJ{constructor(nu,ru,lu,cu,hu,pu){this.outputShape=[],this.variableNames=["x","mean","variance"],_g(nu,ru),_g(nu,lu);let mu="0.0";cu!=null&&(_g(nu,cu),this.variableNames.push("offset"),mu="getOffsetAtOutCoords()");let Au="1.0";hu!=null&&(_g(nu,hu),this.variableNames.push("scale"),Au="getScaleAtOutCoords()"),this.outputShape=nu,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${mu};
        float scale = ${Au};
        float inv = scale * inversesqrt(variance + float(${pu}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class xJ{constructor(nu,ru,lu,cu,hu,pu){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],_g(nu,ru),_g(nu,lu);let mu="vec4(0.0)";cu!=null&&(_g(nu,cu),this.variableNames.push("offset"),mu="getOffsetAtOutCoords()");let Au="vec4(1.0)";hu!=null&&(_g(nu,hu),this.variableNames.push("scale"),Au="getScaleAtOutCoords()"),this.outputShape=nu,this.userCode=`
      void main() {
        vec4 offset = ${mu};
        vec4 scale = ${Au};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${pu}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vJ={kernelName:Um,backendName:"webgl",kernelFunc:({inputs:ou,backend:nu,attrs:ru})=>{const{x:lu,mean:cu,variance:hu,offset:pu,scale:mu}=ou;vu(cu.shape.length===hu.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),vu(pu==null||cu.shape.length===pu.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),vu(mu==null||cu.shape.length===mu.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:Au}=ru;Au==null&&(Au=.001);const bu=[lu,cu,hu];let Cu=null;pu!=null&&(Cu=pu.shape,bu.push(pu));let wu=null;mu!=null&&(wu=mu.shape,bu.push(mu));const Eu=cp().getBool("WEBGL_PACK_NORMALIZATION")?new xJ(lu.shape,cu.shape,hu.shape,Cu,wu,Au):new bJ(lu.shape,cu.shape,hu.shape,Cu,wu,Au);return nu.runWebGLProgram(Eu,bu,bu[0].dtype)}};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class CJ{constructor(nu){this.variableNames=["source"],this.outputShape=nu,this.rank=nu.length;const ru=x0(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const lu=wJ(this.rank);let cu;const hu=nu.map((pu,mu)=>`sourceLoc.${t_[mu]} = start[${mu}] + coords.${t_[mu]};`);cu=`
        ${ru} sourceLoc;
        ${ru} coords = getOutputCoords();
        ${hu.join(`
`)}
      `,this.userCode=`
      void main() {
        ${cu}
        setOutput(getSource(${lu}));
      }
    `}}const t_=["x","y","z","w","u","v"];function wJ(ou){if(ou===1)return"sourceLoc";if(ou<=6)return t_.slice(0,ou).map(nu=>"sourceLoc."+nu).join(",");throw Error(`Slicing for rank ${ou} is not yet supported`)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class EJ{constructor(nu){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nu,this.rank=nu.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const ru=x0(this.rank),lu=Sy("coords",this.rank),cu=Sy("sourceLoc",this.rank),hu=this.rank===1?"sourceLoc":`vec2(${cu.slice(-2).join()})`,pu=`getChannel(getSource(${cu.join()}), ${hu})`,mu=`
      result.x = ${pu};
      if (++${lu[this.rank-1]} < ${nu[this.rank-1]}) {
        ++${cu[this.rank-1]};
        result.y = ${pu};
        --${cu[this.rank-1]};
      }
    `,Au=this.rank===1?"":`
      --${lu[this.rank-1]};
      if (++${lu[this.rank-2]} < ${nu[this.rank-2]}) {
        ++${cu[this.rank-2]};
        result.z = ${pu};
        if (++${lu[this.rank-1]} < ${nu[this.rank-1]}) {
          ++${cu[this.rank-1]};
          result.w = ${pu};
        }
      }
    `,bu=this.rank<=4?`sourceLoc = coords +
            ${ru}(${nu.map((Cu,wu)=>`start[${wu}]`).join()});`:nu.map((Cu,wu)=>`${cu[wu]} = ${lu[wu]} + start[${wu}];`).join(`
`);this.userCode=`
      void main() {
        ${ru} coords = getOutputCoords();
        ${ru} sourceLoc;
        ${bu}
        vec4 result = vec4(0.);
        ${mu}
        ${Au}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SJ(ou,nu,ru,lu){const cu=lu.texData.get(ou.dataId),hu=lu.makeTensorInfo(ru,ou.dtype),pu=lu.texData.get(hu.dataId);Object.assign(pu,cu),pu.refCount=1,pu.shape=ru,pu.dtype=ou.dtype;let mu=CI(nu,xp(ou.shape));cu.slice&&(mu+=cu.slice.flatOffset),pu.slice={flatOffset:mu,origDataId:cu.slice&&cu.slice.origDataId||ou.dataId};const Au=lu.dataRefCount.get(pu.slice.origDataId)||1;return lu.dataRefCount.set(pu.slice.origDataId,Au+1),hu}function yC(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{begin:hu,size:pu}=lu,[mu,Au]=XE(cu,hu,pu);if(bI(cu,mu,Au),Mu(Au)===0)return ru.makeTensorInfo(Au,cu.dtype,[]);if(ru.shouldExecuteOnCPU([cu])||cu.dtype==="string"){const wu=ru.texData.get(cu.dataId),Eu=yY(wu.values,mu,Au,cu.shape,cu.dtype);return ru.makeTensorInfo(Au,cu.dtype,Eu)}const{isPacked:bu}=ru.texData.get(cu.dataId),Cu=vI(cu.shape,mu,Au);if(bu||!Cu){const wu=cp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EJ(Au):new CJ(Au),Eu=[mu];return ru.runWebGLProgram(wu,[cu],cu.dtype,Eu)}return ru.uploadToGPU(cu.dataId),SJ(cu,mu,Au,ru)}const IJ={kernelName:xE,backendName:"webgl",kernelFunc:yC};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TJ={kernelName:Mm,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{blockShape:hu,crops:pu}=lu;vu(cu.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const mu=hu.reduce((Gu,Xu)=>Gu*Xu),Au=fw(cu.shape,hu,mu),bu=mw(Au.length,hu.length),Cu=gw(cu.shape,hu,mu),wu=TI(pu,hu.length),Eu=_I(Cu,pu,hu.length),Tu=[],Ru=Cm({inputs:{x:cu},backend:ru,attrs:{shape:Au}}),Nu=Iy({inputs:{x:Ru},backend:ru,attrs:{perm:bu}}),Pu=Cm({inputs:{x:Nu},backend:ru,attrs:{shape:Cu}}),Fu=yC({inputs:{x:Pu},backend:ru,attrs:{begin:wu,size:Eu}});return Tu.push(Ru),Tu.push(Nu),Tu.push(Pu),Tu.forEach(Gu=>ru.disposeIntermediateTensorInfo(Gu)),Fu}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _J(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,weights:hu}=nu,{size:pu}=lu,mu=ru.readSync(cu.dataId),Au=ru.readSync(hu.dataId),bu=LD(mu,Au,hu.dtype,hu.shape,pu);return ru.makeTensorInfo([pu],hu.dtype,bu)}const MJ={kernelName:Tm,backendName:"webgl",kernelFunc:_J};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RJ=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,kJ=`
  return float(int(a.r) & int(b.r));
`;function BJ(ou){const{inputs:nu,backend:ru}=ou,{a:lu,b:cu}=nu,hu=cp().getBool("WEBGL_PACK_BINARY_OPERATIONS"),pu=cp().getNumber("WEBGL_VERSION");if(ru.shouldExecuteOnCPU([lu,cu])||pu===1){const Au=ru.texData.get(lu.dataId).values,bu=ru.texData.get(cu.dataId).values,[Cu,wu]=V7(lu.shape,cu.shape,Au,bu,lu.dtype),Eu=ru.makeTensorInfo(wu,lu.dtype),Tu=ru.texData.get(Eu.dataId);return Tu.values=Cu,Eu}let mu;return hu?mu=new gC(RJ,lu.shape,cu.shape,!1):mu=new T1(kJ,lu.shape,cu.shape),ru.runWebGLProgram(mu,[lu,cu],lu.dtype)}const LJ={kernelName:Lm,backendName:"webgl",kernelFunc:BJ};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NJ(ou){const{inputs:nu,backend:ru}=ou,{s0:lu,s1:cu}=nu,hu=ru.readSync(lu.dataId),pu=ru.readSync(cu.dataId),mu=_g(Array.from(hu),Array.from(pu));return ru.makeTensorInfo([mu.length],"int32",Int32Array.from(mu))}const DJ={kernelName:Rm,backendName:"webgl",kernelFunc:NJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iF=my({opSnippet:"return float(a != b);",cpuKernelImpl:cY,dtype:"bool"}),FJ={kernelName:lE,backendName:"webgl",kernelFunc:iF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vw(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu,cu=ru.texData.get(lu.dataId);return Wy({inputs:{x:cu.complexTensorInfos.real},backend:ru})}const PJ={kernelName:oS,backendName:"webgl",kernelFunc:Vw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const GJ="return float(int(x));";function OJ(ou,nu){const ru=new Zx(ou.shape,GJ),lu=nu.runWebGLProgram(ru,[ou],"int32");return{dataId:lu.dataId,shape:lu.shape,dtype:lu.dtype}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n_(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{dtype:hu}=lu;if(hu==="complex64"){if(cu.dtype==="complex64")return Wy({inputs:{x:cu},backend:ru});const pu=ay(cu.shape),mu=n_({inputs:{x:cu},backend:ru,attrs:{dtype:"float32"}}),Au=Uv({inputs:{real:mu,imag:pu},backend:ru});return pu.dispose(),ru.disposeIntermediateTensorInfo(mu),Au}if(cu.dtype==="complex64"){const pu=Vw({inputs:{input:cu},backend:ru}),mu=n_({inputs:{x:pu},backend:ru,attrs:{dtype:hu}});return ru.disposeIntermediateTensorInfo(pu),mu}if(!tp(cu.dtype,hu)){const pu=Wy({inputs:{x:cu},backend:ru});return{dataId:pu.dataId,shape:pu.shape,dtype:hu}}if(ru.shouldExecuteOnCPU([cu])){const pu=ru.texData.get(cu.dataId).values,[mu,Au,bu]=z7(pu,cu.shape,cu.dtype,hu);return ru.makeTensorInfo(mu,Au,bu)}if(hu==="int32")return OJ(cu,ru);if(hu==="bool"){const pu=ru.makeTensorInfo([],"bool",Hu("bool",1)),mu=iF({inputs:{a:cu,b:pu},backend:ru});return ru.disposeIntermediateTensorInfo(pu),mu}throw new Error(`Error in Cast: failed to cast ${cu.dtype} to ${hu}`)}const UJ={kernelName:Sm,backendName:"webgl",kernelFunc:n_};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rF="return ceil(x);",$J=u0({opSnippet:rF,packedOpSnippet:rF,cpuKernelImpl:W7}),VJ={kernelName:Fm,backendName:"webgl",kernelFunc:$J};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class zJ{constructor(nu){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=nu,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class WJ{constructor(nu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=nu,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HJ(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{clipValueMin:hu,clipValueMax:pu}=lu;let mu;cp().getBool("WEBGL_PACK_CLIP")?mu=new WJ(cu.shape):mu=new zJ(cu.shape);const Au=[[hu],[pu]];return ru.runWebGLProgram(mu,[cu],cu.dtype,Au)}const XJ={kernelName:i0,backendName:"webgl",kernelFunc:HJ};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class QJ{constructor(nu){this.variableNames=["real","imag"],this.outputShape=nu,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sF(ou,nu){return{dataId:nu.dataId,dtype:nu.dtype,shape:ou.shape}}function KJ(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu,cu=ru.texData.get(lu.dataId),hu=new QJ(lu.shape),pu=[sF(lu,cu.complexTensorInfos.real),sF(lu,cu.complexTensorInfos.imag)];return ru.runWebGLProgram(hu,pu,pu[0].dtype)}const ZJ={kernelName:pv,backendName:"webgl",kernelFunc:KJ};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jJ{constructor(nu){this.outputShape=[],this.outputShape=$x(nu,1),this.variableNames=nu.map((pu,mu)=>`T${mu}`);const ru=new Array(nu.length-1);ru[0]=nu[0][1];for(let pu=1;pu<ru.length;pu++)ru[pu]=ru[pu-1]+nu[pu][1];const lu=[`if (yC < ${ru[0]}) setOutput(getT0(yR, yC));`];for(let pu=1;pu<ru.length;pu++){const mu=ru[pu-1];lu.push(`else if (yC < ${ru[pu]}) setOutput(getT${pu}(yR, yC-${mu}));`)}const cu=ru.length,hu=ru[ru.length-1];lu.push(`else setOutput(getT${cu}(yR, yC-${hu}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${lu.join(`
        `)}
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class YJ{constructor(nu,ru){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=$x(nu,ru);const lu=this.outputShape,cu=lu.length,hu=x0(cu),pu=Sy("coords",cu),mu=["x","y","z","w","u","v"].slice(0,cu);this.variableNames=nu.map((Nu,Pu)=>`T${Pu}`);const Au=new Array(nu.length-1);Au[0]=nu[0][ru];for(let Nu=1;Nu<Au.length;Nu++)Au[Nu]=Au[Nu-1]+nu[Nu][ru];const bu=mu[ru],Cu=mu.slice(-2),wu=mu.join();let Eu=`if (${bu} < ${Au[0]}) {
        return getChannel(
            getT0(${wu}), vec2(${Cu.join()}));
        }`;for(let Nu=1;Nu<Au.length;Nu++){const Pu=Au[Nu-1];Eu+=`
        if (${bu} < ${Au[Nu]}  && ${bu} >= ${Au[Nu-1]}) {
          return getChannel(
            getT${Nu}(${U2(mu,bu,Pu)}),
            vec2(${U2(Cu,bu,Pu)}));
        }`}const Tu=Au.length,Ru=Au[Au.length-1];Eu+=`
        return getChannel(
          getT${Tu}(${U2(mu,bu,Ru)}),
          vec2(${U2(Cu,bu,Ru)}));`,this.userCode=`
      float getValue(${mu.map(Nu=>"int "+Nu)}) {
        ${Eu}
      }

      void main() {
        ${hu} coords = getOutputCoords();
        vec4 result = vec4(getValue(${pu}), 0., 0., 0.);

        ${pu[cu-1]} = ${pu[cu-1]} + 1;
        if (${pu[cu-1]} < ${lu[cu-1]}) {
          result.g = getValue(${pu});
        }

        ${pu[cu-2]} = ${pu[cu-2]} + 1;
        if (${pu[cu-2]} < ${lu[cu-2]}) {
          result.a = getValue(${pu});
        }

        ${pu[cu-1]} = ${pu[cu-1]} - 1;
        if (${pu[cu-2]} < ${lu[cu-2]} &&
            ${pu[cu-1]} < ${lu[cu-1]}) {
          result.b = getValue(${pu});
        }
        setOutput(result);
      }
    `}}function U2(ou,nu,ru){const lu=ou.indexOf(nu);return ou.map((cu,hu)=>hu===lu?`${cu} - ${ru}`:cu).join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $2(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu,cu=ru.texData.get(lu.dataId);return Wy({inputs:{x:cu.complexTensorInfos.imag},backend:ru})}const qJ={kernelName:m0,backendName:"webgl",kernelFunc:$2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zw(ou,nu,ru){const lu=ou[0].dtype;if(lu==="complex64"){const Tu=ou.map(Gu=>Vw({inputs:{input:Gu},backend:ru})),Ru=ou.map(Gu=>$2({inputs:{input:Gu},backend:ru})),Nu=zw(Tu,nu,ru),Pu=zw(Ru,nu,ru),Fu=Uv({inputs:{real:Nu,imag:Pu},backend:ru});return Tu.forEach(Gu=>ru.disposeIntermediateTensorInfo(Gu)),Ru.forEach(Gu=>ru.disposeIntermediateTensorInfo(Gu)),ru.disposeIntermediateTensorInfo(Nu),ru.disposeIntermediateTensorInfo(Pu),Fu}let cu=ru.shouldExecuteOnCPU(ou);if(lu==="string"&&(cu=!0),cu){const Tu=ou.map(Qu=>{const Ju=[-1,Mu(Qu.shape.slice(nu))];return Cm({inputs:{x:Qu},backend:ru,attrs:{shape:Ju}})}),Ru=Tu.map(Qu=>({vals:ru.readSync(Qu.dataId),shape:Qu.shape})),Nu=$x(Tu.map(Qu=>Qu.shape),1),Pu=Tu[0].shape[0]===1,Fu=H7(Ru,Nu,lu,Pu),Gu=$x(ou.map(Qu=>Qu.shape),nu),Xu=ru.makeTensorInfo(Gu,lu,Fu);return Tu.forEach(Qu=>ru.disposeIntermediateTensorInfo(Qu)),Xu}const hu=ou.filter(Tu=>Mu(Tu.shape)>0),pu=cp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&hu[0].shape.length>1;if(hu.length===1){const Tu=pu?new Zx(ou[0].shape,Gv):new Ov(ou[0].shape,Gv);return ru.runWebGLProgram(Tu,ou,lu)}const mu=cp().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(hu.length>mu){const Tu=[];for(let Nu=0;Nu<hu.length;Nu+=mu){const Pu=hu.slice(Nu,Nu+mu);Tu.push(zw(Pu,nu,ru))}const Ru=zw(Tu,nu,ru);for(const Nu of Tu)ru.disposeIntermediateTensorInfo(Nu);return Ru}if(pu){const Tu=new YJ(hu.map(Ru=>Ru.shape),nu);return ru.runWebGLProgram(Tu,hu,lu)}const{tensors2D:Au,outShape:bu}=JJ(hu,nu,ru),Cu=new jJ(Au.map(Tu=>Tu.shape)),wu=ru.runWebGLProgram(Cu,Au,lu);Au.forEach(Tu=>ru.disposeIntermediateTensorInfo(Tu));const Eu=Cm({inputs:{x:wu},attrs:{shape:bu},backend:ru});return ru.disposeIntermediateTensorInfo(wu),Eu}function JJ(ou,nu,ru){const lu=$x(ou.map(cu=>cu.shape),nu);return{tensors2D:ou.map(cu=>Cm({inputs:{x:cu},attrs:{shape:[-1,Mu(cu.shape.slice(nu))]},backend:ru})),outShape:lu}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oF(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{axis:cu}=lu,hu=Wu(cu,nu[0].shape)[0],pu=nu.map(bu=>bu.shape);EI(pu,hu);const mu=$x(nu.map(bu=>bu.shape),hu);if(Mu(mu)===0)return ru.makeTensorInfo(mu,nu[0].dtype,[]);const Au=nu.filter(bu=>Mu(bu.shape)>0);return Au.length===1?Wy({inputs:{x:Au[0]},backend:ru}):zw(Au,hu,ru)}const eee={kernelName:L1,backendName:"webgl",kernelFunc:oF};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class aF{constructor(nu,ru=!1,lu=null,cu=!1,hu=!1){this.variableNames=["x","W"],this.outputShape=nu.outShape;const pu=nu.padInfo.top,mu=nu.padInfo.left,Au=nu.strideHeight,bu=nu.strideWidth,Cu=nu.dilationHeight,wu=nu.dilationWidth,Eu=nu.filterHeight,Tu=nu.filterWidth,Ru=Math.floor(nu.inChannels/4)*4,Nu=nu.inChannels%4,Pu=nu.dataFormat==="channelsLast",Fu=Pu?1:2,Gu=Pu?2:3,Xu=Pu?3:1;let Qu="",Ju="";lu&&(cu?Qu=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${lu}
        }`:hu?Qu=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${lu}
        }`:Qu=`
          float activation(float x) {
            ${lu}
          }
        `,Ju="result = activation(result);");const ip=ru?"result += getBiasAtOutCoords();":"";ru&&this.variableNames.push("bias"),cu&&this.variableNames.push("preluActivationWeights"),hu&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${Qu}

      const ivec2 strides = ivec2(${Au}, ${bu});
      const ivec2 pads = ivec2(${pu}, ${mu});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${Xu}];

        ivec2 xRCCorner =
            ivec2(coords[${Fu}], coords[${Gu}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${Eu}; wR++) {
          int xR = xRCorner + wR * ${Cu};

          if (xR < 0 || xR >= ${nu.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${Tu}; wC++) {
            int xC = xCCorner + wC * ${wu};

            if (xC < 0 || xC >= ${nu.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${Ru}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${Pu}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${Nu===1}) {

              if (${Pu}) {
                dotProd +=
                    getX(batch, xR, xC, ${Ru}) *
                    getW(wR, wC, ${Ru}, d2);
              } else {
                dotProd +=
                    getX(batch, ${Ru}, xR, xC) *
                    getW(wR, wC, ${Ru}, d2);
              }

            } else if (${Nu===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${Ru}, d2),
                getW(wR, wC, ${Ru} + 1, d2)
              );

              if (${Pu}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${Ru}),
                  getX(batch, xR, xC, ${Ru} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${Ru}, xR, xC),
                  getX(batch, ${Ru} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${Nu===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${Ru}, d2),
                getW(wR, wC, ${Ru} + 1, d2),
                getW(wR, wC, ${Ru} + 2, d2)
              );

              if (${Pu}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${Ru}),
                  getX(batch, xR, xC, ${Ru} + 1),
                  getX(batch, xR, xC, ${Ru} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${Ru}, xR, xC),
                  getX(batch, ${Ru} + 1, xR, xC),
                  getX(batch, ${Ru} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${ip}
        ${Ju}
        setOutput(result);
      }
    `}}class tee{constructor(nu){this.variableNames=["x","W"],this.outputShape=nu.outShape;const ru=nu.padInfo.front,lu=nu.padInfo.top,cu=nu.padInfo.left,hu=nu.strideDepth,pu=nu.strideHeight,mu=nu.strideWidth,Au=nu.dilationDepth,bu=nu.dilationHeight,Cu=nu.dilationWidth,wu=nu.filterDepth,Eu=nu.filterHeight,Tu=nu.filterWidth,Ru=Math.floor(nu.inChannels/4)*4,Nu=nu.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${hu}, ${pu}, ${mu});
      const ivec3 pads = ivec3(${ru}, ${lu}, ${cu});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${wu}; wF++) {
          int xF = xFCorner + wF * ${Au};

          if (xF < 0 || xF >= ${nu.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${Eu}; wR++) {
            int xR = xRCorner + wR * ${bu};

            if (xR < 0 || xR >= ${nu.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Tu}; wC++) {
              int xC = xCCorner + wC * ${Cu};

              if (xC < 0 || xC >= ${nu.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${Ru}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${Nu===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${Ru}) *
                  getW(wF, wR, wC, ${Ru}, d2);
              } else if (${Nu===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${Ru}),
                  getX(batch, xF, xR, xC, ${Ru} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${Ru}, d2),
                  getW(wF, wR, wC, ${Ru} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${Nu===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${Ru}),
                  getX(batch, xF, xR, xC, ${Ru} + 1),
                  getX(batch, xF, xR, xC, ${Ru} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${Ru}, d2),
                  getW(wF, wR, wC, ${Ru} + 1, d2),
                  getW(wF, wR, wC, ${Ru} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lF{constructor(nu,ru=!1,lu=null,cu=!1,hu=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=nu.outShape,this.enableShapeUniforms=Ay(this.outputShape.length);const pu=nu.padInfo.left,mu=nu.strideWidth,Au=nu.dilationWidth,bu=nu.filterHeight,Cu=nu.filterWidth,wu=Cu;let Eu=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let Pu=0;Pu<Cu;Pu++)Eu+=`
           vec4 xTexelC${Pu*2};
           int xTexelC${Pu*2}Ready;
           vec4 xTexelC${Pu*2+1};
           int xTexelC${Pu*2+1}Ready;
           vec4 xC${Pu};`;Eu+=`
     for (int r = 0; r < ${bu}; r++) {
      for (int d1 = 0; d1 < ${nu.inChannels}; d1 += 2) {
       `;for(let Pu=0;Pu<Cu;Pu++)Eu+=`
           xTexelC${Pu*2} = vec4(0.0);
           xTexelC${Pu*2}Ready = 0;
           xTexelC${Pu*2+1} = vec4(0.0);
           xTexelC${Pu*2+1}Ready = 0;
           xC${Pu} = vec4(0.0);`;Eu+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let Pu=0;Pu<(wu+1)/2;Pu++){const Fu=Pu*2;if(Eu+=`
           xC = xCCorner + ${Fu*Au};
           `,mu===1){if(Fu<Cu&&(pu%2===1?(Eu+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Fu}Ready == 0) {
                   xTexelC${Fu} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${Fu}.zw = vec2(0.0);
                   }
                   xTexelC${Fu}Ready = 1;
                 }
               `,Au===1&&Fu>0?Eu+=`
                 xC${Fu} = vec4(xTexelC${Fu-2}.zw, xTexelC${Fu}.xy);
                 `:Eu+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${Fu} = vec4(previous.zw, xTexelC${Fu}.xy);
                   } else {
                     xC${Fu} = vec4(0.0, 0.0, xTexelC${Fu}.xy);
                   }
                   `):Eu+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${Fu}Ready == 0) {
                   xTexelC${Fu} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${Fu}.zw = vec2(0.0);
                   }
                   xTexelC${Fu}Ready = 1;
                 }

                 xC${Fu} = xTexelC${Fu};
                 `,Fu+1<Cu)){const Gu=pu%2===0?gu(Au):Au;Au%2===0&&pu%2===1||Au%2!==0&&pu%2!==1?(Eu+=`
                   xCOffset = xC + imod(pads[1], 2) + ${Gu};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Fu+1}Ready == 0) {
                     xTexelC${Fu+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${Fu+1}.zw = vec2(0.0);
                     }
                     xTexelC${Fu+1}Ready = 1;
                   }
                   `,Au>1?Eu+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${Fu+1} = vec4(previous.zw, xTexelC${Fu+1}.xy);
                     } else {
                      xC${Fu+1} = vec4(0.0, 0.0, xTexelC${Fu+1}.xy);
                     }
                     `:Eu+=`
                     xC${Fu+1} = vec4(xTexelC${Fu}.zw, xTexelC${Fu+1}.xy);
                     `):Gu===1?Eu+=`
                     xC${Fu+1} = xTexelC${Fu};
                     `:Eu+=`
                     xCOffset = xC + ${Gu};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Fu+1}Ready == 0) {
                       xTexelC${Fu+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${Fu+1}.zw = vec2(0.0);
                       }
                       xTexelC${Fu+1}Ready = 1;
                     }

                     xC${Fu+1} = xTexelC${Fu+1};
                     `}}else Fu<Cu&&(pu%2===1?(Eu+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Fu}Ready == 0) {
                   xTexelC${Fu} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${Fu}.zw = vec2(0.0);
                   }
                   xTexelC${Fu}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Fu+1}Ready == 0) {
                   xTexelC${Fu+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${Fu+1}.zw = vec2(0.0);
                   }
                   xTexelC${Fu+1}Ready = 1;
                 }

                 xC${Fu} = vec4(xTexelC${Fu}.zw, xTexelC${Fu+1}.zw);
               `,Fu+1<Cu&&(Eu+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${Fu+1} = vec4(xTexelC${Fu+1}.xy, final.xy);
                 `)):(Eu+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${Fu}Ready == 0) {
                   xTexelC${Fu} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${Fu}.zw = vec2(0.0);
                   }
                   xTexelC${Fu}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Fu+1}Ready == 0) {
                   xTexelC${Fu+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${Fu+1}.zw = vec2(0.);
                   }
                   xTexelC${Fu+1}Ready = 1;
                 }

                 xC${Fu} = vec4(
                   xTexelC${Fu}.xy, xTexelC${Fu+1}.xy);
               `,Fu+1<Cu&&(Eu+=`
                   xC${Fu+1} = vec4(xTexelC${Fu}.zw, xTexelC${Fu+1}.zw);
                 `)));Fu<Cu&&(Eu+=`
             wTexel = getW(r, ${Fu}, d1, d2);
             dotProd += xC${Fu}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${nu.inChannels}) {
               dotProd += xC${Fu}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,Fu+1<Cu&&(Eu+=`
               wTexel = getW(r, ${Fu+1}, d1, d2);
               dotProd += xC${Fu+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${nu.inChannels}) {
                 dotProd += xC${Fu+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}Eu+=`
     }
   `,Eu+=`
     }
   `,Eu+=`
     }
   `;let Tu="",Ru="";lu&&(cu?Tu=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${lu}
         }`:hu?Tu=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${lu}
         }`:Tu=`vec4 activation(vec4 x) {
           ${lu}
         }`,Ru="result = activation(result);");const Nu=ru?"result += getBiasAtOutCoords();":"";ru&&this.variableNames.push("bias"),cu&&this.variableNames.push("preluActivationWeights"),hu&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${Tu}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${Eu}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${Nu}
         ${Ru}
         setOutput(result);
       }
     `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class nee{constructor(nu,ru){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=nu,this.enableShapeUniforms=Ay(this.outputShape.length);const{dataFormat:lu}=ru,cu=Ey(),hu=lu==="channelsLast",pu=hu?1:2,mu=hu?2:3,Au=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${nu[2]} && pos < ${nu[1]}) {`;let bu="";for(let Cu=0;Cu<=1;Cu++)for(let wu=0;wu<=1;wu++)bu+=`
          blockIndex = rc.z + ${wu};
          pos = rc.y + ${Cu};

          ${Au}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${pu}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${mu}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${hu}) {
                  innerDims = vec2(d1, ch);
                  result[${Cu*2+wu}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${Cu*2+wu}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${bu}

        ${cu.output} = result;
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function V2(ou,nu){const ru=ou.length;return ru>=3?nu?[...ou.slice(0,-3),ou[ru-3]*ou[ru-2],ou[ru-1]]:[...ou.slice(0,-3),ou[ru-3],ou[ru-2]*ou[ru-1]]:!nu&&ru===1&&ou[0]>1?[ou[0],1]:null}function cF({x:ou,filter:nu,convInfo:ru,backend:lu,bias:cu=null,preluActivationWeights:hu=null,leakyreluAlpha:pu=0,activation:mu=null}){const Au=ou.shape,bu=lu.texData.get(ou.dataId),Cu=ru.inChannels,wu=Au[0]*Au[1]*Au[2],Eu=ru.outChannels,Tu=ru.dataFormat==="channelsLast",Ru=!1,Nu=!1;let Pu;const Fu=[];if(hu!=null){const Gu=V2(hu.shape,Tu);Gu!=null&&(hu=Cm({inputs:{x:hu},backend:lu,attrs:{shape:Gu}}),Fu.push(hu))}if(cu!=null){const Gu=V2(cu.shape,Tu);Gu!=null&&(cu=Cm({inputs:{x:cu},backend:lu,attrs:{shape:Gu}}),Fu.push(cu))}if(!((wu===1||Eu===1)&&Cu>YD)&&bu.isPacked&&Tu&&bu.texture!=null&&Au[2]%2!==0&&ku(bu.shape.slice(-3),Au.slice(-3))){const Gu=Au[0]*Au[1]*(Au[2]+1),Xu={dataId:ou.dataId,shape:[1,Gu,ru.inChannels],dtype:ou.dtype},Qu=bu.shape;bu.shape=bu.shape.slice(),bu.shape[bu.shape.length-2]++,vu(L2(bu.shape,Xu.shape),()=>`packed reshape ${bu.shape} to ${Xu.shape} isn't free`);const Ju=Cm({inputs:{x:nu},backend:lu,attrs:{shape:[1,ru.inChannels,ru.outChannels]}});Fu.push(Ju);const ip=G2({a:Xu,b:Ju,backend:lu,transposeA:Ru,transposeB:Nu,bias:cu,activation:mu,preluActivationWeights:hu,leakyreluAlpha:pu}),rp=lu.texData.get(ip.dataId);vu(rp.isPacked,()=>"batchMatMul result is expected to be packed"),bu.shape=Qu,rp.shape=ru.outShape,Pu=Wy({inputs:{x:ip},backend:lu}),Pu.shape=ru.outShape,Fu.push(ip)}else{const Gu=ru.outHeight*ru.outWidth,Xu=Cm({inputs:{x:ou},backend:lu,attrs:{shape:Tu?[ru.batchSize,Gu,ru.inChannels]:[ru.batchSize,ru.inChannels,Gu]}}),Qu=Cm({inputs:{x:nu},backend:lu,attrs:{shape:[1,ru.inChannels,ru.outChannels]}}),Ju=G2({a:Tu?Xu:Qu,b:Tu?Qu:Xu,transposeA:!Tu,transposeB:Nu,backend:lu,bias:cu,activation:mu,preluActivationWeights:hu,leakyreluAlpha:pu});Pu=Cm({inputs:{x:Ju},backend:lu,attrs:{shape:ru.outShape}}),Fu.push(Xu),Fu.push(Qu),Fu.push(Ju)}for(const Gu of Fu)lu.disposeIntermediateTensorInfo(Gu);return Pu}function uF({x:ou,filter:nu,convInfo:ru,backend:lu,bias:cu=null,preluActivationWeights:hu=null,leakyreluAlpha:pu=0,activation:mu=null}){const{filterWidth:Au,filterHeight:bu,inChannels:Cu,outWidth:wu,outHeight:Eu,dataFormat:Tu}=ru,Ru=Tu==="channelsLast",Nu=Au*bu*Cu,Pu=Eu*wu,Fu=[ru.batchSize,Nu,Pu],Gu=!0,Xu=!1,Qu=[];if(hu!=null){const im=V2(hu.shape,Ru);im!=null&&(hu=Cm({inputs:{x:hu},backend:lu,attrs:{shape:im}}),Qu.push(hu))}if(cu!=null){const im=V2(cu.shape,Ru);im!=null&&(cu=Cm({inputs:{x:cu},backend:lu,attrs:{shape:im}}),Qu.push(cu))}const Ju=Cm({inputs:{x:nu},backend:lu,attrs:{shape:[1,Nu,Mu(nu.shape)/Nu]}});Qu.push(Ju);const ip=new nee(Fu,ru),rp=[ou.shape,[ru.padInfo.top,ru.padInfo.left],[ru.strideHeight,ru.strideWidth],[ru.dilationHeight,ru.dilationWidth],[ru.inChannels],[ru.filterWidth*ru.inChannels],[ru.outWidth]],op=lu.runWebGLProgram(ip,[ou],"float32",rp),hp=Cm({inputs:{x:op},backend:lu,attrs:{shape:Fu}});Qu.push(op),Qu.push(hp);const Ap=cu!=null,Up=hu!=null,Vp=mu==="leakyrelu",zp=mu?Uw(mu,!0):null,qp=new XD(Ru?hp.shape:Ju.shape,Ru?Ju.shape:hp.shape,Ru?[ru.batchSize,Pu,ru.outChannels]:[ru.batchSize,ru.outChannels,Pu],Gu,Xu,Ap,zp,Up,Vp),Yp=Ru?[hp,Ju]:[Ju,hp];if(cu&&Yp.push(cu),Up&&Yp.push(hu),Vp){const im=lu.makeTensorInfo([],"float32",yv(pu,"float32"));Yp.push(im),Qu.push(im)}const em=lu.runWebGLProgram(qp,Yp,"float32"),am=Cm({inputs:{x:em},backend:lu,attrs:{shape:ru.outShape}});Qu.push(em);for(const im of Qu)lu.disposeIntermediateTensorInfo(im);return am}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dataFormat:Au,dilations:bu,dimRoundingMode:Cu}=lu,wu=nv(Au),Eu=hy(cu.shape,hu.shape,pu,bu,mu,Cu,!1,wu);let Tu;if(Eu.filterHeight===1&&Eu.filterWidth===1&&Eu.dilationHeight===1&&Eu.dilationWidth===1&&Eu.strideHeight===1&&Eu.strideWidth===1&&(Eu.padInfo.type==="SAME"||Eu.padInfo.type==="VALID"))Tu=cF({x:cu,filter:hu,convInfo:Eu,backend:ru});else if(Eu.strideWidth<=2&&wu==="channelsLast"&&cp().getBool("WEBGL_EXP_CONV")){const Nu=new lF(Eu),Pu=[[Eu.padInfo.top,Eu.padInfo.left],[Eu.strideHeight,Eu.strideWidth],[Eu.dilationHeight,Eu.dilationWidth],[Eu.inHeight,Eu.inWidth]];Tu=ru.runWebGLProgram(Nu,[cu,hu],"float32",Pu)}else if(cp().getBool("WEBGL_CONV_IM2COL"))Tu=uF({x:cu,filter:hu,convInfo:Eu,backend:ru});else{const Nu=new aF(Eu);Tu=ru.runWebGLProgram(Nu,[cu,hu],"float32")}const Ru=Cm({inputs:{x:Tu},backend:ru,attrs:{shape:Eu.outShape}});return ru.disposeIntermediateTensorInfo(Tu),Ru}const ree={kernelName:zv,backendName:"webgl",kernelFunc:iee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class see{constructor(nu){this.variableNames=["x","dy"],this.outputShape=nu.filterShape;const ru=nu.strideHeight,lu=nu.strideWidth,cu=nu.padInfo.top,hu=nu.padInfo.left,pu=nu.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${nu.batchSize}; b++) {
          for (int yR = 0; yR < ${nu.outHeight}; yR++) {
            int xR = wR + yR * ${ru} - ${cu};

            if (xR < 0 || xR >= ${nu.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${nu.outWidth}; yC++) {
              int xC = wC + yC * ${lu} - ${hu};

              if (xC < 0 || xC >= ${nu.inWidth}) {
                continue;
              }

              ${pu?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class oee{constructor(nu){this.variableNames=["dy","W"],this.outputShape=nu.inShape;const ru=nu.filterHeight,lu=nu.filterWidth,cu=nu.strideHeight,hu=nu.strideWidth,pu=nu.dataFormat==="channelsLast",mu=ru-1-nu.padInfo.top,Au=lu-1-nu.padInfo.left,bu=pu?1:2,Cu=pu?2:3,wu=pu?3:1;this.userCode=`
      const ivec2 pads = ivec2(${mu}, ${Au});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${wu}];

        ivec2 dyCorner = ivec2(coords[${bu}], coords[${Cu}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${ru}; wR++) {
          float dyR = float(dyRCorner + wR) / ${cu}.0;

          if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${ru} - 1 - wR;

          for (int wC = 0; wC < ${lu}; wC++) {
            float dyC = float(dyCCorner + wC) / ${hu}.0;

            if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${lu} - 1 - wC;

            for (int d2 = 0; d2 < ${nu.outChannels}; d2++) {

              if (${pu}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class aee{constructor(nu){this.variableNames=["x","dy"],this.outputShape=nu.filterShape;const ru=nu.strideDepth,lu=nu.strideHeight,cu=nu.strideWidth,hu=nu.padInfo.front,pu=nu.padInfo.top,mu=nu.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${nu.batchSize}; b++) {
          for (int yF = 0; yF < ${nu.outDepth}; yF++) {
            int xF = wF + yF * ${ru} - ${hu};

            if (xF < 0 || xF >= ${nu.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${nu.outHeight}; yR++) {
              int xR = wR + yR * ${lu} - ${pu};

              if (xR < 0 || xR >= ${nu.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${nu.outWidth}; yC++) {
                int xC = wC + yC * ${cu} - ${mu};

                if (xC < 0 || xC >= ${nu.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class lee{constructor(nu){this.variableNames=["dy","W"],this.outputShape=nu.inShape;const ru=nu.filterDepth,lu=nu.filterHeight,cu=nu.filterWidth,hu=nu.strideDepth,pu=nu.strideHeight,mu=nu.strideWidth,Au=ru-1-nu.padInfo.front,bu=lu-1-nu.padInfo.top,Cu=cu-1-nu.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${Au}, ${bu}, ${Cu});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${ru}; wF++) {
          float dyF = float(dyFCorner + wF) / ${hu}.0;

          if (dyF < 0.0 || dyF >= ${nu.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${ru} - 1 - wF;

          for (int wR = 0; wR < ${lu}; wR++) {
            float dyR = float(dyRCorner + wR) / ${pu}.0;

            if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${lu} - 1 - wR;

            for (int wC = 0; wC < ${cu}; wC++) {
              float dyC = float(dyCCorner + wC) / ${mu}.0;

              if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${cu} - 1 - wC;

              for (int d2 = 0; d2 < ${nu.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,dy:hu}=nu,{strides:pu,pad:mu,dataFormat:Au,dimRoundingMode:bu,filterShape:Cu}=lu,wu=nv(Au),Eu=hy(cu.shape,Cu,pu,1,mu,bu,!1,wu),Tu=new see(Eu);return ru.runWebGLProgram(Tu,[cu,hu],"float32")}const uee={kernelName:N1,backendName:"webgl",kernelFunc:cee};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hee{constructor(nu){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=nu.inShape,this.enableShapeUniforms=Ay(this.outputShape.length);const ru=nu.filterHeight,lu=nu.filterWidth,cu=ru-1-nu.padInfo.top,hu=lu-1-nu.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${cu}, ${hu});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${ru}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${ru} - 1 - wR;

          for (int wC = 0; wC < ${lu}; wC++) {
            int wCPerm = ${lu} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${nu.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${nu.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${nu.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${nu.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${nu.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,filter:hu}=nu,{inputShape:pu,strides:mu,pad:Au,dataFormat:bu,dimRoundingMode:Cu}=lu,wu=nv(bu),Eu=hy(pu,hu.shape,mu,1,Au,Cu,!1,wu);if(cp().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&wu==="channelsLast"){const Tu=[[Eu.strideHeight,Eu.strideWidth]],Ru=new hee(Eu);return ru.runWebGLProgram(Ru,[cu,hu],"float32",Tu)}else{const Tu=new oee(Eu);return ru.runWebGLProgram(Tu,[cu,hu],"float32")}}const pee={kernelName:tx,backendName:"webgl",kernelFunc:dee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dilations:Au}=lu,bu=wv(cu.shape,hu.shape,pu,Au,mu),Cu=new tee(bu);return ru.runWebGLProgram(Cu,[cu,hu],"float32")}const mee={kernelName:fv,backendName:"webgl",kernelFunc:fee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,dy:hu}=nu,{strides:pu,pad:mu,filterShape:Au}=lu,bu=wv(cu.shape,Au,pu,1,mu),Cu=new aee(bu);return ru.runWebGLProgram(Cu,[cu,hu],"float32")}const Aee={kernelName:Wv,backendName:"webgl",kernelFunc:gee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,filter:hu}=nu,{pad:pu,strides:mu,inputShape:Au}=lu,bu=wv(Au,hu.shape,mu,1,pu),Cu=new lee(bu);return ru.runWebGLProgram(Cu,[cu,hu],"float32")}const bee={kernelName:D1,backendName:"webgl",kernelFunc:yee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xee=AC+`
  return cos(x);
`,vee=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${_1}
  return result;
`,Cee=u0({opSnippet:xee,packedOpSnippet:vee}),wee={kernelName:Lx,backendName:"webgl",kernelFunc:Cee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Eee=u0({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),See={kernelName:mv,backendName:"webgl",kernelFunc:Eee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Iee{constructor(nu,ru,lu,cu,hu){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[pu,mu,Au,bu]=nu,[Cu]=ru,[wu,Eu]=lu;this.outputShape=[Cu,wu,Eu,bu];const Tu=cu==="bilinear"?1:0,[Ru,Nu]=[`${mu-1}.0`,`${Au-1}.0`],[Pu,Fu,Gu]=wu>1?[`${(mu-1)/(wu-1)}`,"(y2-y1) * height_ratio",`y1*${Ru} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${Ru}`],[Xu,Qu,Ju]=Eu>1?[`${(Au-1)/(Eu-1)}`,"(x2-x1) * width_ratio",`x1*${Nu} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${Nu}`];this.userCode=`
      const float height_ratio = float(${Pu});
      const float width_ratio = float(${Xu});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${pu}) {
          return;
        }

        float height_scale = ${Fu};
        float width_scale = ${Qu};

        float in_y = ${Gu};
        if( in_y < 0.0 || in_y > ${Ru} ) {
          setOutput(float(${hu}));
          return;
        }
        float in_x = ${Ju};
        if( in_x < 0.0 || in_x > ${Nu} ) {
          setOutput(float(${hu}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${Tu} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Tee={kernelName:F1,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{image:cu,boxes:hu,boxInd:pu}=nu,{cropSize:mu,method:Au,extrapolationValue:bu}=lu,Cu=new Iee(cu.shape,hu.shape,mu,Au,bu);return ru.runWebGLProgram(Cu,[cu,hu,pu],"float32")}};var Ww;(function(ou){ou.Prod="*",ou.Sum="+"})(Ww||(Ww={}));class hF{constructor(nu,ru,lu,cu){this.op=nu,this.outputShape=ru,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const hu=this.outputShape.length,pu=this.op===Ww.Prod?"1.0":"0.0",mu=lu?pu:`getX(${dF(hu,"coords",this.op)})`,Au=this.outputShape[this.outputShape.length-1];let bu="",Cu="";lu?(bu=cu?`end != ${Au-1}`:"end != 0",Cu=cu?"end + 1":"end - 1"):(bu=cu?`end + pow2 < ${Au}`:"end >= pow2",Cu=cu?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${x0(hu)} coords = getOutputCoords();
        int end = ${pF(hu,"coords",this.op)};
        float val = ${mu};
        int pow2 = int(pow(2.0, index));
        if (${bu}) {
          int idx = ${Cu};
          ${pF(hu,"coords",this.op)} = idx;
          val ${this.op}= getX(${dF(hu,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function dF(ou,nu,ru){if(ou===1)return`${nu}`;if(ou===2)return`${nu}.x, ${nu}.y`;if(ou===3)return`${nu}.x, ${nu}.y, ${nu}.z`;if(ou===4)return`${nu}.x, ${nu}.y, ${nu}.z, ${nu}.w`;throw new Error(`Cumulative ${ru} for rank ${ou} is not yet supported`)}function pF(ou,nu,ru){if(ou===1)return`${nu}`;if(ou===2)return`${nu}.y`;if(ou===3)return`${nu}.z`;if(ou===4)return`${nu}.w`;throw new Error(`Cumulative ${ru} for rank ${ou} is not yet supported`)}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fF(ou,nu,ru,lu,cu,hu){const pu=nu.shape.length,mu=G0([lu],pu);let Au=nu;mu!=null&&(Au=Iy({inputs:{x:nu},backend:ru,attrs:{perm:mu}}));const bu=H0(1,pu)[0];if(bu!==pu-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${nu.shape.length-1} but got axis=${lu}`);const Cu=Au.shape[bu];let wu=Wy({inputs:{x:Au},backend:ru});for(let Eu=0;Eu<=Math.ceil(Math.log2(Cu))-1;Eu++){const Tu=new hF(ou,Au.shape,!1,hu),Ru=[[Eu]],Nu=wu;wu=ru.runWebGLProgram(Tu,[wu],wu.dtype,Ru),ru.disposeIntermediateTensorInfo(Nu)}if(cu){const Eu=new hF(ou,Au.shape,cu,hu),Tu=wu;wu=ru.runWebGLProgram(Eu,[wu],wu.dtype),ru.disposeIntermediateTensorInfo(Tu)}if(mu!=null){const Eu=Ev(mu),Tu=Iy({inputs:{x:wu},backend:ru,attrs:{perm:Eu}});return ru.disposeIntermediateTensorInfo(wu),ru.disposeIntermediateTensorInfo(Au),Tu}return wu}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _ee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,exclusive:pu,reverse:mu}=lu;return fF(Ww.Prod,cu,ru,hu,pu,mu)}const Mee={kernelName:gv,backendName:"webgl",kernelFunc:_ee};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ree(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,exclusive:pu,reverse:mu}=lu;return fF(Ww.Sum,cu,ru,hu,pu,mu)}const kee={kernelName:Hv,backendName:"webgl",kernelFunc:Ree};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,weights:hu}=nu,{size:pu,binaryOutput:mu}=lu;if(cu.shape.length===1){const Au=ru.readSync(cu.dataId),bu=ru.readSync(hu.dataId),Cu=LD(Au,bu,hu.dtype,hu.shape,pu);return ru.makeTensorInfo([pu],hu.dtype,Cu)}else if(cu.shape.length===2){const Au=ru.bufferSync(cu),bu=ru.bufferSync(hu),Cu=$7(Au,bu,pu,mu);return ru.makeTensorInfo(Cu.shape,hu.dtype,Cu.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${cu.shape.length}.`)}const Lee={kernelName:CC,backendName:"webgl",kernelFunc:Bee};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Nee{constructor(nu,ru,lu){this.variableNames=["x"],this.outputShape=[],this.outputShape=nu,this.blockSize=ru,this.dataFormat=lu,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${ru};
      int offset_h = imod(h, ${ru});
      int in_w = w / ${ru};
      int offset_w = imod(w, ${ru});
      int offset_d = (offset_h * ${ru} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{blockSize:hu,dataFormat:pu}=lu,mu=cu.shape[0],Au=pu==="NHWC"?cu.shape[1]:cu.shape[2],bu=pu==="NHWC"?cu.shape[2]:cu.shape[3],Cu=pu==="NHWC"?cu.shape[3]:cu.shape[1],wu=Au*hu,Eu=bu*hu,Tu=Cu/(hu*hu),Ru=pu==="NHWC"?[mu,wu,Eu,Tu]:[mu,Tu,wu,Eu],Nu=new Nee(Ru,hu,pu);return ru.runWebGLProgram(Nu,[cu],cu.dtype)}const Fee={kernelName:wC,backendName:"webgl",kernelFunc:Dee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class mF{constructor(nu,ru=!1,lu=null,cu=!1,hu=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=nu.outShape,this.enableShapeUniforms=Ay(this.outputShape.length);const pu=nu.filterHeight,mu=nu.filterWidth,Au=nu.outChannels/nu.inChannels;let bu="",Cu="";lu&&(cu?bu=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${lu}
        }`:hu?bu=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${lu}
        }`:bu=`
          float activation(float x) {
            ${lu}
          }
        `,Cu="result = activation(result);");const wu=ru?"result += getBiasAtOutCoords();":"";ru&&this.variableNames.push("bias"),cu&&this.variableNames.push("preluActivationWeights"),hu&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${bu}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${Au};
        int q = d2 - d1 * ${Au};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${pu}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${mu}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${wu}
        ${Cu}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gF{constructor(nu,ru=!1,lu=null,cu=!1,hu=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=nu.outShape,this.enableShapeUniforms=Ay(this.outputShape.length);const pu=nu.outChannels/nu.inChannels,mu=nu.padInfo.left,Au=nu.strideWidth,bu=nu.dilationWidth,Cu=nu.filterHeight,wu=nu.filterWidth,Eu=wu;let Tu=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let Fu=0;Fu<wu;Fu++)Tu+=`
          vec4 xTexelC${Fu*2};
          int xTexelC${Fu*2}Ready;
          vec4 xTexelC${Fu*2+1};
          int xTexelC${Fu*2+1}Ready;
          vec4 xC${Fu};`;Tu+=`
    for (int r = 0; r < ${Cu}; r++) {
      `;for(let Fu=0;Fu<wu;Fu++)Tu+=`
          xTexelC${Fu*2} = vec4(0.0);
          xTexelC${Fu*2}Ready = 0;
          xTexelC${Fu*2+1} = vec4(0.0);
          xTexelC${Fu*2+1}Ready = 0;
          xC${Fu} = vec4(0.0);`;Tu+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let Fu=0;Fu<(Eu+1)/2;Fu++){const Gu=Fu*2;if(Tu+=`
          xC = xCCorner + ${Gu*bu};
          `,Au===1){if(Gu<wu&&(mu%2===1?(Tu+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Gu}Ready == 0) {
                  xTexelC${Gu} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Gu}.zw = vec2(0.0);
                  }
                  xTexelC${Gu}Ready = 1;
                }
              `,bu===1&&Gu>0?Tu+=`
                xC${Gu} = vec4(xTexelC${Gu-2}.zw, xTexelC${Gu}.xy);
                `:Tu+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${Gu} = vec4(previous.zw, xTexelC${Gu}.xy);
                  } else {
                    xC${Gu} = vec4(0.0, 0.0, xTexelC${Gu}.xy);
                  }
                  `):Tu+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${Gu}Ready == 0) {
                  xTexelC${Gu} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${Gu}.zw = vec2(0.0);
                  }
                  xTexelC${Gu}Ready = 1;
                }

                xC${Gu} = xTexelC${Gu};
                `,Gu+1<wu)){const Xu=mu%2===0?gu(bu):bu;bu%2===0&&mu%2===1||bu%2!==0&&mu%2!==1?(Tu+=`
                  xCOffset = xC + imod(pads[1], 2) + ${Xu};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Gu+1}Ready == 0) {
                    xTexelC${Gu+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${Gu+1}.zw = vec2(0.0);
                    }
                    xTexelC${Gu+1}Ready = 1;
                  }
                  `,bu>1?Tu+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${Gu+1} = vec4(previous.zw, xTexelC${Gu+1}.xy);
                    } else {
                     xC${Gu+1} = vec4(0.0, 0.0, xTexelC${Gu+1}.xy);
                    }
                    `:Tu+=`
                    xC${Gu+1} = vec4(xTexelC${Gu}.zw, xTexelC${Gu+1}.xy);
                    `):Xu===1?Tu+=`
                    xC${Gu+1} = xTexelC${Gu};
                    `:Tu+=`
                    xCOffset = xC + ${Xu};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Gu+1}Ready == 0) {
                      xTexelC${Gu+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${Gu+1}.zw = vec2(0.0);
                      }
                      xTexelC${Gu+1}Ready = 1;
                    }

                    xC${Gu+1} = xTexelC${Gu+1};
                    `}}else Gu<wu&&(mu%2===1?(Tu+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Gu}Ready == 0) {
                  xTexelC${Gu} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Gu}.zw = vec2(0.0);
                  }
                  xTexelC${Gu}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Gu+1}Ready == 0) {
                  xTexelC${Gu+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${Gu+1}.zw = vec2(0.0);
                  }
                  xTexelC${Gu+1}Ready = 1;
                }

                xC${Gu} = vec4(xTexelC${Gu}.zw, xTexelC${Gu+1}.zw);
              `,Gu+1<wu&&(Tu+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${Gu+1} = vec4(xTexelC${Gu+1}.xy, final.xy);
                `)):(Tu+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${Gu}Ready == 0) {
                  xTexelC${Gu} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${Gu}.zw = vec2(0.0);
                  }
                  xTexelC${Gu}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Gu+1}Ready == 0) {
                  xTexelC${Gu+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Gu+1}.zw = vec2(0.);
                  }
                  xTexelC${Gu+1}Ready = 1;
                }

                xC${Gu} = vec4(
                  xTexelC${Gu}.xy, xTexelC${Gu+1}.xy);
              `,Gu+1<wu&&(Tu+=`
                  xC${Gu+1} = vec4(xTexelC${Gu}.zw, xTexelC${Gu+1}.zw);
                `)));Gu<wu&&(Tu+=`
            wTexel = getW(r, ${Gu}, d1, q);
            dotProd += xC${Gu} * vec4(wTexel.xz, wTexel.xz);
          `,Gu+1<wu&&(Tu+=`
              wTexel = getW(r, ${Gu+1}, d1, q);
              dotProd += xC${Gu+1} * vec4(wTexel.xz, wTexel.xz);
            `))}Tu+=`
    }
  `,Tu+=`
      }
    `;let Ru="",Nu="";lu&&(cu?Ru=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${lu}
        }`:hu?Ru=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${lu}
        }`:Ru=`vec4 activation(vec4 x) {
          ${lu}
        }`,Nu="result = activation(result);");const Pu=ru?"result += getBiasAtOutCoords();":"";ru&&this.variableNames.push("bias"),cu&&this.variableNames.push("preluActivationWeights"),hu&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${Ru}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${pu};
        int q = d2 - d1 * ${pu};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${Tu}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${Pu}
        ${Nu}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dilations:Au,dimRoundingMode:bu}=lu;let Cu=Au;Cu==null&&(Cu=[1,1]),vu(gy(pu,Cu),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${pu} and dilations '${Cu}'`);const wu=hy(cu.shape,hu.shape,pu,Cu,mu,bu,!0);let Eu;cp().getBool("WEBGL_PACK_DEPTHWISECONV")&&wu.strideWidth<=2&&wu.outChannels/wu.inChannels===1?Eu=new gF(wu):Eu=new mF(wu);const Tu=[[wu.padInfo.top,wu.padInfo.left],[wu.strideHeight,wu.strideWidth],[wu.dilationHeight,wu.dilationWidth],[wu.inHeight,wu.inWidth]];return ru.runWebGLProgram(Eu,[cu,hu],"float32",Tu)}const Gee={kernelName:P1,backendName:"webgl",kernelFunc:Pee};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Oee{constructor(nu){this.variableNames=["x","dy"],this.outputShape=nu.filterShape;const ru=nu.strideHeight,lu=nu.strideWidth,cu=nu.padInfo.top,hu=nu.padInfo.left,pu=nu.outChannels/nu.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${pu} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${nu.batchSize}; b++) {
          for (int yR = 0; yR < ${nu.outHeight}; yR++) {
            int xR = wR + yR * ${ru} - ${cu};

            if (xR < 0 || xR >= ${nu.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${nu.outWidth}; yC++) {
              int xC = wC + yC * ${lu} - ${hu};

              if (xC < 0 || xC >= ${nu.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Uee{constructor(nu){this.variableNames=["dy","W"],this.outputShape=nu.inShape;const ru=nu.filterHeight,lu=nu.filterWidth,cu=nu.strideHeight,hu=nu.strideWidth,pu=ru-1-nu.padInfo.top,mu=lu-1-nu.padInfo.left,Au=nu.outChannels/nu.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${pu}, ${mu});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${ru}; wR++) {
          float dyR = float(dyRCorner + wR) / ${cu}.0;

          if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${ru} - 1 - wR;

          for (int wC = 0; wC < ${lu}; wC++) {
            float dyC = float(dyCCorner + wC) / ${hu}.0;

            if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${lu} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${Au}; dm++) {
              int d2 = d1 * ${Au} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $ee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,dy:hu}=nu,{strides:pu,dilations:mu,pad:Au,dimRoundingMode:bu,filterShape:Cu}=lu,wu=hy(cu.shape,Cu,pu,mu,Au,bu,!0),Eu=new Oee(wu);return ru.runWebGLProgram(Eu,[cu,hu],"float32")}const Vee={kernelName:EC,backendName:"webgl",kernelFunc:$ee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,filter:hu}=nu,{strides:pu,dilations:mu,pad:Au,dimRoundingMode:bu,inputShape:Cu}=lu,wu=hy(Cu,hu.shape,pu,mu,Au,bu,!0),Eu=new Uee(wu);return ru.runWebGLProgram(Eu,[cu,hu],"float32")}const Wee={kernelName:SC,backendName:"webgl",kernelFunc:zee};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Hee{constructor(nu){this.variableNames=["X"],this.outputShape=[nu,nu],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xee(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu,cu=[...lu.shape,...lu.shape],hu=Mu(lu.shape),pu=Cm({inputs:{x:lu},backend:ru,attrs:{shape:[hu]}}),mu=new Hee(hu),Au=ru.runWebGLProgram(mu,[pu],pu.dtype),bu=Cm({inputs:{x:Au},backend:ru,attrs:{shape:cu}});return ru.disposeIntermediateTensorInfo(pu),ru.disposeIntermediateTensorInfo(Au),bu}const Qee={kernelName:jw,backendName:"webgl",kernelFunc:Xee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Kee{constructor(nu){this.variableNames=["x","W"],this.outputShape=nu.outShape;const{inHeight:ru,inWidth:lu,padInfo:cu,strideHeight:hu,strideWidth:pu,filterHeight:mu,filterWidth:Au,dilationHeight:bu,dilationWidth:Cu}=nu,{top:wu,left:Eu}=cu;this.userCode=`
      const ivec2 strides = ivec2(${hu}, ${pu});
      const ivec2 pads = ivec2(${wu}, ${Eu});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${mu}; h++) {
          int hIn = hBeg + h * ${bu};

          if (hIn >= 0 && hIn < ${ru}) {
            for (int w = 0; w < ${Au}; w++) {
              int wIn = wBeg + w * ${Cu};

              if (wIn >= 0 && wIn < ${lu}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu}=nu,{strides:pu,pad:mu,dilations:Au}=lu,bu=iw(cu.shape,hu.shape,pu,mu,"NHWC",Au);let Cu;const wu=new Kee(bu);Cu=ru.runWebGLProgram(wu,[cu,hu],"float32");const Eu=Cm({inputs:{x:Cu},backend:ru,attrs:{shape:bu.outShape}});return ru.disposeIntermediateTensorInfo(Cu),Eu}const jee={kernelName:np,backendName:"webgl",kernelFunc:Zee};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yee(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{equation:cu}=lu,hu=nu,{allDims:pu,summedDims:mu,idDims:Au}=PI(cu,hu.length);OI(pu.length,Au,hu);const{path:bu,steps:Cu}=UI(mu,Au),wu=Cu.length;let Eu=null,Tu=pu.length;const Ru=[];for(let Nu=0;Nu<wu;++Nu){for(const Pu of Cu[Nu]){const{permutationIndices:Fu,expandDims:Gu}=GI(Tu,Au[Pu]);let Xu;$I(Fu)?Xu=hu[Pu]:(Xu=Iy({inputs:{x:hu[Pu]},backend:ru,attrs:{perm:Fu}}),Ru.push(Xu));const Qu=Xu.shape.slice();for(let Ju=0;Ju<Gu.length;++Ju)Qu.splice(Gu[Ju],0,1);ku(Xu.shape,Qu)||(Xu=Cm({inputs:{x:Xu},backend:ru,attrs:{shape:Qu}}),Ru.push(Xu)),Eu===null?Eu=Xu:(Eu=JT({inputs:{a:Xu,b:Eu},backend:ru}),Ru.push(Eu))}Nu<wu-1&&(bu[Nu]>=0&&(Eu=P2({inputs:{x:Eu},backend:ru,attrs:{axis:bu[Nu]-(pu.length-Tu),keepDims:!1}}),Ru.push(Eu)),Tu--)}for(const Nu of Ru)Nu!==Eu&&ru.disposeIntermediateTensorInfo(Nu);return Eu}const qee={kernelName:gm,backendName:"webgl",kernelFunc:Yee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Jee=u0({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),ete={kernelName:_m,backendName:"webgl",kernelFunc:Jee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tte="return (b >= 0.0) ? a : a * (b + 1.0);",nte=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ite={kernelName:Nm,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru}=ou,{dy:lu,y:cu}=nu,hu=cp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gC(nte,lu.shape,cu.shape):new T1(tte,lu.shape,cu.shape);return ru.runWebGLProgram(hu,[lu,cu],lu.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rte=my({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:X7}),ste={kernelName:Km,backendName:"webgl",kernelFunc:rte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ote=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${MI};
  float a1 = ${RI};
  float a2 = ${kI};
  float a3 = ${BI};
  float a4 = ${LI};
  float a5 = ${NI};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ate=u0({opSnippet:ote}),lte={kernelName:Dm,backendName:"webgl",kernelFunc:ate};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cte=AC+`
  return exp(x);
`,AF=u0({opSnippet:cte,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:Q7,dtype:"float32"}),ute={kernelName:Zm,backendName:"webgl",kernelFunc:AF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function i_(ou){const{inputs:nu,attrs:ru,backend:lu}=ou,{dim:cu}=ru,{input:hu}=nu,pu=hu.shape.length,mu=hu.shape.slice();let Au=cu;return cu<0&&(vu(-(pu+1)<=cu,()=>`Axis must be in the interval [${-(pu+1)}, ${pu}]`),Au=pu+cu+1),mu.splice(Au,0,1),Cm({inputs:{x:hu},backend:lu,attrs:{shape:mu}})}const hte={kernelName:Vm,backendName:"webgl",kernelFunc:i_};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yF="return exp(x) - 1.0;",dte=u0({opSnippet:yF,packedOpSnippet:yF,cpuKernelImpl:K7}),pte={kernelName:r0,backendName:"webgl",kernelFunc:dte};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class bF{constructor(nu,ru,lu){this.variableNames=["real","imag"];const cu=ru[1];this.outputShape=ru;const hu=lu?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,pu=lu?`${cu}.0`:"1.0";let mu;if(nu==="real")mu="return real * expR - imag * expI;";else if(nu==="imag")mu="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${nu}.`);this.userCode=`
      const float exponentMultiplier = ${hu};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${mu}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${cu});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${cu}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${pu};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xF(ou,nu,ru){const lu=ru.texData.get(ou.dataId),cu=Mu(ou.shape),hu=ou.shape[ou.shape.length-1],pu=cu/hu,mu=Cm({inputs:{x:ou},backend:ru,attrs:{shape:[pu,hu]}}),Au=mu.shape,bu=new bF("real",Au,nu),Cu=new bF("imag",Au,nu),wu=[{dataId:lu.complexTensorInfos.real.dataId,dtype:lu.complexTensorInfos.real.dtype,shape:Au},{dataId:lu.complexTensorInfos.imag.dataId,dtype:lu.complexTensorInfos.imag.dtype,shape:Au}],Eu=ru.runWebGLProgram(bu,wu,"float32"),Tu=ru.runWebGLProgram(Cu,wu,"float32"),Ru=Uv({inputs:{real:Eu,imag:Tu},backend:ru});ru.disposeIntermediateTensorInfo(Eu),ru.disposeIntermediateTensorInfo(Tu);const Nu=Cm({inputs:{x:Ru},backend:ru,attrs:{shape:ou.shape}});return ru.disposeIntermediateTensorInfo(mu),ru.disposeIntermediateTensorInfo(Ru),Nu}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fte(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu;return xF(lu,!1,ru)}const mte={kernelName:h0,backendName:"webgl",kernelFunc:fte};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gte{constructor(nu,ru){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=nu,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Hw(ou){const{backend:nu,attrs:ru}=ou,{shape:lu,value:cu}=ru;let{dtype:hu}=ru;if(hu=hu||Dp(cu),hu==="string"){const pu=Yu(hu,Mu(lu));return pu.fill(cu),nu.makeTensorInfo(lu,hu,pu)}else{const pu=new gte(lu,cu),mu=[[cu]];return nu.runWebGLProgram(pu,[],hu,mu)}}const Ate={kernelName:P0,backendName:"webgl",kernelFunc:Hw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class yte{constructor(nu){this.variableNames=["Image"],this.outputShape=[];const ru=nu[2];this.outputShape=nu,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${ru} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${ru}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bte={kernelName:N0,backendName:"webgl",kernelFunc:({inputs:ou,backend:nu})=>{const{image:ru}=ou,lu=nu,cu=new yte(ru.shape);return lu.runWebGLProgram(cu,[ru],ru.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vF="return floor(x);",xte=u0({opSnippet:vF,packedOpSnippet:vF,cpuKernelImpl:Z7}),vte={kernelName:s0,backendName:"webgl",kernelFunc:xte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Cte=my({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),wte={kernelName:z0,backendName:"webgl",kernelFunc:Cte};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ete{constructor(nu){this.variableNames=["A"];const ru=Ey(),[lu,cu]=nu;this.outputShape=nu,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${cu}.0, ${lu}.0);

        vec4 values = ${ru.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ste{constructor(nu){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const ru=Ey(),[lu,cu]=nu;this.outputShape=nu,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${cu}.0, ${lu}.0);
            vec4 values = ${ru.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${ru.output} = result;
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ite={kernelName:mS,backendName:"webgl",kernelFunc:Tte};let bC,r_=cp().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Tte(ou){const{inputs:nu,backend:ru,attrs:lu}=ou;let{pixels:cu}=nu;const{numChannels:hu}=lu,pu=typeof HTMLVideoElement<"u"&&cu instanceof HTMLVideoElement,mu=typeof HTMLImageElement<"u"&&cu instanceof HTMLImageElement,[Au,bu]=pu?[cu.videoWidth,cu.videoHeight]:[cu.width,cu.height],Cu=[bu,Au],wu=[bu,Au,hu];if(mu||pu){const Nu=cp().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(bC==null||Nu!==r_)&&(r_=Nu,bC=document.createElement("canvas").getContext("2d",{willReadFrequently:r_})),bC.canvas.width=Au,bC.canvas.height=bu,bC.drawImage(cu,0,0,Au,bu),cu=bC.canvas}const Eu=ru.makeTensorInfo(Cu,"int32");ru.texData.get(Eu.dataId).usage=_b.PIXELS,ru.gpgpu.uploadPixelDataToTexture(ru.getTexture(Eu.dataId),cu);const Tu=cp().getBool("WEBGL_PACK")?new Ste(wu):new Ete(wu),Ru=ru.runWebGLProgram(Tu,[Eu],"int32");return ru.disposeData(Eu.dataId),Ru}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _te(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu,bias:pu,preluActivationWeights:mu}=nu,{strides:Au,pad:bu,dataFormat:Cu,dilations:wu,dimRoundingMode:Eu,activation:Tu,leakyreluAlpha:Ru}=lu,Nu=nv(Cu),Pu=hy(cu.shape,hu.shape,Au,wu,bu,Eu,!1,Nu);let Fu;const Gu=[],Xu=pu!=null,Qu=mu!=null,Ju=Tu==="leakyrelu",ip=()=>{const op=[cu,hu],hp=(Ap,Up)=>{if(Up==="NCHW"&&Ap.shape.length===1&&Ap.shape[0]!==1){const Vp=Cm({inputs:{x:Ap},backend:ru,attrs:{shape:[Ap.shape[0],1,1]}});return Gu.push(Vp),Vp}return Ap};if(Xu&&op.push(hp(pu,Cu)),Qu&&op.push(hp(mu,Cu)),Ju){const Ap=ru.makeTensorInfo([],"float32",yv(Ru,"float32"));op.push(Ap),Gu.push(Ap)}return op};if(Pu.filterHeight===1&&Pu.filterWidth===1&&Pu.dilationHeight===1&&Pu.dilationWidth===1&&Pu.strideHeight===1&&Pu.strideWidth===1&&(Pu.padInfo.type==="SAME"||Pu.padInfo.type==="VALID"))Fu=cF({x:cu,filter:hu,convInfo:Pu,backend:ru,bias:pu,activation:Tu,preluActivationWeights:mu,leakyreluAlpha:Ru});else if(Pu.strideWidth<=2&&Nu==="channelsLast"&&cp().getBool("WEBGL_EXP_CONV")){const op=Tu?Uw(Tu,!0):null,hp=new lF(Pu,Xu,op,Qu,Ju),Ap=[[Pu.padInfo.top,Pu.padInfo.left],[Pu.strideHeight,Pu.strideWidth],[Pu.dilationHeight,Pu.dilationWidth],[Pu.inHeight,Pu.inWidth]],Up=ip();Fu=ru.runWebGLProgram(hp,Up,"float32",Ap)}else if(cp().getBool("WEBGL_CONV_IM2COL"))Fu=uF({x:cu,filter:hu,convInfo:Pu,backend:ru,bias:pu,activation:Tu,preluActivationWeights:mu,leakyreluAlpha:Ru});else{const op=Tu?Uw(Tu,!1):null,hp=new aF(Pu,Xu,op,Qu,Ju),Ap=ip();Fu=ru.runWebGLProgram(hp,Ap,"float32")}const rp=Cm({inputs:{x:Fu},backend:ru,attrs:{shape:Pu.outShape}});return Gu.push(Fu),Gu.forEach(op=>ru.disposeIntermediateTensorInfo(op)),rp}const Mte={kernelName:ME,backendName:"webgl",kernelFunc:_te};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rte(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,filter:hu,bias:pu,preluActivationWeights:mu}=nu,{strides:Au,pad:bu,dilations:Cu,dimRoundingMode:wu,activation:Eu,leakyreluAlpha:Tu}=lu,Ru=[];let Nu=Cu;Nu==null&&(Nu=[1,1]),vu(gy(Au,Nu),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${Au} and dilations '${Nu}'`);const Pu=hy(cu.shape,hu.shape,Au,Nu,bu,wu,!0),Fu=cp().getBool("WEBGL_PACK_DEPTHWISECONV")&&Pu.strideWidth<=2&&Pu.outChannels/Pu.inChannels===1,Gu=Eu?Uw(Eu,Fu):null,Xu=[cu,hu],Qu=pu!=null,Ju=mu!=null,ip=Eu==="leakyrelu";if(Qu&&Xu.push(pu),Ju&&Xu.push(mu),ip){const Ap=ru.makeTensorInfo([],"float32",yv(Tu,"float32"));Xu.push(Ap),Ru.push(Ap)}let rp;Fu?rp=new gF(Pu,Qu,Gu,Ju,ip):rp=new mF(Pu,Qu,Gu,Ju,ip);const op=[[Pu.padInfo.top,Pu.padInfo.left],[Pu.strideHeight,Pu.strideWidth],[Pu.dilationHeight,Pu.dilationWidth],[Pu.inHeight,Pu.inWidth]],hp=ru.runWebGLProgram(rp,Xu,"float32",op);return Ru.forEach(Ap=>ru.disposeIntermediateTensorInfo(Ap)),hp}const kte={kernelName:W_,backendName:"webgl",kernelFunc:Rte};class Bte{constructor(nu,ru,lu,cu){this.sliceDim=nu,this.strides=ru,this.paramsShape=cu,this.variableNames=["x","indices"],this.outputShape=lu;const hu=x0(lu.length);let pu=`
    int index;`;for(let mu=0;mu<this.sliceDim;mu++)pu+=`
          index = round(getIndices(coords[0], ${mu}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[mu]};
          flattenIndex += index * ${this.strides[mu]};`;this.userCode=`
         void main() {
          ${hu} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${pu}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lte(ou){const{inputs:nu,backend:ru}=ou,{params:lu,indices:cu}=nu,hu=cu.shape,pu=hu[hu.length-1],mu=Mu(lu.shape),[Au,bu,Cu,wu]=AI(lu,cu),Eu=Cm({inputs:{x:cu},backend:ru,attrs:{shape:[bu,pu]}}),Tu=Cm({inputs:{x:lu},backend:ru,attrs:{shape:[Mu(lu.shape)/Cu,Cu]}});if(ru.shouldExecuteOnCPU([lu,cu])||lu.dtype==="string"){const Fu=ru.readSync(cu.dataId),Gu=ru.bufferSync(lu),Xu=j7(Fu,Gu,lu.dtype,bu,pu,Cu,wu,lu.shape,mu);return ru.makeTensorInfo(Au,lu.dtype,Xu.values)}const Ru=new Bte(pu,wu,[bu,Cu],lu.shape),Nu=ru.runWebGLProgram(Ru,[Tu,Eu],Tu.dtype),Pu=Cm({inputs:{x:Nu},backend:ru,attrs:{shape:Au}});return ru.disposeIntermediateTensorInfo(Eu),ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Nu),Pu}const Nte={kernelName:d0,backendName:"webgl",kernelFunc:Lte};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Dte{constructor(nu,ru){this.variableNames=["A","indices"],this.outputShape=ru,this.rank=ru.length;const lu=x0(this.rank),cu=Fte(nu);this.userCode=`
      void main() {
        ${lu} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${nu[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${cu}));
      }
    `}}function Fte(ou,nu){const ru=["resRC.x","resRC.y","resRC.z","resRC.w"],lu=[];for(let cu=0;cu<ou.length;cu++)cu===2?lu.push("index"):lu.push(`${ru[cu]}`);return lu.join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CF(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,indices:hu}=nu,{axis:pu,batchDims:mu}=lu,Au=Wu(pu,cu.shape)[0];if(cp().get("DEBUG")){const Gu=ru.readSync(hu.dataId),Xu=cu.shape[Au];for(let Qu=0;Qu<Gu.length;++Qu){const Ju=Gu[Qu];vu(Ju<=Xu-1&&Ju>=0,()=>`GatherV2: the index value ${Ju} is not in [0, ${Xu-1}]`)}}const bu=WI(cu,hu,Au,mu),Cu=Mu(hu.shape),wu=[],Eu=Cm({inputs:{x:cu},backend:ru,attrs:{shape:[bu.batchSize,bu.outerSize,bu.dimSize,bu.sliceSize]}}),Tu=Cm({inputs:{x:hu},backend:ru,attrs:{shape:[bu.batchSize,Cu/bu.batchSize]}});wu.push(Eu),wu.push(Tu);const Ru=[bu.batchSize,bu.outerSize,Cu/bu.batchSize,bu.sliceSize];if(ru.shouldExecuteOnCPU([cu,hu])||cu.dtype==="string"){const Gu=ru.bufferSync(Tu),Xu=ru.bufferSync(Eu),Qu=Y7(Xu,Gu,Ru);return wu.forEach(Ju=>ru.disposeIntermediateTensorInfo(Ju)),ru.makeTensorInfo(bu.outputShape,Qu.dtype,Qu.values)}const Nu=new Dte(Eu.shape,Ru),Pu=ru.runWebGLProgram(Nu,[Eu,Tu],Eu.dtype);wu.push(Pu);const Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:bu.outputShape}});return wu.forEach(Gu=>ru.disposeIntermediateTensorInfo(Gu)),Fu}const Pte={kernelName:Nx,backendName:"webgl",kernelFunc:CF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gte=my({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:q7,dtype:"bool"}),Ote={kernelName:cy,backendName:"webgl",kernelFunc:Gte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ute=my({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:J7}),$te={kernelName:yy,backendName:"webgl",kernelFunc:Ute};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vte(ou){const{inputs:nu,backend:ru}=ou,{input:lu}=nu;return xF(lu,!0,ru)}const zte={kernelName:Dx,backendName:"webgl",kernelFunc:Vte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wte=u0({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Hte={kernelName:V0,backendName:"webgl",kernelFunc:Wte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Xte=u0({opSnippet:"return float(isinf(x));",dtype:"bool"}),Qte={kernelName:Py,backendName:"webgl",kernelFunc:Xte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kte=u0({opSnippet:"return float(isnan(x));",dtype:"bool"}),Zte={kernelName:_0,backendName:"webgl",kernelFunc:Kte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jte=my({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:eY,dtype:"bool"}),Yte={kernelName:yx,backendName:"webgl",kernelFunc:jte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qte=my({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:tY,dtype:"bool"}),Jte={kernelName:Xv,backendName:"webgl",kernelFunc:qte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ene(ou){const{backend:nu,attrs:ru}=ou,{start:lu,stop:cu,num:hu}=ru,pu=nY(lu,cu,hu);return nu.makeTensorInfo([pu.length],"float32",pu)}const tne={kernelName:T_,backendName:"webgl",kernelFunc:ene};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nne=AC+`
  return x < 0.0 ? 0./0. : log(x);
`,ine=u0({opSnippet:nne,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:iY}),rne={kernelName:IC,backendName:"webgl",kernelFunc:ine};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sne=AC+`
  return log(1.0 + x);
`,one=u0({opSnippet:sne}),ane={kernelName:TC,backendName:"webgl",kernelFunc:one};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lne=my({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),cne={kernelName:Yw,backendName:"webgl",kernelFunc:lne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const une=u0({opSnippet:"return float(!(x >= 1.0));"}),hne={kernelName:qw,backendName:"webgl",kernelFunc:une};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dne=my({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),pne={kernelName:Jw,backendName:"webgl",kernelFunc:dne};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fne{constructor(nu,ru,lu,cu,hu){this.variableNames=["x"],this.outputShape=[];const pu=ru,mu=nu[3]-1;this.outputShape=nu;let Au;const bu=`float(${lu}) + float(${cu}) * sum`;hu===.5?Au=`inversesqrt(${bu})`:hu===1?Au=`1.0/(${bu})`:Au=`exp(log(${bu}) * float(-${hu}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${pu}; j <= ${pu}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${mu}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${Au};
        setOutput(val);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class mne{constructor(nu,ru,lu,cu,hu){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const pu=ru,mu=nu[3]-1;this.outputShape=nu;let Au;const bu=`float(${lu}) + float(${cu}) * sum`;hu===.5?Au=`inversesqrt(${bu})`:hu===1?Au=`1.0/(${bu})`:Au=`exp(log(${bu}) * float(-${hu}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${pu};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${pu}; j <= ${pu}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${mu}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${Au};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gne={kernelName:eE,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{depthRadius:hu,bias:pu,alpha:mu,beta:Au}=lu,bu=cp().getBool("WEBGL_PACK_NORMALIZATION")?new mne(cu.shape,hu,pu,mu,Au):new fne(cu.shape,hu,pu,mu,Au);return ru.runWebGLProgram(bu,[cu],cu.dtype)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ane{constructor(nu,ru,lu,cu,hu){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=nu,this.depth=nu[3],this.depthRadius=ru,this.bias=lu,this.alpha=cu,this.beta=hu,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${ru})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${ru} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${cu}) * norm + float(${lu});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${cu})
                * float(${hu})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${hu});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yne={kernelName:J2,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,y:hu,dy:pu}=nu,{depthRadius:mu,bias:Au,alpha:bu,beta:Cu}=lu,wu=new Ane(cu.shape,mu,Au,bu,Cu);return ru.runWebGLProgram(wu,[cu,hu,pu],cu.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bne(ou,nu,ru,lu){const cu=Mu(nu),hu=Mu(ou.shape)/cu,pu=Cm({inputs:{x:ou},attrs:{shape:[hu,cu]},backend:lu}),mu=M1(pu,ou.dtype,"max",lu),Au=Cm({inputs:{x:mu},attrs:{shape:ru},backend:lu});return lu.disposeIntermediateTensorInfo(pu),lu.disposeIntermediateTensorInfo(mu),Au}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wF(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{reductionIndices:hu,keepDims:pu}=lu,mu=cu.shape.length,Au=Wu(hu,cu.shape);let bu=Au;const Cu=G0(bu,mu),wu=Cu!=null,Eu=ru.shouldExecuteOnCPU([cu]);let Tu=cu;if(wu){if(Eu){const Gu=ru.texData.get(Tu.dataId).values,Xu=new Array(mu);for(let ip=0;ip<Xu.length;ip++)Xu[ip]=cu.shape[Cu[ip]];const Qu=jT(Gu,cu.shape,cu.dtype,Cu,Xu);Tu=ru.makeTensorInfo(Xu,cu.dtype);const Ju=ru.texData.get(Tu.dataId);Ju.values=Qu}else Tu=F2(cu,Cu,ru);bu=H0(bu.length,mu)}dy("max",bu,mu);const[Ru,Nu]=oy(Tu.shape,bu);let Pu=Ru;pu&&(Pu=j0(Ru,Au));let Fu;if(Eu){const Gu=ru.texData.get(Tu.dataId).values,Xu=rY(Gu,Mu(Nu),Pu,cu.dtype);Fu=ru.makeTensorInfo(Pu,cu.dtype);const Qu=ru.texData.get(Fu.dataId);Qu.values=Xu}else Fu=bne(Tu,Nu,Pu,ru);return wu&&ru.disposeIntermediateTensorInfo(Tu),Fu}const xne={kernelName:tE,backendName:"webgl",kernelFunc:wF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vne=qT+`
  return max(a, b);
`,Cne=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+_1+`
  return result;
`,wne=my({opSnippet:vne,packedOpSnippet:Cne,cpuKernelImpl:sY}),Ene={kernelName:_C,backendName:"webgl",kernelFunc:wne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sne(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu;Gw(cu,"maxPool");const{filterSize:hu,strides:pu,pad:mu,dimRoundingMode:Au}=lu,bu=1;vu(gy(pu,bu),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${pu} and dilations '${bu}'`);const Cu=ox(cu.shape,hu,pu,bu,mu,Au);if(Cu.filterWidth===1&&Cu.filterHeight===1&&ku(Cu.inShape,Cu.outShape))return Wy({inputs:{x:cu},backend:ru});const wu=new $w(Cu,"max",!1);return ru.runWebGLProgram(wu,[cu],cu.dtype)}const Ine={kernelName:nE,backendName:"webgl",kernelFunc:Sne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tne(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{filterSize:hu,strides:pu,pad:mu,dataFormat:Au,dimRoundingMode:bu}=lu,Cu=[1,1,1],wu=tv(cu.shape,hu,pu,Cu,mu,bu,Au),Eu=new e_(wu,"max",!1);return ru.runWebGLProgram(Eu,[cu],cu.dtype)}const _ne={kernelName:iE,backendName:"webgl",kernelFunc:Tne};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Mne{constructor(nu){this.variableNames=["dy","maxPos"],this.outputShape=nu.inShape;const ru=nu.strideHeight,lu=nu.strideWidth,cu=nu.dilationHeight,hu=nu.effectiveFilterHeight,pu=nu.effectiveFilterWidth,mu=hu-1-nu.padInfo.top,Au=pu-1-nu.padInfo.left,bu=hu*pu-1;this.userCode=`
      const ivec2 pads = ivec2(${mu}, ${Au});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${hu};
          wR += ${cu}) {
          float dyR = float(dyRCorner + wR) / ${ru}.0;

          if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${pu}; wC++) {
            float dyC = float(dyCCorner + wC) / ${lu}.0;

            if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${bu} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${pu} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Rne{constructor(nu){this.variableNames=["dy","maxPos"],this.outputShape=nu.inShape;const ru=nu.strideDepth,lu=nu.strideHeight,cu=nu.strideWidth,hu=nu.dilationDepth,pu=nu.dilationHeight,mu=nu.dilationWidth,Au=nu.effectiveFilterDepth,bu=nu.effectiveFilterHeight,Cu=nu.effectiveFilterWidth,wu=Au-1-nu.padInfo.front,Eu=bu-1-nu.padInfo.top,Tu=Cu-1-nu.padInfo.left,Ru=Au*bu*Cu-1;this.userCode=`
      const ivec3 pads = ivec3(${wu}, ${Eu}, ${Tu});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${Au};
           wD += ${hu}) {
          float dyD = float(dyDCorner + wD) / ${ru}.0;

          if (dyD < 0.0 || dyD >= ${nu.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${bu};
              wR += ${pu}) {
            float dyR = float(dyRCorner + wR) / ${lu}.0;

            if (dyR < 0.0 || dyR >= ${nu.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${Cu};
                wC += ${mu}) {
              float dyC = float(dyCCorner + wC) / ${cu}.0;

              if (dyC < 0.0 || dyC >= ${nu.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${Ru} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${bu} * ${Cu} +
                  wR * ${Cu} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kne(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu}=nu,pu=hu,{filterSize:mu,strides:Au,pad:bu,dimRoundingMode:Cu}=lu,wu=[1,1,1],Eu=tv(pu.shape,mu,Au,wu,bu,Cu),Tu=new e_(Eu,"max",!0),Ru=ru.runWebGLProgram(Tu,[pu],pu.dtype),Nu=new Rne(Eu),Pu=ru.runWebGLProgram(Nu,[cu,Ru],pu.dtype);return ru.disposeIntermediateTensorInfo(Ru),Pu}const Bne={kernelName:tS,backendName:"webgl",kernelFunc:kne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lne(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{dy:cu,input:hu,output:pu}=nu,mu=hu;Gw([hu,pu],"maxPoolGrad");const{filterSize:Au,strides:bu,pad:Cu,dimRoundingMode:wu}=lu,Eu=ox(mu.shape,Au,bu,1,Cu,wu),Tu=!0,Ru=new $w(Eu,"max",Tu),Nu=ru.runWebGLProgram(Ru,[mu],mu.dtype),Pu=new Mne(Eu),Fu=ru.runWebGLProgram(Pu,[cu,Nu],mu.dtype);return ru.disposeIntermediateTensorInfo(Nu),Fu}const Nne={kernelName:eS,backendName:"webgl",kernelFunc:Lne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dne(ou,nu,ru,lu){let cu=new $w(ru,"max",!1);const hu=lu.runWebGLProgram(cu,[ou],"float32");cu=new $w(ru,"max",!0,!0,nu);const pu=lu.runWebGLProgram(cu,[ou],"float32");return[hu,pu]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Fne={kernelName:__,backendName:"webgl",kernelFunc:({inputs:ou,attrs:nu,backend:ru})=>{const{x:lu}=ou,{filterSize:cu,strides:hu,pad:pu,includeBatchInIndex:mu}=nu,Au=ru;vu(lu.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${lu.shape.length}.`);const bu=[1,1];vu(gy(hu,bu),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${hu} and dilations '${bu}'`);const Cu=ox(lu.shape,cu,hu,bu,pu),[wu,Eu]=Dne(lu,mu,Cu,Au);return[wu,Eu]}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pne(ou,nu,ru,lu){const cu=Mu(nu),hu=Mu(ou.shape)/cu,pu=Cm({inputs:{x:ou},attrs:{shape:[hu,cu]},backend:lu}),mu=M1(pu,"float32","mean",lu),Au=Cm({inputs:{x:mu},attrs:{shape:ru},backend:lu});return lu.disposeIntermediateTensorInfo(pu),lu.disposeIntermediateTensorInfo(mu),Au}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gne={kernelName:rE,backendName:"webgl",kernelFunc:({inputs:ou,attrs:nu,backend:ru})=>{const{x:lu}=ou,{keepDims:cu,axis:hu}=nu,pu=ru,mu=lu.shape.length,Au=Wu(hu,lu.shape);let bu=Au;const Cu=G0(bu,mu),wu=Cu!=null,Eu=pu.shouldExecuteOnCPU([lu]),Tu=[];let Ru=lu;if(wu){if(Eu){const Xu=pu.texData.get(Ru.dataId).values,Qu=new Array(mu);for(let rp=0;rp<Qu.length;rp++)Qu[rp]=lu.shape[Cu[rp]];const Ju=jT(Xu,lu.shape,lu.dtype,Cu,Qu);Ru=pu.makeTensorInfo(Qu,lu.dtype);const ip=pu.texData.get(Ru.dataId);ip.values=Ju}else Ru=F2(lu,Cu,pu);Tu.push(Ru),bu=H0(bu.length,mu)}dy("sum",bu,mu);const[Nu,Pu]=oy(Ru.shape,bu);let Fu=Nu;cu&&(Fu=j0(Nu,Au));const Gu=Pne(Ru,Pu,Fu,pu);for(const Xu of Tu)pu.disposeIntermediateTensorInfo(Xu);return Gu}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function One(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu,mu=cu.shape.length,Au=Wu(hu,cu.shape);let bu=Au;const Cu=G0(bu,mu);let wu=cu;Cu!=null&&(wu=Iy({inputs:{x:cu},backend:ru,attrs:{perm:Cu}}),bu=H0(bu.length,cu.shape.length)),dy("min",bu,mu);const[Eu,Tu]=oy(wu.shape,bu),Ru=Mu(Tu),Nu=Cm({inputs:{x:wu},backend:ru,attrs:{shape:[-1,Ru]}}),Pu=M1(Nu,Nu.dtype,"min",ru);let Fu;if(pu){const Gu=j0(Eu,Au);Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:Gu}})}else Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:Eu}});return ru.disposeIntermediateTensorInfo(Nu),ru.disposeIntermediateTensorInfo(Pu),Cu!=null&&ru.disposeIntermediateTensorInfo(wu),Fu}const Une={kernelName:sE,backendName:"webgl",kernelFunc:One};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $ne=qT+`
  return min(a, b);
`,Vne=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+_1+`
  return result;
`,zne=my({opSnippet:$ne,packedOpSnippet:Vne,cpuKernelImpl:oY}),Wne={kernelName:MC,backendName:"webgl",kernelFunc:zne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Hne{constructor(nu,ru,lu){this.variableNames=["x"],this.outputShape=ru.map((Cu,wu)=>Cu[0]+nu[wu]+Cu[1]);const cu=nu.length,hu=x0(cu),pu=ru.map(Cu=>Cu[0]).join(","),mu=ru.map((Cu,wu)=>Cu[0]+nu[wu]).join(","),Au=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,cu),bu=lu==="reflect"?0:1;if(cu===1){this.userCode=`
        int start = ${pu};
        int end = ${mu};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${bu};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${bu};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${hu} start = ${hu}(${pu});
      ${hu} end = ${hu}(${mu});

      void main() {
        ${hu} outC = getOutputCoords();
        for (int i = 0; i < ${cu}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${bu};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${bu};
          }
        }
        ${hu} coords = outC - start;
        setOutput(getX(${Au}));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Xne{constructor(nu,ru,lu){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ru.map((Ru,Nu)=>Ru[0]+nu[Nu]+Ru[1]);const cu=nu.length,hu=x0(cu),pu=ru.map(Ru=>Ru[0]).join(","),mu=ru.map((Ru,Nu)=>Ru[0]+nu[Nu]).join(","),Au=Sy("rc",cu),bu=Sy("source",cu),Cu=`${Au[cu-1]} < ${this.outputShape[cu-1]}`,wu=cu===1?"source":`vec2(${bu.slice(-2).join()})`,Eu=lu==="reflect"?0:1;let Tu="";if(cu===1){const Ru=`
        ${hu} source = rc;
        if (source < start) {
          source = start * 2 - source - ${Eu};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${Eu};
        }
        source -= start;
      `;Tu=`
        ${hu} rc = outputLoc;
        ${Ru}
        result[0] = getChannel(getX(${bu.join()}), ${wu});
        ${Au[cu-1]} += 1;
        if(${Cu}) {
          ${Ru}
          result[1] = getChannel(getX(${bu.join()}), ${wu});
        }
      `}else{const Ru=`
        ${hu} source = rc;
        ${hu} lt = ${hu}(lessThan(source, start));
        ${hu} gte = ${hu}(greaterThanEqual(source, end));
        ${hu} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${Eu}) +
                gte * ((end - 1) * 2 - source + ${Eu});
        source -= start;
      `;Tu=`
        ${hu} rc = outputLoc;
        ${Ru}
        result[0] = getChannel(getX(${bu.join()}), ${wu});
        ${Au[cu-1]} += 1;
        if(${Cu}) {
          ${Ru}
          result[1] = getChannel(getX(${bu.join()}), ${wu});
        }
        rc = outputLoc;
        ${Au[cu-2]} += 1;
        if(${Au[cu-2]} < ${this.outputShape[cu-2]}) {
          ${Ru}
          result[2] = getChannel(getX(${bu.join()}), ${wu});
          ${Au[cu-1]} += 1;
          if(${Cu}) {
            ${Ru}
            result[3] = getChannel(getX(${bu.join()}), ${wu});
          }
        }
      `}this.userCode=`
      const ${hu} start = ${hu}(${pu});
      const ${hu} end = ${hu}(${mu});

      void main() {
        ${hu} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${Tu}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qne={kernelName:oE,backendName:"webgl",kernelFunc:({inputs:ou,backend:nu,attrs:ru})=>{const{x:lu}=ou,{paddings:cu,mode:hu}=ru,pu=cp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Xne(lu.shape,cu,hu):new Hne(lu.shape,cu,hu);return nu.runWebGLProgram(pu,[lu],lu.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kne=`if (b == 0.0) return NAN;
  return mod(a, b);`,Zne=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+_1+`
  return result;
`,jne=my({opSnippet:Kne,packedOpSnippet:Zne}),Yne={kernelName:RC,backendName:"webgl",kernelFunc:jne};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class qne{constructor(nu,ru,lu){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[nu,lu],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${ru-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${ru-1}));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EF=my({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),Jne={kernelName:Gp,backendName:"webgl",kernelFunc:EF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SF="return a - b;",IF=my({opSnippet:SF,packedOpSnippet:SF,supportsComplex:!0,cpuKernelImpl:TY}),eie={kernelName:XC,backendName:"webgl",kernelFunc:IF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TF(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{logits:cu}=nu,{dim:hu}=lu,pu=Wu([hu],cu.shape),mu=wF({inputs:{x:cu},backend:ru,attrs:{reductionIndices:pu,keepDims:!1}}),Au=j0(mu.shape,pu),bu=Cm({inputs:{x:mu},backend:ru,attrs:{shape:Au}}),Cu=IF({inputs:{a:cu,b:bu},backend:ru}),wu=AF({inputs:{x:Cu},backend:ru}),Eu=P2({inputs:{x:wu},backend:ru,attrs:{axis:pu,keepDims:!1}}),Tu=Cm({inputs:{x:Eu},backend:ru,attrs:{shape:Au}}),Ru=EF({inputs:{a:wu,b:Tu},backend:ru});return ru.disposeIntermediateTensorInfo(mu),ru.disposeIntermediateTensorInfo(bu),ru.disposeIntermediateTensorInfo(Cu),ru.disposeIntermediateTensorInfo(wu),ru.disposeIntermediateTensorInfo(Eu),ru.disposeIntermediateTensorInfo(Tu),Ru}const tie={kernelName:EE,backendName:"webgl",kernelFunc:TF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{logits:cu}=nu,{numSamples:hu,seed:pu,normalized:mu}=lu,Au=mu?cu:TF({inputs:{logits:cu},backend:ru,attrs:{dim:cu.shape.length-1}}),bu=Au.shape[0],Cu=Au.shape[1],wu=new qne(bu,Cu,hu),Eu=[[pu]],Tu=ru.runWebGLProgram(wu,[Au],"int32",Eu);return mu||ru.disposeIntermediateTensorInfo(Au),Tu}const iie={kernelName:M_,backendName:"webgl",kernelFunc:nie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rie=gx+`
  return -x;
`,sie=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function oie(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;if(ru.shouldExecuteOnCPU([lu])){const hu=ru.texData.get(lu.dataId),[pu,mu]=lY(hu.values,lu.shape,lu.dtype);return ru.makeTensorInfo(mu,lu.dtype,pu)}let cu;return cp().getBool("WEBGL_PACK_UNARY_OPERATIONS")?cu=new Ov(lu.shape,sie):cu=new Zx(lu.shape,rie),ru.runWebGLProgram(cu,[lu],lu.dtype)}const aie={kernelName:aE,backendName:"webgl",kernelFunc:oie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lie=dI;function cie(ou){Xy("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:nu,backend:ru,attrs:lu}=ou,{boxes:cu,scores:hu}=nu,{maxOutputSize:pu,iouThreshold:mu,scoreThreshold:Au}=lu,bu=ru.readSync(cu.dataId),Cu=ru.readSync(hu.dataId),{selectedIndices:wu}=lie(bu,Cu,pu,mu,Au);return ru.makeTensorInfo([wu.length],"int32",new Int32Array(wu))}const uie={kernelName:nS,backendName:"webgl",kernelFunc:cie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hie=pI;function die(ou){Xy("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:nu,backend:ru,attrs:lu}=ou,{boxes:cu,scores:hu}=nu,{maxOutputSize:pu,iouThreshold:mu,scoreThreshold:Au,padToMaxOutputSize:bu}=lu,Cu=ru.readSync(cu.dataId),wu=ru.readSync(hu.dataId),{selectedIndices:Eu,validOutputs:Tu}=hie(Cu,wu,pu,mu,Au,bu);return[ru.makeTensorInfo([Eu.length],"int32",new Int32Array(Eu)),ru.makeTensorInfo([],"int32",new Int32Array([Tu]))]}const pie={kernelName:iS,backendName:"webgl",kernelFunc:die};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fie=fI;function mie(ou){Xy("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:nu,backend:ru,attrs:lu}=ou,{boxes:cu,scores:hu}=nu,{maxOutputSize:pu,iouThreshold:mu,scoreThreshold:Au,softNmsSigma:bu}=lu,Cu=ru.readSync(cu.dataId),wu=ru.readSync(hu.dataId),Eu=pu,Tu=mu,Ru=Au,Nu=bu,{selectedIndices:Pu,selectedScores:Fu}=fie(Cu,wu,Eu,Tu,Ru,Nu);return[ru.makeTensorInfo([Pu.length],"int32",new Int32Array(Pu)),ru.makeTensorInfo([Fu.length],"float32",new Float32Array(Fu))]}const gie={kernelName:rS,backendName:"webgl",kernelFunc:mie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Aie{constructor(nu,ru,lu,cu){this.variableNames=["indices"],this.outputShape=[nu,ru],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${cu}), float(${lu}),
                      float(index == coords.y)));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yie={kernelName:uE,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{indices:cu}=nu,{dtype:hu,depth:pu,onValue:mu,offValue:Au}=lu,bu=Mu(cu.shape),Cu=new Aie(bu,pu,mu,Au),wu=Cm({inputs:{x:cu},backend:ru,attrs:{shape:[bu]}}),Eu=ru.runWebGLProgram(Cu,[wu],hu);ru.disposeIntermediateTensorInfo(wu);const Tu=[...cu.shape,pu],Ru=Cm({inputs:{x:Eu},backend:ru,attrs:{shape:Tu}});return ru.disposeIntermediateTensorInfo(Eu),Ru}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function z2(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;if(lu.dtype==="complex64"){const cu=Vw({inputs:{input:lu},backend:ru}),hu=z2({inputs:{x:cu},backend:ru}),pu=$2({inputs:{input:lu},backend:ru}),mu=z2({inputs:{x:pu},backend:ru}),Au=Uv({inputs:{real:hu,imag:mu},backend:ru});return ru.disposeIntermediateTensorInfo(cu),ru.disposeIntermediateTensorInfo(hu),ru.disposeIntermediateTensorInfo(pu),ru.disposeIntermediateTensorInfo(mu),Au}else return Hw({attrs:{shape:lu.shape,dtype:lu.dtype,value:lu.dtype==="string"?"":0},backend:ru})}const bie={kernelName:TE,backendName:"webgl",kernelFunc:z2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _F(ou){const{inputs:nu,backend:ru}=ou,{x:lu}=nu;if(lu.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(lu.dtype==="complex64"){const cu=Vw({inputs:{input:lu},backend:ru}),hu=_F({inputs:{x:cu},backend:ru}),pu=$2({inputs:{input:lu},backend:ru}),mu=z2({inputs:{x:pu},backend:ru}),Au=Uv({inputs:{real:hu,imag:mu},backend:ru});return ru.disposeIntermediateTensorInfo(cu),ru.disposeIntermediateTensorInfo(hu),ru.disposeIntermediateTensorInfo(pu),ru.disposeIntermediateTensorInfo(mu),Au}else return Hw({attrs:{shape:lu.shape,dtype:lu.dtype,value:1},backend:ru})}const xie={kernelName:cE,backendName:"webgl",kernelFunc:_F};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{axis:cu}=lu;if(nu.length===1)return i_({inputs:{input:nu[0]},backend:ru,attrs:{dim:cu}});const hu=nu[0].shape,pu=nu[0].dtype;nu.forEach(Cu=>{Su(hu,Cu.shape,"All tensors passed to stack must have matching shapes"),vu(pu===Cu.dtype,()=>"All tensors passed to stack must have matching dtypes")});const mu=[],Au=nu.map(Cu=>{const wu=i_({inputs:{input:Cu},backend:ru,attrs:{dim:cu}});return mu.push(wu),wu}),bu=oF({inputs:Au,backend:ru,attrs:{axis:cu}});return mu.forEach(Cu=>ru.disposeIntermediateTensorInfo(Cu)),bu}const Cie={kernelName:hE,backendName:"webgl",kernelFunc:vie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wie{constructor(nu,ru,lu){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=ru.map((bu,Cu)=>bu[0]+nu[Cu]+bu[1]);const cu=nu.length,hu=x0(cu),pu=ru.map(bu=>bu[0]).join(","),mu=ru.map((bu,Cu)=>bu[0]+nu[Cu]).join(","),Au=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,cu);if(cu===1){this.userCode=`
        int start = ${pu};
        int end = ${mu};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${hu} start = ${hu}(${pu});
      ${hu} end = ${hu}(${mu});

      void main() {
        ${hu} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${hu} coords = outC - start;
          setOutput(getX(${Au}));
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Eie{constructor(nu,ru,lu){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=ru.map((Nu,Pu)=>Nu[0]+nu[Pu]+Nu[1]);const cu=nu.length,hu=x0(cu),pu=ru.map(Nu=>Nu[0]).join(","),mu=ru.map((Nu,Pu)=>Nu[0]+nu[Pu]).join(","),Au=Sy("rc",cu),bu=Sy("source",cu),Cu=`${Au[cu-1]} < ${this.outputShape[cu-1]}`,wu=cu===1?"source":`vec2(${bu.slice(-2).join()})`,Eu=[`${hu} rc = outputLoc;`,`${Au[cu-1]} += 1;
       if(${Cu}) {
      `,cu===1?"":`}
       rc = outputLoc;
       ${Au[cu-2]} += 1;
       if(${Au[cu-2]} < ${this.outputShape[cu-2]}) {`,cu===1?"":`  ${Au[cu-1]} += 1;
         if(${Cu}) {`],Tu=cu===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let Ru="";for(let Nu=0,Pu=cu===1?2:4;Nu<Pu;Nu++)Ru+=`
        ${Eu[Nu]}
        if (${Tu}) {
          result[${Nu}] = float(value);
        } else {
          ${hu} source = rc - start;
          result[${Nu}] = getChannel(getX(${bu.join()}), ${wu});
        }
      `;Ru+=cu===1?"} ":"}}",this.userCode=`
      const ${hu} start = ${hu}(${pu});
      const ${hu} end = ${hu}(${mu});

      void main() {
        ${hu} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${Ru}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MF=ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{paddings:hu,constantValue:pu}=lu;if(Mu(cu.shape)===0){const bu=hu.map((Cu,wu)=>Cu[0]+cu.shape[wu]+Cu[1]);return Hw({backend:ru,attrs:{shape:bu,value:pu,dtype:cu.dtype}})}const mu=cp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Eie(cu.shape,hu,pu):new wie(cu.shape,hu,pu),Au=[[pu]];return ru.runWebGLProgram(mu,[cu],cu.dtype,Au)},Sie={kernelName:dE,backendName:"webgl",kernelFunc:MF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Iie=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Tie=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+_1+`
  return result;
`,_ie=my({opSnippet:Iie,packedOpSnippet:Tie}),Mie={kernelName:BC,backendName:"webgl",kernelFunc:_ie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{axis:hu,keepDims:pu}=lu,mu=cu.shape.length,Au=[],bu=Wu(hu,cu.shape);let Cu=bu;const wu=G0(Cu,mu);let Eu=cu;wu!=null&&(Eu=Iy({inputs:{x:cu},backend:ru,attrs:{perm:wu}}),Cu=H0(Cu.length,mu),Au.push(Eu)),dy("prod",Cu,mu);let Tu;if(ru.shouldExecuteOnCPU([Eu])){const Ru=ru.texData.get(Eu.dataId).values,{outVals:Nu,outShape:Pu,outDtype:Fu}=uY(Eu.shape,Eu.dtype,Ru,Cu);Tu=ru.makeTensorInfo(Pu,Fu,Nu)}else{const[Ru,Nu]=oy(Eu.shape,Cu),Pu=Mu(Nu),Fu=Cm({inputs:{x:Eu},backend:ru,attrs:{shape:[-1,Pu]}}),Gu=TS(cu.dtype),Xu=M1(Fu,Gu,"prod",ru);Tu=Cm({inputs:{x:Xu},backend:ru,attrs:{shape:Ru}}),Au.push(Fu),Au.push(Xu)}if(pu){Au.push(Tu);const Ru=j0(Tu.shape,bu);Tu=Cm({inputs:{x:Tu},backend:ru,attrs:{shape:Ru}})}return Au.forEach(Ru=>ru.disposeIntermediateTensorInfo(Ru)),Tu}const kie={kernelName:fE,backendName:"webgl",kernelFunc:Rie};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{paramsNestedSplits:cu,paramsDenseValues:hu,indices:pu}=nu,{outputRaggedRank:mu}=lu,Au=cu.map(Fu=>ru.readSync(Fu.dataId)),bu=cu.map(Fu=>Fu.shape),Cu=ru.readSync(hu.dataId),wu=ru.readSync(pu.dataId),[Eu,Tu,Ru]=hY(Au,bu,Cu,hu.shape,hu.dtype,wu,pu.shape,mu),Nu=Eu.map(Fu=>ru.makeTensorInfo([Fu.length],"int32",Fu)),Pu=ru.makeTensorInfo(Ru,hu.dtype,Tu);return Nu.concat([Pu])}const Lie={kernelName:R_,backendName:"webgl",kernelFunc:Bie};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nie(ou){const{inputs:nu,backend:ru}=ou,{starts:lu,limits:cu,deltas:hu}=nu,pu=ru.readSync(lu.dataId),mu=ru.readSync(cu.dataId),Au=ru.readSync(hu.dataId),[bu,Cu]=dY(pu,lu.shape,lu.dtype,mu,cu.shape,Au,hu.shape),wu=ru.makeTensorInfo([bu.length],"int32",bu),Eu=ru.makeTensorInfo([Cu.length],lu.dtype,Cu);return[wu,Eu]}const Die={kernelName:k_,backendName:"webgl",kernelFunc:Nie};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{shape:cu,values:hu,defaultValue:pu,rowPartitionTensors:mu}=nu,{rowPartitionTypes:Au}=lu,bu=ru.readSync(cu.dataId),Cu=ru.readSync(hu.dataId),wu=ru.readSync(pu.dataId),Eu=mu.map(Pu=>ru.readSync(Pu.dataId)),Tu=mu.map(Pu=>Pu.shape),[Ru,Nu]=pY(bu,cu.shape,Cu,hu.shape,hu.dtype,wu,pu.shape,Eu,Tu,Au);return ru.makeTensorInfo(Ru,hu.dtype,Nu)}const Pie={kernelName:B_,backendName:"webgl",kernelFunc:Fie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RF=ou=>{const{backend:nu,attrs:ru}=ou,{start:lu,stop:cu,step:hu,dtype:pu}=ru,mu=fY(lu,cu,hu,pu);return nu.makeTensorInfo([mu.length],pu,mu)},Gie={kernelName:sS,backendName:"webgl",kernelFunc:RF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Oie=u0({opSnippet:"return 1.0 / x;"}),Uie={kernelName:LC,backendName:"webgl",kernelFunc:Oie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $ie=gx+`
  return (x < 0.0) ? 0.0 : x;
`,Vie=u0({opSnippet:$ie,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),zie={kernelName:NC,backendName:"webgl",kernelFunc:Vie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wie=gx+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Hie=u0({opSnippet:Wie,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Xie={kernelName:DC,backendName:"webgl",kernelFunc:Hie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Qie{constructor(nu,ru,lu,cu,hu){this.variableNames=["A"],this.outputShape=[];const[pu,mu,Au,bu]=nu;this.outputShape=[pu,ru,lu,bu];const Cu=[cu&&ru>1?mu-1:mu,cu&&lu>1?Au-1:Au],wu=[cu&&ru>1?ru-1:ru,cu&&lu>1?lu-1:lu];let Eu;hu?Eu="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":Eu="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${Cu[0]/wu[0]},
          ${Cu[1]/wu[1]});
      const vec2 inputShapeRC = vec2(${mu}.0, ${Au}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${Eu};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Kie{constructor(nu,ru,lu,cu,hu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[pu,mu,Au,bu]=nu;this.outputShape=[pu,ru,lu,bu];const Cu=[cu&&ru>1?mu-1:mu,cu&&lu>1?Au-1:Au],wu=[cu&&ru>1?ru-1:ru,cu&&lu>1?lu-1:lu];let Eu;hu?Eu="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":Eu="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${Cu[0]/wu[0]},
          ${Cu[1]/wu[1]},
          ${Cu[1]/wu[1]});
      const vec3 inputShapeRC = vec3(${mu}.0, ${Au}.0,
                                     ${Au}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${Eu};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${bu-1};
        bool hasNextRow = coords.z < ${lu-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu}=nu,{alignCorners:hu,halfPixelCenters:pu,size:mu}=lu,[Au,bu]=mu,Cu=cp().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Kie(cu.shape,Au,bu,hu,pu):new Qie(cu.shape,Au,bu,hu,pu);return ru.runWebGLProgram(Cu,[cu],"float32")}const jie={kernelName:AE,backendName:"webgl",kernelFunc:Zie};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Yie{constructor(nu,ru,lu){this.variableNames=["dy"],this.outputShape=[],this.outputShape=ru;const[,cu,hu]=ru,[,pu,mu]=nu,Au=[lu&&pu>1?cu-1:cu,lu&&mu>1?hu-1:hu],bu=[lu&&pu>1?pu-1:pu,lu&&mu>1?mu-1:mu],Cu=Au[0]/bu[0],wu=Au[1]/bu[1],Eu=1/Cu,Tu=1/wu,Ru=Math.ceil(Eu)*2+2,Nu=Math.ceil(Tu)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${Cu});
        const float widthScale = float(${wu});

        const float invHeightScale = float(${Eu});
        const float invWidthScale = float(${Tu});

        const int winHeight = int(${Ru});
        const int winWidth = int(${Nu});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${pu}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${mu}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${cu-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${hu-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qie(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu,dy:hu}=nu,{alignCorners:pu}=lu,mu=new Yie(hu.shape,cu.shape,pu);return ru.runWebGLProgram(mu,[hu],hu.dtype)}const Jie={kernelName:lS,backendName:"webgl",kernelFunc:qie};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ere{constructor(nu,ru,lu,cu,hu){this.variableNames=["A"],this.outputShape=[];const[pu,mu,Au,bu]=nu;this.outputShape=[pu,ru,lu,bu];const Cu=[cu&&ru>1?mu-1:mu,cu&&lu>1?Au-1:Au],wu=[cu&&ru>1?ru-1:ru,cu&&lu>1?lu-1:lu],Eu=cu?"0.5":"0.0";let Tu;hu?Tu="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":Tu="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${Cu[0]/wu[0]},
          ${Cu[1]/wu[1]});
      const vec2 inputShapeRC = vec2(${mu}.0, ${Au}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${Tu};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${Eu})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class tre{constructor(nu,ru,lu,cu,hu){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[pu,mu,Au,bu]=nu;this.outputShape=[pu,ru,lu,bu];const Cu=[cu&&ru>1?mu-1:mu,cu&&lu>1?Au-1:Au],wu=[cu&&ru>1?ru-1:ru,cu&&lu>1?lu-1:lu],Eu=cu?"0.5":"0.0";let Tu;hu?Tu="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":Tu="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${Cu[0]/wu[0]},
          ${Cu[1]/wu[1]},
          ${Cu[1]/wu[1]});
      const vec3 inputShapeRC = vec3(${mu}.0, ${Au}.0,
                                     ${Au}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${Tu};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${Eu})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${bu-1};
        bool hasNextRow = coords.z < ${lu-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu}=nu,{alignCorners:hu,halfPixelCenters:pu,size:mu}=lu,[Au,bu]=mu,Cu=cp().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tre(cu.shape,Au,bu,hu,pu):new ere(cu.shape,Au,bu,hu,pu);return ru.runWebGLProgram(Cu,[cu],cu.dtype)}const ire={kernelName:gE,backendName:"webgl",kernelFunc:nre};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class rre{constructor(nu,ru,lu){this.variableNames=["dy"],this.outputShape=[],this.outputShape=ru;const[,cu,hu]=ru,[,pu,mu]=nu,Au=[lu&&pu>1?cu-1:cu,lu&&mu>1?hu-1:hu],bu=[lu&&pu>1?pu-1:pu,lu&&mu>1?mu-1:mu],Cu=Au[0]/bu[0],wu=Au[1]/bu[1],Eu=1/Cu,Tu=1/wu,Ru=Math.ceil(Eu)*2+2,Nu=Math.ceil(Tu)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${Cu});
        const float widthScale = float(${wu});

        const float invHeightScale = float(${Eu});
        const float invWidthScale = float(${Tu});

        const int winHeight = int(${Ru});
        const int winWidth = int(${Nu});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${pu}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${mu}) {
              continue;
            }

            float sourceFracRow =
              float(${Au[0]}) *
                (float(dyR) / float(${bu[0]}));

            float sourceFracCol =
                float(${Au[1]}) *
                  (float(dyC) / float(${bu[1]}));

            int sourceNearestRow = int(min(
                float(int(${cu}) - 1),
                ${lu} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${hu}) - 1),
                ${lu} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{images:cu,dy:hu}=nu,{alignCorners:pu}=lu,mu=new rre(hu.shape,cu.shape,pu);return ru.runWebGLProgram(mu,[hu],hu.dtype)}const ore={kernelName:aS,backendName:"webgl",kernelFunc:sre};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class are{constructor(nu,ru){this.variableNames=["x"];const lu=nu.length;if(lu>4)throw new Error(`WebGL backend: Reverse of rank-${lu} tensor is not yet supported`);if(this.outputShape=nu,lu===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${nu[0]} - coord - 1));
        }
      `;return}const cu=mu=>ru.indexOf(mu)!==-1&&nu[mu]!==1?`${nu[mu]} - coords[${mu}] - 1`:`coords[${mu}]`,hu=nu.map((mu,Au)=>cu(Au)).join(","),pu=x0(lu);this.userCode=`
      void main() {
        ${pu} coords = getOutputCoords();
        setOutput(getX(${hu}));
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lre{constructor(nu,ru){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const lu=nu.length;if(lu>4)throw new Error(`WebGL backend: Reverse of rank-${lu} tensor is not yet supported`);this.outputShape=nu;const cu=Sy("rc",lu),hu=`${cu[lu-1]} + 1 < ${this.outputShape[lu-1]}`,pu=`${cu[lu-2]} + 1 < ${this.outputShape[lu-2]}`,mu=x0(lu);lu===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${nu[0]} - rc - 1),
            ${nu[0]} - rc - 1);
          if(${hu}){
              result.g = getChannel(getX(${nu[0]} - (rc  + 1) - 1),
                ${nu[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${mu} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${Au(cu.slice())};
          if(${hu}){
            result.g = ${bu(cu.slice())};
          }
          if(${pu}) {
            result.b = ${Cu(cu.slice())};
            if(${hu}) {
              result.a = ${wu(cu.slice())};
            }
          }
          setOutput(result);
        }
    `;function Au(Ru){return Eu(Ru)}function bu(Ru){return Ru[lu-1]="("+Ru[lu-1]+" + 1)",Eu(Ru)}function Cu(Ru){return Ru[lu-2]="("+Ru[lu-2]+" + 1)",Eu(Ru)}function wu(Ru){return Ru[lu-1]="("+Ru[lu-1]+" + 1)",Ru[lu-2]="("+Ru[lu-2]+" + 1)",Eu(Ru)}function Eu(Ru){const Nu=nu.map((Gu,Xu)=>Tu(Xu,Ru)),Pu=Nu.join(","),Fu=Nu.slice(-2).join(",");return`getChannel(getX(${Pu}), vec2(${Fu}))`}function Tu(Ru,Nu){return ru.indexOf(Ru)!==-1&&nu[Ru]!==1?`${nu[Ru]} - ${Nu[Ru]} - 1`:`${Nu[Ru]}`}}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{dims:hu}=lu,pu=cu.shape.length,mu=Wu(hu,cu.shape);if(pu===0)return Wy({inputs:{x:cu},backend:ru});const Au=cp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lre(cu.shape,mu):new are(cu.shape,mu);return ru.runWebGLProgram(Au,[cu],cu.dtype)}const ure={kernelName:yE,backendName:"webgl",kernelFunc:cre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hre{constructor(nu,ru){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const lu=nu[1],cu=nu[2];this.outputShape=nu;let hu="";typeof ru=="number"?hu=`float outputValue = ${ru.toFixed(2)};`:hu=`
        vec3 fill = vec3(${ru.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${hu}
          if(coordX >= 0 && coordX < ${cu} && coordY >= 0 && coordY < ${lu}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dre={kernelName:gS,backendName:"webgl",kernelFunc:({inputs:ou,attrs:nu,backend:ru})=>{const{image:lu}=ou,{radians:cu,fillValue:hu,center:pu}=nu,mu=ru,Au=new hre(lu.shape,hu),[bu,Cu]=II(pu,lu.shape[1],lu.shape[2]),wu=[[bu,Cu,Math.sin(cu),Math.cos(cu)]];return mu.runWebGLProgram(Au,[lu],lu.dtype,wu)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pre=u0({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),fre={kernelName:FC,backendName:"webgl",kernelFunc:pre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mre=u0({opSnippet:"return inversesqrt(x);",cpuKernelImpl:mY}),gre={kernelName:PC,backendName:"webgl",kernelFunc:mre};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class s_{constructor(nu,ru,lu,cu,hu,pu,mu=!0,Au=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=pu;const bu=x0(hu.length),Cu=x0(pu.length);let wu="";lu===1?wu="i":lu===2&&(wu="i, j");const Eu=`getIndices(${wu})`;let Tu="";cu===1?Tu="i":cu===2&&(Tu="i, coords[1]");const Ru=`getUpdates(${Tu})`;let Nu="";Au&&(Nu="coords[0], coords[1]");const Pu=`getDefaultValue(${Nu})`,Fu=ru>1?"strides[j]":"strides";this.userCode=`
        ${bu} strides = ${bu}(${hu});

        void main() {
          ${Cu} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${nu}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${ru}; j++) {
              int index = round(${Eu});
              flattenedIndex += index * ${Fu};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${Ru};
              found = true;
            }
          }
          setOutput(mix(${Pu}, sum, float(found)));
        }
      `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Are{constructor(nu,ru,lu,cu,hu,pu,mu=!0,Au=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=pu;const bu=x0(hu.length),Cu=x0(pu.length);let wu="";lu===1?wu="i":lu===2&&(wu="i, j");const Eu=`getIndices(${wu})`;let Tu="";cu===1?Tu="i":cu===2&&(Tu="i, coords[1]");const Ru=`getUpdates(${Tu})`;let Nu="";Au&&(Nu="coords[0], coords[1]");const Pu=`getDefaultValue(${Nu})`,Fu=ru>1?"strides[j]":"strides",Gu=ru>1?"strides[j + 1]":"strides";this.userCode=`
        ${bu} strides = ${bu}(${hu});

        void main() {
          ${Cu} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${nu}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${ru}; j+=2) {
              ivec4 index = round(${Eu});
              flattenedIndex += index.xz * ${Fu};
              if (j + 1 < ${ru}) {
                flattenedIndex += index.yw * ${Gu};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${Ru};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${Pu}, sum, found));
        }
      `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{indices:cu,updates:hu}=nu,{shape:pu}=lu,{sliceRank:mu,numUpdates:Au,sliceSize:bu,strides:Cu,outputSize:wu}=h1(hu,cu,pu),Eu=[wu/bu,bu];if(wu===0)return ru.makeTensorInfo(pu,cu.dtype);const Tu=Cm({inputs:{x:cu},backend:ru,attrs:{shape:[Au,mu]}}),Ru=Cm({inputs:{x:hu},backend:ru,attrs:{shape:[Au,bu]}}),Nu=ru.makeTensorInfo([],"float32",new Float32Array([0]));let Pu;cp().getBool("WEBGL_PACK")?Pu=new Are(Au,mu,Tu.shape.length,Ru.shape.length,Cu,Eu):Pu=new s_(Au,mu,Tu.shape.length,Ru.shape.length,Cu,Eu);const Fu=ru.runWebGLProgram(Pu,[Ru,Tu,Nu],Ru.dtype),Gu=Cm({inputs:{x:Fu},backend:ru,attrs:{shape:pu}});return ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),ru.disposeIntermediateTensorInfo(Fu),ru.disposeIntermediateTensorInfo(Nu),Gu}const bre={kernelName:L_,backendName:"webgl",kernelFunc:yre};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class xre{constructor(nu,ru,lu,cu){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[nu,lu];const hu="while (left < right) {",pu=`for (int i = 0; i < ${Math.ceil(Math.log2(ru+1))}; ++i) { if (left >= right) break;`,mu=cp().getNumber("WEBGL_VERSION")===2?hu:pu,Au=cu==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${mu}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${Au} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{sortedSequence:cu,values:hu}=nu,{side:pu}=lu,mu=new xre(cu.shape[0],cu.shape[1],hu.shape[1],pu),Au=[[cu.shape[1]]];return ru.runWebGLProgram(mu,[cu,hu],"int32",Au)}const Cre={kernelName:D_,backendName:"webgl",kernelFunc:vre};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wre{constructor(nu,ru,lu){this.variableNames=["c","a","b"],this.outputShape=ru;let cu,hu;if(lu>4)throw Error(`Where for rank ${lu} is not yet supported`);if(lu===1)hu="resRC",cu="resRC";else{const mu=["resRC.x","resRC.y","resRC.z","resRC.w"],Au=[],bu=[];for(let Cu=0;Cu<ru.length;Cu++)bu.push(`${mu[Cu]}`),Cu<nu&&Au.push(`${mu[Cu]}`);cu=Au.join(),hu=bu.join()}const pu=x0(lu);this.userCode=`
      void main() {
        ${pu} resRC = getOutputCoords();
        float cVal = getC(${cu});
        if (cVal >= 1.0) {
          setOutput(getA(${hu}));
        } else {
          setOutput(getB(${hu}));
        }
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ere(ou){const{inputs:nu,backend:ru}=ou,{condition:lu,t:cu,e:hu}=nu,pu=new wre(lu.shape.length,cu.shape,cu.shape.length);return ru.runWebGLProgram(pu,[lu,cu,hu],Uy(cu.dtype,hu.dtype))}const Sre={kernelName:bE,backendName:"webgl",kernelFunc:Ere};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ire=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${ZE};
  float scale = ${jE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Tre=u0({opSnippet:Ire}),_re={kernelName:GC,backendName:"webgl",kernelFunc:Tre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Mre=AC+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Rre=u0({opSnippet:Mre,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:AY}),kre={kernelName:VC,backendName:"webgl",kernelFunc:Rre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bre=u0({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),Lre={kernelName:$C,backendName:"webgl",kernelFunc:Bre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nre=AC+`
  return sin(x);
`,Dre=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${_1}
  return result;
`,Fre=u0({opSnippet:Nre,packedOpSnippet:Dre}),Pre={kernelName:OC,backendName:"webgl",kernelFunc:Fre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gre=u0({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),Ore={kernelName:UC,backendName:"webgl",kernelFunc:Gre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ure=u0({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),$re={kernelName:zC,backendName:"webgl",kernelFunc:Ure};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Vre={kernelName:CE,backendName:"webgl",kernelFunc:ou=>{const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{blockShape:hu,paddings:pu}=lu;vu(cu.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const mu=hu.reduce((Fu,Gu)=>Fu*Gu),Au=[[0,0]];Au.push(...pu);for(let Fu=1+hu.length;Fu<cu.shape.length;++Fu)Au.push([0,0]);const bu=[],Cu=MF({inputs:{x:cu},backend:ru,attrs:{paddings:Au,constantValue:0}}),wu=fw(Cu.shape,hu,mu,!1),Eu=mw(wu.length,hu.length,!1),Tu=gw(Cu.shape,hu,mu,!1),Ru=Cm({inputs:{x:Cu},backend:ru,attrs:{shape:wu}}),Nu=Iy({inputs:{x:Ru},backend:ru,attrs:{perm:Eu}}),Pu=Cm({inputs:{x:Nu},backend:ru,attrs:{shape:Tu}});return bu.push(Cu),bu.push(Ru),bu.push(Nu),bu.forEach(Fu=>ru.disposeIntermediateTensorInfo(Fu)),Pu}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zre(ou){const{inputs:nu,backend:ru}=ou,{indices:lu,values:cu,denseShape:hu,defaultValue:pu}=nu;if(hu.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${hu.shape}`);if(lu.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${lu.shape}`);if(cu.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${cu.shape}`);if(pu.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${pu.shape}`);const mu=ru.readSync(lu.dataId),Au=ru.readSync(cu.dataId),bu=ru.readSync(hu.dataId),Cu=ru.readSync(pu.dataId)[0],[wu,Eu,Tu,Ru,Nu]=bY(mu,lu.shape,lu.dtype,Au,cu.dtype,bu,Cu);return[ru.makeTensorInfo(Eu,lu.dtype,wu),ru.makeTensorInfo([Eu[0]],cu.dtype,Tu),ru.makeTensorInfo([Ru.length],"bool",new Uint8Array(Ru.map(Pu=>Number(Pu)))),ru.makeTensorInfo([Nu.length],lu.dtype,new Int32Array(Nu))]}const Wre={kernelName:F_,backendName:"webgl",kernelFunc:zre};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Hre(ou){const{inputs:nu,backend:ru}=ou,{inputIndices:lu,inputShape:cu,newShape:hu}=nu;if(lu.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${lu.shape}`);if(cu.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${cu.shape}`);if(hu.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${hu.shape}`);const pu=Array.from(ru.readSync(cu.dataId)),mu=ru.readSync(lu.dataId),Au=Array.from(ru.readSync(hu.dataId)),[bu,Cu,wu]=xY(mu,lu.shape,lu.dtype,pu,Au);return[ru.makeTensorInfo(Cu,lu.dtype,bu),ru.makeTensorInfo([wu.length],hu.dtype,new Int32Array(wu))]}const Xre={kernelName:P_,backendName:"webgl",kernelFunc:Hre};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Qre(ou){const{inputs:nu,backend:ru}=ou,{data:lu,indices:cu,segmentIds:hu}=nu;if(lu.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(cu.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${cu.shape}`);if(hu.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${hu.shape}`);const pu=ru.readSync(lu.dataId),mu=ru.readSync(cu.dataId),Au=ru.readSync(hu.dataId),[bu,Cu]=DD(pu,lu.shape,lu.dtype,mu,Au,!0);return ru.makeTensorInfo(Cu,lu.dtype,bu)}const Kre={kernelName:G_,backendName:"webgl",kernelFunc:Qre};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zre(ou){const{inputs:nu,backend:ru}=ou,{data:lu,indices:cu,segmentIds:hu}=nu;if(lu.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(cu.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${cu.shape}`);if(hu.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${hu.shape}`);const pu=ru.readSync(lu.dataId),mu=ru.readSync(cu.dataId),Au=ru.readSync(hu.dataId),[bu,Cu]=DD(pu,lu.shape,lu.dtype,mu,Au);return ru.makeTensorInfo(Cu,lu.dtype,bu)}const jre={kernelName:O_,backendName:"webgl",kernelFunc:Zre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{sparseIndices:cu,sparseValues:hu,defaultValue:pu}=nu,{outputShape:mu}=lu,{sliceRank:Au,numUpdates:bu,sliceSize:Cu,strides:wu,outputSize:Eu}=h1(hu,cu,mu),Tu=!1;if(hu.dtype==="string"){const Fu=ru.bufferSync(cu),Gu=ru.bufferSync(hu),Xu=xv(ru.readSync(pu.dataId)[0]),Qu=gY(Fu,Gu,mu,Eu,Cu,bu,Au,wu,Xu,Tu);return ru.makeTensorInfo(mu,Qu.dtype,Qu.values)}const Ru=new s_(bu,Au,cu.shape.length,hu.shape.length,wu,[Eu,1],Tu),Nu=ru.runWebGLProgram(Ru,[hu,cu,pu],hu.dtype),Pu=Cm({inputs:{x:Nu},backend:ru,attrs:{shape:mu}});return ru.disposeIntermediateTensorInfo(Nu),Pu}const qre={kernelName:U_,backendName:"webgl",kernelFunc:Yre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Jre(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{numOrSizeSplits:hu,axis:pu}=lu,mu=Wu(pu,cu.shape)[0],Au=VI(cu,hu,mu),bu=cu.shape.length,Cu=new Array(bu).fill(0),wu=cu.shape.slice();return Au.map(Eu=>{const Tu=[...wu];Tu[mu]=Eu;const Ru=yC({inputs:{x:cu},backend:ru,attrs:{begin:Cu,size:Tu}});return Cu[mu]+=Eu,Ru})}const ese={kernelName:wE,backendName:"webgl",kernelFunc:Jre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kF="return sqrt(x);",tse=u0({opSnippet:kF,packedOpSnippet:kF,cpuKernelImpl:vY}),nse={kernelName:WC,backendName:"webgl",kernelFunc:tse};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ise=u0({opSnippet:"return x * x;"}),rse={kernelName:cS,backendName:"webgl",kernelFunc:ise};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BF="return (a - b) * (a - b);",sse=my({opSnippet:BF,packedOpSnippet:BF}),ose={kernelName:HC,backendName:"webgl",kernelFunc:sse};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ase(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu;if(cu.dtype!=="string")throw new Error("Input must be of datatype string");const hu=ru.readSync(cu.dataId),pu=ov(hu),mu=CY(pu,"string",lu);return ru.makeTensorInfo(cu.shape,"string",mu)}const lse={kernelName:uS,backendName:"webgl",kernelFunc:ase};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cse({inputs:ou,attrs:nu,backend:ru}){const{x:lu}=ou,cu=gx+`
    return x > 0.0 ? 1.0 : float(${nu.alpha});
  `,hu=new Zx(lu.shape,cu);return ru.runWebGLProgram(hu,[lu],lu.dtype)}const use={kernelName:jC,backendName:"webgl",kernelFunc:cse};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hse{constructor(nu,ru,lu){this.variableNames=["x"],this.outputShape=lu;const cu=lu.length,hu=x0(lu.length),pu=x0(lu.length);let mu="";if(cu===1)mu="coords * strides + begin";else{let Au=0;mu=lu.map((bu,Cu)=>(Au++,lu.length===1?`coords * strides[${Cu}] + begin[${Cu}]`:`coords[${Au-1}] * strides[${Cu}] + begin[${Cu}]`)).join(",")}this.userCode=`
      ${hu} begin = ${hu}(${nu});
      ${hu} strides = ${hu}(${ru});

      void main() {
        ${pu} coords = getOutputCoords();
        setOutput(getX(${mu}));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{begin:hu,end:pu,strides:mu,beginMask:Au,endMask:bu,ellipsisMask:Cu,newAxisMask:wu,shrinkAxisMask:Eu}=lu,{finalShapeSparse:Tu,finalShape:Ru,isIdentity:Nu,sliceDim0:Pu,isSimpleSlice:Fu,begin:Gu,end:Xu,strides:Qu}=wI(cu.shape,hu,pu,mu,Au,bu,Cu,wu,Eu);let Ju;if(Nu)Ju=Cm({inputs:{x:cu},backend:ru,attrs:{shape:Ru}});else if(Pu||Fu){vu(cu.shape.length>=1,()=>`Input must have rank at least 1, got: ${cu.shape.length}`);const rp=xI(Gu,Xu,Qu),op=yC({inputs:{x:cu},backend:ru,attrs:{begin:Gu,size:rp}});Ju=Cm({inputs:{x:op},backend:ru,attrs:{shape:Ru}}),ru.disposeIntermediateTensorInfo(op)}else if(ru.shouldExecuteOnCPU([cu])){const rp=ru.readSync(cu.dataId),op=t0(cu.shape,cu.dtype,rp),hp=wY(Tu,op,Qu,Gu);Ju=ru.makeTensorInfo(Ru,cu.dtype,hp.values)}else{const rp=new hse(Gu,Qu,Tu);Ju=ru.runWebGLProgram(rp,[cu],cu.dtype)}const ip=Cm({inputs:{x:Ju},backend:ru,attrs:{shape:Ru}});return ru.disposeIntermediateTensorInfo(Ju),ip}const pse={kernelName:hS,backendName:"webgl",kernelFunc:dse};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{separator:cu,nGramWidths:hu,leftPad:pu,rightPad:mu,padWidth:Au,preserveShortSequences:bu}=lu,{data:Cu,dataSplits:wu}=nu,Eu=ru.readSync(Cu.dataId),Tu=ru.readSync(wu.dataId),[Ru,Nu]=EY(Eu,Tu,cu,hu,pu,mu,Au,bu);return[ru.makeTensorInfo([Ru.length],"string",Ru),ru.makeTensorInfo(wu.shape,"int32",Nu)]}const mse={kernelName:$_,backendName:"webgl",kernelFunc:fse};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{skipEmpty:cu}=lu,{input:hu,delimiter:pu}=nu;if(hu.dtype!=="string")throw new Error("Input must be of datatype string");if(hu.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${hu.shape}`);if(pu.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${pu.shape}`);const mu=ru.readSync(hu.dataId),Au=ru.readSync(pu.dataId)[0],[bu,Cu,wu]=SY(mu,Au,cu),Eu=Cu.length;return[ru.makeTensorInfo([Eu,2],"int32",bu),ru.makeTensorInfo([Eu],"string",Cu),ru.makeTensorInfo([2],"int32",new Int32Array(wu))]}const Ase={kernelName:V_,backendName:"webgl",kernelFunc:gse};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{numBuckets:cu}=lu,{input:hu}=nu;if(hu.dtype!=="string")throw new Error("Input must be of datatype string");if(cu<=0)throw new Error("Number of buckets must be at least 1");const pu=ru.readSync(hu.dataId),mu=IY(pu,cu);return ru.makeTensorInfo(hu.shape,"int32",mu)}const bse={kernelName:z_,backendName:"webgl",kernelFunc:yse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xse=u0({opSnippet:"return tan(x);"}),vse={kernelName:QC,backendName:"webgl",kernelFunc:xse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Cse=u0({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),wse={kernelName:KC,backendName:"webgl",kernelFunc:Cse};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ese(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{tensor:cu,indices:hu,updates:pu}=nu,{sliceRank:mu,numUpdates:Au,sliceSize:bu,strides:Cu,outputSize:wu}=h1(pu,hu,cu.shape),Eu=[wu/bu,bu];if(wu===0)return ru.makeTensorInfo(cu.shape,hu.dtype);const Tu=Cm({inputs:{x:hu},backend:ru,attrs:{shape:[Au,mu]}}),Ru=Cm({inputs:{x:pu},backend:ru,attrs:{shape:[Au,bu]}}),Nu=Cm({inputs:{x:cu},backend:ru,attrs:{shape:Eu}}),Pu=new s_(Au,mu,Tu.shape.length,Ru.shape.length,Cu,Eu,!1,!0),Fu=ru.runWebGLProgram(Pu,[Ru,Tu,Nu],Nu.dtype),Gu=Cm({inputs:{x:Fu},backend:ru,attrs:{shape:cu.shape}});return ru.disposeIntermediateTensorInfo(Tu),ru.disposeIntermediateTensorInfo(Ru),ru.disposeIntermediateTensorInfo(Nu),ru.disposeIntermediateTensorInfo(Fu),Gu}const Sse={kernelName:N_,backendName:"webgl",kernelFunc:Ese};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ise{constructor(nu,ru){this.variableNames=["A"];const lu=new Array(nu.length);for(let pu=0;pu<lu.length;pu++)lu[pu]=nu[pu]*ru[pu];this.outputShape=lu,this.rank=lu.length;const cu=x0(this.rank),hu=Tse(nu);this.userCode=`
      void main() {
        ${cu} resRC = getOutputCoords();
        setOutput(getA(${hu}));
      }
    `}}function Tse(ou){const nu=ou.length;if(nu>5)throw Error(`Tile for rank ${nu} is not yet supported`);if(nu===1)return`imod(resRC, ${ou[0]})`;const ru=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],lu=[];for(let cu=0;cu<ou.length;cu++)lu.push(`imod(${ru[cu]}, ${ou[cu]})`);return lu.join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LF(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{reps:hu}=lu;if(cu.dtype==="string"||cu.shape.length>5){const mu=ru.readSync(cu.dataId),Au=cu.dtype==="string"?mu.map(wu=>xv(wu)):mu,bu=t0(cu.shape,cu.dtype,Au),Cu=_Y(bu,hu);return ru.makeTensorInfo(Cu.shape,Cu.dtype,Cu.values)}const pu=new Ise(cu.shape,hu);return ru.runWebGLProgram(pu,[cu],cu.dtype)}const _se={kernelName:ZC,backendName:"webgl",kernelFunc:LF};class Mse{constructor(nu){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=nu,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Rse{constructor(nu){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=nu,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function R1(ou,nu){nu!==null&&ou.disposeIntermediateTensorInfo(nu)}function NF(ou){let nu=1;for(;nu<ou;)nu*=2;return nu}function kse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu}=nu,{k:hu,sorted:pu}=lu,mu=cp().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),Au=cp().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),bu=cu.shape,Cu=bu[bu.length-1];if(ru.shouldExecuteOnCPU([cu])||Cu<mu||hu>Au){const hp=ru.readSync(cu.dataId),[Ap,Up]=MY(hp,bu,cu.dtype,hu,pu);return[ru.makeTensorInfo(Ap.shape,Ap.dtype,Ap.values),ru.makeTensorInfo(Up.shape,Up.dtype,Up.values)]}if(hu===0)return bu[bu.length-1]=0,[ru.makeTensorInfo(bu,cu.dtype,[]),ru.makeTensorInfo(bu,"int32",[])];if(Cu===1)return[cu,Hw({attrs:{shape:bu,dtype:"int32",value:0},backend:ru})];const wu=ru.texData.get(cu.dataId),Eu=wu!==null&&wu.isPacked,Tu=Eu?ru.unpackTensor(cu):cu,Ru=Mu(bu)/Cu,Nu=Cm({inputs:{x:Tu},attrs:{shape:[Ru,Cu]},backend:ru});Eu&&R1(ru,Tu);const Pu=NF(hu),Fu=NF(Cu);let Gu=null;const Xu=()=>Gu===null?[Nu,Nu]:[Nu,Gu],Qu=(hp,Ap,Up)=>{const Vp=Xu(),zp=new Mse(Up),qp=[[Cu],[Gu===null?1:0],[Number.NEGATIVE_INFINITY],[hp],[Ap]],Yp=Gu;Gu=ru.runWebGLProgram(zp,Vp,"int32",qp),R1(ru,Yp)};for(let hp=1;hp<Pu;hp*=2){const Ap=hp*2;for(let Up=hp;Up>=1;Up/=2)Qu(Ap,Up,[Ru,Fu])}for(let hp=Fu;hp>Pu;hp/=2){const Ap=Xu(),Up=new Rse([Ru,hp/2]),Vp=[[Cu],[Gu===null?1:0],[Pu]],zp=Gu;Gu=ru.runWebGLProgram(Up,Ap,"int32",Vp),R1(ru,zp);const qp=Pu/2,Yp=qp*2;for(let em=qp;em>=1;em/=2)Qu(Yp,em,Gu.shape)}let Ju=Gu;Gu=yC({inputs:{x:Gu},backend:ru,attrs:{begin:0,size:[Ru,hu]}}),R1(ru,Ju);let ip=CF({inputs:{x:Nu,indices:Gu},backend:ru,attrs:{axis:1,batchDims:1}});R1(ru,Nu);const rp=bu.slice(0,-1);rp.push(hu),Ju=Gu,Gu=Cm({inputs:{x:Gu},attrs:{shape:rp},backend:ru}),R1(ru,Ju);const op=ip;return ip=Cm({inputs:{x:ip},attrs:{shape:rp},backend:ru}),R1(ru,op),[ip,Gu]}const Bse={kernelName:dS,backendName:"webgl",kernelFunc:kse};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Lse{constructor(nu,ru,lu,cu,hu,pu){this.variableNames=["Image","Transforms"],this.outputShape=pu;const mu=lu==="nearest"?1:2;let Au;switch(cu){case"constant":Au=1;break;case"reflect":Au=2;break;case"wrap":Au=3;break;case"nearest":Au=4;break;default:Au=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${Au} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${Au} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${Au} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${nu} && 0 <= coordX && coordX < ${ru}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${hu});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${hu});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${ru}));
                float mapY = mapCoord(inY, float(${nu}));

                if (${mu} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{image:cu,transforms:hu}=nu,{interpolation:pu,fillMode:mu,fillValue:Au,outputShape:bu}=lu,[Cu,wu,Eu,Tu]=cu.shape,[Ru,Nu]=bu??[wu,Eu],Pu=[Cu,Ru,Nu,Tu],Fu=new Lse(wu,Eu,pu,mu,Au,Pu);return ru.runWebGLProgram(Fu,[cu,hu],"float32")}const Dse={kernelName:pS,backendName:"webgl",kernelFunc:Nse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fse(ou){const{inputs:nu,attrs:ru,backend:lu}=ou,{axis:cu}=ru,{x:hu}=nu;Gw(hu,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const pu=lu.readSync(hu.dataId),{outputValues:mu,outputShape:Au,indices:bu}=RY(pu,cu,hu.shape,hu.dtype);return[lu.makeTensorInfo(Au,hu.dtype,mu),lu.makeTensorInfo([bu.length],"int32",bu)]}const Pse={kernelName:fS,backendName:"webgl",kernelFunc:Fse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gse(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{value:cu}=nu;let{axis:hu}=lu;hu<0&&(hu+=cu.shape.length);const pu=cu,mu=pu.shape.length,Au=cu.shape[hu],bu=new Array(mu-1);let Cu=0;for(let Nu=0;Nu<mu;Nu++)Nu!==hu&&(bu[Cu++]=pu.shape[Nu]);const wu=[],Eu=new Array(mu).fill(0),Tu=pu.shape.slice();Tu[hu]=1;const Ru=new Array(Au);for(let Nu=0;Nu<Ru.length;Nu++){Eu[hu]=Nu;const Pu=yC({inputs:{x:pu},backend:ru,attrs:{begin:Eu,size:Tu}}),Fu=Cm({inputs:{x:Pu},backend:ru,attrs:{shape:bu}});Ru[Nu]=Fu,wu.push(Pu)}return wu.forEach(Nu=>ru.disposeIntermediateTensorInfo(Nu)),Ru}const Ose={kernelName:SE,backendName:"webgl",kernelFunc:Gse};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Use{constructor(nu,ru){this.variableNames=["x","segmentIds"];const lu=nu.windowSize,cu=nu.batchSize,hu=nu.inSize,pu=nu.numSegments,mu=pu*Math.ceil(hu/lu);this.outputShape=[cu,mu];const Au="0.0",bu="sumValue",Cu=Math.floor(lu/4)*4,wu=lu%4,Eu=`
        sumValue += dot(values, segFilter);
    `;let Tu="";hu%lu>0&&(Tu=`
        if (inIdx < 0 || inIdx >= ${hu}) {
          return initializationValue;
        }
      `);let Ru="";hu%lu>0&&(Ru=`
        if (inIdx < 0 || inIdx >= ${hu}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${Au};

      float getValue(int batch, int inIdx) {
        ${Tu}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${Ru}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${pu})) * float(${lu}));
        int currentSeg = int(mod(float(outIdx), float(${pu})));

        float sumValue = 0.0;

        for (int i = 0; i < ${Cu}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${Eu}
        }

        int inIdx = inOffset + ${Cu};
        if (${wu===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${Eu}
        } else if (${wu===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${Eu}
        } else if (${wu===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${Eu}
        }
        setOutput(${bu});
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $se(ou){const{inputs:nu,backend:ru,attrs:lu}=ou,{x:cu,segmentIds:hu}=nu,{numSegments:pu}=lu,mu=cu.shape.length,Au=[];let bu=0;const Cu=G0([bu],mu);let wu=cu;Cu!=null&&(wu=Iy({inputs:{x:cu},backend:ru,attrs:{perm:Cu}}),Au.push(wu),bu=H0(1,mu)[0]);const Eu=aB(wu.shape,bu,pu),Tu=Mu([wu.shape[bu]]),Ru=Cm({inputs:{x:wu},backend:ru,attrs:{shape:[-1,Tu]}});Au.push(Ru);const Nu=TS(cu.dtype),Pu=(Qu,Ju,ip,rp,op)=>{const hp=Qu.shape[0],Ap=Qu.shape[1],Up=oB(Ap,op),Vp={windowSize:Up,inSize:Ap,batchSize:hp,numSegments:op},zp=new Use(Vp,Ju),qp=ru.compileAndRun(zp,[Qu,ip],rp);if(Au.push(qp),qp.shape[1]===op)return qp;const Yp=RF({backend:ru,attrs:{start:0,stop:op,step:1,dtype:"float32"}}),em=LF({inputs:{x:Yp},backend:ru,attrs:{reps:[Ap/Up]}});return Au.push(Yp),Au.push(em),Pu(qp,Ju,em,rp,op)},Fu=Pu(Ru,"unsortedSegmentSum",hu,Nu,pu),Gu=Cm({inputs:{x:Fu},backend:ru,attrs:{shape:Eu}});let Xu=Gu;if(Cu!=null){Au.push(Gu);const Qu=Ev(Cu);Xu=Iy({inputs:{x:Xu},backend:ru,attrs:{perm:Qu}})}return Au.forEach(Qu=>ru.disposeIntermediateTensorInfo(Qu)),Xu}const Vse={kernelName:IE,backendName:"webgl",kernelFunc:$se};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zse=[vq,wq,Iq,Mq,kq,Nq,Fq,Gq,Vq,Wq,Qq,jq,Jq,iJ,oJ,lJ,uJ,fJ,gJ,yJ,vJ,TJ,MJ,LJ,DJ,UJ,VJ,XJ,rq,ZJ,eee,ree,uee,pee,mee,Aee,bee,wee,See,Tee,Mee,kee,Lee,Fee,Gee,Vee,Wee,Qee,jee,qee,ete,ite,ste,lte,ute,hte,pte,mte,Ate,bte,vte,wte,Ite,Mte,kte,Nte,Pte,Ote,$te,iq,zte,qJ,Hte,Qte,Zte,oq,Yte,Jte,tne,rne,ane,cne,hne,pne,gne,yne,xne,Ene,Ine,_ne,Bne,Nne,Fne,Gne,Une,Wne,Qne,Yne,iie,cq,aie,uie,pie,gie,FJ,yie,xie,Cie,Sie,Mie,lq,kie,Lie,Die,Pie,Gie,PJ,Jne,Uie,zie,Xie,hq,jie,Jie,ire,ore,ure,dre,fre,gre,bre,Cre,Sre,_re,kre,Lre,Pre,Ore,IJ,tie,$re,Vre,Wre,Xre,Kre,jre,qre,ese,nse,rse,ose,lse,use,pse,mse,Ase,bse,eie,yq,vse,wse,Sse,_se,Bse,Dse,bq,Pse,Ose,Vse,bie];for(const ou of zse)Qy(ou);const DF="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIFd0e2NvbnN0cnVjdG9yKG49W10sZT1RdCl7aWYodGhpcy5kYXRhPW4sdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmNvbXBhcmU9ZSx0aGlzLmxlbmd0aD4wKWZvcihsZXQgdD0odGhpcy5sZW5ndGg+PjEpLTE7dD49MDt0LS0pdGhpcy5fZG93bih0KX1wdXNoKG4pe3RoaXMuZGF0YS5wdXNoKG4pLHRoaXMubGVuZ3RoKyssdGhpcy5fdXAodGhpcy5sZW5ndGgtMSl9cG9wKCl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBuPXRoaXMuZGF0YVswXSxlPXRoaXMuZGF0YS5wb3AoKTtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLmxlbmd0aD4wJiYodGhpcy5kYXRhWzBdPWUsdGhpcy5fZG93bigwKSksbn1wZWVrKCl7cmV0dXJuIHRoaXMuZGF0YVswXX1fdXAobil7Y29uc3R7ZGF0YTplLGNvbXBhcmU6dH09dGhpcyxzPWVbbl07Zm9yKDtuPjA7KXtjb25zdCByPW4tMT4+MSxpPWVbcl07aWYodChzLGkpPj0wKWJyZWFrO2Vbbl09aSxuPXJ9ZVtuXT1zfV9kb3duKG4pe2NvbnN0e2RhdGE6ZSxjb21wYXJlOnR9PXRoaXMscz10aGlzLmxlbmd0aD4+MSxyPWVbbl07Zm9yKDtuPHM7KXtsZXQgaT0objw8MSkrMSxoPWVbaV07Y29uc3QgbD1pKzE7aWYobDx0aGlzLmxlbmd0aCYmdChlW2xdLGgpPDAmJihpPWwsaD1lW2xdKSx0KGgscik+PTApYnJlYWs7ZVtuXT1oLG49aX1lW25dPXJ9fWZ1bmN0aW9uIFF0KG8sbil7cmV0dXJuIG88bj8tMTpvPm4/MTowfWNvbnN0IHl0PW89Pntjb25zdHt2MTpuLHYyOmV9PW87bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9KG5bc11eZVtzXSk+Pj4wO3QrPVp0KHIpfXJldHVybiB0fSxadD1vPT57dmFyIG49by0obz4+MSYxNDMxNjU1NzY1KTtyZXR1cm4gbj0obj4+MiY4NTg5OTM0NTkpKyhuJjg1ODk5MzQ1OSksbj0obj4+NCkrbiYyNTI2NDUxMzUsbj0obj4+OCkrbiYxNjcxMTkzNSxuPShuPj4xNikrbiY2NTUzNSxufSxjdD0xLHZ0PW89Pntjb25zdHtrZXl3aWR0aDpuLGtleWhlaWdodDplLHF1ZXJ5d2lkdGg6dCxxdWVyeWhlaWdodDpzLG1hdGNoZXM6cn09byxpPXQqMS4yLGg9LWksbD1zKjEuMix1PS1sLGY9MTIsZz0xMCxhPS0xLGo9MSx5PTEvTWF0aC5sb2coMTApLG09TWF0aC5tYXgobixlKSxNPU1hdGguZmxvb3Iobi8yKSxUPU1hdGguZmxvb3IoZS8yKSxFPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludC5zY2FsZSxLPXJbTl0ua2V5cG9pbnQuc2NhbGU7Sz09MCYmY29uc29sZS5sb2coIkVSUk9SIGRpdmlkZSB6ZXJvIik7Y29uc3Qgdj0kL0s7RS5wdXNoKHYqbSl9RS5zb3J0KChOLCQpPT5OLSQpO2NvbnN0IFI9LjI1KkVbTWF0aC5mbG9vcihFLmxlbmd0aC8yKS0oRS5sZW5ndGglMj09MD8xOjApLTFdLHE9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGktaCkvUikpLEk9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGwtdSkvUikpLHo9cSpJLEI9eipmLGM9W10scD1bXSxTPXt9O2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludCxLPXJbTl0ua2V5cG9pbnQse3g6dix5OlYsc2NhbGU6TCxhbmdsZTpDfT14dCh7cXVlcnlwb2ludDokLGtleXBvaW50Okssa2V5Y2VudGVyWDpNLGtleWNlbnRlclk6VCxzY2FsZU9uZU92ZXJMb2dLOnl9KTtpZih2PGh8fHY+PWl8fFY8dXx8Vj49bHx8Qzw9LU1hdGguUEl8fEM+TWF0aC5QSXx8TDxhfHxMPj1qKXtjW05dPSExO2NvbnRpbnVlfWxldCBYPXEqKHYtaCkvKGktaCksd3Q9SSooVi11KS8obC11KSxwdD1mKihDK01hdGguUEkpLygyKk1hdGguUEkpLGR0PWcqKEwtYSkvKGotYSk7cFtOXT17YmluWDpYLGJpblk6d3QsYmluQW5nbGU6cHQsYmluU2NhbGU6ZHR9O2xldCBpdD1NYXRoLmZsb29yKFgtLjUpLGx0PU1hdGguZmxvb3Iod3QtLjUpLGh0PU1hdGguZmxvb3IoZHQtLjUpLGp0PShNYXRoLmZsb29yKHB0LS41KStmKSVmO2lmKGl0PDB8fGl0KzE+PXF8fGx0PDB8fGx0KzE+PUl8fGh0PDB8fGh0KzE+PWcpe2NbTl09ITE7Y29udGludWV9Zm9yKGxldCB1dD0wO3V0PDI7dXQrKyl7bGV0IGt0PWl0K3V0O2ZvcihsZXQgYnQ9MDtidDwyO2J0Kyspe2xldCB1bj1sdCtidDtmb3IobGV0IEl0PTA7SXQ8MjtJdCsrKXtsZXQgY249KGp0K0l0KSVmO2ZvcihsZXQgUnQ9MDtSdDwyO1J0Kyspe2xldCBmbj1odCtSdDtjb25zdCBOdD1rdCt1bipxK2NuKnorZm4qQjtTW050XT09PXZvaWQgMCYmKFNbTnRdPTApLFNbTnRdKz0xfX19fWNbTl09ITB9bGV0IGQ9MCxEPS0xO2lmKE9iamVjdC5rZXlzKFMpLmZvckVhY2goTj0+e1NbTl0+ZCYmKGQ9U1tOXSxEPU4pfSksZDwzKXJldHVybltdO2NvbnN0IFU9TWF0aC5mbG9vcihEJUIleiVxKSxGPU1hdGguZmxvb3IoKEQtVSklQiV6L3EpLFA9TWF0aC5mbG9vcigoRC1VLUYqcSklQi96KSxZPU1hdGguZmxvb3IoKEQtVS1GKnEtUCp6KS9CKSxHPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtpZighY1tOXSljb250aW51ZTtjb25zdCAkPXBbTl07aWYoTWF0aC5hYnMoJC5iaW5YLShVKy41KSk+PWN0fHxNYXRoLmFicygkLmJpblktKEYrLjUpKT49Y3R8fE1hdGguYWJzKCQuYmluU2NhbGUtKFkrLjUpKT49Y3QpY29udGludWU7Y29uc3QgTD1NYXRoLmFicygkLmJpbkFuZ2xlLShQKy41KSk7TWF0aC5taW4oTCxmLUwpPj1jdHx8Ry5wdXNoKHJbTl0pfXJldHVybiBHfSx4dD0oe3F1ZXJ5cG9pbnQ6byxrZXlwb2ludDpuLGtleWNlbnRlclg6ZSxrZXljZW50ZXJZOnQsc2NhbGVPbmVPdmVyTG9nSzpzfSk9PntsZXQgcj1vLmFuZ2xlLW4uYW5nbGU7cjw9LU1hdGguUEk/cis9MipNYXRoLlBJOnI+TWF0aC5QSSYmKHItPTIqTWF0aC5QSSk7Y29uc3QgaT1vLnNjYWxlL24uc2NhbGUsaD1pKk1hdGguY29zKHIpLGw9aSpNYXRoLnNpbihyKSx1PVtoLC1sLGwsaF0sZj1bdVswXSpuLngrdVsxXSpuLnksdVsyXSpuLngrdVszXSpuLnldLGc9by54LWZbMF0sYT1vLnktZlsxXTtyZXR1cm57eDp1WzBdKmUrdVsxXSp0K2cseTp1WzJdKmUrdVszXSp0K2EsYW5nbGU6cixzY2FsZTpNYXRoLmxvZyhpKSpzfX0sQXQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBXKG8pe3JldHVybiBBdC5jYWxsKG8pLmVuZHNXaXRoKCJBcnJheV0iKX1mdW5jdGlvbiB0ZShvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307aWYoIVcobykpdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBiZSBhbiBhcnJheSIpO2lmKG8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eSIpO3ZhciBlPW4uZnJvbUluZGV4LHQ9ZT09PXZvaWQgMD8wOmUscz1uLnRvSW5kZXgscj1zPT09dm9pZCAwP28ubGVuZ3RoOnM7aWYodDwwfHx0Pj1vLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEVycm9yKCJmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCIpO2lmKHI8PXR8fHI+by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBFcnJvcigidG9JbmRleCBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIGZyb21JbmRleCBhbmQgYXQgbW9zdCBlcXVhbCB0byBsZW5ndGgiKTtmb3IodmFyIGk9b1t0XSxoPXQrMTtoPHI7aCsrKW9baF0+aSYmKGk9b1toXSk7cmV0dXJuIGl9ZnVuY3Rpb24gZWUobyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKCFXKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKTt2YXIgZT1uLmZyb21JbmRleCx0PWU9PT12b2lkIDA/MDplLHM9bi50b0luZGV4LHI9cz09PXZvaWQgMD9vLmxlbmd0aDpzO2lmKHQ8MHx8dD49by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcigiZnJvbUluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsZW5ndGgiKTtpZihyPD10fHxyPm8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRXJyb3IoInRvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoIik7Zm9yKHZhciBpPW9bdF0saD10KzE7aDxyO2grKylvW2hdPGkmJihpPW9baF0pO3JldHVybiBpfWZ1bmN0aW9uIHF0KG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fTtpZihXKG8pKXtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTt2YXIgZTtpZihuLm91dHB1dCE9PXZvaWQgMCl7aWYoIVcobi5vdXRwdXQpKXRocm93IG5ldyBUeXBlRXJyb3IoIm91dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQiKTtlPW4ub3V0cHV0fWVsc2UgZT1uZXcgQXJyYXkoby5sZW5ndGgpO3ZhciB0PWVlKG8pLHM9dGUobyk7aWYodD09PXMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheSIpO3ZhciByPW4ubWluLGk9cj09PXZvaWQgMD9uLmF1dG9NaW5NYXg/dDowOnIsaD1uLm1heCxsPWg9PT12b2lkIDA/bi5hdXRvTWluTWF4P3M6MTpoO2lmKGk+PWwpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbiIpO2Zvcih2YXIgdT0obC1pKS8ocy10KSxmPTA7ZjxvLmxlbmd0aDtmKyspZVtmXT0ob1tmXS10KSp1K2k7cmV0dXJuIGV9Y29uc3QgZnQ9IiAiLnJlcGVhdCgyKSxfdD0iICIucmVwZWF0KDQpO2Z1bmN0aW9uIG5lKCl7cmV0dXJuIFR0KHRoaXMpfWZ1bmN0aW9uIFR0KG8sbj17fSl7Y29uc3R7bWF4Um93czplPTE1LG1heENvbHVtbnM6dD0xMCxtYXhOdW1TaXplOnM9OCxwYWRNaW51czpyPSJhdXRvIn09bjtyZXR1cm5gJHtvLmNvbnN0cnVjdG9yLm5hbWV9IHsKJHtmdH1bCiR7X3R9JHtzZShvLGUsdCxzLHIpfQoke2Z0fV0KJHtmdH1yb3dzOiAke28ucm93c30KJHtmdH1jb2x1bW5zOiAke28uY29sdW1uc30KfWB9ZnVuY3Rpb24gc2UobyxuLGUsdCxzKXtjb25zdHtyb3dzOnIsY29sdW1uczppfT1vLGg9TWF0aC5taW4ocixuKSxsPU1hdGgubWluKGksZSksdT1bXTtpZihzPT09ImF1dG8iKXtzPSExO3Q6Zm9yKGxldCBmPTA7ZjxoO2YrKylmb3IobGV0IGc9MDtnPGw7ZysrKWlmKG8uZ2V0KGYsZyk8MCl7cz0hMDticmVhayB0fX1mb3IobGV0IGY9MDtmPGg7ZisrKXtsZXQgZz1bXTtmb3IobGV0IGE9MDthPGw7YSsrKWcucHVzaChvZShvLmdldChmLGEpLHQscykpO3UucHVzaChgJHtnLmpvaW4oIiAiKX1gKX1yZXR1cm4gbCE9PWkmJih1W3UubGVuZ3RoLTFdKz1gIC4uLiAke2ktZX0gbW9yZSBjb2x1bW5zYCksaCE9PXImJnUucHVzaChgLi4uICR7ci1ufSBtb3JlIHJvd3NgKSx1LmpvaW4oYAoke190fWApfWZ1bmN0aW9uIG9lKG8sbixlKXtyZXR1cm4obz49MCYmZT9gICR7enQobyxuLTEpfWA6enQobyxuKSkucGFkRW5kKG4pfWZ1bmN0aW9uIHp0KG8sbil7bGV0IGU9by50b1N0cmluZygpO2lmKGUubGVuZ3RoPD1uKXJldHVybiBlO2xldCB0PW8udG9GaXhlZChuKTtpZih0Lmxlbmd0aD5uJiYodD1vLnRvRml4ZWQoTWF0aC5tYXgoMCxuLSh0Lmxlbmd0aC1uKSkpKSx0Lmxlbmd0aDw9biYmIXQuc3RhcnRzV2l0aCgiMC4wMDAiKSYmIXQuc3RhcnRzV2l0aCgiLTAuMDAwIikpcmV0dXJuIHQ7bGV0IHM9by50b0V4cG9uZW50aWFsKG4pO3JldHVybiBzLmxlbmd0aD5uJiYocz1vLnRvRXhwb25lbnRpYWwoTWF0aC5tYXgoMCxuLShzLmxlbmd0aC1uKSkpKSxzLnNsaWNlKDApfWZ1bmN0aW9uIHJlKG8sbil7by5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5hZGRTKHQpOnRoaXMuYWRkTSh0KX0sby5wcm90b3R5cGUuYWRkUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpK3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5hZGRNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSt0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5hZGQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuYWRkKHMpfSxvLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnN1YlModCk6dGhpcy5zdWJNKHQpfSxvLnByb3RvdHlwZS5zdWJTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciktdCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLnN1Yk09ZnVuY3Rpb24odCl7aWYodD1uLmNoZWNrTWF0cml4KHQpLHRoaXMucm93cyE9PXQucm93c3x8dGhpcy5jb2x1bW5zIT09dC5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwiKTtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpLXQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnN1Yj1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5zdWIocyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PW8ucHJvdG90eXBlLnN1YixvLnByb3RvdHlwZS5zdWJ0cmFjdFM9by5wcm90b3R5cGUuc3ViUyxvLnByb3RvdHlwZS5zdWJ0cmFjdE09by5wcm90b3R5cGUuc3ViTSxvLnN1YnRyYWN0PW8uc3ViLG8ucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMubXVsUyh0KTp0aGlzLm11bE0odCl9LG8ucHJvdG90eXBlLm11bFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSp0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubXVsTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikqdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ubXVsPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLm11bChzKX0sby5wcm90b3R5cGUubXVsdGlwbHk9by5wcm90b3R5cGUubXVsLG8ucHJvdG90eXBlLm11bHRpcGx5Uz1vLnByb3RvdHlwZS5tdWxTLG8ucHJvdG90eXBlLm11bHRpcGx5TT1vLnByb3RvdHlwZS5tdWxNLG8ubXVsdGlwbHk9by5tdWwsby5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5kaXZTKHQpOnRoaXMuZGl2TSh0KX0sby5wcm90b3R5cGUuZGl2Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpL3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5kaXZNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKS90LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5kaXY9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuZGl2KHMpfSxvLnByb3RvdHlwZS5kaXZpZGU9by5wcm90b3R5cGUuZGl2LG8ucHJvdG90eXBlLmRpdmlkZVM9by5wcm90b3R5cGUuZGl2UyxvLnByb3RvdHlwZS5kaXZpZGVNPW8ucHJvdG90eXBlLmRpdk0sby5kaXZpZGU9by5kaXYsby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5tb2RTKHQpOnRoaXMubW9kTSh0KX0sby5wcm90b3R5cGUubW9kUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpJXQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5tb2RNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSV0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5tb2Q9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkubW9kKHMpfSxvLnByb3RvdHlwZS5tb2R1bHVzPW8ucHJvdG90eXBlLm1vZCxvLnByb3RvdHlwZS5tb2R1bHVzUz1vLnByb3RvdHlwZS5tb2RTLG8ucHJvdG90eXBlLm1vZHVsdXNNPW8ucHJvdG90eXBlLm1vZE0sby5tb2R1bHVzPW8ubW9kLG8ucHJvdG90eXBlLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMuYW5kUyh0KTp0aGlzLmFuZE0odCl9LG8ucHJvdG90eXBlLmFuZFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSZ0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuYW5kTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikmdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8uYW5kPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLmFuZChzKX0sby5wcm90b3R5cGUub3I9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLm9yUyh0KTp0aGlzLm9yTSh0KX0sby5wcm90b3R5cGUub3JTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ub3I9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkub3Iocyl9LG8ucHJvdG90eXBlLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMueG9yUyh0KTp0aGlzLnhvck0odCl9LG8ucHJvdG90eXBlLnhvclM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKV50KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUueG9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciledC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ueG9yPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnhvcihzKX0sby5wcm90b3R5cGUubGVmdFNoaWZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5sZWZ0U2hpZnRTKHQpOnRoaXMubGVmdFNoaWZ0TSh0KX0sby5wcm90b3R5cGUubGVmdFNoaWZ0Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpPDx0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGVmdFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik8PHQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLmxlZnRTaGlmdD1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5sZWZ0U2hpZnQocyl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHQpOnRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odCl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdChzKX0sby5wcm90b3R5cGUucmlnaHRTaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMucmlnaHRTaGlmdFModCk6dGhpcy5yaWdodFNoaWZ0TSh0KX0sby5wcm90b3R5cGUucmlnaHRTaGlmdFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKT4+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5yaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+Pj50LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5yaWdodFNoaWZ0PWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnJpZ2h0U2hpZnQocyl9LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdD1vLnByb3RvdHlwZS5yaWdodFNoaWZ0LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdFM9by5wcm90b3R5cGUucmlnaHRTaGlmdFMsby5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0TT1vLnByb3RvdHlwZS5yaWdodFNoaWZ0TSxvLnplcm9GaWxsUmlnaHRTaGlmdD1vLnJpZ2h0U2hpZnQsby5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsfnRoaXMuZ2V0KHQscykpO3JldHVybiB0aGlzfSxvLm5vdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubm90KCl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYWJzKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFicygpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hY29zKCl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zaCh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFjb3NoKCl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFzaW4oKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXNpbmgoKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXRhbigpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hdGFuaCgpfSxvLnByb3RvdHlwZS5jYnJ0PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jYnJ0KHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jYnJ0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5jYnJ0KCl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNlaWwodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNlaWwoKX0sby5wcm90b3R5cGUuY2x6MzI9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNsejMyKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jbHozMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY2x6MzIoKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jb3ModGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY29zKCl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNvc2godGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNvc2goKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHAodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuZXhwKCl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHBtMSh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmV4cG0xKCl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5mbG9vcih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZsb29yKCl9LG8ucHJvdG90eXBlLmZyb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguZnJvdW5kKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5mcm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZyb3VuZCgpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZyh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5sb2coKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzFwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMXAoKX0sby5wcm90b3R5cGUubG9nMTA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzEwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxMD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMTAoKX0sby5wcm90b3R5cGUubG9nMj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgubG9nMih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMigpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgucm91bmQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5yb3VuZCgpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaWduKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaWduKCl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguc2luKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNpbigpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaW5oKCl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnNxcnQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNxcnQoKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC50YW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudGFuKCl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnRhbmgoKX0sby5wcm90b3R5cGUudHJ1bmM9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRydW5jKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby50cnVuYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudHJ1bmMoKX0sby5wb3c9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkucG93KHMpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnBvd1ModCk6dGhpcy5wb3dNKHQpfSxvLnByb3RvdHlwZS5wb3dTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLE1hdGgucG93KHRoaXMuZ2V0KHMsciksdCkpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5wb3dNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsTWF0aC5wb3codGhpcy5nZXQocyxyKSx0LmdldChzLHIpKSk7cmV0dXJuIHRoaXN9fWZ1bmN0aW9uIFEobyxuLGUpe2xldCB0PWU/by5yb3dzOm8ucm93cy0xO2lmKG48MHx8bj50KXRocm93IG5ldyBSYW5nZUVycm9yKCJSb3cgaW5kZXggb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gWihvLG4sZSl7bGV0IHQ9ZT9vLmNvbHVtbnM6by5jb2x1bW5zLTE7aWYobjwwfHxuPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiB0dChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8uY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMiKTtyZXR1cm4gbn1mdW5jdGlvbiBldChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MiKTtyZXR1cm4gbn1mdW5jdGlvbiBpZShvLG4pe2lmKCFXKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoInJvdyBpbmRpY2VzIG11c3QgYmUgYW4gYXJyYXkiKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihuW2VdPDB8fG5bZV0+PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigicm93IGluZGljZXMgYXJlIG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIGxlKG8sbil7aWYoIVcobikpdGhyb3cgbmV3IFR5cGVFcnJvcigiY29sdW1uIGluZGljZXMgbXVzdCBiZSBhbiBhcnJheSIpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKG5bZV08MHx8bltlXT49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gRnQobyxuLGUsdCxzKXtpZihhcmd1bWVudHMubGVuZ3RoIT09NSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiZXhwZWN0ZWQgNCBhcmd1bWVudHMiKTtpZihhdCgic3RhcnRSb3ciLG4pLGF0KCJlbmRSb3ciLGUpLGF0KCJzdGFydENvbHVtbiIsdCksYXQoImVuZENvbHVtbiIscyksbj5lfHx0PnN8fG48MHx8bj49by5yb3dzfHxlPDB8fGU+PW8ucm93c3x8dDwwfHx0Pj1vLmNvbHVtbnN8fHM8MHx8cz49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gZ3QobyxuPTApe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8bzt0KyspZS5wdXNoKG4pO3JldHVybiBlfWZ1bmN0aW9uIGF0KG8sbil7aWYodHlwZW9mIG4hPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gbXVzdCBiZSBhIG51bWJlcmApfWZ1bmN0aW9uIG50KG8pe2lmKG8uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiRW1wdHkgbWF0cml4IGhhcyBubyBlbGVtZW50cyB0byBpbmRleCIpfWZ1bmN0aW9uIGhlKG8pe2xldCBuPWd0KG8ucm93cyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW2VdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIHVlKG8pe2xldCBuPWd0KG8uY29sdW1ucyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW3RdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGNlKG8pe2xldCBuPTA7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKyluKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGZlKG8pe2xldCBuPWd0KG8ucm93cywxKTtmb3IobGV0IGU9MDtlPG8ucm93czsrK2UpZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KW5bZV0qPW8uZ2V0KGUsdCk7cmV0dXJuIG59ZnVuY3Rpb24gZ2Uobyl7bGV0IG49Z3Qoby5jb2x1bW5zLDEpO2ZvcihsZXQgZT0wO2U8by5yb3dzOysrZSlmb3IobGV0IHQ9MDt0PG8uY29sdW1uczsrK3Qpblt0XSo9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBhZShvKXtsZXQgbj0xO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspbio9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBtZShvLG4sZSl7Y29uc3QgdD1vLnJvd3Mscz1vLmNvbHVtbnMscj1bXTtmb3IobGV0IGk9MDtpPHQ7aSsrKXtsZXQgaD0wLGw9MCx1PTA7Zm9yKGxldCBmPTA7ZjxzO2YrKyl1PW8uZ2V0KGksZiktZVtpXSxoKz11LGwrPXUqdTtuP3IucHVzaCgobC1oKmgvcykvKHMtMSkpOnIucHVzaCgobC1oKmgvcykvcyl9cmV0dXJuIHJ9ZnVuY3Rpb24gd2UobyxuLGUpe2NvbnN0IHQ9by5yb3dzLHM9by5jb2x1bW5zLHI9W107Zm9yKGxldCBpPTA7aTxzO2krKyl7bGV0IGg9MCxsPTAsdT0wO2ZvcihsZXQgZj0wO2Y8dDtmKyspdT1vLmdldChmLGkpLWVbaV0saCs9dSxsKz11KnU7bj9yLnB1c2goKGwtaCpoL3QpLyh0LTEpKTpyLnB1c2goKGwtaCpoL3QpL3QpfXJldHVybiByfWZ1bmN0aW9uIHBlKG8sbixlKXtjb25zdCB0PW8ucm93cyxzPW8uY29sdW1ucyxyPXQqcztsZXQgaT0wLGg9MCxsPTA7Zm9yKGxldCB1PTA7dTx0O3UrKylmb3IobGV0IGY9MDtmPHM7ZisrKWw9by5nZXQodSxmKS1lLGkrPWwsaCs9bCpsO3JldHVybiBuPyhoLWkqaS9yKS8oci0xKTooaC1pKmkvcikvcn1mdW5jdGlvbiBkZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCktbltlXSl9ZnVuY3Rpb24geWUobyxuKXtmb3IobGV0IGU9MDtlPG8ucm93cztlKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KGUsdCxvLmdldChlLHQpLW5bdF0pfWZ1bmN0aW9uIE1lKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS1uKX1mdW5jdGlvbiBFZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8uY29sdW1ucztzKyspdCs9TWF0aC5wb3coby5nZXQoZSxzKSwyKS8oby5jb2x1bW5zLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIFNlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW2VdKX1mdW5jdGlvbiBqZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5jb2x1bW5zO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8ucm93cztzKyspdCs9TWF0aC5wb3coby5nZXQocyxlKSwyKS8oby5yb3dzLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIGtlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW3RdKX1mdW5jdGlvbiBiZShvKXtjb25zdCBuPW8uc2l6ZS0xO2xldCBlPTA7Zm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKWZvcihsZXQgcz0wO3M8by5yb3dzO3MrKyllKz1NYXRoLnBvdyhvLmdldChzLHQpLDIpL247cmV0dXJuIE1hdGguc3FydChlKX1mdW5jdGlvbiBJZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCkvbil9Y2xhc3MgX3tzdGF0aWMgZnJvbTFEQXJyYXkobixlLHQpe2lmKG4qZSE9PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJkYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zIik7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHRbaSplK2hdKTtyZXR1cm4gcn1zdGF0aWMgcm93VmVjdG9yKG4pe2xldCBlPW5ldyBiKDEsbi5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KDAsdCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgY29sdW1uVmVjdG9yKG4pe2xldCBlPW5ldyBiKG4ubGVuZ3RoLDEpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KHQsMCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgemVyb3MobixlKXtyZXR1cm4gbmV3IGIobixlKX1zdGF0aWMgb25lcyhuLGUpe3JldHVybiBuZXcgYihuLGUpLmZpbGwoMSl9c3RhdGljIHJhbmQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7cmFuZG9tOnM9TWF0aC5yYW5kb219PXQ7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHMoKSk7cmV0dXJuIHJ9c3RhdGljIHJhbmRJbnQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7bWluOnM9MCxtYXg6cj0xZTMscmFuZG9tOmk9TWF0aC5yYW5kb219PXQ7aWYoIU51bWJlci5pc0ludGVnZXIocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWluIG11c3QgYmUgYW4gaW50ZWdlciIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1heCBtdXN0IGJlIGFuIGludGVnZXIiKTtpZihzPj1yKXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IGg9ci1zLGw9bmV3IGIobixlKTtmb3IobGV0IHU9MDt1PG47dSsrKWZvcihsZXQgZj0wO2Y8ZTtmKyspe2xldCBnPXMrTWF0aC5yb3VuZChpKCkqaCk7bC5zZXQodSxmLGcpfXJldHVybiBsfXN0YXRpYyBleWUobixlLHQpe2U9PT12b2lkIDAmJihlPW4pLHQ9PT12b2lkIDAmJih0PTEpO2xldCBzPU1hdGgubWluKG4sZSkscj10aGlzLnplcm9zKG4sZSk7Zm9yKGxldCBpPTA7aTxzO2krKylyLnNldChpLGksdCk7cmV0dXJuIHJ9c3RhdGljIGRpYWcobixlLHQpe2xldCBzPW4ubGVuZ3RoO2U9PT12b2lkIDAmJihlPXMpLHQ9PT12b2lkIDAmJih0PWUpO2xldCByPU1hdGgubWluKHMsZSx0KSxpPXRoaXMuemVyb3MoZSx0KTtmb3IobGV0IGg9MDtoPHI7aCsrKWkuc2V0KGgsaCxuW2hdKTtyZXR1cm4gaX1zdGF0aWMgbWluKG4sZSl7bj10aGlzLmNoZWNrTWF0cml4KG4pLGU9dGhpcy5jaGVja01hdHJpeChlKTtsZXQgdD1uLnJvd3Mscz1uLmNvbHVtbnMscj1uZXcgYih0LHMpO2ZvcihsZXQgaT0wO2k8dDtpKyspZm9yKGxldCBoPTA7aDxzO2grKylyLnNldChpLGgsTWF0aC5taW4obi5nZXQoaSxoKSxlLmdldChpLGgpKSk7cmV0dXJuIHJ9c3RhdGljIG1heChuLGUpe249dGhpcy5jaGVja01hdHJpeChuKSxlPXRoaXMuY2hlY2tNYXRyaXgoZSk7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IHRoaXModCxzKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgaD0wO2g8cztoKyspci5zZXQoaSxoLE1hdGgubWF4KG4uZ2V0KGksaCksZS5nZXQoaSxoKSkpO3JldHVybiByfXN0YXRpYyBjaGVja01hdHJpeChuKXtyZXR1cm4gXy5pc01hdHJpeChuKT9uOm5ldyBiKG4pfXN0YXRpYyBpc01hdHJpeChuKXtyZXR1cm4gbiE9bnVsbCYmbi5rbGFzcz09PSJNYXRyaXgifWdldCBzaXplKCl7cmV0dXJuIHRoaXMucm93cyp0aGlzLmNvbHVtbnN9YXBwbHkobil7aWYodHlwZW9mIG4hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyluLmNhbGwodGhpcyxlLHQpO3JldHVybiB0aGlzfXRvMURBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5wdXNoKHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXRvMkRBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKyl7bi5wdXNoKFtdKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspbltlXS5wdXNoKHRoaXMuZ2V0KGUsdCkpfXJldHVybiBufXRvSlNPTigpe3JldHVybiB0aGlzLnRvMkRBcnJheSgpfWlzUm93VmVjdG9yKCl7cmV0dXJuIHRoaXMucm93cz09PTF9aXNDb2x1bW5WZWN0b3IoKXtyZXR1cm4gdGhpcy5jb2x1bW5zPT09MX1pc1ZlY3Rvcigpe3JldHVybiB0aGlzLnJvd3M9PT0xfHx0aGlzLmNvbHVtbnM9PT0xfWlzU3F1YXJlKCl7cmV0dXJuIHRoaXMucm93cz09PXRoaXMuY29sdW1uc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMucm93cz09PTB8fHRoaXMuY29sdW1ucz09PTB9aXNTeW1tZXRyaWMoKXtpZih0aGlzLmlzU3F1YXJlKCkpe2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IGU9MDtlPD1uO2UrKylpZih0aGlzLmdldChuLGUpIT09dGhpcy5nZXQoZSxuKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX1pc0VjaGVsb25Gb3JtKCl7bGV0IG49MCxlPTAsdD0tMSxzPSEwLHI9ITE7Zm9yKDtuPHRoaXMucm93cyYmczspe2ZvcihlPTAscj0hMTtlPHRoaXMuY29sdW1ucyYmcj09PSExOyl0aGlzLmdldChuLGUpPT09MD9lKys6dGhpcy5nZXQobixlKT09PTEmJmU+dD8ocj0hMCx0PWUpOihzPSExLHI9ITApO24rK31yZXR1cm4gc31pc1JlZHVjZWRFY2hlbG9uRm9ybSgpe2xldCBuPTAsZT0wLHQ9LTEscz0hMCxyPSExO2Zvcig7bjx0aGlzLnJvd3MmJnM7KXtmb3IoZT0wLHI9ITE7ZTx0aGlzLmNvbHVtbnMmJnI9PT0hMTspdGhpcy5nZXQobixlKT09PTA/ZSsrOnRoaXMuZ2V0KG4sZSk9PT0xJiZlPnQ/KHI9ITAsdD1lKToocz0hMSxyPSEwKTtmb3IobGV0IGk9ZSsxO2k8dGhpcy5yb3dzO2krKyl0aGlzLmdldChuLGkpIT09MCYmKHM9ITEpO24rK31yZXR1cm4gc31lY2hlbG9uRm9ybSgpe2xldCBuPXRoaXMuY2xvbmUoKSxlPTAsdD0wO2Zvcig7ZTxuLnJvd3MmJnQ8bi5jb2x1bW5zOyl7bGV0IHM9ZTtmb3IobGV0IHI9ZTtyPG4ucm93cztyKyspbi5nZXQocix0KT5uLmdldChzLHQpJiYocz1yKTtpZihuLmdldChzLHQpPT09MCl0Kys7ZWxzZXtuLnN3YXBSb3dzKGUscyk7bGV0IHI9bi5nZXQoZSx0KTtmb3IobGV0IGk9dDtpPG4uY29sdW1ucztpKyspbi5zZXQoZSxpLG4uZ2V0KGUsaSkvcik7Zm9yKGxldCBpPWUrMTtpPG4ucm93cztpKyspe2xldCBoPW4uZ2V0KGksdCkvbi5nZXQoZSx0KTtuLnNldChpLHQsMCk7Zm9yKGxldCBsPXQrMTtsPG4uY29sdW1ucztsKyspbi5zZXQoaSxsLG4uZ2V0KGksbCktbi5nZXQoZSxsKSpoKX1lKyssdCsrfX1yZXR1cm4gbn1yZWR1Y2VkRWNoZWxvbkZvcm0oKXtsZXQgbj10aGlzLmVjaGVsb25Gb3JtKCksZT1uLmNvbHVtbnMsdD1uLnJvd3Mscz10LTE7Zm9yKDtzPj0wOylpZihuLm1heFJvdyhzKT09PTApcy0tO2Vsc2V7bGV0IHI9MCxpPSExO2Zvcig7cjx0JiZpPT09ITE7KW4uZ2V0KHMscik9PT0xP2k9ITA6cisrO2ZvcihsZXQgaD0wO2g8cztoKyspe2xldCBsPW4uZ2V0KGgscik7Zm9yKGxldCB1PXI7dTxlO3UrKyl7bGV0IGY9bi5nZXQoaCx1KS1sKm4uZ2V0KHMsdSk7bi5zZXQoaCx1LGYpfX1zLS19cmV0dXJuIG59c2V0KCl7dGhyb3cgbmV3IEVycm9yKCJzZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQiKX1nZXQoKXt0aHJvdyBuZXcgRXJyb3IoImdldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCIpfXJlcGVhdChuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e3Jvd3M6ZT0xLGNvbHVtbnM6dD0xfT1uO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpfHxlPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoInJvd3MgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIiKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJjb2x1bW5zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIik7bGV0IHM9bmV3IGIodGhpcy5yb3dzKmUsdGhpcy5jb2x1bW5zKnQpO2ZvcihsZXQgcj0wO3I8ZTtyKyspZm9yKGxldCBpPTA7aTx0O2krKylzLnNldFN1Yk1hdHJpeCh0aGlzLHRoaXMucm93cypyLHRoaXMuY29sdW1ucyppKTtyZXR1cm4gc31maWxsKG4pe2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LG4pO3JldHVybiB0aGlzfW5lZygpe3JldHVybiB0aGlzLm11bFMoLTEpfWdldFJvdyhuKXtRKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUucHVzaCh0aGlzLmdldChuLHQpKTtyZXR1cm4gZX1nZXRSb3dWZWN0b3Iobil7cmV0dXJuIGIucm93VmVjdG9yKHRoaXMuZ2V0Um93KG4pKX1zZXRSb3cobixlKXtRKHRoaXMsbiksZT10dCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsZVt0XSk7cmV0dXJuIHRoaXN9c3dhcFJvd3MobixlKXtRKHRoaXMsbiksUSh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl7bGV0IHM9dGhpcy5nZXQobix0KTt0aGlzLnNldChuLHQsdGhpcy5nZXQoZSx0KSksdGhpcy5zZXQoZSx0LHMpfXJldHVybiB0aGlzfWdldENvbHVtbihuKXtaKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWUucHVzaCh0aGlzLmdldCh0LG4pKTtyZXR1cm4gZX1nZXRDb2x1bW5WZWN0b3Iobil7cmV0dXJuIGIuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKG4pKX1zZXRDb2x1bW4obixlKXtaKHRoaXMsbiksZT1ldCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLnNldCh0LG4sZVt0XSk7cmV0dXJuIHRoaXN9c3dhcENvbHVtbnMobixlKXtaKHRoaXMsbiksWih0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxuKTt0aGlzLnNldCh0LG4sdGhpcy5nZXQodCxlKSksdGhpcy5zZXQodCxlLHMpfXJldHVybiB0aGlzfWFkZFJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KStuW3RdKTtyZXR1cm4gdGhpc31zdWJSb3dWZWN0b3Iobil7bj10dCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCktblt0XSk7cmV0dXJuIHRoaXN9bXVsUm93VmVjdG9yKG4pe249dHQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpKm5bdF0pO3JldHVybiB0aGlzfWRpdlJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KS9uW3RdKTtyZXR1cm4gdGhpc31hZGRDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkrbltlXSk7cmV0dXJuIHRoaXN9c3ViQ29sdW1uVmVjdG9yKG4pe249ZXQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpLW5bZV0pO3JldHVybiB0aGlzfW11bENvbHVtblZlY3RvcihuKXtuPWV0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KSpuW2VdKTtyZXR1cm4gdGhpc31kaXZDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkvbltlXSk7cmV0dXJuIHRoaXN9bXVsUm93KG4sZSl7USh0aGlzLG4pO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplKTtyZXR1cm4gdGhpc31tdWxDb2x1bW4obixlKXtaKHRoaXMsbik7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXRoaXMuc2V0KHQsbix0aGlzLmdldCh0LG4pKmUpO3JldHVybiB0aGlzfW1heChuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk+ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1heEluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5uJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1pbihuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk8ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1pbkluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxuJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1heFJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPmUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1heFJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk+ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1pblJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPGUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1pblJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk8ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1heENvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPmUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1heENvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik+ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fW1pbkNvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPGUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1pbkNvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik8ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fWRpYWcoKXtsZXQgbj1NYXRoLm1pbih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKSxlPVtdO2ZvcihsZXQgdD0wO3Q8bjt0KyspZS5wdXNoKHRoaXMuZ2V0KHQsdCkpO3JldHVybiBlfW5vcm0obj0iZnJvYmVuaXVzIil7bGV0IGU9MDtpZihuPT09Im1heCIpcmV0dXJuIHRoaXMubWF4KCk7aWYobj09PSJmcm9iZW5pdXMiKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKWU9ZSt0aGlzLmdldCh0LHMpKnRoaXMuZ2V0KHQscyk7cmV0dXJuIE1hdGguc3FydChlKX1lbHNlIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIG5vcm0gdHlwZTogJHtufWApfWN1bXVsYXRpdmVTdW0oKXtsZXQgbj0wO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbis9dGhpcy5nZXQoZSx0KSx0aGlzLnNldChlLHQsbik7cmV0dXJuIHRoaXN9ZG90KG4pe18uaXNNYXRyaXgobikmJihuPW4udG8xREFycmF5KCkpO2xldCBlPXRoaXMudG8xREFycmF5KCk7aWYoZS5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9ycyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBzaXplIik7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0Kz1lW3NdKm5bc107cmV0dXJuIHR9bW11bChuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5yb3dzLHQ9dGhpcy5jb2x1bW5zLHM9bi5jb2x1bW5zLHI9bmV3IGIoZSxzKSxpPW5ldyBGbG9hdDY0QXJyYXkodCk7Zm9yKGxldCBoPTA7aDxzO2grKyl7Zm9yKGxldCBsPTA7bDx0O2wrKylpW2xdPW4uZ2V0KGwsaCk7Zm9yKGxldCBsPTA7bDxlO2wrKyl7bGV0IHU9MDtmb3IobGV0IGY9MDtmPHQ7ZisrKXUrPXRoaXMuZ2V0KGwsZikqaVtmXTtyLnNldChsLGgsdSl9fXJldHVybiByfXN0cmFzc2VuMngyKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigyLDIpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPW4uZ2V0KDAsMCkscj10aGlzLmdldCgwLDEpLGk9bi5nZXQoMCwxKSxoPXRoaXMuZ2V0KDEsMCksbD1uLmdldCgxLDApLHU9dGhpcy5nZXQoMSwxKSxmPW4uZ2V0KDEsMSksZz0odCt1KSoocytmKSxhPShoK3UpKnMsaj10KihpLWYpLHc9dSoobC1zKSx5PSh0K3IpKmYsbT0oaC10KSoocytpKSxNPShyLXUpKihsK2YpLFQ9Zyt3LXkrTSxFPWoreSxrPWErdyxSPWctYStqK207cmV0dXJuIGUuc2V0KDAsMCxUKSxlLnNldCgwLDEsRSksZS5zZXQoMSwwLGspLGUuc2V0KDEsMSxSKSxlfXN0cmFzc2VuM3gzKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigzLDMpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPXRoaXMuZ2V0KDAsMSkscj10aGlzLmdldCgwLDIpLGk9dGhpcy5nZXQoMSwwKSxoPXRoaXMuZ2V0KDEsMSksbD10aGlzLmdldCgxLDIpLHU9dGhpcy5nZXQoMiwwKSxmPXRoaXMuZ2V0KDIsMSksZz10aGlzLmdldCgyLDIpLGE9bi5nZXQoMCwwKSxqPW4uZ2V0KDAsMSksdz1uLmdldCgwLDIpLHk9bi5nZXQoMSwwKSxtPW4uZ2V0KDEsMSksTT1uLmdldCgxLDIpLFQ9bi5nZXQoMiwwKSxFPW4uZ2V0KDIsMSksaz1uLmdldCgyLDIpLFI9KHQrcytyLWktaC1mLWcpKm0scT0odC1pKSooLWorbSksST1oKigtYStqK3ktbS1NLVQrayksej0oLXQraStoKSooYS1qK20pLEI9KGkraCkqKC1hK2opLGM9dCphLHA9KC10K3UrZikqKGEtdytNKSxTPSgtdCt1KSoody1NKSxkPSh1K2YpKigtYSt3KSxEPSh0K3Mrci1oLWwtdS1mKSpNLFU9ZiooLWErdyt5LW0tTS1UK0UpLEY9KC1yK2YrZykqKG0rVC1FKSxQPShyLWcpKihtLUUpLFk9cipULEc9KGYrZykqKC1UK0UpLE49KC1yK2grbCkqKE0rVC1rKSwkPShyLWwpKihNLWspLEs9KGgrbCkqKC1UK2spLHY9cyp5LFY9bCpFLEw9aSp3LEM9dSpqLFg9ZyprLHd0PWMrWSt2LHB0PVIreitCK2MrRitZK0csZHQ9YytwK2QrRCtZK04rSyxpdD1xK0kreitjK1krTiskLGx0PXEreitCK2MrVixodD1ZK04rJCtLK0wsanQ9YytwK1MrVStGK1ArWSx1dD1GK1ArWStHK0Msa3Q9YytwK1MrZCtYO3JldHVybiBlLnNldCgwLDAsd3QpLGUuc2V0KDAsMSxwdCksZS5zZXQoMCwyLGR0KSxlLnNldCgxLDAsaXQpLGUuc2V0KDEsMSxsdCksZS5zZXQoMSwyLGh0KSxlLnNldCgyLDAsanQpLGUuc2V0KDIsMSx1dCksZS5zZXQoMiwyLGt0KSxlfW1tdWxTdHJhc3NlbihuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5jbG9uZSgpLHQ9ZS5yb3dzLHM9ZS5jb2x1bW5zLHI9bi5yb3dzLGk9bi5jb2x1bW5zO3MhPT1yJiZjb25zb2xlLndhcm4oYE11bHRpcGx5aW5nICR7dH0geCAke3N9IGFuZCAke3J9IHggJHtpfSBtYXRyaXg6IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLmApO2Z1bmN0aW9uIGgoZyxhLGope2xldCB3PWcucm93cyx5PWcuY29sdW1ucztpZih3PT09YSYmeT09PWopcmV0dXJuIGc7e2xldCBtPV8uemVyb3MoYSxqKTtyZXR1cm4gbT1tLnNldFN1Yk1hdHJpeChnLDAsMCksbX19bGV0IGw9TWF0aC5tYXgodCxyKSx1PU1hdGgubWF4KHMsaSk7ZT1oKGUsbCx1KSxuPWgobixsLHUpO2Z1bmN0aW9uIGYoZyxhLGosdyl7aWYoajw9NTEyfHx3PD01MTIpcmV0dXJuIGcubW11bChhKTtqJTI9PT0xJiZ3JTI9PT0xPyhnPWgoZyxqKzEsdysxKSxhPWgoYSxqKzEsdysxKSk6aiUyPT09MT8oZz1oKGcsaisxLHcpLGE9aChhLGorMSx3KSk6dyUyPT09MSYmKGc9aChnLGosdysxKSxhPWgoYSxqLHcrMSkpO2xldCB5PXBhcnNlSW50KGcucm93cy8yLDEwKSxtPXBhcnNlSW50KGcuY29sdW1ucy8yLDEwKSxNPWcuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxUPWEuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxFPWcuc3ViTWF0cml4KDAseS0xLG0sZy5jb2x1bW5zLTEpLGs9YS5zdWJNYXRyaXgoMCx5LTEsbSxhLmNvbHVtbnMtMSksUj1nLnN1Yk1hdHJpeCh5LGcucm93cy0xLDAsbS0xKSxxPWEuc3ViTWF0cml4KHksYS5yb3dzLTEsMCxtLTEpLEk9Zy5zdWJNYXRyaXgoeSxnLnJvd3MtMSxtLGcuY29sdW1ucy0xKSx6PWEuc3ViTWF0cml4KHksYS5yb3dzLTEsbSxhLmNvbHVtbnMtMSksQj1mKF8uYWRkKE0sSSksXy5hZGQoVCx6KSx5LG0pLGM9ZihfLmFkZChSLEkpLFQseSxtKSxwPWYoTSxfLnN1YihrLHopLHksbSksUz1mKEksXy5zdWIocSxUKSx5LG0pLGQ9ZihfLmFkZChNLEUpLHoseSxtKSxEPWYoXy5zdWIoUixNKSxfLmFkZChULGspLHksbSksVT1mKF8uc3ViKEUsSSksXy5hZGQocSx6KSx5LG0pLEY9Xy5hZGQoQixTKTtGLnN1YihkKSxGLmFkZChVKTtsZXQgUD1fLmFkZChwLGQpLFk9Xy5hZGQoYyxTKSxHPV8uc3ViKEIsYyk7Ry5hZGQocCksRy5hZGQoRCk7bGV0IE49Xy56ZXJvcygyKkYucm93cywyKkYuY29sdW1ucyk7cmV0dXJuIE49Ti5zZXRTdWJNYXRyaXgoRiwwLDApLE49Ti5zZXRTdWJNYXRyaXgoUCxGLnJvd3MsMCksTj1OLnNldFN1Yk1hdHJpeChZLDAsRi5jb2x1bW5zKSxOPU4uc2V0U3ViTWF0cml4KEcsRi5yb3dzLEYuY29sdW1ucyksTi5zdWJNYXRyaXgoMCxqLTEsMCx3LTEpfXJldHVybiBmKGUsbixsLHUpfXNjYWxlUm93cyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMucm93cztyKyspe2NvbnN0IGk9dGhpcy5nZXRSb3cocik7aS5sZW5ndGg+MCYmcXQoaSx7bWluOmUsbWF4OnQsb3V0cHV0Oml9KSxzLnNldFJvdyhyLGkpfXJldHVybiBzfXNjYWxlQ29sdW1ucyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspe2NvbnN0IGk9dGhpcy5nZXRDb2x1bW4ocik7aS5sZW5ndGgmJnF0KGkse21pbjplLG1heDp0LG91dHB1dDppfSkscy5zZXRDb2x1bW4ocixpKX1yZXR1cm4gc31mbGlwUm93cygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMuY29sdW1ucy8yKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQoZSx0KSxyPXRoaXMuZ2V0KGUsdGhpcy5jb2x1bW5zLTEtdCk7dGhpcy5zZXQoZSx0LHIpLHRoaXMuc2V0KGUsdGhpcy5jb2x1bW5zLTEtdCxzKX1yZXR1cm4gdGhpc31mbGlwQ29sdW1ucygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMucm93cy8yKTtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxlKSxyPXRoaXMuZ2V0KHRoaXMucm93cy0xLXQsZSk7dGhpcy5zZXQodCxlLHIpLHRoaXMuc2V0KHRoaXMucm93cy0xLXQsZSxzKX1yZXR1cm4gdGhpc31rcm9uZWNrZXJQcm9kdWN0KG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT10aGlzLnJvd3MsdD10aGlzLmNvbHVtbnMscz1uLnJvd3Mscj1uLmNvbHVtbnMsaT1uZXcgYihlKnMsdCpyKTtmb3IobGV0IGg9MDtoPGU7aCsrKWZvcihsZXQgbD0wO2w8dDtsKyspZm9yKGxldCB1PTA7dTxzO3UrKylmb3IobGV0IGY9MDtmPHI7ZisrKWkuc2V0KHMqaCt1LHIqbCtmLHRoaXMuZ2V0KGgsbCkqbi5nZXQodSxmKSk7cmV0dXJuIGl9a3JvbmVja2VyU3VtKG4pe2lmKG49Yi5jaGVja01hdHJpeChuKSwhdGhpcy5pc1NxdWFyZSgpfHwhbi5pc1NxdWFyZSgpKXRocm93IG5ldyBFcnJvcigiS3JvbmVja2VyIFN1bSBuZWVkcyB0d28gU3F1YXJlIE1hdHJpY2VzIik7bGV0IGU9dGhpcy5yb3dzLHQ9bi5yb3dzLHM9dGhpcy5rcm9uZWNrZXJQcm9kdWN0KGIuZXllKHQsdCkpLHI9Yi5leWUoZSxlKS5rcm9uZWNrZXJQcm9kdWN0KG4pO3JldHVybiBzLmFkZChyKX10cmFuc3Bvc2UoKXtsZXQgbj1uZXcgYih0aGlzLmNvbHVtbnMsdGhpcy5yb3dzKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKW4uc2V0KHQsZSx0aGlzLmdldChlLHQpKTtyZXR1cm4gbn1zb3J0Um93cyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspdGhpcy5zZXRSb3coZSx0aGlzLmdldFJvdyhlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zb3J0Q29sdW1ucyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspdGhpcy5zZXRDb2x1bW4oZSx0aGlzLmdldENvbHVtbihlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zdWJNYXRyaXgobixlLHQscyl7RnQodGhpcyxuLGUsdCxzKTtsZXQgcj1uZXcgYihlLW4rMSxzLXQrMSk7Zm9yKGxldCBpPW47aTw9ZTtpKyspZm9yKGxldCBoPXQ7aDw9cztoKyspci5zZXQoaS1uLGgtdCx0aGlzLmdldChpLGgpKTtyZXR1cm4gcn1zdWJNYXRyaXhSb3cobixlLHQpe2lmKGU9PT12b2lkIDAmJihlPTApLHQ9PT12b2lkIDAmJih0PXRoaXMuY29sdW1ucy0xKSxlPnR8fGU8MHx8ZT49dGhpcy5jb2x1bW5zfHx0PDB8fHQ+PXRoaXMuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXJndW1lbnQgb3V0IG9mIHJhbmdlIik7bGV0IHM9bmV3IGIobi5sZW5ndGgsdC1lKzEpO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7cisrKWZvcihsZXQgaT1lO2k8PXQ7aSsrKXtpZihuW3JdPDB8fG5bcl0+PXRoaXMucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm93IGluZGV4IG91dCBvZiByYW5nZTogJHtuW3JdfWApO3Muc2V0KHIsaS1lLHRoaXMuZ2V0KG5bcl0saSkpfXJldHVybiBzfXN1Yk1hdHJpeENvbHVtbihuLGUsdCl7aWYoZT09PXZvaWQgMCYmKGU9MCksdD09PXZvaWQgMCYmKHQ9dGhpcy5yb3dzLTEpLGU+dHx8ZTwwfHxlPj10aGlzLnJvd3N8fHQ8MHx8dD49dGhpcy5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKCJBcmd1bWVudCBvdXQgb2YgcmFuZ2UiKTtsZXQgcz1uZXcgYih0LWUrMSxuLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspZm9yKGxldCBpPWU7aTw9dDtpKyspe2lmKG5bcl08MHx8bltyXT49dGhpcy5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKGBDb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlOiAke25bcl19YCk7cy5zZXQoaS1lLHIsdGhpcy5nZXQoaSxuW3JdKSl9cmV0dXJuIHN9c2V0U3ViTWF0cml4KG4sZSx0KXtpZihuPWIuY2hlY2tNYXRyaXgobiksbi5pc0VtcHR5KCkpcmV0dXJuIHRoaXM7bGV0IHM9ZStuLnJvd3MtMSxyPXQrbi5jb2x1bW5zLTE7RnQodGhpcyxlLHMsdCxyKTtmb3IobGV0IGk9MDtpPG4ucm93cztpKyspZm9yKGxldCBoPTA7aDxuLmNvbHVtbnM7aCsrKXRoaXMuc2V0KGUraSx0K2gsbi5nZXQoaSxoKSk7cmV0dXJuIHRoaXN9c2VsZWN0aW9uKG4sZSl7aWUodGhpcyxuKSxsZSh0aGlzLGUpO2xldCB0PW5ldyBiKG4ubGVuZ3RoLGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9bltzXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyl7bGV0IGg9ZVtpXTt0LnNldChzLGksdGhpcy5nZXQocixoKSl9fXJldHVybiB0fXRyYWNlKCl7bGV0IG49TWF0aC5taW4odGhpcy5yb3dzLHRoaXMuY29sdW1ucyksZT0wO2ZvcihsZXQgdD0wO3Q8bjt0KyspZSs9dGhpcy5nZXQodCx0KTtyZXR1cm4gZX1jbG9uZSgpe2xldCBuPW5ldyBiKHRoaXMucm93cyx0aGlzLmNvbHVtbnMpO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXN1bShuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBoZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIHVlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBjZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19cHJvZHVjdChuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBmZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIGdlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBhZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19bWVhbihuKXtjb25zdCBlPXRoaXMuc3VtKG4pO3N3aXRjaChuKXtjYXNlInJvdyI6e2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyllW3RdLz10aGlzLmNvbHVtbnM7cmV0dXJuIGV9Y2FzZSJjb2x1bW4iOntmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspZVt0XS89dGhpcy5yb3dzO3JldHVybiBlfWNhc2Ugdm9pZCAwOnJldHVybiBlL3RoaXMuc2l6ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19dmFyaWFuY2UobixlPXt9KXtpZih0eXBlb2Ygbj09Im9iamVjdCImJihlPW4sbj12b2lkIDApLHR5cGVvZiBlIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7dW5iaWFzZWQ6dD0hMCxtZWFuOnM9dGhpcy5tZWFuKG4pfT1lO2lmKHR5cGVvZiB0IT0iYm9vbGVhbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigidW5iaWFzZWQgbXVzdCBiZSBhIGJvb2xlYW4iKTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyhzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtZWFuIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4gbWUodGhpcyx0LHMpfWNhc2UiY29sdW1uIjp7aWYoIVcocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWVhbiBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIHdlKHRoaXMsdCxzKX1jYXNlIHZvaWQgMDp7aWYodHlwZW9mIHMhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIm1lYW4gbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBwZSh0aGlzLHQscyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXN0YW5kYXJkRGV2aWF0aW9uKG4sZSl7dHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKTtjb25zdCB0PXRoaXMudmFyaWFuY2UobixlKTtpZihuPT09dm9pZCAwKXJldHVybiBNYXRoLnNxcnQodCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXT1NYXRoLnNxcnQodFtzXSk7cmV0dXJuIHR9Y2VudGVyKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e2NlbnRlcjp0PXRoaXMubWVhbihuKX09ZTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBkZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiB5ZSh0aGlzLHQpLHRoaXN9Y2FzZSB2b2lkIDA6e2lmKHR5cGVvZiB0IT0ibnVtYmVyIil0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBNZSh0aGlzLHQpLHRoaXN9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXNjYWxlKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2xldCB0PWUuc2NhbGU7c3dpdGNoKG4pe2Nhc2Uicm93Ijp7aWYodD09PXZvaWQgMCl0PUVlKHRoaXMpO2Vsc2UgaWYoIVcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigic2NhbGUgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBTZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZih0PT09dm9pZCAwKXQ9amUodGhpcyk7ZWxzZSBpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJzY2FsZSBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIGtlKHRoaXMsdCksdGhpc31jYXNlIHZvaWQgMDp7aWYodD09PXZvaWQgMCl0PWJlKHRoaXMpO2Vsc2UgaWYodHlwZW9mIHQhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoInNjYWxlIG11c3QgYmUgYSBudW1iZXIiKTtyZXR1cm4gSWUodGhpcyx0KSx0aGlzfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtufWApfX10b1N0cmluZyhuKXtyZXR1cm4gVHQodGhpcyxuKX19Xy5wcm90b3R5cGUua2xhc3M9Ik1hdHJpeCIsdHlwZW9mIFN5bWJvbDwidSImJihfLnByb3RvdHlwZVtTeW1ib2wuZm9yKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpXT1uZSk7ZnVuY3Rpb24gUHQobyxuKXtyZXR1cm4gby1ufWZ1bmN0aW9uIFJlKG8pe3JldHVybiBvLmV2ZXJ5KG49PnR5cGVvZiBuPT0ibnVtYmVyIil9Xy5yYW5kb209Xy5yYW5kLF8ucmFuZG9tSW50PV8ucmFuZEludCxfLmRpYWdvbmFsPV8uZGlhZyxfLnByb3RvdHlwZS5kaWFnb25hbD1fLnByb3RvdHlwZS5kaWFnLF8uaWRlbnRpdHk9Xy5leWUsXy5wcm90b3R5cGUubmVnYXRlPV8ucHJvdG90eXBlLm5lZyxfLnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0PV8ucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7Y2xhc3MgYiBleHRlbmRzIF97Y29uc3RydWN0b3IobixlKXtpZihzdXBlcigpLGIuaXNNYXRyaXgobikpcmV0dXJuIG4uY2xvbmUoKTtpZihOdW1iZXIuaXNJbnRlZ2VyKG4pJiZuPj0wKWlmKHRoaXMuZGF0YT1bXSxOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wKWZvcihsZXQgdD0wO3Q8bjt0KyspdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShlKSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJuQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2Vsc2UgaWYoVyhuKSl7Y29uc3QgdD1uO2lmKG49dC5sZW5ndGgsZT1uP3RbMF0ubGVuZ3RoOjAsdHlwZW9mIGUhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIkRhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQiKTt0aGlzLmRhdGE9W107Zm9yKGxldCBzPTA7czxuO3MrKyl7aWYodFtzXS5sZW5ndGghPT1lKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucyIpO2lmKCFSZSh0W3NdKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnB1dCBkYXRhIGNvbnRhaW5zIG5vbi1udW1lcmljIHZhbHVlcyIpO3RoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKHRbc10pKX19ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Iik7dGhpcy5yb3dzPW4sdGhpcy5jb2x1bW5zPWV9c2V0KG4sZSx0KXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdPXQsdGhpc31nZXQobixlKXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdfXJlbW92ZVJvdyhuKXtyZXR1cm4gUSh0aGlzLG4pLHRoaXMuZGF0YS5zcGxpY2UobiwxKSx0aGlzLnJvd3MtPTEsdGhpc31hZGRSb3cobixlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9bixuPXRoaXMucm93cyksUSh0aGlzLG4sITApLGU9RmxvYXQ2NEFycmF5LmZyb20odHQodGhpcyxlKSksdGhpcy5kYXRhLnNwbGljZShuLDAsZSksdGhpcy5yb3dzKz0xLHRoaXN9cmVtb3ZlQ29sdW1uKG4pe1oodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspe2NvbnN0IHQ9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmNvbHVtbnMtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl0W3NdPXRoaXMuZGF0YVtlXVtzXTtmb3IobGV0IHM9bisxO3M8dGhpcy5jb2x1bW5zO3MrKyl0W3MtMV09dGhpcy5kYXRhW2VdW3NdO3RoaXMuZGF0YVtlXT10fXJldHVybiB0aGlzLmNvbHVtbnMtPTEsdGhpc31hZGRDb2x1bW4obixlKXt0eXBlb2YgZT4idSImJihlPW4sbj10aGlzLmNvbHVtbnMpLFoodGhpcyxuLCEwKSxlPWV0KHRoaXMsZSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXtjb25zdCBzPW5ldyBGbG9hdDY0QXJyYXkodGhpcy5jb2x1bW5zKzEpO2xldCByPTA7Zm9yKDtyPG47cisrKXNbcl09dGhpcy5kYXRhW3RdW3JdO2ZvcihzW3IrK109ZVt0XTtyPHRoaXMuY29sdW1ucysxO3IrKylzW3JdPXRoaXMuZGF0YVt0XVtyLTFdO3RoaXMuZGF0YVt0XT1zfXJldHVybiB0aGlzLmNvbHVtbnMrPTEsdGhpc319cmUoXyxiKTtjbGFzcyBzdCBleHRlbmRzIF97Y29uc3RydWN0b3Iobil7c3VwZXIoKSx0aGlzLmRhdGE9bix0aGlzLnJvd3M9bi5sZW5ndGgsdGhpcy5jb2x1bW5zPW5bMF0ubGVuZ3RofXNldChuLGUsdCl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXT10LHRoaXN9Z2V0KG4sZSl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXX19Y2xhc3MgTmV7Y29uc3RydWN0b3Iobil7bj1zdC5jaGVja01hdHJpeChuKTtsZXQgZT1uLmNsb25lKCksdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgRmxvYXQ2NEFycmF5KHQpLGk9MSxoLGwsdSxmLGcsYSxqLHcseTtmb3IoaD0wO2g8dDtoKyspcltoXT1oO2Zvcih3PW5ldyBGbG9hdDY0QXJyYXkodCksbD0wO2w8cztsKyspe2ZvcihoPTA7aDx0O2grKyl3W2hdPWUuZ2V0KGgsbCk7Zm9yKGg9MDtoPHQ7aCsrKXtmb3IoeT1NYXRoLm1pbihoLGwpLGc9MCx1PTA7dTx5O3UrKylnKz1lLmdldChoLHUpKndbdV07d1toXS09ZyxlLnNldChoLGwsd1toXSl9Zm9yKGY9bCxoPWwrMTtoPHQ7aCsrKU1hdGguYWJzKHdbaF0pPk1hdGguYWJzKHdbZl0pJiYoZj1oKTtpZihmIT09bCl7Zm9yKHU9MDt1PHM7dSsrKWE9ZS5nZXQoZix1KSxlLnNldChmLHUsZS5nZXQobCx1KSksZS5zZXQobCx1LGEpO2o9cltmXSxyW2ZdPXJbbF0scltsXT1qLGk9LWl9aWYobDx0JiZlLmdldChsLGwpIT09MClmb3IoaD1sKzE7aDx0O2grKyllLnNldChoLGwsZS5nZXQoaCxsKS9lLmdldChsLGwpKX10aGlzLkxVPWUsdGhpcy5waXZvdFZlY3Rvcj1yLHRoaXMucGl2b3RTaWduPWl9aXNTaW5ndWxhcigpe2xldCBuPXRoaXMuTFUsZT1uLmNvbHVtbnM7Zm9yKGxldCB0PTA7dDxlO3QrKylpZihuLmdldCh0LHQpPT09MClyZXR1cm4hMDtyZXR1cm4hMX1zb2x2ZShuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5MVTtpZihlLnJvd3MhPT1uLnJvd3MpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zIik7aWYodGhpcy5pc1Npbmd1bGFyKCkpdGhyb3cgbmV3IEVycm9yKCJMVSBtYXRyaXggaXMgc2luZ3VsYXIiKTtsZXQgcz1uLmNvbHVtbnMscj1uLnN1Yk1hdHJpeFJvdyh0aGlzLnBpdm90VmVjdG9yLDAscy0xKSxpPWUuY29sdW1ucyxoLGwsdTtmb3IodT0wO3U8aTt1KyspZm9yKGg9dSsxO2g8aTtoKyspZm9yKGw9MDtsPHM7bCsrKXIuc2V0KGgsbCxyLmdldChoLGwpLXIuZ2V0KHUsbCkqZS5nZXQoaCx1KSk7Zm9yKHU9aS0xO3U+PTA7dS0tKXtmb3IobD0wO2w8cztsKyspci5zZXQodSxsLHIuZ2V0KHUsbCkvZS5nZXQodSx1KSk7Zm9yKGg9MDtoPHU7aCsrKWZvcihsPTA7bDxzO2wrKylyLnNldChoLGwsci5nZXQoaCxsKS1yLmdldCh1LGwpKmUuZ2V0KGgsdSkpfXJldHVybiByfWdldCBkZXRlcm1pbmFudCgpe2xldCBuPXRoaXMuTFU7aWYoIW4uaXNTcXVhcmUoKSl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCBtdXN0IGJlIHNxdWFyZSIpO2xldCBlPXRoaXMucGl2b3RTaWduLHQ9bi5jb2x1bW5zO2ZvcihsZXQgcz0wO3M8dDtzKyspZSo9bi5nZXQocyxzKTtyZXR1cm4gZX1nZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI+aT9zLnNldChyLGksbi5nZXQocixpKSk6cj09PWk/cy5zZXQocixpLDEpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI8PWk/cy5zZXQocixpLG4uZ2V0KHIsaSkpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgcGl2b3RQZXJtdXRhdGlvblZlY3Rvcigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucGl2b3RWZWN0b3IpfX1mdW5jdGlvbiB4KG8sbil7bGV0IGU9MDtyZXR1cm4gTWF0aC5hYnMobyk+TWF0aC5hYnMobik/KGU9bi9vLE1hdGguYWJzKG8pKk1hdGguc3FydCgxK2UqZSkpOm4hPT0wPyhlPW8vbixNYXRoLmFicyhuKSpNYXRoLnNxcnQoMStlKmUpKTowfWNsYXNzIHZle2NvbnN0cnVjdG9yKG4pe249c3QuY2hlY2tNYXRyaXgobik7bGV0IGU9bi5jbG9uZSgpLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IEZsb2F0NjRBcnJheShzKSxpLGgsbCx1O2ZvcihsPTA7bDxzO2wrKyl7bGV0IGY9MDtmb3IoaT1sO2k8dDtpKyspZj14KGYsZS5nZXQoaSxsKSk7aWYoZiE9PTApe2ZvcihlLmdldChsLGwpPDAmJihmPS1mKSxpPWw7aTx0O2krKyllLnNldChpLGwsZS5nZXQoaSxsKS9mKTtmb3IoZS5zZXQobCxsLGUuZ2V0KGwsbCkrMSksaD1sKzE7aDxzO2grKyl7Zm9yKHU9MCxpPWw7aTx0O2krKyl1Kz1lLmdldChpLGwpKmUuZ2V0KGksaCk7Zm9yKHU9LXUvZS5nZXQobCxsKSxpPWw7aTx0O2krKyllLnNldChpLGgsZS5nZXQoaSxoKSt1KmUuZ2V0KGksbCkpfX1yW2xdPS1mfXRoaXMuUVI9ZSx0aGlzLlJkaWFnPXJ9c29sdmUobil7bj1iLmNoZWNrTWF0cml4KG4pO2xldCBlPXRoaXMuUVIsdD1lLnJvd3M7aWYobi5yb3dzIT09dCl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlIik7aWYoIXRoaXMuaXNGdWxsUmFuaygpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Iik7bGV0IHM9bi5jb2x1bW5zLHI9bi5jbG9uZSgpLGk9ZS5jb2x1bW5zLGgsbCx1LGY7Zm9yKHU9MDt1PGk7dSsrKWZvcihsPTA7bDxzO2wrKyl7Zm9yKGY9MCxoPXU7aDx0O2grKylmKz1lLmdldChoLHUpKnIuZ2V0KGgsbCk7Zm9yKGY9LWYvZS5nZXQodSx1KSxoPXU7aDx0O2grKylyLnNldChoLGwsci5nZXQoaCxsKStmKmUuZ2V0KGgsdSkpfWZvcih1PWktMTt1Pj0wO3UtLSl7Zm9yKGw9MDtsPHM7bCsrKXIuc2V0KHUsbCxyLmdldCh1LGwpL3RoaXMuUmRpYWdbdV0pO2ZvcihoPTA7aDx1O2grKylmb3IobD0wO2w8cztsKyspci5zZXQoaCxsLHIuZ2V0KGgsbCktci5nZXQodSxsKSplLmdldChoLHUpKX1yZXR1cm4gci5zdWJNYXRyaXgoMCxpLTEsMCxzLTEpfWlzRnVsbFJhbmsoKXtsZXQgbj10aGlzLlFSLmNvbHVtbnM7Zm9yKGxldCBlPTA7ZTxuO2UrKylpZih0aGlzLlJkaWFnW2VdPT09MClyZXR1cm4hMTtyZXR1cm4hMH1nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4uY29sdW1ucyx0PW5ldyBiKGUsZSkscyxyO2ZvcihzPTA7czxlO3MrKylmb3Iocj0wO3I8ZTtyKyspczxyP3Quc2V0KHMscixuLmdldChzLHIpKTpzPT09cj90LnNldChzLHIsdGhpcy5SZGlhZ1tzXSk6dC5zZXQocyxyLDApO3JldHVybiB0fWdldCBvcnRob2dvbmFsTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCkscixpLGgsbDtmb3IoaD10LTE7aD49MDtoLS0pe2ZvcihyPTA7cjxlO3IrKylzLnNldChyLGgsMCk7Zm9yKHMuc2V0KGgsaCwxKSxpPWg7aTx0O2krKylpZihuLmdldChoLGgpIT09MCl7Zm9yKGw9MCxyPWg7cjxlO3IrKylsKz1uLmdldChyLGgpKnMuZ2V0KHIsaSk7Zm9yKGw9LWwvbi5nZXQoaCxoKSxyPWg7cjxlO3IrKylzLnNldChyLGkscy5nZXQocixpKStsKm4uZ2V0KHIsaCkpfX1yZXR1cm4gc319Y2xhc3MgRHR7Y29uc3RydWN0b3IobixlPXt9KXtpZihuPXN0LmNoZWNrTWF0cml4KG4pLG4uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IG11c3QgYmUgbm9uLWVtcHR5Iik7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zO2NvbnN0e2NvbXB1dGVMZWZ0U2luZ3VsYXJWZWN0b3JzOnI9ITAsY29tcHV0ZVJpZ2h0U2luZ3VsYXJWZWN0b3JzOmk9ITAsYXV0b1RyYW5zcG9zZTpoPSExfT1lO2xldCBsPSEhcix1PSEhaSxmPSExLGc7aWYodDxzKWlmKCFoKWc9bi5jbG9uZSgpLGNvbnNvbGUud2FybigiQ29tcHV0aW5nIFNWRCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgY29sdW1ucyB0aGFuIHJvd3MuIENvbnNpZGVyIGVuYWJsaW5nIGF1dG9UcmFuc3Bvc2UiKTtlbHNle2c9bi50cmFuc3Bvc2UoKSx0PWcucm93cyxzPWcuY29sdW1ucyxmPSEwO2xldCBjPWw7bD11LHU9Y31lbHNlIGc9bi5jbG9uZSgpO2xldCBhPU1hdGgubWluKHQscyksaj1NYXRoLm1pbih0KzEscyksdz1uZXcgRmxvYXQ2NEFycmF5KGopLHk9bmV3IGIodCxhKSxtPW5ldyBiKHMscyksTT1uZXcgRmxvYXQ2NEFycmF5KHMpLFQ9bmV3IEZsb2F0NjRBcnJheSh0KSxFPW5ldyBGbG9hdDY0QXJyYXkoaik7Zm9yKGxldCBjPTA7YzxqO2MrKylFW2NdPWM7bGV0IGs9TWF0aC5taW4odC0xLHMpLFI9TWF0aC5tYXgoMCxNYXRoLm1pbihzLTIsdCkpLHE9TWF0aC5tYXgoayxSKTtmb3IobGV0IGM9MDtjPHE7YysrKXtpZihjPGspe3dbY109MDtmb3IobGV0IHA9YztwPHQ7cCsrKXdbY109eCh3W2NdLGcuZ2V0KHAsYykpO2lmKHdbY10hPT0wKXtnLmdldChjLGMpPDAmJih3W2NdPS13W2NdKTtmb3IobGV0IHA9YztwPHQ7cCsrKWcuc2V0KHAsYyxnLmdldChwLGMpL3dbY10pO2cuc2V0KGMsYyxnLmdldChjLGMpKzEpfXdbY109LXdbY119Zm9yKGxldCBwPWMrMTtwPHM7cCsrKXtpZihjPGsmJndbY10hPT0wKXtsZXQgUz0wO2ZvcihsZXQgZD1jO2Q8dDtkKyspUys9Zy5nZXQoZCxjKSpnLmdldChkLHApO1M9LVMvZy5nZXQoYyxjKTtmb3IobGV0IGQ9YztkPHQ7ZCsrKWcuc2V0KGQscCxnLmdldChkLHApK1MqZy5nZXQoZCxjKSl9TVtwXT1nLmdldChjLHApfWlmKGwmJmM8aylmb3IobGV0IHA9YztwPHQ7cCsrKXkuc2V0KHAsYyxnLmdldChwLGMpKTtpZihjPFIpe01bY109MDtmb3IobGV0IHA9YysxO3A8cztwKyspTVtjXT14KE1bY10sTVtwXSk7aWYoTVtjXSE9PTApe01bYysxXTwwJiYoTVtjXT0wLU1bY10pO2ZvcihsZXQgcD1jKzE7cDxzO3ArKylNW3BdLz1NW2NdO01bYysxXSs9MX1pZihNW2NdPS1NW2NdLGMrMTx0JiZNW2NdIT09MCl7Zm9yKGxldCBwPWMrMTtwPHQ7cCsrKVRbcF09MDtmb3IobGV0IHA9YysxO3A8dDtwKyspZm9yKGxldCBTPWMrMTtTPHM7UysrKVRbcF0rPU1bU10qZy5nZXQocCxTKTtmb3IobGV0IHA9YysxO3A8cztwKyspe2xldCBTPS1NW3BdL01bYysxXTtmb3IobGV0IGQ9YysxO2Q8dDtkKyspZy5zZXQoZCxwLGcuZ2V0KGQscCkrUypUW2RdKX19aWYodSlmb3IobGV0IHA9YysxO3A8cztwKyspbS5zZXQocCxjLE1bcF0pfX1sZXQgST1NYXRoLm1pbihzLHQrMSk7aWYoazxzJiYod1trXT1nLmdldChrLGspKSx0PEkmJih3W0ktMV09MCksUisxPEkmJihNW1JdPWcuZ2V0KFIsSS0xKSksTVtJLTFdPTAsbCl7Zm9yKGxldCBjPWs7YzxhO2MrKyl7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfWZvcihsZXQgYz1rLTE7Yz49MDtjLS0paWYod1tjXSE9PTApe2ZvcihsZXQgcD1jKzE7cDxhO3ArKyl7bGV0IFM9MDtmb3IobGV0IGQ9YztkPHQ7ZCsrKVMrPXkuZ2V0KGQsYykqeS5nZXQoZCxwKTtTPS1TL3kuZ2V0KGMsYyk7Zm9yKGxldCBkPWM7ZDx0O2QrKyl5LnNldChkLHAseS5nZXQoZCxwKStTKnkuZ2V0KGQsYykpfWZvcihsZXQgcD1jO3A8dDtwKyspeS5zZXQocCxjLC15LmdldChwLGMpKTt5LnNldChjLGMsMSt5LmdldChjLGMpKTtmb3IobGV0IHA9MDtwPGMtMTtwKyspeS5zZXQocCxjLDApfWVsc2V7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfX1pZih1KWZvcihsZXQgYz1zLTE7Yz49MDtjLS0pe2lmKGM8UiYmTVtjXSE9PTApZm9yKGxldCBwPWMrMTtwPHM7cCsrKXtsZXQgUz0wO2ZvcihsZXQgZD1jKzE7ZDxzO2QrKylTKz1tLmdldChkLGMpKm0uZ2V0KGQscCk7Uz0tUy9tLmdldChjKzEsYyk7Zm9yKGxldCBkPWMrMTtkPHM7ZCsrKW0uc2V0KGQscCxtLmdldChkLHApK1MqbS5nZXQoZCxjKSl9Zm9yKGxldCBwPTA7cDxzO3ArKyltLnNldChwLGMsMCk7bS5zZXQoYyxjLDEpfWxldCB6PUktMSxCPU51bWJlci5FUFNJTE9OO2Zvcig7ST4wOyl7bGV0IGMscDtmb3IoYz1JLTI7Yz49LTEmJmMhPT0tMTtjLS0pe2NvbnN0IFM9TnVtYmVyLk1JTl9WQUxVRStCKk1hdGguYWJzKHdbY10rTWF0aC5hYnMod1tjKzFdKSk7aWYoTWF0aC5hYnMoTVtjXSk8PVN8fE51bWJlci5pc05hTihNW2NdKSl7TVtjXT0wO2JyZWFrfX1pZihjPT09SS0yKXA9NDtlbHNle2xldCBTO2ZvcihTPUktMTtTPj1jJiZTIT09YztTLS0pe2xldCBkPShTIT09ST9NYXRoLmFicyhNW1NdKTowKSsoUyE9PWMrMT9NYXRoLmFicyhNW1MtMV0pOjApO2lmKE1hdGguYWJzKHdbU10pPD1CKmQpe3dbU109MDticmVha319Uz09PWM/cD0zOlM9PT1JLTE/cD0xOihwPTIsYz1TKX1zd2l0Y2goYysrLHApe2Nhc2UgMTp7bGV0IFM9TVtJLTJdO01bSS0yXT0wO2ZvcihsZXQgZD1JLTI7ZD49YztkLS0pe2xldCBEPXgod1tkXSxTKSxVPXdbZF0vRCxGPVMvRDtpZih3W2RdPUQsZCE9PWMmJihTPS1GKk1bZC0xXSxNW2QtMV09VSpNW2QtMV0pLHUpZm9yKGxldCBQPTA7UDxzO1ArKylEPVUqbS5nZXQoUCxkKStGKm0uZ2V0KFAsSS0xKSxtLnNldChQLEktMSwtRiptLmdldChQLGQpK1UqbS5nZXQoUCxJLTEpKSxtLnNldChQLGQsRCl9YnJlYWt9Y2FzZSAyOntsZXQgUz1NW2MtMV07TVtjLTFdPTA7Zm9yKGxldCBkPWM7ZDxJO2QrKyl7bGV0IEQ9eCh3W2RdLFMpLFU9d1tkXS9ELEY9Uy9EO2lmKHdbZF09RCxTPS1GKk1bZF0sTVtkXT1VKk1bZF0sbClmb3IobGV0IFA9MDtQPHQ7UCsrKUQ9VSp5LmdldChQLGQpK0YqeS5nZXQoUCxjLTEpLHkuc2V0KFAsYy0xLC1GKnkuZ2V0KFAsZCkrVSp5LmdldChQLGMtMSkpLHkuc2V0KFAsZCxEKX1icmVha31jYXNlIDM6e2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5hYnMod1tJLTFdKSxNYXRoLmFicyh3W0ktMl0pLE1hdGguYWJzKE1bSS0yXSksTWF0aC5hYnMod1tjXSksTWF0aC5hYnMoTVtjXSkpLGQ9d1tJLTFdL1MsRD13W0ktMl0vUyxVPU1bSS0yXS9TLEY9d1tjXS9TLFA9TVtjXS9TLFk9KChEK2QpKihELWQpK1UqVSkvMixHPWQqVSooZCpVKTtsZXQgTj0wOyhZIT09MHx8RyE9PTApJiYoWTwwP049MC1NYXRoLnNxcnQoWSpZK0cpOk49TWF0aC5zcXJ0KFkqWStHKSxOPUcvKFkrTikpO2xldCAkPShGK2QpKihGLWQpK04sSz1GKlA7Zm9yKGxldCB2PWM7djxJLTE7disrKXtsZXQgVj14KCQsSyk7Vj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpO2xldCBMPSQvVixDPUsvVjtpZih2IT09YyYmKE1bdi0xXT1WKSwkPUwqd1t2XStDKk1bdl0sTVt2XT1MKk1bdl0tQyp3W3ZdLEs9Qyp3W3YrMV0sd1t2KzFdPUwqd1t2KzFdLHUpZm9yKGxldCBYPTA7WDxzO1grKylWPUwqbS5nZXQoWCx2KStDKm0uZ2V0KFgsdisxKSxtLnNldChYLHYrMSwtQyptLmdldChYLHYpK0wqbS5nZXQoWCx2KzEpKSxtLnNldChYLHYsVik7aWYoVj14KCQsSyksVj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpLEw9JC9WLEM9Sy9WLHdbdl09ViwkPUwqTVt2XStDKndbdisxXSx3W3YrMV09LUMqTVt2XStMKndbdisxXSxLPUMqTVt2KzFdLE1bdisxXT1MKk1bdisxXSxsJiZ2PHQtMSlmb3IobGV0IFg9MDtYPHQ7WCsrKVY9TCp5LmdldChYLHYpK0MqeS5nZXQoWCx2KzEpLHkuc2V0KFgsdisxLC1DKnkuZ2V0KFgsdikrTCp5LmdldChYLHYrMSkpLHkuc2V0KFgsdixWKX1NW0ktMl09JDticmVha31jYXNlIDQ6e2lmKHdbY108PTAmJih3W2NdPXdbY108MD8td1tjXTowLHUpKWZvcihsZXQgUz0wO1M8PXo7UysrKW0uc2V0KFMsYywtbS5nZXQoUyxjKSk7Zm9yKDtjPHomJiEod1tjXT49d1tjKzFdKTspe2xldCBTPXdbY107aWYod1tjXT13W2MrMV0sd1tjKzFdPVMsdSYmYzxzLTEpZm9yKGxldCBkPTA7ZDxzO2QrKylTPW0uZ2V0KGQsYysxKSxtLnNldChkLGMrMSxtLmdldChkLGMpKSxtLnNldChkLGMsUyk7aWYobCYmYzx0LTEpZm9yKGxldCBkPTA7ZDx0O2QrKylTPXkuZ2V0KGQsYysxKSx5LnNldChkLGMrMSx5LmdldChkLGMpKSx5LnNldChkLGMsUyk7YysrfUktLTticmVha319fWlmKGYpe2xldCBjPW07bT15LHk9Y310aGlzLm09dCx0aGlzLm49cyx0aGlzLnM9dyx0aGlzLlU9eSx0aGlzLlY9bX1zb2x2ZShuKXtsZXQgZT1uLHQ9dGhpcy50aHJlc2hvbGQscz10aGlzLnMubGVuZ3RoLHI9Yi56ZXJvcyhzLHMpO2ZvcihsZXQgYT0wO2E8czthKyspTWF0aC5hYnModGhpcy5zW2FdKTw9dD9yLnNldChhLGEsMCk6ci5zZXQoYSxhLDEvdGhpcy5zW2FdKTtsZXQgaT10aGlzLlUsaD10aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzLGw9aC5tbXVsKHIpLHU9aC5yb3dzLGY9aS5yb3dzLGc9Yi56ZXJvcyh1LGYpO2ZvcihsZXQgYT0wO2E8dTthKyspZm9yKGxldCBqPTA7ajxmO2orKyl7bGV0IHc9MDtmb3IobGV0IHk9MDt5PHM7eSsrKXcrPWwuZ2V0KGEseSkqaS5nZXQoaix5KTtnLnNldChhLGosdyl9cmV0dXJuIGcubW11bChlKX1zb2x2ZUZvckRpYWdvbmFsKG4pe3JldHVybiB0aGlzLnNvbHZlKGIuZGlhZyhuKSl9aW52ZXJzZSgpe2xldCBuPXRoaXMuVixlPXRoaXMudGhyZXNob2xkLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IGIodCx0aGlzLnMubGVuZ3RoKTtmb3IobGV0IGY9MDtmPHQ7ZisrKWZvcihsZXQgZz0wO2c8cztnKyspTWF0aC5hYnModGhpcy5zW2ddKT5lJiZyLnNldChmLGcsbi5nZXQoZixnKS90aGlzLnNbZ10pO2xldCBpPXRoaXMuVSxoPWkucm93cyxsPWkuY29sdW1ucyx1PW5ldyBiKHQsaCk7Zm9yKGxldCBmPTA7Zjx0O2YrKylmb3IobGV0IGc9MDtnPGg7ZysrKXtsZXQgYT0wO2ZvcihsZXQgaj0wO2o8bDtqKyspYSs9ci5nZXQoZixqKSppLmdldChnLGopO3Uuc2V0KGYsZyxhKX1yZXR1cm4gdX1nZXQgY29uZGl0aW9uKCl7cmV0dXJuIHRoaXMuc1swXS90aGlzLnNbTWF0aC5taW4odGhpcy5tLHRoaXMubiktMV19Z2V0IG5vcm0yKCl7cmV0dXJuIHRoaXMuc1swXX1nZXQgcmFuaygpe2xldCBuPU1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXSpOdW1iZXIuRVBTSUxPTixlPTAsdD10aGlzLnM7Zm9yKGxldCBzPTAscj10Lmxlbmd0aDtzPHI7cysrKXRbc10+biYmZSsrO3JldHVybiBlfWdldCBkaWFnb25hbCgpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucyl9Z2V0IHRocmVzaG9sZCgpe3JldHVybiBOdW1iZXIuRVBTSUxPTi8yKk1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXX1nZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpe3JldHVybiB0aGlzLlV9Z2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCl7cmV0dXJuIHRoaXMuVn1nZXQgZGlhZ29uYWxNYXRyaXgoKXtyZXR1cm4gYi5kaWFnKHRoaXMucyl9fWZ1bmN0aW9uIE10KG8sbj0hMSl7cmV0dXJuIG89c3QuY2hlY2tNYXRyaXgobyksbj9uZXcgRHQobykuaW52ZXJzZSgpOnFlKG8sYi5leWUoby5yb3dzKSl9ZnVuY3Rpb24gcWUobyxuLGU9ITEpe3JldHVybiBvPXN0LmNoZWNrTWF0cml4KG8pLG49c3QuY2hlY2tNYXRyaXgobiksZT9uZXcgRHQobykuc29sdmUobik6by5pc1NxdWFyZSgpP25ldyBOZShvKS5zb2x2ZShuKTpuZXcgdmUobykuc29sdmUobil9Y29uc3QgX2U9MTIzNCxUZT0oKT0+KHtzZWVkOl9lLGFycmF5U2h1ZmZsZShuKXtjb25zdHthcnI6ZSxzYW1wbGVTaXplOnR9PW47Zm9yKGxldCBzPTA7czx0O3MrKyl7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCByPXRoaXMuc2VlZD4+MTYmMzI3Njc7cj1yJWUubGVuZ3RoO2xldCBpPWVbc107ZVtzXT1lW3JdLGVbcl09aX19LG5leHRJbnQobil7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCBlPXRoaXMuc2VlZD4+MTYmMzI3Njc7cmV0dXJuIGU9ZSVuLGV9fSksSj0obyxuLGUpPT4oblswXS1vWzBdKSooZVsxXS1vWzFdKS0oblsxXS1vWzFdKSooZVswXS1vWzBdKSx6ZT0obyxuLGUsdCxzLHIsaSxoKT0+IShKKG8sbixlKT4wIT1KKHMscixpKT4wfHxKKG4sZSx0KT4wIT1KKHIsaSxoKT4wfHxKKGUsdCxvKT4wIT1KKGksaCxzKT4wfHxKKHQsbyxuKT4wIT1KKGgscyxyKT4wKSxGZT0obyxuLGUsdCxzLHIpPT5KKG8sbixlKT4wPT1KKHQscyxyKT4wLFBlPW89Pntjb25zdCBuPW9bNF0qb1s4XS1vWzVdKm9bN10sZT1vWzNdKm9bOF0tb1s1XSpvWzZdLHQ9b1szXSpvWzddLW9bNF0qb1s2XTtyZXR1cm4gb1swXSpuLW9bMV0qZStvWzJdKnR9LEJ0PShvLG4pPT57Y29uc3QgZT1QZShvKTtpZihNYXRoLmFicyhlKTw9bilyZXR1cm4gbnVsbDtjb25zdCB0PTEvZTtyZXR1cm5bKG9bNF0qb1s4XS1vWzVdKm9bN10pKnQsKG9bMl0qb1s3XS1vWzFdKm9bOF0pKnQsKG9bMV0qb1s1XS1vWzJdKm9bNF0pKnQsKG9bNV0qb1s2XS1vWzNdKm9bOF0pKnQsKG9bMF0qb1s4XS1vWzJdKm9bNl0pKnQsKG9bMl0qb1szXS1vWzBdKm9bNV0pKnQsKG9bM10qb1s3XS1vWzRdKm9bNl0pKnQsKG9bMV0qb1s2XS1vWzBdKm9bN10pKnQsKG9bMF0qb1s0XS1vWzFdKm9bM10pKnRdfSxvdD0obyxuKT0+e2NvbnN0IGU9bls2XSpvWzBdK25bN10qb1sxXStuWzhdLHQ9W107cmV0dXJuIHRbMF09KG5bMF0qb1swXStuWzFdKm9bMV0rblsyXSkvZSx0WzFdPShuWzNdKm9bMF0rbls0XSpvWzFdK25bNV0pL2UsdH0sRGU9KG8sbixlLHQpPT57Y29uc3Qgcz1ydChuLG8pLHI9cnQoZSxvKSxpPXJ0KHQsbyksaD1ydChuLGUpLGw9cnQodCxlKSx1PW10KHMsciksZj1tdChyLGkpLGc9bXQocyxpKSxhPW10KGgsbCk7cmV0dXJuIE1hdGgubWluKE1hdGgubWluKE1hdGgubWluKHUsZiksZyksYSl9LEJlPShvLG4sZSx0KT0+e2NvbnN0IHM9SihvLG4sZSk8PTA7cmV0dXJuIShKKG4sZSx0KTw9MCE9PXN8fEooZSx0LG8pPD0wIT09c3x8Sih0LG8sbik8PTAhPT1zKX0scnQ9KG8sbik9PltvWzBdLW5bMF0sb1sxXS1uWzFdXSxtdD0obyxuKT0+e2NvbnN0IGU9b1swXSpuWzFdLW9bMV0qblswXTtyZXR1cm4gTWF0aC5hYnMoZSkqLjV9LFZ0PShvLG4pPT57Y29uc3R7bm9ybVBvaW50czplLHBhcmFtOnR9PVh0KG8pLHtub3JtUG9pbnRzOnMscGFyYW06cn09WHQobiksaT1zLmxlbmd0aCxoPVtdLGw9W107Zm9yKGxldCB1PTA7dTxpO3UrKyl7Y29uc3QgZj1bZVt1XVswXSxlW3VdWzFdLDEsMCwwLDAsLShlW3VdWzBdKnNbdV1bMF0pLC0oZVt1XVsxXSpzW3VdWzBdKV0sZz1bMCwwLDAsZVt1XVswXSxlW3VdWzFdLDEsLShlW3VdWzBdKnNbdV1bMV0pLC0oZVt1XVsxXSpzW3VdWzFdKV07aC5wdXNoKGYpLGgucHVzaChnKSxsLnB1c2goW3NbdV1bMF1dKSxsLnB1c2goW3NbdV1bMV1dKX10cnl7Y29uc3QgdT1uZXcgYihoKSxmPW5ldyBiKGwpLGc9dS50cmFuc3Bvc2UoKSxhPWcubW11bCh1KSxqPWcubW11bChmKSx5PU10KGEpLm1tdWwoaikudG8xREFycmF5KCk7cmV0dXJuIFZlKHksdCxyKX1jYXRjaHtyZXR1cm4gbnVsbH19LFh0PW89PntsZXQgbj0wLGU9MDtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyluKz1vW2xdWzBdLGUrPW9bbF1bMV07bGV0IHQ9bi9vLmxlbmd0aCxzPWUvby5sZW5ndGgscj0wO2ZvcihsZXQgbD0wO2w8by5sZW5ndGg7bCsrKXtjb25zdCB1PW9bbF1bMF0tdCxmPW9bbF1bMV0tcztyKz1NYXRoLnNxcnQodSp1K2YqZil9bGV0IGk9TWF0aC5zcXJ0KDIpKm8ubGVuZ3RoL3I7Y29uc3QgaD1bXTtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyloLnB1c2goWyhvW2xdWzBdLXQpKmksKG9bbF1bMV0tcykqaV0pO3JldHVybntub3JtUG9pbnRzOmgscGFyYW06e21lYW5YOnQsbWVhblk6cyxzOml9fX0sVmU9KG8sbixlKT0+e2NvbnN0IHQ9ZS5zKmUubWVhblgscz1lLnMqZS5tZWFuWSxyPVtvWzBdK3Qqb1s2XSxvWzFdK3Qqb1s3XSwob1swXSt0Km9bNl0pKi1uLm1lYW5YKyhvWzFdK3Qqb1s3XSkqLW4ubWVhblkrKG9bMl0rdCkvbi5zLG9bM10rcypvWzZdLG9bNF0rcypvWzddLChvWzNdK3Mqb1s2XSkqLW4ubWVhblgrKG9bNF0rcypvWzddKSotbi5tZWFuWSsob1s1XStzKS9uLnMsZS5zKm9bNl0sZS5zKm9bN10sZS5zKm9bNl0qLW4ubWVhblgrZS5zKm9bN10qLW4ubWVhblkrZS5zL24uc107Zm9yKGxldCBpPTA7aTw5O2krKylyW2ldPXJbaV0vcls4XTtyZXR1cm4gcn0sWGU9LjAxLFVlPTEwLCRlPTIwLExlPTEwLFV0PW89Pntjb25zdHtzcmNQb2ludHM6bixkc3RQb2ludHM6ZSxrZXlmcmFtZTp0LHF1aWNrTW9kZTpzfT1vLHI9W1swLDBdLFt0LndpZHRoLDBdLFt0LndpZHRoLHQuaGVpZ2h0XSxbMCx0LmhlaWdodF1dLGk9NDtpZihuLmxlbmd0aDxpKXJldHVybiBudWxsO2NvbnN0IGg9WGUsbD0xLyhoKmgpLHU9TWF0aC5taW4oVWUsbi5sZW5ndGgpLGY9VGUoKSxnPVtdO2ZvcihsZXQgRT0wO0U8bi5sZW5ndGg7RSsrKWdbRV09RTtmLmFycmF5U2h1ZmZsZSh7YXJyOmcsc2FtcGxlU2l6ZTpnLmxlbmd0aH0pO2NvbnN0IGE9cz9MZTokZSxqPWEqMjtsZXQgdz0wO2NvbnN0IHk9W107Zm9yKDt3PGomJnkubGVuZ3RoPGE7KXtpZih3Kz0xLGYuYXJyYXlTaHVmZmxlKHthcnI6ZyxzYW1wbGVTaXplOml9KSwhemUobltnWzBdXSxuW2dbMV1dLG5bZ1syXV0sbltnWzNdXSxlW2dbMF1dLGVbZ1sxXV0sZVtnWzJdXSxlW2dbM11dKSljb250aW51ZTtjb25zdCBFPVZ0KFtuW2dbMF1dLG5bZ1sxXV0sbltnWzJdXSxuW2dbM11dXSxbZVtnWzBdXSxlW2dbMV1dLGVbZ1syXV0sZVtnWzNdXV0pO0UhPT1udWxsJiZIZSh7SDpFLHRlc3RQb2ludHM6cn0pJiZ5LnB1c2goRSl9aWYoeS5sZW5ndGg9PT0wKXJldHVybiBudWxsO2NvbnN0IG09W107Zm9yKGxldCBFPTA7RTx5Lmxlbmd0aDtFKyspbS5wdXNoKHtIOnlbRV0sY29zdDowfSk7bGV0IE09dTtmb3IobGV0IEU9MDtFPG4ubGVuZ3RoJiZtLmxlbmd0aD4yO0UrPU0pe009TWF0aC5taW4odSxuLmxlbmd0aC1FKTtsZXQgaz1FK007Zm9yKGxldCBSPTA7UjxtLmxlbmd0aDtSKyspZm9yKGxldCBxPUU7cTxrO3ErKyl7Y29uc3QgST1DZSh7SDptW1JdLkgsc3JjUG9pbnQ6bltxXSxkc3RQb2ludDplW3FdLG9uZU92ZXJTY2FsZTI6bH0pO21bUl0uY29zdCs9SX1tLnNvcnQoKFIscSk9PlIuY29zdC1xLmNvc3QpLG0uc3BsaWNlKC1NYXRoLmZsb29yKChtLmxlbmd0aCsxKS8yKSl9bGV0IFQ9bnVsbDtmb3IobGV0IEU9MDtFPG0ubGVuZ3RoO0UrKyl7Y29uc3Qgaz1ZZSh7aW5IOm1bRV0uSH0pO2lmKE9lKHtIOmssdGVzdFBvaW50czpyLGtleWZyYW1lOnR9KSl7VD1rO2JyZWFrfX1yZXR1cm4gVH0sT2U9KHtIOm8sdGVzdFBvaW50czpuLGtleWZyYW1lOmV9KT0+e2NvbnN0IHQ9QnQobywxZS01KTtpZih0PT09bnVsbClyZXR1cm4hMTtjb25zdCBzPVtdO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXMucHVzaChvdChuW2ldLHQpKTtyZXR1cm4hKERlKHNbMF0sc1sxXSxzWzJdLHNbM10pPGUud2lkdGgqZS5oZWlnaHQqMWUtNHx8IUJlKHNbMF0sc1sxXSxzWzJdLHNbM10pKX0sWWU9KHtpbkg6b30pPT57Y29uc3Qgbj0xL29bOF0sZT1bXTtmb3IobGV0IHQ9MDt0PDg7dCsrKWVbdF09b1t0XSpuO3JldHVybiBlWzhdPTEsZX0sQ2U9KHtIOm8sc3JjUG9pbnQ6bixkc3RQb2ludDplLG9uZU92ZXJTY2FsZTI6dH0pPT57Y29uc3Qgcz1vdChuLG8pLHI9W3NbMF0tZVswXSxzWzFdLWVbMV1dO3JldHVybiBNYXRoLmxvZygxKyhyWzBdKnJbMF0rclsxXSpyWzFdKSp0KX0sSGU9KHtIOm8sdGVzdFBvaW50czpufSk9Pntjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWVbdF09b3Qoblt0XSxvKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3Qgcz10LHI9KHQrMSklbi5sZW5ndGgsaT0odCsyKSVuLmxlbmd0aDtpZighRmUobltzXSxuW3JdLG5baV0sZVtzXSxlW3JdLGVbaV0pKXJldHVybiExfXJldHVybiEwfSwkdD0zLEx0PTYsS2U9OCxPdD0uNyxKZT0oe2tleWZyYW1lOm8scXVlcnlwb2ludHM6bixxdWVyeXdpZHRoOmUscXVlcnloZWlnaHQ6dCxkZWJ1Z01vZGU6c30pPT57bGV0IHI9e307Y29uc3QgaT1bXTtmb3IobGV0IG09MDttPG4ubGVuZ3RoO20rKyl7Y29uc3QgTT1uW21dLFQ9TS5tYXhpbWE/by5tYXhpbWFQb2ludHM6by5taW5pbWFQb2ludHM7aWYoVC5sZW5ndGg9PT0wKWNvbnRpbnVlO2NvbnN0IEU9TS5tYXhpbWE/by5tYXhpbWFQb2ludHNDbHVzdGVyLnJvb3ROb2RlOm8ubWluaW1hUG9pbnRzQ2x1c3Rlci5yb290Tm9kZSxrPVtdLFI9bmV3IFd0KFtdLChCLGMpPT5CLmQtYy5kKTtFdCh7bm9kZTpFLGtleXBvaW50czpULHF1ZXJ5cG9pbnQ6TSxxdWV1ZTpSLGtleXBvaW50SW5kZXhlczprLG51bVBvcDowfSk7bGV0IHE9LTEsST1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUix6PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2ZvcihsZXQgQj0wO0I8ay5sZW5ndGg7QisrKXtjb25zdCBjPVRba1tCXV0scD15dCh7djE6Yy5kZXNjcmlwdG9ycyx2MjpNLmRlc2NyaXB0b3JzfSk7cDxJPyh6PUksST1wLHE9a1tCXSk6cDx6JiYoej1wKX1xIT09LTEmJih6PT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDEqSS96PE90KSYmaS5wdXNoKHtxdWVyeXBvaW50Ok0sa2V5cG9pbnQ6VFtxXX0pfWlmKHMmJihyLm1hdGNoZXM9aSksaS5sZW5ndGg8THQpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgaD12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczppfSk7cyYmKHIuaG91Z2hNYXRjaGVzPWgpO2NvbnN0IGw9VXQoe3NyY1BvaW50czpoLm1hcChtPT5bbS5rZXlwb2ludC54LG0ua2V5cG9pbnQueV0pLGRzdFBvaW50czpoLm1hcChtPT5bbS5xdWVyeXBvaW50LngsbS5xdWVyeXBvaW50LnldKSxrZXlmcmFtZTpvfSk7aWYobD09PW51bGwpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgdT1ZdCh7SDpsLG1hdGNoZXM6aCx0aHJlc2hvbGQ6JHR9KTtpZihzJiYoci5pbmxpZXJNYXRjaGVzPXUpLHUubGVuZ3RoPEx0KXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IGY9QnQobCwxZS01KSxnPTEwKjEwLGE9W107Zm9yKGxldCBtPTA7bTxuLmxlbmd0aDttKyspe2NvbnN0IE09blttXSxUPW90KFtNLngsTS55XSxmKTtsZXQgRT0tMSxrPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Y29uc3QgcT1NLm1heGltYT9vLm1heGltYVBvaW50czpvLm1pbmltYVBvaW50cztmb3IobGV0IEk9MDtJPHEubGVuZ3RoO0krKyl7Y29uc3Qgej1xW0ldO2lmKCh6LngtVFswXSkqKHoueC1UWzBdKSsoei55LVRbMV0pKih6LnktVFsxXSk+Zyljb250aW51ZTtjb25zdCBjPXl0KHt2MTp6LmRlc2NyaXB0b3JzLHYyOk0uZGVzY3JpcHRvcnN9KTtjPGs/KFI9ayxrPWMsRT1JKTpjPFImJihSPWMpfUUhPT0tMSYmKFI9PT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8MSprL1I8T3QpJiZhLnB1c2goe3F1ZXJ5cG9pbnQ6TSxrZXlwb2ludDpxW0VdfSl9cyYmKHIubWF0Y2hlczI9YSk7Y29uc3Qgaj12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczphfSk7cyYmKHIuaG91Z2hNYXRjaGVzMj1qKTtjb25zdCB3PVV0KHtzcmNQb2ludHM6ai5tYXAobT0+W20ua2V5cG9pbnQueCxtLmtleXBvaW50LnldKSxkc3RQb2ludHM6ai5tYXAobT0+W20ucXVlcnlwb2ludC54LG0ucXVlcnlwb2ludC55XSksa2V5ZnJhbWU6b30pO2lmKHc9PT1udWxsKXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IHk9WXQoe0g6dyxtYXRjaGVzOmosdGhyZXNob2xkOiR0fSk7cmV0dXJuIHMmJihyLmlubGllck1hdGNoZXMyPXkpLHtIOncsbWF0Y2hlczp5LGRlYnVnRXh0cmE6cn19LEV0PSh7bm9kZTpvLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSk9PntpZihvLmxlYWYpe2ZvcihsZXQgbD0wO2w8by5wb2ludEluZGV4ZXMubGVuZ3RoO2wrKylzLnB1c2goby5wb2ludEluZGV4ZXNbbF0pO3JldHVybn1jb25zdCBpPVtdO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKXtjb25zdCBmPW8uY2hpbGRyZW5bbF0uY2VudGVyUG9pbnRJbmRleCxnPXl0KHt2MTpuW2ZdLmRlc2NyaXB0b3JzLHYyOmUuZGVzY3JpcHRvcnN9KTtpLnB1c2goZyl9bGV0IGg9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Zm9yKGxldCBsPTA7bDxvLmNoaWxkcmVuLmxlbmd0aDtsKyspaD1NYXRoLm1pbihoLGlbbF0pO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKWlbbF0hPT1oJiZ0LnB1c2goe25vZGU6by5jaGlsZHJlbltsXSxkOmlbbF19KTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKylpW2xdPT09aCYmRXQoe25vZGU6by5jaGlsZHJlbltsXSxrZXlwb2ludHM6bixxdWVyeXBvaW50OmUscXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pO2lmKHI8S2UmJnQubGVuZ3RoPjApe2NvbnN0e25vZGU6bCxkOnV9PXQucG9wKCk7cis9MSxFdCh7bm9kZTpsLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSl9fSxZdD1vPT57Y29uc3R7SDpuLG1hdGNoZXM6ZSx0aHJlc2hvbGQ6dH09byxzPXQqdCxyPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKXtjb25zdCBoPWVbaV0ucXVlcnlwb2ludCxsPWVbaV0ua2V5cG9pbnQsdT1vdChbbC54LGwueV0sbik7KHVbMF0taC54KSoodVswXS1oLngpKyh1WzFdLWgueSkqKHVbMV0taC55KTw9cyYmci5wdXNoKGVbaV0pfXJldHVybiByfTtjbGFzcyBHZXtjb25zdHJ1Y3RvcihuLGUsdD0hMSl7dGhpcy5xdWVyeVdpZHRoPW4sdGhpcy5xdWVyeUhlaWdodD1lLHRoaXMuZGVidWdNb2RlPXR9bWF0Y2hEZXRlY3Rpb24obixlKXtsZXQgdD17ZnJhbWVzOltdfSxzPW51bGw7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspe2NvbnN0e0g6dSxtYXRjaGVzOmYsZGVidWdFeHRyYTpnfT1KZSh7a2V5ZnJhbWU6bltsXSxxdWVyeXBvaW50czplLHF1ZXJ5d2lkdGg6dGhpcy5xdWVyeVdpZHRoLHF1ZXJ5aGVpZ2h0OnRoaXMucXVlcnlIZWlnaHQsZGVidWdNb2RlOnRoaXMuZGVidWdNb2RlfSk7dC5mcmFtZXMucHVzaChnKSx1JiYocz09PW51bGx8fHMubWF0Y2hlcy5sZW5ndGg8Zi5sZW5ndGgpJiYocz17a2V5ZnJhbWVJbmRleDpsLEg6dSxtYXRjaGVzOmZ9KX1pZihzPT09bnVsbClyZXR1cm57a2V5ZnJhbWVJbmRleDotMSxkZWJ1Z0V4dHJhOnR9O2NvbnN0IHI9W10saT1bXSxoPW5bcy5rZXlmcmFtZUluZGV4XTtmb3IobGV0IGw9MDtsPHMubWF0Y2hlcy5sZW5ndGg7bCsrKXtjb25zdCB1PXMubWF0Y2hlc1tsXS5xdWVyeXBvaW50LGY9cy5tYXRjaGVzW2xdLmtleXBvaW50O3IucHVzaCh7eDp1LngseTp1Lnl9KSxpLnB1c2goe3g6KGYueCsuNSkvaC5zY2FsZSx5OihmLnkrLjUpL2guc2NhbGUsejowfSl9cmV0dXJue3NjcmVlbkNvb3JkczpyLHdvcmxkQ29vcmRzOmksa2V5ZnJhbWVJbmRleDpzLmtleWZyYW1lSW5kZXgsZGVidWdFeHRyYTp0fX19Y29uc3QgV2U9KHtzY3JlZW5Db29yZHM6byx3b3JsZENvb3JkczpuLHByb2plY3Rpb25UcmFuc2Zvcm06ZX0pPT57Y29uc3QgdD1WdChuLm1hcChtPT5bbS54LG0ueV0pLG8ubWFwKG09PlttLngsbS55XSkpLHM9bmV3IGIoW1t0WzBdLHRbMV0sdFsyXV0sW3RbM10sdFs0XSx0WzVdXSxbdFs2XSx0WzddLHRbOF1dXSkscj1uZXcgYihlKSxsPU10KHIpLm1tdWwocykudG8xREFycmF5KCksdT1NYXRoLnNxcnQobFswXSpsWzBdK2xbM10qbFszXStsWzZdKmxbNl0pLGY9TWF0aC5zcXJ0KGxbMV0qbFsxXStsWzRdKmxbNF0rbFs3XSpsWzddKSxnPSh1K2YpLzIsYT1bXTthWzBdPWxbMF0vdSxhWzNdPWxbM10vdSxhWzZdPWxbNl0vdSxhWzFdPWxbMV0vZixhWzRdPWxbNF0vZixhWzddPWxbN10vZixhWzJdPWFbM10qYVs3XS1hWzZdKmFbNF0sYVs1XT1hWzZdKmFbMV0tYVswXSphWzddLGFbOF09YVswXSphWzRdLWFbMV0qYVszXTtjb25zdCBqPU1hdGguc3FydChhWzJdKmFbMl0rYVs1XSphWzVdK2FbOF0qYVs4XSk7YVsyXS89aixhWzVdLz1qLGFbOF0vPWo7Y29uc3Qgdz1bXTtyZXR1cm4gd1swXT1sWzJdL2csd1sxXT1sWzVdL2csd1syXT1sWzhdL2csW1thWzBdLGFbMV0sYVsyXSx3WzBdXSxbYVszXSxhWzRdLGFbNV0sd1sxXV0sW2FbNl0sYVs3XSxhWzhdLHdbMl1dXX0sUWU9KG8sbik9Pltbb1swXVswXSpuWzBdWzBdK29bMF1bMl0qblsyXVswXSxvWzBdWzBdKm5bMF1bMV0rb1swXVsyXSpuWzJdWzFdLG9bMF1bMF0qblswXVsyXStvWzBdWzJdKm5bMl1bMl0sb1swXVswXSpuWzBdWzNdK29bMF1bMl0qblsyXVszXV0sW29bMV1bMV0qblsxXVswXStvWzFdWzJdKm5bMl1bMF0sb1sxXVsxXSpuWzFdWzFdK29bMV1bMl0qblsyXVsxXSxvWzFdWzFdKm5bMV1bMl0rb1sxXVsyXSpuWzJdWzJdLG9bMV1bMV0qblsxXVszXStvWzFdWzJdKm5bMl1bM11dLFtuWzJdWzBdLG5bMl1bMV0sblsyXVsyXSxuWzJdWzNdXV0sQ3Q9KG8sbixlLHQpPT57Y29uc3Qgcz1vWzBdWzBdKm4rb1swXVsxXSplK29bMF1bM10scj1vWzFdWzBdKm4rb1sxXVsxXSplK29bMV1bM10saT1vWzJdWzBdKm4rb1syXVsxXSplK29bMl1bM107cmV0dXJue3g6cyx5OnIsejppfX0sWmU9KG8sbixlLHQpPT57Y29uc3R7eDpzLHk6cix6Oml9PUN0KG8sbixlKTtyZXR1cm57eDpzL2kseTpyL2l9fSx4ZT01LEFlPTQsSHQ9MTAsdG49LjEsZW49Ljk5O2xldCBIPVtbXSxbXSxbXV0sQT1bW10sW11dLE89W1tdLFtdLFtdXTtjb25zdCBubj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dH0pPT57bGV0IHM9MCxyPTA7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDtnKyspcys9ZVtnXS54LHIrPWVbZ10ueTtzLz1lLmxlbmd0aCxyLz1lLmxlbmd0aDtjb25zdCBpPVtdO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7ZysrKWkucHVzaCh7eDplW2ddLngtcyx5OmVbZ10ueS1yLHo6ZVtnXS56fSk7Y29uc3QgaD1bW10sW10sW11dO2ZvcihsZXQgZz0wO2c8MztnKyspZm9yKGxldCBhPTA7YTwzO2ErKyloW2ddW2FdPW9bZ11bYV07aFswXVszXT1vWzBdWzBdKnMrb1swXVsxXSpyK29bMF1bM10saFsxXVszXT1vWzFdWzBdKnMrb1sxXVsxXSpyK29bMV1bM10saFsyXVszXT1vWzJdWzBdKnMrb1syXVsxXSpyK29bMl1bM107Y29uc3QgbD1bMSwuOCwuNiwuNCwwXTtsZXQgdT1oLGY9bnVsbDtmb3IobGV0IGc9MDtnPGwubGVuZ3RoO2crKyl7Y29uc3QgYT1zbih7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTp1LHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkczppLHNjcmVlbkNvb3Jkczp0LGlubGllclByb2I6bFtnXX0pO2lmKHU9YS5tb2RlbFZpZXdUcmFuc2Zvcm0sYS5lcnI8eGUpe2Y9dTticmVha319cmV0dXJuIGY9PT1udWxsP251bGw6KGZbMF1bM109ZlswXVszXS1mWzBdWzBdKnMtZlswXVsxXSpyLGZbMV1bM109ZlsxXVszXS1mWzFdWzBdKnMtZlsxXVsxXSpyLGZbMl1bM109ZlsyXVszXS1mWzJdWzBdKnMtZlsyXVsxXSpyLGYpfSxzbj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dCxpbmxpZXJQcm9iOnN9KT0+e2NvbnN0IHI9czwxO2xldCBpPW8saD0wLGw9MCx1PW5ldyBBcnJheShlLmxlbmd0aCksZj1uZXcgQXJyYXkoZS5sZW5ndGgpLGc9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBqPTA7ajw9SHQ7aisrKXtjb25zdCB3PVFlKG4saSk7Zm9yKGxldCBFPTA7RTxlLmxlbmd0aDtFKyspe2NvbnN0IGs9WmUodyxlW0VdLngsZVtFXS55LGVbRV0ueiksUj10W0VdLngtay54LHE9dFtFXS55LWsueTtnW0VdPVIsYVtFXT1xLHVbRV09UipSK3EqcX1sZXQgeTtpZihsPTAscil7Y29uc3QgRT1NYXRoLm1heCgzLE1hdGguZmxvb3IoZS5sZW5ndGgqcyktMSk7Zm9yKGxldCBrPTA7azxlLmxlbmd0aDtrKyspZltrXT11W2tdO2Yuc29ydCgoayxSKT0+ay1SKSx5PU1hdGgubWF4KGZbRV0qQWUsMTYpO2ZvcihsZXQgaz0wO2s8ZS5sZW5ndGg7aysrKWZba10+eT9sKz15LzY6bCs9eS82KigxLSgxLWZba10veSkqKDEtZltrXS95KSooMS1mW2tdL3kpKX1lbHNlIGZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKWwrPXVbRV07aWYobC89ZS5sZW5ndGgsbDx0bnx8aj4wJiZsL2g+ZW58fGo9PT1IdClicmVhaztoPWw7Y29uc3QgbT1bXSxNPVtdO2ZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKXtpZihyJiZ1W0VdPnkpY29udGludWU7Y29uc3Qgaz1sbih7bW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybTp3LG1vZGVsVmlld1RyYW5zZm9ybTppLHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkOmVbRV19KTtpZihyKXtjb25zdCBSPSgxLXVbRV0veSkqKDEtdVtFXS95KTtmb3IobGV0IHE9MDtxPDI7cSsrKWZvcihsZXQgST0wO0k8NjtJKyspa1txXVtJXSo9UjttLnB1c2goW2dbRV0qUl0pLG0ucHVzaChbYVtFXSpSXSl9ZWxzZSBtLnB1c2goW2dbRV1dKSxtLnB1c2goW2FbRV1dKTtmb3IobGV0IFI9MDtSPGsubGVuZ3RoO1IrKylNLnB1c2goa1tSXSl9Y29uc3QgVD1ybih7ZFU6bSxKX1VfUzpNfSk7aWYoVD09PW51bGwpYnJlYWs7aT1vbih7bW9kZWxWaWV3VHJhbnNmb3JtOmksZFM6VH0pfXJldHVybnttb2RlbFZpZXdUcmFuc2Zvcm06aSxlcnI6bH19LG9uPSh7bW9kZWxWaWV3VHJhbnNmb3JtOm8sZFM6bn0pPT57bGV0IGU9blswXSpuWzBdK25bMV0qblsxXStuWzJdKm5bMl0sdCxzLHI7ZTwxZS02Pyh0PTEscz0wLHI9MCxlPTApOihlPU1hdGguc3FydChlKSx0PW5bMF0vZSxzPW5bMV0vZSxyPW5bMl0vZSk7Y29uc3QgaT1NYXRoLmNvcyhlKSxoPU1hdGguc2luKGUpLGw9MS1pO0hbMF1bMF09dCp0KmwraSxIWzBdWzFdPXQqcypsLXIqaCxIWzBdWzJdPXQqcipsK3MqaCxIWzBdWzNdPW5bM10sSFsxXVswXT1zKnQqbCtyKmgsSFsxXVsxXT1zKnMqbCtpLEhbMV1bMl09cypyKmwtdCpoLEhbMV1bM109bls0XSxIWzJdWzBdPXIqdCpsLXMqaCxIWzJdWzFdPXIqcypsK3QqaCxIWzJdWzJdPXIqcipsK2ksSFsyXVszXT1uWzVdO2NvbnN0IHU9W1tdLFtdLFtdXTtmb3IobGV0IGY9MDtmPDM7ZisrKXtmb3IobGV0IGc9MDtnPDQ7ZysrKXVbZl1bZ109b1tmXVswXSpIWzBdW2ddK29bZl1bMV0qSFsxXVtnXStvW2ZdWzJdKkhbMl1bZ107dVtmXVszXSs9b1tmXVszXX1yZXR1cm4gdX0scm49KHtkVTpvLEpfVV9TOm59KT0+e2NvbnN0IGU9bmV3IGIobiksdD1uZXcgYihvKSxzPWUudHJhbnNwb3NlKCkscj1zLm1tdWwoZSksaT1zLm1tdWwodCk7bGV0IGg7dHJ5e2g9TXQocil9Y2F0Y2h7cmV0dXJuIG51bGx9cmV0dXJuIGgubW11bChpKS50bzFEQXJyYXkoKX0sbG49KHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtOm8sbW9kZWxWaWV3VHJhbnNmb3JtOm4scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmQ6dH0pPT57Y29uc3Qgcz1uLHt4OnIseTppLHo6aH09dCxsPUN0KG8scixpKSx1PWwueipsLno7QVswXVswXT1lWzBdWzBdKmwuei91LEFbMF1bMV09ZVswXVsxXSpsLnovdSxBWzBdWzJdPShlWzBdWzJdKmwuei1lWzJdWzJdKmwueCkvdSxBWzFdWzBdPWVbMV1bMF0qbC56L3UsQVsxXVsxXT1lWzFdWzFdKmwuei91LEFbMV1bMl09KGVbMV1bMl0qbC56LWVbMl1bMl0qbC55KS91LE9bMF1bMF09c1swXVsyXSppLE9bMF1bMV09LXNbMF1bMl0qcixPWzBdWzJdPXNbMF1bMV0qci1zWzBdWzBdKmksT1swXVszXT1zWzBdWzBdLE9bMF1bNF09c1swXVsxXSxPWzBdWzVdPXNbMF1bMl0sT1sxXVswXT1zWzFdWzJdKmksT1sxXVsxXT0tc1sxXVsyXSpyLE9bMV1bMl09c1sxXVsxXSpyLXNbMV1bMF0qaSxPWzFdWzNdPXNbMV1bMF0sT1sxXVs0XT1zWzFdWzFdLE9bMV1bNV09c1sxXVsyXSxPWzJdWzBdPXNbMl1bMl0qaSxPWzJdWzFdPS1zWzJdWzJdKnIsT1syXVsyXT1zWzJdWzFdKnItc1syXVswXSppLE9bMl1bM109c1syXVswXSxPWzJdWzRdPXNbMl1bMV0sT1syXVs1XT1zWzJdWzJdO2NvbnN0IGY9W1tdLFtdXTtmb3IobGV0IGc9MDtnPDI7ZysrKWZvcihsZXQgYT0wO2E8NjthKyspe2ZbZ11bYV09MDtmb3IobGV0IGo9MDtqPDM7aisrKWZbZ11bYV0rPUFbZ11bal0qT1tqXVthXX1yZXR1cm4gZn07Y2xhc3MgaG57Y29uc3RydWN0b3Iobil7dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtPW59ZXN0aW1hdGUoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmV9KXtyZXR1cm4gV2Uoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmUscHJvamVjdGlvblRyYW5zZm9ybTp0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm19KX1yZWZpbmVFc3RpbWF0ZSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTpuLHdvcmxkQ29vcmRzOmUsc2NyZWVuQ29vcmRzOnR9KXtyZXR1cm4gbm4oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06bix3b3JsZENvb3JkczplLHNjcmVlbkNvb3Jkczp0LHByb2plY3Rpb25UcmFuc2Zvcm06dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtfSl9fWxldCBLdD1udWxsLEp0PSExLEd0PW51bGwsU3Q9bnVsbDtvbm1lc3NhZ2U9bz0+e2NvbnN0e2RhdGE6bn09bztzd2l0Y2gobi50eXBlKXtjYXNlInNldHVwIjpuLnByb2plY3Rpb25UcmFuc2Zvcm0sS3Q9bi5tYXRjaGluZ0RhdGFMaXN0LEp0PW4uZGVidWdNb2RlLEd0PW5ldyBHZShuLmlucHV0V2lkdGgsbi5pbnB1dEhlaWdodCxKdCksU3Q9bmV3IGhuKG4ucHJvamVjdGlvblRyYW5zZm9ybSk7YnJlYWs7Y2FzZSJtYXRjaCI6Y29uc3QgZT1uLnRhcmdldEluZGV4ZXM7bGV0IHQ9LTEscz1udWxsLHI9bnVsbDtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrKyl7Y29uc3QgZz1lW2ZdLHtrZXlmcmFtZUluZGV4OmEsc2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6dyxkZWJ1Z0V4dHJhOnl9PUd0Lm1hdGNoRGV0ZWN0aW9uKEt0W2ddLG4uZmVhdHVyZVBvaW50cyk7aWYocj15LGEhPT0tMSl7Y29uc3QgbT1TdC5lc3RpbWF0ZSh7c2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6d30pO20mJih0PWcscz1tKTticmVha319cG9zdE1lc3NhZ2Uoe3R5cGU6Im1hdGNoRG9uZSIsdGFyZ2V0SW5kZXg6dCxtb2RlbFZpZXdUcmFuc2Zvcm06cyxkZWJ1Z0V4dHJhOnJ9KTticmVhaztjYXNlInRyYWNrVXBkYXRlIjpjb25zdHttb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfT1uLHU9U3QucmVmaW5lRXN0aW1hdGUoe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfSk7cG9zdE1lc3NhZ2Uoe3R5cGU6InRyYWNrVXBkYXRlRG9uZSIsbW9kZWxWaWV3VHJhbnNmb3JtOnV9KTticmVhaztjYXNlImRpc3Bvc2UiOmNsb3NlKCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSB0eXBlICcke24udHlwZX0nYCl9fX0pKCk7Cg==",FF=typeof window<"u"&&window.Blob&&new Blob([atob(DF)],{type:"text/javascript;charset=utf-8"});function Wse(ou){let nu;try{if(nu=FF&&(window.URL||window.webkitURL).createObjectURL(FF),!nu)throw"";const ru=new Worker(nu,{name:ou==null?void 0:ou.name});return ru.addEventListener("error",()=>{(window.URL||window.webkitURL).revokeObjectURL(nu)}),ru}catch{return new Worker("data:application/javascript;base64,"+DF,{name:ou==null?void 0:ou.name})}finally{nu&&(window.URL||window.webkitURL).revokeObjectURL(nu)}}const Hse=(ou,nu)=>[[ou[0][0]*nu[0][0]+ou[0][2]*nu[2][0],ou[0][0]*nu[0][1]+ou[0][2]*nu[2][1],ou[0][0]*nu[0][2]+ou[0][2]*nu[2][2],ou[0][0]*nu[0][3]+ou[0][2]*nu[2][3]],[ou[1][1]*nu[1][0]+ou[1][2]*nu[2][0],ou[1][1]*nu[1][1]+ou[1][2]*nu[2][1],ou[1][1]*nu[1][2]+ou[1][2]*nu[2][2],ou[1][1]*nu[1][3]+ou[1][2]*nu[2][3]],[nu[2][0],nu[2][1],nu[2][2],nu[2][3]]],Xse=(ou,nu,ru,lu)=>{const cu=ou[0][0]*nu+ou[0][1]*ru+ou[0][3],hu=ou[1][0]*nu+ou[1][1]*ru+ou[1][3],pu=ou[2][0]*nu+ou[2][1]*ru+ou[2][3];return{x:cu,y:hu,z:pu}},Qse=(ou,nu,ru,lu)=>{const{x:cu,y:hu,z:pu}=Xse(ou,nu,ru);return{x:cu/pu,y:hu/pu}},Kse=6,Zse=1,jse=10,Yse=1,qse=.8,Jse=1,jx=1e3;class eoe{constructor(nu,ru,lu,cu,hu,pu=!1){this.markerDimensions=nu,this.trackingDataList=ru,this.projectionTransform=lu,this.debugMode=pu,this.trackingKeyframeList=[];for(let Au=0;Au<ru.length;Au++)this.trackingKeyframeList.push(ru[Au][Jse]);let mu=0;for(let Au=0;Au<this.trackingKeyframeList.length;Au++)mu=Math.max(mu,this.trackingKeyframeList[Au].points.length);this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(let Au=0;Au<this.trackingKeyframeList.length;Au++){const{featurePoints:bu,imagePixels:Cu,imageProperties:wu}=this._prebuild(this.trackingKeyframeList[Au],mu);this.featurePointsListT[Au]=bu,this.imagePixelsListT[Au]=Cu,this.imagePropertiesListT[Au]=wu}this.kernelCaches={}}dummyRun(nu){let ru=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let lu=0;lu<this.featurePointsListT.length;lu++)this.track(nu,ru,lu)}track(nu,ru,lu){let cu={};const hu=Hse(this.projectionTransform,ru),pu=this._buildAdjustedModelViewTransform(hu);this.markerDimensions[lu][0],this.markerDimensions[lu][1],this.trackingKeyframeList[lu].width,this.trackingKeyframeList[lu].height;const mu=this.featurePointsListT[lu],Au=this.imagePixelsListT[lu],bu=this.imagePropertiesListT[lu],Cu=this._computeProjection(pu,nu,lu),{matchingPointsT:wu,simT:Eu}=this._computeMatching(mu,Au,bu,Cu),Tu=wu.arraySync(),Ru=Eu.arraySync(),Nu=this.trackingKeyframeList[lu],Pu=[],Fu=[],Gu=[];for(let Xu=0;Xu<Tu.length;Xu++)if(Ru[Xu]>qse&&Xu<Nu.points.length){Gu.push(Xu);const Qu=Qse(hu,Tu[Xu][0],Tu[Xu][1]);Fu.push(Qu),Pu.push({x:Nu.points[Xu].x/Nu.scale,y:Nu.points[Xu].y/Nu.scale,z:0})}return this.debugMode&&(cu={projectedImage:Cu.arraySync(),matchingPoints:wu.arraySync(),goodTrack:Gu,trackedPoints:Fu}),pu.dispose(),Cu.dispose(),wu.dispose(),Eu.dispose(),{worldCoords:Pu,screenCoords:Fu,debugExtra:cu}}_computeMatching(nu,ru,lu,cu){const hu=Kse,pu=hu*2+1,mu=jse*Zse,Au=Yse,bu=mu*2+1,Cu=cu.shape[0],wu=cu.shape[1],Eu=nu.shape[0];if(!this.kernelCaches.computeMatching){const Tu={variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[Eu,bu*bu],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    int featureIndex = coords[0];
	    int searchOffsetIndex = coords[1];

	    int markerWidth = int(getMarkerProperties(0));
	    int markerHeight = int(getMarkerProperties(1));
	    float markerScale = getMarkerProperties(2);

	    int searchOffsetX = imod(searchOffsetIndex, ${bu}) * ${Au};
	    int searchOffsetY = searchOffsetIndex / ${bu} * ${Au};

	    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);
	    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);

	    int sx = sCenterX + searchOffsetX - ${mu};
	    int sy = sCenterY + searchOffsetY - ${mu};

	    if (sx < ${hu} || sx >= (${wu} - ${hu}) || sy < ${hu} || sy >= (${Cu} - ${hu})) {
	      setOutput(-2.);
	    } 
	    else {
	      float sumPoint = 0.;
	      float sumPointSquare = 0.;
	      float sumTemplate = 0.;
	      float sumTemplateSquare = 0.;
	      float sumPointTemplate = 0.;

	      for (int templateOffsetY = 0; templateOffsetY < ${pu}; templateOffsetY++) {
		for (int templateOffsetX = 0; templateOffsetX < ${pu}; templateOffsetX++) {
		  int fx2 = sCenterX + templateOffsetX - ${hu};
		  int fy2 = sCenterY + templateOffsetY - ${hu};

		  int sx2 = sx + templateOffsetX - ${hu};
		  int sy2 = sy + templateOffsetY - ${hu};

		  int markerPixelIndex = fy2 * markerWidth + fx2;
		  float markerPixel = getMarkerPixels(markerPixelIndex);
		  float targetPixel = getTargetPixels(sy2, sx2);

		  sumTemplate += markerPixel;
		  sumTemplateSquare += markerPixel * markerPixel;
		  sumPoint += targetPixel;
		  sumPointSquare += targetPixel * targetPixel;
		  sumPointTemplate += targetPixel * markerPixel;
		}
	      }

	      // Normalized cross-correlation
	      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)
	      float count = float(${pu} * ${pu});
	      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);
	      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);

	      if (pointVariance < 0.0000001) {
		setOutput(-3.);
	      } else if (templateVariance < 0.0000001) {
		//setOutput(sumTemplate);
		setOutput(-4.);
	      } else {
		sumPointTemplate -= sumPoint / count * sumTemplate;
		float sim = sumPointTemplate / pointVariance / templateVariance;  
		setOutput(sim);
	      }
	    }
	  }
	`},Ru={variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[Eu,2],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    float markerScale = getMarkerProperties(2);

	    int featureIndex = coords[0];

	    int maxIndex = int(getMaxIndex(featureIndex));
	    int searchLocationIndex = maxIndex / ${bu*bu};
	    int searchOffsetIndex = imod(maxIndex, ${bu*bu});

	    if (coords[1] == 0) {
	      int searchOffsetX = imod(searchOffsetIndex, ${bu}) * ${Au};
	      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${mu}) / markerScale);
	    }
	    else if (coords[1] == 1) {
	      int searchOffsetY = searchOffsetIndex / ${bu} * ${Au};
	      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${mu}) / markerScale);
	    }
	  }
	`},Nu={variableNames:["sims","maxIndex"],outputShape:[Eu],userCode:`
	  void main() {
	    int featureIndex = getOutputCoords();
	    int maxIndex = int(getMaxIndex(featureIndex));
	    setOutput(getSims(featureIndex, maxIndex));
	  }
	`};this.kernelCaches.computeMatching=[Tu,Ru,Nu]}return Op(()=>{const Tu=this.kernelCaches.computeMatching,Ru=this._compileAndRun(Tu[0],[nu,ru,lu,cu]),Nu=Ru.argMax(1),Pu=this._compileAndRun(Tu[1],[nu,lu,Nu]),Fu=this._compileAndRun(Tu[2],[Ru,Nu]);return{matchingPointsT:Pu,simT:Fu}})}_computeProjection(nu,ru,lu){const cu=this.trackingKeyframeList[lu].width,hu=this.trackingKeyframeList[lu].height,pu=this.trackingKeyframeList[lu].scale,mu=cu+"-"+hu+"-"+pu;if(this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),!this.kernelCaches.computeProjection[mu]){const Au={variableNames:["M","pixel"],outputShape:[hu,cu],userCode:`
	  void main() {
	      ivec2 coords = getOutputCoords();

	      float m00 = getM(0, 0) * ${jx}.;
	      float m01 = getM(0, 1) * ${jx}.;
	      float m03 = getM(0, 3) * ${jx}.;
	      float m10 = getM(1, 0) * ${jx}.;
	      float m11 = getM(1, 1) * ${jx}.;
	      float m13 = getM(1, 3) * ${jx}.;
	      float m20 = getM(2, 0) * ${jx}.;
	      float m21 = getM(2, 1) * ${jx}.;
	      float m23 = getM(2, 3) * ${jx}.;

	      float y = float(coords[0]) / float(${pu});
	      float x = float(coords[1]) / float(${pu});
	      float uz = (x * m20) + (y * m21) + m23;
	      float oneOverUz = 1. / uz;

	      float ux = (x * m00) + (y * m01) + m03;
	      float uy = (x * m10) + (y * m11) + m13;

	      ux = floor(ux * oneOverUz + 0.5);
	      uy = floor(uy * oneOverUz + 0.5);
	      setOutput(getPixel(int(uy), int(ux)));
	    }
	`};this.kernelCaches.computeProjection[mu]=Au}return Op(()=>{const Au=this.kernelCaches.computeProjection[mu];return this._compileAndRun(Au,[nu,ru])})}_buildAdjustedModelViewTransform(nu){return Op(()=>{let ru=[];for(let lu=0;lu<nu.length;lu++){ru.push([]);for(let cu=0;cu<nu[lu].length;cu++)ru[lu].push(nu[lu][cu]/jx)}return Ky(ru,[3,4])})}_prebuild(nu,ru){return Op(()=>{const lu=nu.scale,cu=[];for(let mu=0;mu<ru;mu++)mu<nu.points.length?cu.push([nu.points[mu].x/lu,nu.points[mu].y/lu]):cu.push([-1,-1]);const hu=Ky(nu.data,[nu.width*nu.height]),pu=Ky([nu.width,nu.height,nu.scale],[3]);return{featurePoints:Ky(cu,[cu.length,2],"float32"),imagePixels:hu,imageProperties:pu}})}_compileAndRun(nu,ru){const lu=vv().compileAndRun(nu,ru);return w0().makeTensorFromDataId(lu.dataId,lu.shape,lu.dtype)}}const W2=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],k1=[];for(let ou=0;ou<W2.length;ou++){const nu=W2[ou].sigma;for(let ru=0;ru<W2[ou].points.length;ru++){const lu=W2[ou].points[ru];k1.push([nu,lu[0],lu[1]])}}const o_={};function toe(ou){const nu=ou.shape[1],ru=ou.shape[0],lu="w"+nu+"h"+ru;if(!o_.hasOwnProperty(lu)){const cu={variableNames:["p"],outputShape:[ru,nu],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0], coords[1]-2);
          sum += getP(coords[0], coords[1]-1) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0], coords[1]+1) * 4.;
          sum += getP(coords[0], coords[1]+2);
          setOutput(sum);
        }
      `},hu={variableNames:["p"],outputShape:[ru,nu],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0]-2, coords[1]);
          sum += getP(coords[0]-1, coords[1]) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0]+1, coords[1]) * 4.;
          sum += getP(coords[0]+2, coords[1]);
          sum /= 256.;
          setOutput(sum);
        }
      `};o_[lu]=[cu,hu]}return o_[lu]}const noe={kernelName:"BinomialFilter",backendName:"webgl",kernelFunc:ou=>{const nu=ou.inputs.image,ru=ou.backend,[lu,cu]=toe(nu),hu=ru.runWebGLProgram(lu,[nu],nu.dtype),pu=ru.runWebGLProgram(cu,[hu],nu.dtype);return ru.disposeIntermediateTensorInfo(hu),pu}},H2=7,PF=3,ioe=PF*PF,a_=4,roe=(a_+1)*(a_+1)/a_,l_={};function soe(ou){const nu=ou.shape[1],ru=ou.shape[0],lu="w"+nu+"h"+ru;if(!l_.hasOwnProperty(lu)){const cu={variableNames:["image0","image1","image2"],outputShape:[ru,nu],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();
    
          int y = coords[0];
          int x = coords[1];
    
          float value = getImage1(y, x);
    
          // Step 1: find local maxima/minima
          if (value * value < ${ioe}.) {
            setOutput(0.);
            return;
          }
          if (y < ${H2} || y > ${ru-1-H2}) {
            setOutput(0.);
            return;
          }
          if (x < ${H2} || x > ${nu-1-H2}) {
            setOutput(0.);
            return;
          }
    
          bool isMax = true;
          bool isMin = true;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              float value0 = getImage0(y+dy, x+dx);
              float value1 = getImage1(y+dy, x+dx);
              float value2 = getImage2(y+dy, x+dx);
    
        if (value < value0 || value < value1 || value < value2) {
          isMax = false;
        }
        if (value > value0 || value > value1 || value > value2) {
          isMin = false;
        }
            }
          }
    
          if (!isMax && !isMin) {
            setOutput(0.);
            return;
          }
    
          // compute edge score and reject based on threshold
          float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);
          float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);
          float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));
    
          float det = (dxx * dyy) - (dxy * dxy);
    
          if (abs(det) < 0.0001) { // determinant undefined. no solution
            setOutput(0.);
            return;
          }
    
          float edgeScore = (dxx + dyy) * (dxx + dyy) / det;
    
          if (abs(edgeScore) >= ${roe} ) {
            setOutput(0.);
            return;
          }
          setOutput(getImage1(y,x));
        }
      `};l_[lu]=cu}return l_[lu]}const ooe={kernelName:"BuildExtremas",backendName:"webgl",kernelFunc:ou=>{let{image0:nu,image1:ru,image2:lu}=ou.inputs;const cu=ou.backend,hu=soe(ru);return nu=w0().runKernel("DownsampleBilinear",{image:nu}),lu=w0().runKernel("UpsampleBilinear",{image:lu,targetImage:ru}),cu.runWebGLProgram(hu,[nu,ru,lu],ru.dtype)}},Xw=36,c_={};function aoe(ou){const nu=ou.shape[0];if(!c_.hasOwnProperty(nu)){const ru={variableNames:["histogram"],outputShape:[ou.shape[0]],userCode:`
            void main() {
                int featureIndex = getOutputCoords();

                int maxIndex = 0;
                for (int i = 1; i < ${Xw}; i++) {
                    if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {
                        maxIndex = i;
                    }
                }

                int prev = imod(maxIndex - 1 + ${Xw}, ${Xw});
                int next = imod(maxIndex + 1, ${Xw});

                /**
                 * Fit a quatratic to 3 points. The system of equations is:
                 *
                 * y0 = A*x0^2 + B*x0 + C
                 * y1 = A*x1^2 + B*x1 + C
                 * y2 = A*x2^2 + B*x2 + C
                 *
                 * This system of equations is solved for A,B,C.
                 */
                float p10 = float(maxIndex - 1);
                float p11 = getHistogram(featureIndex, prev); 
                float p20 = float(maxIndex);
                float p21 = getHistogram(featureIndex, maxIndex); 
                float p30 = float(maxIndex + 1);
                float p31 = getHistogram(featureIndex, next); 

                float d1 = (p30-p20)*(p30-p10);
                float d2 = (p10-p20)*(p30-p10);
                float d3 = p10-p20;

                // If any of the denominators are zero then, just use maxIndex.
                    float fbin = float(maxIndex);
                if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {
                float a = p10*p10;
                float b = p20*p20;

                // Solve for the coefficients A,B,C
                float A = ((p31-p21)/d1)-((p11-p21)/d2);
                float B = ((p11-p21)+(A*(b-a)))/d3;
                float C = p11-(A*a)-(B*p10);
                fbin = -B / (2. * A);
                }

                float an = 2.0 *${Math.PI} * (fbin + 0.5) / ${Xw}. - ${Math.PI};
                setOutput(an);
            }
            `};c_[nu]=ru}return c_[nu]}const loe={kernelName:"ComputeExtremaAngles",backendName:"webgl",kernelFunc:ou=>{const{histograms:nu}=ou.inputs,ru=ou.backend,lu=aoe(nu);return ru.runWebGLProgram(lu,[nu],nu.dtype)}},GF=7,u_={};function coe(ou,nu){const ru=`${ou}|${nu.shape[0]}`;if(!u_.hasOwnProperty(ru)){const lu=[];for(let pu=1;pu<ou;pu++)lu.push("image"+pu);let cu="float getPixel(int octave, int y, int x) {";for(let pu=1;pu<ou;pu++)cu+=`
  if (octave == ${pu}) {
	return getImage${pu}(y, x);
  }
`;cu+="}";const hu={variableNames:[...lu,"extrema","angles","freakPoints"],outputShape:[nu.shape[0],k1.length],userCode:`
  ${cu}
  void main() {
	ivec2 coords = getOutputCoords();
	int featureIndex = coords[0];
	int freakIndex = coords[1];

	float freakSigma = getFreakPoints(freakIndex, 0);
	float freakX = getFreakPoints(freakIndex, 1);
	float freakY = getFreakPoints(freakIndex, 2);

	int octave = int(getExtrema(featureIndex, 1));
	float inputY = getExtrema(featureIndex, 2);
	float inputX = getExtrema(featureIndex, 3);
	float inputAngle = getAngles(featureIndex);
	float cos = ${GF}. * cos(inputAngle);
	float sin = ${GF}. * sin(inputAngle);

	float yp = inputY + freakX * sin + freakY * cos;
	float xp = inputX + freakX * cos + freakY * -sin;

	int x0 = int(floor(xp));
	int x1 = x0 + 1;
	int y0 = int(floor(yp));
	int y1 = y0 + 1;

	float f1 = getPixel(octave, y0, x0);
	float f2 = getPixel(octave, y0, x1);
	float f3 = getPixel(octave, y1, x0);
	float f4 = getPixel(octave, y1, x1);

	float x1f = float(x1);
	float y1f = float(y1);
	float x0f = float(x0);
	float y0f = float(y0);

	// ratio for interpolation between four neighbouring points
	float value = (x1f - xp) * (y1f - yp) * f1
		+ (xp - x0f) * (y1f - yp) * f2
		+ (x1f - xp) * (yp - y0f) * f3
		+ (xp - x0f) * (yp - y0f) * f4;

	setOutput(value);
  }
`};u_[ru]=hu}return u_[ru]}const uoe={kernelName:"ComputeExtremaFreak",backendName:"webgl",kernelFunc:ou=>{const{gaussianImagesT:nu,prunedExtremas:ru,prunedExtremasAngles:lu,freakPointsT:cu,pyramidImagesLength:hu}=ou.inputs,pu=ou.backend,mu=coe(hu,ru);return pu.runWebGLProgram(mu,[...nu,ru,lu,cu],"float32")}},OF=(k1.length-1)*k1.length/2,hoe=Math.ceil(OF/8),h_={};function doe(ou){const nu=`${ou.shape[0]}`;if(!h_.hasOwnProperty(nu)){const ru={variableNames:["freak","p"],outputShape:[ou.shape[0],hoe],userCode:`
  void main() {
    ivec2 coords = getOutputCoords();
    int featureIndex = coords[0];
    int descIndex = coords[1] * 8;

    int sum = 0;
    for (int i = 0; i < 8; i++) {
      if (descIndex + i >= ${OF}) {
        continue;
      }

      int p1 = int(getP(descIndex + i, 0));
      int p2 = int(getP(descIndex + i, 1));

      float v1 = getFreak(featureIndex, p1);
      float v2 = getFreak(featureIndex, p2);

      if (v1 < v2 + 0.01) {
        sum += int(pow(2.0, float(7 - i)));
      }
    }
    setOutput(float(sum));
  }
`};h_[nu]=ru}return h_[nu]}const poe={kernelName:"ComputeFreakDescriptors",backendName:"webgl",kernelFunc:ou=>{const{extremaFreaks:nu,positionT:ru}=ou.inputs,{backend:lu}=ou,cu=doe(nu);return lu.runWebGLProgram(cu,[nu,ru],"int32")}},d_={};function foe(ou,nu){const ru=`${ou}|${nu}`;if(!d_.hasOwnProperty(ru)){const lu=[];let cu="float getPixel(int octave, int y, int x) {";for(let hu=1;hu<ou;hu++)lu.push("image"+hu),cu+=`
				if (octave == ${hu}) {
					return getImage${hu}(y, x);
				}
			`;cu+="}",d_[ru]={variableNames:[...lu,"extrema"],outputShape:[nu,3,3],userCode:`
			${cu}
		
			void main() {
				ivec3 coords = getOutputCoords();
				int featureIndex = coords[0];
				float score = getExtrema(featureIndex, 0);
				if (score == 0.0) {
					return;
				}
		
				int dy = coords[1]-1;
				int dx = coords[2]-1;
				int octave = int(getExtrema(featureIndex, 1));
				int y = int(getExtrema(featureIndex, 2));
				int x = int(getExtrema(featureIndex, 3));
				setOutput(getPixel(octave, y+dy, x+dx));
			}
			`}}return d_[ru]}const moe={kernelName:"ComputeLocalization",backendName:"webgl",kernelFunc:ou=>{const{prunedExtremasList:nu,dogPyramidImagesT:ru}=ou.inputs,lu=ou.backend,cu=foe(ru.length,nu.length),hu=Ky(nu,[nu.length,nu[0].length],"int32");return lu.runWebGLProgram(cu,[...ru.slice(1),hu],ru[0].dtype)}},goe=.159154943091895,xC=36,p_={};function Aoe(ou,nu,ru){const lu=`${ru}|${ou.shape[0]}|${nu.shape[0]}`;if(!p_.hasOwnProperty(lu)){const cu=[];for(let Au=1;Au<ru;Au++)cu.push("image"+Au);let hu="float getPixel(int octave, int y, int x) {";for(let Au=1;Au<ru;Au++)hu+=`
            if (octave == ${Au}) {
                return getImage${Au}(y, x);
            }
            `;hu+="}";const pu={variableNames:[...cu,"extrema","radial"],outputShape:[ou.shape[0],nu.shape[0],2],userCode:`
                ${hu}

                void main() {
                    ivec3 coords = getOutputCoords();
                    int featureIndex = coords[0];
                    int radialIndex = coords[1];
                    int propertyIndex = coords[2];

                    int radialY = int(getRadial(radialIndex, 0));
                    int radialX = int(getRadial(radialIndex, 1));
                    float radialW = getRadial(radialIndex, 2);

                    int octave = int(getExtrema(featureIndex, 1));
                    int y = int(getExtrema(featureIndex, 2));
                    int x = int(getExtrema(featureIndex, 3));

                    int xp = x + radialX;
                    int yp = y + radialY;

                    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);
                    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);

                    if (propertyIndex == 0) {
                    // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0
                    
                    float angle = atan(dy, dx) + ${Math.PI};
                    float fbin = angle * ${xC}. * ${goe};
                    setOutput(fbin);
                    return;
                    }

                    if (propertyIndex == 1) {
                        float mag = sqrt(dx * dx + dy * dy);
                        float magnitude = radialW * mag;
                        setOutput(magnitude);
                        return;
                    }
                }

                `},mu={variableNames:["fbinMag"],outputShape:[ou.shape[0],xC],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int featureIndex = coords[0];
                int binIndex = coords[1];

                float sum = 0.;
                for (int i = 0; i < ${nu.shape[0]}; i++) {
                    float fbin = getFbinMag(featureIndex, i, 0);
                    int bin = int(floor(fbin - 0.5));
                    int b1 = imod(bin + ${xC}, ${xC});
                    int b2 = imod(bin + 1 + ${xC}, ${xC});

                    if (b1 == binIndex || b2 == binIndex) {
                        float magnitude = getFbinMag(featureIndex, i, 1);
                        float w2 = fbin - float(bin) - 0.5;
                        float w1 = w2 * -1. + 1.;

                        if (b1 == binIndex) {
                            sum += w1 * magnitude;
                        }
                        if (b2 == binIndex) {
                            sum += w2 * magnitude;
                        }
                    }
                }
                setOutput(sum);
            }
            `};p_[lu]=[pu,mu]}return p_[lu]}const yoe={kernelName:"ComputeOrientationHistograms",backendName:"webgl",kernelFunc:ou=>{const{gaussianImagesT:nu,prunedExtremasT:ru,radialPropertiesT:lu,pyramidImagesLength:cu}=ou.inputs,hu=ou.backend,[pu,mu]=Aoe(ru,lu,cu),Au=hu.runWebGLProgram(pu,[...nu,ru,lu],lu.dtype),bu=hu.runWebGLProgram(mu,[Au],lu.dtype);return hu.disposeIntermediateTensorInfo(Au),bu}},f_={};function boe(ou){const nu=ou.shape[1],ru=ou.shape[0],lu="w"+nu+"h"+ru;if(!f_.hasOwnProperty(lu)){const cu={variableNames:["p"],outputShape:[Math.floor(ru/2),Math.floor(nu/2)],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int y = coords[0] * 2;
                int x = coords[1] * 2;
        
                float sum = getP(y, x) * 0.25;
                sum += getP(y+1,x) * 0.25; 
                sum += getP(y, x+1) * 0.25; 
                sum += getP(y+1,x+1) * 0.25;
                setOutput(sum);
            }
            `};f_[lu]=cu}return f_[lu]}const xoe={kernelName:"DownsampleBilinear",backendName:"webgl",kernelFunc:ou=>{const nu=ou.inputs.image,ru=ou.backend,lu=boe(nu);return ru.runWebGLProgram(lu,[nu],nu.dtype)}},voe={kernelName:"ExtremaReduction",backendName:"webgl",kernelFunc:ou=>{const{extremasResultT:nu}=ou.inputs,ru=ou.backend,lu=nu.shape[0],cu=nu.shape[1],hu={variableNames:["extrema"],outputShape:[Math.floor(lu/2),Math.floor(cu/2)],userCode:`
		  void main() {
			ivec2 coords = getOutputCoords();
			int y = coords[0] * 2;
			int x = coords[1] * 2;
  
			float location = 0.0;
			float values = getExtrema(y, x);
  
			if (getExtrema(y+1, x) != 0.0) {
			  location = 1.0;
		  values = getExtrema(y+1, x);
			}
			else if (getExtrema(y, x+1) != 0.0) {
			  location = 2.0;
		  values = getExtrema(y, x+1);
			}
			else if (getExtrema(y+1, x+1) != 0.0) {
			  location = 3.0;
		  values = getExtrema(y+1, x+1);
			}
  
			if (values < 0.0) {
			  setOutput(location * -1000.0 + values);
			} else {
			  setOutput(location * 1000.0 + values);
			}
		  }
		`};return ru.runWebGLProgram(hu,[nu],nu.dtype)}},X2=36,Coe=5,m_={};function woe(ou){const nu=`h${ou.shape[0]}`;if(!m_.hasOwnProperty(nu)){const ru={variableNames:["histogram"],outputShape:[ou.shape[0],X2],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();

                int featureIndex = coords[0];
                int binIndex = coords[1];

                int prevBin = imod(binIndex - 1 + ${X2}, ${X2});
                int nextBin = imod(binIndex + 1, ${X2});
                float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);

                setOutput(result);
            }
            `};m_[nu]=ru}return m_[nu]}const Eoe={kernelName:"SmoothHistograms",backendName:"webgl",kernelFunc:ou=>{let{histograms:nu}=ou.inputs;const ru=ou.backend,lu=woe(nu);for(let cu=0;cu<Coe;cu++){const hu=nu;nu=ru.runWebGLProgram(lu,[nu],nu.dtype),cu>0&&ru.disposeIntermediateTensorInfo(hu)}return nu}},g_={};function Soe(ou,nu){const ru=nu.shape[1],lu=nu.shape[0],cu="w"+ru+"h"+lu;if(!g_.hasOwnProperty(cu)){const hu={variableNames:["p"],outputShape:[lu,ru],userCode:`
              void main() {
                ivec2 coords = getOutputCoords();
                int j = coords[0];
                int i = coords[1];
        
                float sj = 0.5 * float(j) - 0.25; 
                float si = 0.5 * float(i) - 0.25;
        
                float sj0 = floor(sj);
                float sj1 = ceil(sj);
                float si0 = floor(si);
                float si1 = ceil(si);
        
                int sj0I = int(sj0);
                int sj1I = int(sj1);
                int si0I = int(si0);
                int si1I = int(si1);
        
                float sum = 0.0;
                sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);
                sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);
                sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);
                sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);
                setOutput(sum);
              }
            `};g_[cu]=hu}return g_[cu]}const Ioe={kernelName:"UpsampleBilinear",backendName:"webgl",kernelFunc:ou=>{const{image:nu,targetImage:ru}=ou.inputs,lu=ou.backend,cu=Soe(nu,ru);return lu.runWebGLProgram(cu,[nu],nu.dtype)}};Qy(noe),Qy(ooe),Qy(loe),Qy(uoe),Qy(poe),Qy(moe),Qy(yoe),Qy(xoe),Qy(voe),Qy(Eoe),Qy(Ioe);const UF=8,Toe=5,Qw=10,_oe=5,A_=3,Moe=1.5;(k1.length-1)*k1.length/2;class $F{constructor(nu,ru,lu=!1){this.debugMode=lu,this.width=nu,this.height=ru;let cu=0;for(;nu>=UF&&ru>=UF&&(nu/=2,ru/=2,cu++,cu!==Toe););this.numOctaves=cu,this.tensorCaches={},this.kernelCaches={}}detectImageData(nu){const ru=new Uint8ClampedArray(4*nu.length);for(let cu=0;cu<nu.length;cu++)ru[4*cu]=nu[cu],ru[4*cu+1]=nu[cu],ru[4*cu+2]=nu[cu],ru[4*cu+3]=255;const lu=new ImageData(ru,this.width,this.height);return this.detect(lu)}detect(nu){let ru=null;const lu=[];for(let Fu=0;Fu<this.numOctaves;Fu++){let Gu,Xu;Fu===0?Gu=this._applyFilter(nu):Gu=this._downsampleBilinear(lu[Fu-1][lu[Fu-1].length-1]),Xu=this._applyFilter(Gu),lu.push([Gu,Xu])}const cu=[];for(let Fu=0;Fu<this.numOctaves;Fu++){let Gu=this._differenceImageBinomial(lu[Fu][0],lu[Fu][1]);cu.push(Gu)}const hu=[];for(let Fu=1;Fu<this.numOctaves-1;Fu++){const Gu=this._buildExtremas(cu[Fu-1],cu[Fu],cu[Fu+1]);hu.push(Gu)}const pu=this._applyPrune(hu),mu=this._computeLocalization(pu,cu),Au=this._computeOrientationHistograms(mu,lu),bu=this._smoothHistograms(Au),Cu=this._computeExtremaAngles(bu),wu=this._computeExtremaFreak(lu,mu,Cu),Eu=this._computeFreakDescriptors(wu),Tu=mu.arraySync(),Ru=Cu.arraySync(),Nu=Eu.arraySync();this.debugMode&&(ru={pyramidImages:lu.map(Fu=>Fu.map(Gu=>Gu.arraySync())),dogPyramidImages:cu.map(Fu=>Fu?Fu.arraySync():null),extremasResults:hu.map(Fu=>Fu.arraySync()),extremaAngles:Cu.arraySync(),prunedExtremas:pu,localizedExtremas:mu.arraySync()}),lu.forEach(Fu=>Fu.forEach(Gu=>Gu.dispose())),cu.forEach(Fu=>Fu&&Fu.dispose()),hu.forEach(Fu=>Fu.dispose()),mu.dispose(),Au.dispose(),bu.dispose(),Cu.dispose(),wu.dispose(),Eu.dispose();const Pu=[];for(let Fu=0;Fu<Tu.length;Fu++){if(Tu[Fu][0]==0)continue;const Gu=[];for(let op=0;op<Nu[Fu].length;op+=4){const hp=Nu[Fu][op],Ap=Nu[Fu][op+1],Up=Nu[Fu][op+2],Vp=Nu[Fu][op+3];let zp=hp*16777216+Ap*65536+Up*256+Vp;Gu.push(zp)}const Xu=Tu[Fu][1],Qu=Tu[Fu][2],Ju=Tu[Fu][3]*Math.pow(2,Xu)+Math.pow(2,Xu-1)-.5,ip=Qu*Math.pow(2,Xu)+Math.pow(2,Xu-1)-.5,rp=Math.pow(2,Xu);Pu.push({maxima:Tu[Fu][0]>0,x:Ju,y:ip,scale:rp,angle:Ru[Fu],descriptors:Gu})}return{featurePoints:Pu,debugExtra:ru}}_computeFreakDescriptors(nu){if(!this.tensorCaches.computeFreakDescriptors){const lu=[],cu=[];for(let mu=0;mu<nu.shape[1];mu++)for(let Au=mu+1;Au<nu.shape[1];Au++)lu.push(mu),cu.push(Au);const hu=Ky(lu,[lu.length]).cast("int32"),pu=Ky(cu,[cu.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:Zy(Ux([hu,pu],1))}}const{positionT:ru}=this.tensorCaches.computeFreakDescriptors;return Op(()=>w0().runKernel("ComputeFreakDescriptors",{extremaFreaks:nu,positionT:ru}))}_computeExtremaFreak(nu,ru,lu){this.tensorCaches._computeExtremaFreak||Op(()=>{const pu=Ky(k1);this.tensorCaches._computeExtremaFreak={freakPointsT:Zy(pu)}});const{freakPointsT:cu}=this.tensorCaches._computeExtremaFreak,hu=[];for(let pu=1;pu<nu.length;pu++)hu.push(nu[pu][1]);return Op(()=>w0().runKernel("ComputeExtremaFreak",{gaussianImagesT:hu,prunedExtremas:ru,prunedExtremasAngles:lu,freakPointsT:cu,pyramidImagesLength:nu.length}))}_computeExtremaAngles(nu){return Op(()=>w0().runKernel("ComputeExtremaAngles",{histograms:nu}))}_computeOrientationHistograms(nu,ru){const lu=[];for(let hu=1;hu<ru.length;hu++)lu.push(ru[hu][1]);this.tensorCaches.orientationHistograms||Op(()=>{const hu=-1/(2*A_*A_),pu=A_*Moe,mu=Math.ceil(pu),Au=[];for(let bu=-mu;bu<=mu;bu++)for(let Cu=-mu;Cu<=mu;Cu++){const wu=Cu*Cu+bu*bu;if(wu<=pu*pu){const Eu=wu*hu;let Tu=(720+Eu*(720+Eu*(360+Eu*(120+Eu*(30+Eu*(6+Eu))))))*.0013888888;Au.push([bu,Cu,Tu])}}this.tensorCaches.orientationHistograms={radialPropertiesT:Zy(Ky(Au,[Au.length,3]))}});const{radialPropertiesT:cu}=this.tensorCaches.orientationHistograms;return Op(()=>w0().runKernel("ComputeOrientationHistograms",{gaussianImagesT:lu,prunedExtremasT:nu,radialPropertiesT:cu,pyramidImagesLength:ru.length}))}_smoothHistograms(nu){return Op(()=>w0().runKernel("SmoothHistograms",{histograms:nu}))}_computeLocalization(nu,ru){return Op(()=>{const lu=w0().runKernel("ComputeLocalization",{prunedExtremasList:nu,dogPyramidImagesT:ru}).arraySync(),cu=[];for(let pu=0;pu<lu.length;pu++){cu.push([]);for(let mu=0;mu<lu[pu].length;mu++)cu[pu].push([])}const hu=[];for(let pu=0;pu<nu.length;pu++)hu[pu]=[nu[pu][0],nu[pu][1],nu[pu][2],nu[pu][3]];for(let pu=0;pu<hu.length;pu++){if(hu[pu][0]===0)continue;const mu=lu[pu],Au=.5*(mu[1][2]-mu[1][0]),bu=.5*(mu[2][1]-mu[0][1]),Cu=mu[1][2]+mu[1][0]-2*mu[1][1],wu=mu[2][1]+mu[0][1]-2*mu[1][1],Eu=.25*(mu[0][0]+mu[2][2]-mu[0][2]-mu[2][0]),Tu=Cu*wu-Eu*Eu,Ru=(wu*-Au+-Eu*-bu)/Tu,Nu=(-Eu*-Au+Cu*-bu)/Tu,Pu=hu[pu][2]+Nu,Fu=hu[pu][3]+Ru;Math.abs(Tu)<1e-4||(hu[pu][2]=Pu,hu[pu][3]=Fu)}return Ky(hu,[hu.length,hu[0].length],"float32")})}_applyPrune(nu){const ru=Qw*Qw,lu=_oe,cu=[],hu=[];for(let mu=0;mu<ru;mu++){hu.push([]),cu.push([]);for(let Au=0;Au<lu;Au++)hu[mu].push([0,0,0,0]),cu[mu].push(0)}Op(()=>{for(let mu=0;mu<nu.length;mu++){const Au=w0().runKernel("ExtremaReduction",{extremasResultT:nu[mu]}),bu=mu+1,Cu=Au.arraySync(),wu=Au.shape[0],Eu=Au.shape[1],Tu=Eu*2/Qw,Ru=wu*2/Qw;for(let Nu=0;Nu<wu;Nu++)for(let Pu=0;Pu<Eu;Pu++){const Fu=Cu[Nu][Pu];if(Fu==0)continue;const Gu=Fu%1e3,Xu=Math.floor(Math.abs(Fu)/1e3),Qu=Pu*2+(Xu===2||Xu===3?1:0),Ju=Nu*2+(Xu===1||Xu===3?1:0),ip=Math.floor(Qu/Tu),rp=Math.floor(Ju/Ru)*Qw+ip,op=Math.abs(Gu);let hp=lu;for(;hp>=1&&op>cu[rp][hp-1];)hp-=1;if(hp<lu){for(let Ap=lu-1;Ap>=hp+1;Ap--)cu[rp][Ap]=cu[rp][Ap-1],hu[rp][Ap][0]=hu[rp][Ap-1][0],hu[rp][Ap][1]=hu[rp][Ap-1][1],hu[rp][Ap][2]=hu[rp][Ap-1][2],hu[rp][Ap][3]=hu[rp][Ap-1][3];cu[rp][hp]=op,hu[rp][hp][0]=Gu,hu[rp][hp][1]=bu,hu[rp][hp][2]=Ju,hu[rp][hp][3]=Qu}}}});const pu=[];for(let mu=0;mu<ru;mu++)for(let Au=0;Au<lu;Au++)pu.push(hu[mu][Au]);return pu}_buildExtremas(nu,ru,lu){return Op(()=>w0().runKernel("BuildExtremas",{image0:nu,image1:ru,image2:lu}))}_differenceImageBinomial(nu,ru){return Op(()=>nu.sub(ru))}_applyFilter(nu){return Op(()=>w0().runKernel("BinomialFilter",{image:nu}))}_downsampleBilinear(nu){return Op(()=>w0().runKernel("DownsampleBilinear",{image:nu}))}_compileAndRun(nu,ru){const lu=vv().compileAndRun(nu,ru);return w0().makeTensorFromDataId(lu.dataId,lu.shape,lu.dtype)}_runWebGLProgram(nu,ru,lu){const cu=vv().runWebGLProgram(nu,ru,lu);return w0().makeTensorFromDataId(cu.dataId,cu.shape,cu.dtype)}}class Roe{constructor(nu,ru,lu=!1){this.debugMode=lu,this.width=nu,this.height=ru;let cu=Math.min(nu,ru)/2,hu=Math.pow(2,Math.round(Math.log(cu)/Math.log(2)));this.cropSize=hu,this.detector=new $F(hu,hu,lu),this.kernelCaches={},this.lastRandomIndex=4}detect(nu){const ru=Math.floor(this.height/2-this.cropSize/2),lu=Math.floor(this.width/2-this.cropSize/2),cu=this._detect(nu,lu,ru);return this.debugMode&&(cu.debugExtra.crop={startX:lu,startY:ru,cropSize:this.cropSize}),cu}detectMoving(nu){const ru=this.lastRandomIndex%3,lu=Math.floor(this.lastRandomIndex/3);let cu=Math.floor(this.height/2-this.cropSize+lu*this.cropSize/2),hu=Math.floor(this.width/2-this.cropSize+ru*this.cropSize/2);return hu<0&&(hu=0),cu<0&&(cu=0),hu>=this.width-this.cropSize&&(hu=this.width-this.cropSize-1),cu>=this.height-this.cropSize&&(cu=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(nu,hu,cu)}_detect(nu,ru,lu){const cu=nu.slice([lu,ru],[this.cropSize,this.cropSize]),{featurePoints:hu,debugExtra:pu}=this.detector.detect(cu);return hu.forEach(mu=>{mu.x+=ru,mu.y+=lu}),this.debugMode&&(pu.projectedImage=cu.arraySync()),cu.dispose(),{featurePoints:hu,debugExtra:pu}}}const VF=({image:ou,ratio:nu})=>{const ru=Math.round(ou.width*nu),lu=Math.round(ou.height*nu),cu=new Uint8Array(ru*lu);for(let hu=0;hu<ru;hu++){let pu=Math.round(1*hu/nu),mu=Math.round(1*(hu+1)/nu)-1;mu>=ou.width&&(mu=ou.width-1);for(let Au=0;Au<lu;Au++){let bu=Math.round(1*Au/nu),Cu=Math.round(1*(Au+1)/nu)-1;Cu>=ou.height&&(Cu=ou.height-1);let wu=0,Eu=0;for(let Tu=pu;Tu<=mu;Tu++)for(let Ru=bu;Ru<=Cu;Ru++)wu+=1*ou.data[Ru*ou.width+Tu],Eu+=1;cu[Au*ru+hu]=Math.floor(wu/Eu)}}return{data:cu,width:ru,height:lu}},koe=100,Boe=ou=>{const nu=koe/Math.min(ou.width,ou.height),ru=[];let lu=nu;for(;;)if(ru.push(lu),lu*=Math.pow(2,1/3),lu>=.95){lu=1;break}ru.push(lu),ru.reverse();const cu=[];for(let hu=0;hu<ru.length;hu++)ou.width*ru[hu],ou.height*ru[hu],cu.push(Object.assign(VF({image:ou,ratio:ru[hu]}),{scale:ru[hu]}));return cu},Loe=ou=>{const nu=Math.min(ou.width,ou.height),ru=[],lu=[];ru.push(256/nu),ru.push(128/nu);for(let cu=0;cu<ru.length;cu++)lu.push(Object.assign(VF({image:ou,ratio:ru[cu]}),{scale:ru[cu]}));return lu},Noe=ou=>{const{v1:nu,v2:ru}=ou;let lu=0;for(let cu=0;cu<nu.length;cu++){let hu=(nu[cu]^ru[cu])>>>0;lu+=Doe(hu)}return lu},Doe=ou=>{var nu=ou-(ou>>1&1431655765);return nu=(nu>>2&858993459)+(nu&858993459),nu=(nu>>4)+nu&252645135,nu=(nu>>8)+nu&16711935,nu=(nu>>16)+nu&65535,nu},Foe=1234,Poe=()=>({seed:Foe,arrayShuffle(ou){const{arr:nu,sampleSize:ru}=ou;for(let lu=0;lu<ru;lu++){this.seed=(214013*this.seed+2531011)%-2147483648;let cu=this.seed>>16&32767;cu=cu%nu.length;let hu=nu[lu];nu[lu]=nu[cu],nu[cu]=hu}},nextInt(ou){this.seed=(214013*this.seed+2531011)%-2147483648;let nu=this.seed>>16&32767;return nu=nu%ou,nu}}),Goe=16,Ooe=128,y_=8,Uoe=ou=>{const{points:nu,pointIndexes:ru,randomizer:lu}=ou,cu=[];for(let Au=0;Au<ru.length;Au++)cu.push(Au);let hu=Number.MAX_SAFE_INTEGER,pu=-1;const mu=[];for(let Au=0;Au<Ooe;Au++){lu.arrayShuffle({arr:cu,sampleSize:y_});let bu=0;const Cu=[];for(let wu=0;wu<ru.length;wu++){let Eu=Number.MAX_SAFE_INTEGER;for(let Tu=0;Tu<y_;Tu++){const Ru=ru[cu[Tu]],Nu=Noe({v1:nu[ru[wu]].descriptors,v2:nu[Ru].descriptors});Nu<Eu&&(Cu[wu]=cu[Tu],Eu=Nu)}bu+=Eu}mu.push(Cu),bu<hu&&(hu=bu,pu=Au)}return mu[pu]},zF=({points:ou})=>{const nu=[];for(let lu=0;lu<ou.length;lu++)nu.push(lu);const ru=Poe();return{rootNode:WF({points:ou,pointIndexes:nu,centerPointIndex:null,randomizer:ru})}},WF=ou=>{const{points:nu,pointIndexes:ru,centerPointIndex:lu,randomizer:cu}=ou;let hu=!1;(ru.length<=y_||ru.length<=Goe)&&(hu=!0);const pu={};if(!hu){const Au=Uoe({points:nu,pointIndexes:ru,randomizer:cu});for(let bu=0;bu<Au.length;bu++)pu[ru[Au[bu]]]===void 0&&(pu[ru[Au[bu]]]=[]),pu[ru[Au[bu]]].push(ru[bu])}Object.keys(pu).length===1&&(hu=!0);const mu={centerPointIndex:lu};if(hu){mu.leaf=!0,mu.pointIndexes=[];for(let Au=0;Au<ru.length;Au++)mu.pointIndexes.push(ru[Au]);return mu}return mu.leaf=!1,mu.children=[],Object.keys(pu).forEach(Au=>{mu.children.push(WF({points:nu,pointIndexes:pu[Au],centerPointIndex:Au,randomizer:cu}))}),mu};var B1=4294967295;function $oe(ou,nu,ru){var lu=ru/4294967296,cu=ru;ou.setUint32(nu,lu),ou.setUint32(nu+4,cu)}function HF(ou,nu,ru){var lu=Math.floor(ru/4294967296),cu=ru;ou.setUint32(nu,lu),ou.setUint32(nu+4,cu)}function XF(ou,nu){var ru=ou.getInt32(nu),lu=ou.getUint32(nu+4);return ru*4294967296+lu}function Voe(ou,nu){var ru=ou.getUint32(nu),lu=ou.getUint32(nu+4);return ru*4294967296+lu}var b_,x_,v_,Q2=(typeof process$1>"u"||((b_=process$1==null?void 0:define_process_env_default)===null||b_===void 0?void 0:b_.TEXT_ENCODING)!=="never")&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function QF(ou){for(var nu=ou.length,ru=0,lu=0;lu<nu;){var cu=ou.charCodeAt(lu++);if(cu&4294967168)if(!(cu&4294965248))ru+=2;else{if(cu>=55296&&cu<=56319&&lu<nu){var hu=ou.charCodeAt(lu);(hu&64512)===56320&&(++lu,cu=((cu&1023)<<10)+(hu&1023)+65536)}cu&4294901760?ru+=4:ru+=3}else{ru++;continue}}return ru}function zoe(ou,nu,ru){for(var lu=ou.length,cu=ru,hu=0;hu<lu;){var pu=ou.charCodeAt(hu++);if(pu&4294967168)if(!(pu&4294965248))nu[cu++]=pu>>6&31|192;else{if(pu>=55296&&pu<=56319&&hu<lu){var mu=ou.charCodeAt(hu);(mu&64512)===56320&&(++hu,pu=((pu&1023)<<10)+(mu&1023)+65536)}pu&4294901760?(nu[cu++]=pu>>18&7|240,nu[cu++]=pu>>12&63|128,nu[cu++]=pu>>6&63|128):(nu[cu++]=pu>>12&15|224,nu[cu++]=pu>>6&63|128)}else{nu[cu++]=pu;continue}nu[cu++]=pu&63|128}}var K2=Q2?new TextEncoder:void 0,Woe=Q2?typeof process$1<"u"&&((x_=process$1==null?void 0:define_process_env_default)===null||x_===void 0?void 0:x_.TEXT_ENCODING)!=="force"?200:0:B1;function Hoe(ou,nu,ru){nu.set(K2.encode(ou),ru)}function Xoe(ou,nu,ru){K2.encodeInto(ou,nu.subarray(ru))}var Qoe=K2!=null&&K2.encodeInto?Xoe:Hoe,Koe=4096;function KF(ou,nu,ru){for(var lu=nu,cu=lu+ru,hu=[],pu="";lu<cu;){var mu=ou[lu++];if(!(mu&128))hu.push(mu);else if((mu&224)===192){var Au=ou[lu++]&63;hu.push((mu&31)<<6|Au)}else if((mu&240)===224){var Au=ou[lu++]&63,bu=ou[lu++]&63;hu.push((mu&31)<<12|Au<<6|bu)}else if((mu&248)===240){var Au=ou[lu++]&63,bu=ou[lu++]&63,Cu=ou[lu++]&63,wu=(mu&7)<<18|Au<<12|bu<<6|Cu;wu>65535&&(wu-=65536,hu.push(wu>>>10&1023|55296),wu=56320|wu&1023),hu.push(wu)}else hu.push(mu);hu.length>=Koe&&(pu+=String.fromCharCode.apply(String,hu),hu.length=0)}return hu.length>0&&(pu+=String.fromCharCode.apply(String,hu)),pu}var Zoe=Q2?new TextDecoder:null,joe=Q2?typeof process$1<"u"&&((v_=process$1==null?void 0:define_process_env_default)===null||v_===void 0?void 0:v_.TEXT_DECODER)!=="force"?200:0:B1;function Yoe(ou,nu,ru){var lu=ou.subarray(nu,nu+ru);return Zoe.decode(lu)}var Z2=function(){function ou(nu,ru){this.type=nu,this.data=ru}return ou}(),qoe=function(){var ou=function(nu,ru){return ou=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(lu,cu){lu.__proto__=cu}||function(lu,cu){for(var hu in cu)Object.prototype.hasOwnProperty.call(cu,hu)&&(lu[hu]=cu[hu])},ou(nu,ru)};return function(nu,ru){if(typeof ru!="function"&&ru!==null)throw new TypeError("Class extends value "+String(ru)+" is not a constructor or null");ou(nu,ru);function lu(){this.constructor=nu}nu.prototype=ru===null?Object.create(ru):(lu.prototype=ru.prototype,new lu)}}(),Yx=function(ou){qoe(nu,ou);function nu(ru){var lu=ou.call(this,ru)||this,cu=Object.create(nu.prototype);return Object.setPrototypeOf(lu,cu),Object.defineProperty(lu,"name",{configurable:!0,enumerable:!1,value:nu.name}),lu}return nu}(Error),Joe=-1,eae=4294967296-1,tae=17179869184-1;function nae(ou){var nu=ou.sec,ru=ou.nsec;if(nu>=0&&ru>=0&&nu<=tae)if(ru===0&&nu<=eae){var lu=new Uint8Array(4),cu=new DataView(lu.buffer);return cu.setUint32(0,nu),lu}else{var hu=nu/4294967296,pu=nu&4294967295,lu=new Uint8Array(8),cu=new DataView(lu.buffer);return cu.setUint32(0,ru<<2|hu&3),cu.setUint32(4,pu),lu}else{var lu=new Uint8Array(12),cu=new DataView(lu.buffer);return cu.setUint32(0,ru),HF(cu,4,nu),lu}}function iae(ou){var nu=ou.getTime(),ru=Math.floor(nu/1e3),lu=(nu-ru*1e3)*1e6,cu=Math.floor(lu/1e9);return{sec:ru+cu,nsec:lu-cu*1e9}}function rae(ou){if(ou instanceof Date){var nu=iae(ou);return nae(nu)}else return null}function sae(ou){var nu=new DataView(ou.buffer,ou.byteOffset,ou.byteLength);switch(ou.byteLength){case 4:{var ru=nu.getUint32(0),lu=0;return{sec:ru,nsec:lu}}case 8:{var cu=nu.getUint32(0),hu=nu.getUint32(4),ru=(cu&3)*4294967296+hu,lu=cu>>>2;return{sec:ru,nsec:lu}}case 12:{var ru=XF(nu,4),lu=nu.getUint32(0);return{sec:ru,nsec:lu}}default:throw new Yx("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(ou.length))}}function oae(ou){var nu=sae(ou);return new Date(nu.sec*1e3+nu.nsec/1e6)}var aae={type:Joe,encode:rae,decode:oae},ZF=function(){function ou(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(aae)}return ou.prototype.register=function(nu){var ru=nu.type,lu=nu.encode,cu=nu.decode;if(ru>=0)this.encoders[ru]=lu,this.decoders[ru]=cu;else{var hu=1+ru;this.builtInEncoders[hu]=lu,this.builtInDecoders[hu]=cu}},ou.prototype.tryToEncode=function(nu,ru){for(var lu=0;lu<this.builtInEncoders.length;lu++){var cu=this.builtInEncoders[lu];if(cu!=null){var hu=cu(nu,ru);if(hu!=null){var pu=-1-lu;return new Z2(pu,hu)}}}for(var lu=0;lu<this.encoders.length;lu++){var cu=this.encoders[lu];if(cu!=null){var hu=cu(nu,ru);if(hu!=null){var pu=lu;return new Z2(pu,hu)}}}return nu instanceof Z2?nu:null},ou.prototype.decode=function(nu,ru,lu){var cu=ru<0?this.builtInDecoders[-1-ru]:this.decoders[ru];return cu?cu(nu,ru,lu):new Z2(ru,nu)},ou.defaultCodec=new ou,ou}();function j2(ou){return ou instanceof Uint8Array?ou:ArrayBuffer.isView(ou)?new Uint8Array(ou.buffer,ou.byteOffset,ou.byteLength):ou instanceof ArrayBuffer?new Uint8Array(ou):Uint8Array.from(ou)}function lae(ou){if(ou instanceof ArrayBuffer)return new DataView(ou);var nu=j2(ou);return new DataView(nu.buffer,nu.byteOffset,nu.byteLength)}var cae=100,uae=2048,hae=function(){function ou(nu,ru,lu,cu,hu,pu,mu,Au){nu===void 0&&(nu=ZF.defaultCodec),ru===void 0&&(ru=void 0),lu===void 0&&(lu=cae),cu===void 0&&(cu=uae),hu===void 0&&(hu=!1),pu===void 0&&(pu=!1),mu===void 0&&(mu=!1),Au===void 0&&(Au=!1),this.extensionCodec=nu,this.context=ru,this.maxDepth=lu,this.initialBufferSize=cu,this.sortKeys=hu,this.forceFloat32=pu,this.ignoreUndefined=mu,this.forceIntegerToFloat=Au,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return ou.prototype.reinitializeState=function(){this.pos=0},ou.prototype.encodeSharedRef=function(nu){return this.reinitializeState(),this.doEncode(nu,1),this.bytes.subarray(0,this.pos)},ou.prototype.encode=function(nu){return this.reinitializeState(),this.doEncode(nu,1),this.bytes.slice(0,this.pos)},ou.prototype.doEncode=function(nu,ru){if(ru>this.maxDepth)throw new Error("Too deep objects in depth ".concat(ru));nu==null?this.encodeNil():typeof nu=="boolean"?this.encodeBoolean(nu):typeof nu=="number"?this.encodeNumber(nu):typeof nu=="string"?this.encodeString(nu):this.encodeObject(nu,ru)},ou.prototype.ensureBufferSizeToWrite=function(nu){var ru=this.pos+nu;this.view.byteLength<ru&&this.resizeBuffer(ru*2)},ou.prototype.resizeBuffer=function(nu){var ru=new ArrayBuffer(nu),lu=new Uint8Array(ru),cu=new DataView(ru);lu.set(this.bytes),this.view=cu,this.bytes=lu},ou.prototype.encodeNil=function(){this.writeU8(192)},ou.prototype.encodeBoolean=function(nu){nu===!1?this.writeU8(194):this.writeU8(195)},ou.prototype.encodeNumber=function(nu){Number.isSafeInteger(nu)&&!this.forceIntegerToFloat?nu>=0?nu<128?this.writeU8(nu):nu<256?(this.writeU8(204),this.writeU8(nu)):nu<65536?(this.writeU8(205),this.writeU16(nu)):nu<4294967296?(this.writeU8(206),this.writeU32(nu)):(this.writeU8(207),this.writeU64(nu)):nu>=-32?this.writeU8(224|nu+32):nu>=-128?(this.writeU8(208),this.writeI8(nu)):nu>=-32768?(this.writeU8(209),this.writeI16(nu)):nu>=-2147483648?(this.writeU8(210),this.writeI32(nu)):(this.writeU8(211),this.writeI64(nu)):this.forceFloat32?(this.writeU8(202),this.writeF32(nu)):(this.writeU8(203),this.writeF64(nu))},ou.prototype.writeStringHeader=function(nu){if(nu<32)this.writeU8(160+nu);else if(nu<256)this.writeU8(217),this.writeU8(nu);else if(nu<65536)this.writeU8(218),this.writeU16(nu);else if(nu<4294967296)this.writeU8(219),this.writeU32(nu);else throw new Error("Too long string: ".concat(nu," bytes in UTF-8"))},ou.prototype.encodeString=function(nu){var ru=5,lu=nu.length;if(lu>Woe){var cu=QF(nu);this.ensureBufferSizeToWrite(ru+cu),this.writeStringHeader(cu),Qoe(nu,this.bytes,this.pos),this.pos+=cu}else{var cu=QF(nu);this.ensureBufferSizeToWrite(ru+cu),this.writeStringHeader(cu),zoe(nu,this.bytes,this.pos),this.pos+=cu}},ou.prototype.encodeObject=function(nu,ru){var lu=this.extensionCodec.tryToEncode(nu,this.context);if(lu!=null)this.encodeExtension(lu);else if(Array.isArray(nu))this.encodeArray(nu,ru);else if(ArrayBuffer.isView(nu))this.encodeBinary(nu);else if(typeof nu=="object")this.encodeMap(nu,ru);else throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(nu)))},ou.prototype.encodeBinary=function(nu){var ru=nu.byteLength;if(ru<256)this.writeU8(196),this.writeU8(ru);else if(ru<65536)this.writeU8(197),this.writeU16(ru);else if(ru<4294967296)this.writeU8(198),this.writeU32(ru);else throw new Error("Too large binary: ".concat(ru));var lu=j2(nu);this.writeU8a(lu)},ou.prototype.encodeArray=function(nu,ru){var lu=nu.length;if(lu<16)this.writeU8(144+lu);else if(lu<65536)this.writeU8(220),this.writeU16(lu);else if(lu<4294967296)this.writeU8(221),this.writeU32(lu);else throw new Error("Too large array: ".concat(lu));for(var cu=0,hu=nu;cu<hu.length;cu++){var pu=hu[cu];this.doEncode(pu,ru+1)}},ou.prototype.countWithoutUndefined=function(nu,ru){for(var lu=0,cu=0,hu=ru;cu<hu.length;cu++){var pu=hu[cu];nu[pu]!==void 0&&lu++}return lu},ou.prototype.encodeMap=function(nu,ru){var lu=Object.keys(nu);this.sortKeys&&lu.sort();var cu=this.ignoreUndefined?this.countWithoutUndefined(nu,lu):lu.length;if(cu<16)this.writeU8(128+cu);else if(cu<65536)this.writeU8(222),this.writeU16(cu);else if(cu<4294967296)this.writeU8(223),this.writeU32(cu);else throw new Error("Too large map object: ".concat(cu));for(var hu=0,pu=lu;hu<pu.length;hu++){var mu=pu[hu],Au=nu[mu];this.ignoreUndefined&&Au===void 0||(this.encodeString(mu),this.doEncode(Au,ru+1))}},ou.prototype.encodeExtension=function(nu){var ru=nu.data.length;if(ru===1)this.writeU8(212);else if(ru===2)this.writeU8(213);else if(ru===4)this.writeU8(214);else if(ru===8)this.writeU8(215);else if(ru===16)this.writeU8(216);else if(ru<256)this.writeU8(199),this.writeU8(ru);else if(ru<65536)this.writeU8(200),this.writeU16(ru);else if(ru<4294967296)this.writeU8(201),this.writeU32(ru);else throw new Error("Too large extension object: ".concat(ru));this.writeI8(nu.type),this.writeU8a(nu.data)},ou.prototype.writeU8=function(nu){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,nu),this.pos++},ou.prototype.writeU8a=function(nu){var ru=nu.length;this.ensureBufferSizeToWrite(ru),this.bytes.set(nu,this.pos),this.pos+=ru},ou.prototype.writeI8=function(nu){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,nu),this.pos++},ou.prototype.writeU16=function(nu){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,nu),this.pos+=2},ou.prototype.writeI16=function(nu){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,nu),this.pos+=2},ou.prototype.writeU32=function(nu){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,nu),this.pos+=4},ou.prototype.writeI32=function(nu){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,nu),this.pos+=4},ou.prototype.writeF32=function(nu){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,nu),this.pos+=4},ou.prototype.writeF64=function(nu){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,nu),this.pos+=8},ou.prototype.writeU64=function(nu){this.ensureBufferSizeToWrite(8),$oe(this.view,this.pos,nu),this.pos+=8},ou.prototype.writeI64=function(nu){this.ensureBufferSizeToWrite(8),HF(this.view,this.pos,nu),this.pos+=8},ou}(),dae={};function pae(ou,nu){nu===void 0&&(nu=dae);var ru=new hae(nu.extensionCodec,nu.context,nu.maxDepth,nu.initialBufferSize,nu.sortKeys,nu.forceFloat32,nu.ignoreUndefined,nu.forceIntegerToFloat);return ru.encodeSharedRef(ou)}function C_(ou){return"".concat(ou<0?"-":"","0x").concat(Math.abs(ou).toString(16).padStart(2,"0"))}var fae=16,mae=16,gae=function(){function ou(nu,ru){nu===void 0&&(nu=fae),ru===void 0&&(ru=mae),this.maxKeyLength=nu,this.maxLengthPerKey=ru,this.hit=0,this.miss=0,this.caches=[];for(var lu=0;lu<this.maxKeyLength;lu++)this.caches.push([])}return ou.prototype.canBeCached=function(nu){return nu>0&&nu<=this.maxKeyLength},ou.prototype.find=function(nu,ru,lu){var cu=this.caches[lu-1];e:for(var hu=0,pu=cu;hu<pu.length;hu++){for(var mu=pu[hu],Au=mu.bytes,bu=0;bu<lu;bu++)if(Au[bu]!==nu[ru+bu])continue e;return mu.str}return null},ou.prototype.store=function(nu,ru){var lu=this.caches[nu.length-1],cu={bytes:nu,str:ru};lu.length>=this.maxLengthPerKey?lu[Math.random()*lu.length|0]=cu:lu.push(cu)},ou.prototype.decode=function(nu,ru,lu){var cu=this.find(nu,ru,lu);if(cu!=null)return this.hit++,cu;this.miss++;var hu=KF(nu,ru,lu),pu=Uint8Array.prototype.slice.call(nu,ru,ru+lu);return this.store(pu,hu),hu},ou}(),Aae=function(ou,nu,ru,lu){function cu(hu){return hu instanceof ru?hu:new ru(function(pu){pu(hu)})}return new(ru||(ru=Promise))(function(hu,pu){function mu(Cu){try{bu(lu.next(Cu))}catch(wu){pu(wu)}}function Au(Cu){try{bu(lu.throw(Cu))}catch(wu){pu(wu)}}function bu(Cu){Cu.done?hu(Cu.value):cu(Cu.value).then(mu,Au)}bu((lu=lu.apply(ou,[])).next())})},w_=function(ou,nu){var ru={label:0,sent:function(){if(hu[0]&1)throw hu[1];return hu[1]},trys:[],ops:[]},lu,cu,hu,pu;return pu={next:mu(0),throw:mu(1),return:mu(2)},typeof Symbol=="function"&&(pu[Symbol.iterator]=function(){return this}),pu;function mu(bu){return function(Cu){return Au([bu,Cu])}}function Au(bu){if(lu)throw new TypeError("Generator is already executing.");for(;ru;)try{if(lu=1,cu&&(hu=bu[0]&2?cu.return:bu[0]?cu.throw||((hu=cu.return)&&hu.call(cu),0):cu.next)&&!(hu=hu.call(cu,bu[1])).done)return hu;switch(cu=0,hu&&(bu=[bu[0]&2,hu.value]),bu[0]){case 0:case 1:hu=bu;break;case 4:return ru.label++,{value:bu[1],done:!1};case 5:ru.label++,cu=bu[1],bu=[0];continue;case 7:bu=ru.ops.pop(),ru.trys.pop();continue;default:if(hu=ru.trys,!(hu=hu.length>0&&hu[hu.length-1])&&(bu[0]===6||bu[0]===2)){ru=0;continue}if(bu[0]===3&&(!hu||bu[1]>hu[0]&&bu[1]<hu[3])){ru.label=bu[1];break}if(bu[0]===6&&ru.label<hu[1]){ru.label=hu[1],hu=bu;break}if(hu&&ru.label<hu[2]){ru.label=hu[2],ru.ops.push(bu);break}hu[2]&&ru.ops.pop(),ru.trys.pop();continue}bu=nu.call(ou,ru)}catch(Cu){bu=[6,Cu],cu=0}finally{lu=hu=0}if(bu[0]&5)throw bu[1];return{value:bu[0]?bu[1]:void 0,done:!0}}},jF=function(ou){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var nu=ou[Symbol.asyncIterator],ru;return nu?nu.call(ou):(ou=typeof __values=="function"?__values(ou):ou[Symbol.iterator](),ru={},lu("next"),lu("throw"),lu("return"),ru[Symbol.asyncIterator]=function(){return this},ru);function lu(hu){ru[hu]=ou[hu]&&function(pu){return new Promise(function(mu,Au){pu=ou[hu](pu),cu(mu,Au,pu.done,pu.value)})}}function cu(hu,pu,mu,Au){Promise.resolve(Au).then(function(bu){hu({value:bu,done:mu})},pu)}},vC=function(ou){return this instanceof vC?(this.v=ou,this):new vC(ou)},yae=function(ou,nu,ru){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var lu=ru.apply(ou,nu||[]),cu,hu=[];return cu={},pu("next"),pu("throw"),pu("return"),cu[Symbol.asyncIterator]=function(){return this},cu;function pu(Eu){lu[Eu]&&(cu[Eu]=function(Tu){return new Promise(function(Ru,Nu){hu.push([Eu,Tu,Ru,Nu])>1||mu(Eu,Tu)})})}function mu(Eu,Tu){try{Au(lu[Eu](Tu))}catch(Ru){wu(hu[0][3],Ru)}}function Au(Eu){Eu.value instanceof vC?Promise.resolve(Eu.value.v).then(bu,Cu):wu(hu[0][2],Eu)}function bu(Eu){mu("next",Eu)}function Cu(Eu){mu("throw",Eu)}function wu(Eu,Tu){Eu(Tu),hu.shift(),hu.length&&mu(hu[0][0],hu[0][1])}},bae=function(ou){var nu=typeof ou;return nu==="string"||nu==="number"},Kw=-1,E_=new DataView(new ArrayBuffer(0)),xae=new Uint8Array(E_.buffer),S_=function(){try{E_.getInt8(0)}catch(ou){return ou.constructor}throw new Error("never reached")}(),YF=new S_("Insufficient data"),vae=new gae,Cae=function(){function ou(nu,ru,lu,cu,hu,pu,mu,Au){nu===void 0&&(nu=ZF.defaultCodec),ru===void 0&&(ru=void 0),lu===void 0&&(lu=B1),cu===void 0&&(cu=B1),hu===void 0&&(hu=B1),pu===void 0&&(pu=B1),mu===void 0&&(mu=B1),Au===void 0&&(Au=vae),this.extensionCodec=nu,this.context=ru,this.maxStrLength=lu,this.maxBinLength=cu,this.maxArrayLength=hu,this.maxMapLength=pu,this.maxExtLength=mu,this.keyDecoder=Au,this.totalPos=0,this.pos=0,this.view=E_,this.bytes=xae,this.headByte=Kw,this.stack=[]}return ou.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=Kw,this.stack.length=0},ou.prototype.setBuffer=function(nu){this.bytes=j2(nu),this.view=lae(this.bytes),this.pos=0},ou.prototype.appendBuffer=function(nu){if(this.headByte===Kw&&!this.hasRemaining(1))this.setBuffer(nu);else{var ru=this.bytes.subarray(this.pos),lu=j2(nu),cu=new Uint8Array(ru.length+lu.length);cu.set(ru),cu.set(lu,ru.length),this.setBuffer(cu)}},ou.prototype.hasRemaining=function(nu){return this.view.byteLength-this.pos>=nu},ou.prototype.createExtraByteError=function(nu){var ru=this,lu=ru.view,cu=ru.pos;return new RangeError("Extra ".concat(lu.byteLength-cu," of ").concat(lu.byteLength," byte(s) found at buffer[").concat(nu,"]"))},ou.prototype.decode=function(nu){this.reinitializeState(),this.setBuffer(nu);var ru=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return ru},ou.prototype.decodeMulti=function(nu){return w_(this,function(ru){switch(ru.label){case 0:this.reinitializeState(),this.setBuffer(nu),ru.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return ru.sent(),[3,1];case 3:return[2]}})},ou.prototype.decodeAsync=function(nu){var ru,lu,cu,hu;return Aae(this,void 0,void 0,function(){var pu,mu,Au,bu,Cu,wu,Eu,Tu;return w_(this,function(Ru){switch(Ru.label){case 0:pu=!1,Ru.label=1;case 1:Ru.trys.push([1,6,7,12]),ru=jF(nu),Ru.label=2;case 2:return[4,ru.next()];case 3:if(lu=Ru.sent(),!!lu.done)return[3,5];if(Au=lu.value,pu)throw this.createExtraByteError(this.totalPos);this.appendBuffer(Au);try{mu=this.doDecodeSync(),pu=!0}catch(Nu){if(!(Nu instanceof S_))throw Nu}this.totalPos+=this.pos,Ru.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return bu=Ru.sent(),cu={error:bu},[3,12];case 7:return Ru.trys.push([7,,10,11]),lu&&!lu.done&&(hu=ru.return)?[4,hu.call(ru)]:[3,9];case 8:Ru.sent(),Ru.label=9;case 9:return[3,11];case 10:if(cu)throw cu.error;return[7];case 11:return[7];case 12:if(pu){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,mu]}throw Cu=this,wu=Cu.headByte,Eu=Cu.pos,Tu=Cu.totalPos,new RangeError("Insufficient data in parsing ".concat(C_(wu)," at ").concat(Tu," (").concat(Eu," in the current buffer)"))}})})},ou.prototype.decodeArrayStream=function(nu){return this.decodeMultiAsync(nu,!0)},ou.prototype.decodeStream=function(nu){return this.decodeMultiAsync(nu,!1)},ou.prototype.decodeMultiAsync=function(nu,ru){return yae(this,arguments,function(){var lu,cu,hu,pu,mu,Au,bu,Cu,wu;return w_(this,function(Eu){switch(Eu.label){case 0:lu=ru,cu=-1,Eu.label=1;case 1:Eu.trys.push([1,13,14,19]),hu=jF(nu),Eu.label=2;case 2:return[4,vC(hu.next())];case 3:if(pu=Eu.sent(),!!pu.done)return[3,12];if(mu=pu.value,ru&&cu===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(mu),lu&&(cu=this.readArraySize(),lu=!1,this.complete()),Eu.label=4;case 4:Eu.trys.push([4,9,,10]),Eu.label=5;case 5:return[4,vC(this.doDecodeSync())];case 6:return[4,Eu.sent()];case 7:return Eu.sent(),--cu===0?[3,8]:[3,5];case 8:return[3,10];case 9:if(Au=Eu.sent(),!(Au instanceof S_))throw Au;return[3,10];case 10:this.totalPos+=this.pos,Eu.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return bu=Eu.sent(),Cu={error:bu},[3,19];case 14:return Eu.trys.push([14,,17,18]),pu&&!pu.done&&(wu=hu.return)?[4,vC(wu.call(hu))]:[3,16];case 15:Eu.sent(),Eu.label=16;case 16:return[3,18];case 17:if(Cu)throw Cu.error;return[7];case 18:return[7];case 19:return[2]}})})},ou.prototype.doDecodeSync=function(){e:for(;;){var nu=this.readHeadByte(),ru=void 0;if(nu>=224)ru=nu-256;else if(nu<192)if(nu<128)ru=nu;else if(nu<144){var lu=nu-128;if(lu!==0){this.pushMapState(lu),this.complete();continue e}else ru={}}else if(nu<160){var lu=nu-144;if(lu!==0){this.pushArrayState(lu),this.complete();continue e}else ru=[]}else{var cu=nu-160;ru=this.decodeUtf8String(cu,0)}else if(nu===192)ru=null;else if(nu===194)ru=!1;else if(nu===195)ru=!0;else if(nu===202)ru=this.readF32();else if(nu===203)ru=this.readF64();else if(nu===204)ru=this.readU8();else if(nu===205)ru=this.readU16();else if(nu===206)ru=this.readU32();else if(nu===207)ru=this.readU64();else if(nu===208)ru=this.readI8();else if(nu===209)ru=this.readI16();else if(nu===210)ru=this.readI32();else if(nu===211)ru=this.readI64();else if(nu===217){var cu=this.lookU8();ru=this.decodeUtf8String(cu,1)}else if(nu===218){var cu=this.lookU16();ru=this.decodeUtf8String(cu,2)}else if(nu===219){var cu=this.lookU32();ru=this.decodeUtf8String(cu,4)}else if(nu===220){var lu=this.readU16();if(lu!==0){this.pushArrayState(lu),this.complete();continue e}else ru=[]}else if(nu===221){var lu=this.readU32();if(lu!==0){this.pushArrayState(lu),this.complete();continue e}else ru=[]}else if(nu===222){var lu=this.readU16();if(lu!==0){this.pushMapState(lu),this.complete();continue e}else ru={}}else if(nu===223){var lu=this.readU32();if(lu!==0){this.pushMapState(lu),this.complete();continue e}else ru={}}else if(nu===196){var lu=this.lookU8();ru=this.decodeBinary(lu,1)}else if(nu===197){var lu=this.lookU16();ru=this.decodeBinary(lu,2)}else if(nu===198){var lu=this.lookU32();ru=this.decodeBinary(lu,4)}else if(nu===212)ru=this.decodeExtension(1,0);else if(nu===213)ru=this.decodeExtension(2,0);else if(nu===214)ru=this.decodeExtension(4,0);else if(nu===215)ru=this.decodeExtension(8,0);else if(nu===216)ru=this.decodeExtension(16,0);else if(nu===199){var lu=this.lookU8();ru=this.decodeExtension(lu,1)}else if(nu===200){var lu=this.lookU16();ru=this.decodeExtension(lu,2)}else if(nu===201){var lu=this.lookU32();ru=this.decodeExtension(lu,4)}else throw new Yx("Unrecognized type byte: ".concat(C_(nu)));this.complete();for(var hu=this.stack;hu.length>0;){var pu=hu[hu.length-1];if(pu.type===0)if(pu.array[pu.position]=ru,pu.position++,pu.position===pu.size)hu.pop(),ru=pu.array;else continue e;else if(pu.type===1){if(!bae(ru))throw new Yx("The type of key must be string or number but "+typeof ru);if(ru==="__proto__")throw new Yx("The key __proto__ is not allowed");pu.key=ru,pu.type=2;continue e}else if(pu.map[pu.key]=ru,pu.readCount++,pu.readCount===pu.size)hu.pop(),ru=pu.map;else{pu.key=null,pu.type=1;continue e}}return ru}},ou.prototype.readHeadByte=function(){return this.headByte===Kw&&(this.headByte=this.readU8()),this.headByte},ou.prototype.complete=function(){this.headByte=Kw},ou.prototype.readArraySize=function(){var nu=this.readHeadByte();switch(nu){case 220:return this.readU16();case 221:return this.readU32();default:{if(nu<160)return nu-144;throw new Yx("Unrecognized array type byte: ".concat(C_(nu)))}}},ou.prototype.pushMapState=function(nu){if(nu>this.maxMapLength)throw new Yx("Max length exceeded: map length (".concat(nu,") > maxMapLengthLength (").concat(this.maxMapLength,")"));this.stack.push({type:1,size:nu,key:null,readCount:0,map:{}})},ou.prototype.pushArrayState=function(nu){if(nu>this.maxArrayLength)throw new Yx("Max length exceeded: array length (".concat(nu,") > maxArrayLength (").concat(this.maxArrayLength,")"));this.stack.push({type:0,size:nu,array:new Array(nu),position:0})},ou.prototype.decodeUtf8String=function(nu,ru){var lu;if(nu>this.maxStrLength)throw new Yx("Max length exceeded: UTF-8 byte length (".concat(nu,") > maxStrLength (").concat(this.maxStrLength,")"));if(this.bytes.byteLength<this.pos+ru+nu)throw YF;var cu=this.pos+ru,hu;return this.stateIsMapKey()&&!((lu=this.keyDecoder)===null||lu===void 0)&&lu.canBeCached(nu)?hu=this.keyDecoder.decode(this.bytes,cu,nu):nu>joe?hu=Yoe(this.bytes,cu,nu):hu=KF(this.bytes,cu,nu),this.pos+=ru+nu,hu},ou.prototype.stateIsMapKey=function(){if(this.stack.length>0){var nu=this.stack[this.stack.length-1];return nu.type===1}return!1},ou.prototype.decodeBinary=function(nu,ru){if(nu>this.maxBinLength)throw new Yx("Max length exceeded: bin length (".concat(nu,") > maxBinLength (").concat(this.maxBinLength,")"));if(!this.hasRemaining(nu+ru))throw YF;var lu=this.pos+ru,cu=this.bytes.subarray(lu,lu+nu);return this.pos+=ru+nu,cu},ou.prototype.decodeExtension=function(nu,ru){if(nu>this.maxExtLength)throw new Yx("Max length exceeded: ext length (".concat(nu,") > maxExtLength (").concat(this.maxExtLength,")"));var lu=this.view.getInt8(this.pos+ru),cu=this.decodeBinary(nu,ru+1);return this.extensionCodec.decode(cu,lu,this.context)},ou.prototype.lookU8=function(){return this.view.getUint8(this.pos)},ou.prototype.lookU16=function(){return this.view.getUint16(this.pos)},ou.prototype.lookU32=function(){return this.view.getUint32(this.pos)},ou.prototype.readU8=function(){var nu=this.view.getUint8(this.pos);return this.pos++,nu},ou.prototype.readI8=function(){var nu=this.view.getInt8(this.pos);return this.pos++,nu},ou.prototype.readU16=function(){var nu=this.view.getUint16(this.pos);return this.pos+=2,nu},ou.prototype.readI16=function(){var nu=this.view.getInt16(this.pos);return this.pos+=2,nu},ou.prototype.readU32=function(){var nu=this.view.getUint32(this.pos);return this.pos+=4,nu},ou.prototype.readI32=function(){var nu=this.view.getInt32(this.pos);return this.pos+=4,nu},ou.prototype.readU64=function(){var nu=Voe(this.view,this.pos);return this.pos+=8,nu},ou.prototype.readI64=function(){var nu=XF(this.view,this.pos);return this.pos+=8,nu},ou.prototype.readF32=function(){var nu=this.view.getFloat32(this.pos);return this.pos+=4,nu},ou.prototype.readF64=function(){var nu=this.view.getFloat64(this.pos);return this.pos+=8,nu},ou}(),wae={};function Eae(ou,nu){nu===void 0&&(nu=wae);var ru=new Cae(nu.extensionCodec,nu.context,nu.maxStrLength,nu.maxBinLength,nu.maxArrayLength,nu.maxMapLength,nu.maxExtLength);return ru.decode(ou)}const qF=2;class Sae{constructor(){this.data=null}compileImageTargets(nu,ru){return new Promise(async(lu,cu)=>{const hu=[];for(let bu=0;bu<nu.length;bu++){const Cu=nu[bu],wu=this.createProcessCanvas(Cu).getContext("2d");wu.drawImage(Cu,0,0,Cu.width,Cu.height);const Eu=wu.getImageData(0,0,Cu.width,Cu.height),Tu=new Uint8Array(Cu.width*Cu.height);for(let Nu=0;Nu<Tu.length;Nu++){const Pu=Nu*4;Tu[Nu]=Math.floor((Eu.data[Pu]+Eu.data[Pu+1]+Eu.data[Pu+2])/3)}const Ru={data:Tu,height:Cu.height,width:Cu.width};hu.push(Ru)}const pu=50/hu.length;let mu=0;this.data=[];for(let bu=0;bu<hu.length;bu++){const Cu=hu[bu],wu=Boe(Cu),Eu=pu/wu.length,Tu=await Iae(wu,()=>{mu+=Eu,ru(mu)});this.data.push({targetImage:Cu,imageList:wu,matchingData:Tu})}for(let bu=0;bu<hu.length;bu++){const Cu=Loe(hu[bu]);this.data[bu].trackingImageList=Cu}const Au=await this.compileTrack({progressCallback:ru,targetImages:hu,basePercent:50});for(let bu=0;bu<hu.length;bu++)this.data[bu].trackingData=Au[bu];lu(this.data)})}exportData(){const nu=[];for(let ru=0;ru<this.data.length;ru++)nu.push({targetImage:{width:this.data[ru].targetImage.width,height:this.data[ru].targetImage.height},trackingData:this.data[ru].trackingData,matchingData:this.data[ru].matchingData});return pae({v:qF,dataList:nu})}importData(nu){const ru=Eae(new Uint8Array(nu));if(!ru.v||ru.v!==qF)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:lu}=ru;this.data=[];for(let cu=0;cu<lu.length;cu++)this.data.push({targetImage:lu[cu].targetImage,trackingData:lu[cu].trackingData,matchingData:lu[cu].matchingData});return this.data}createProcessCanvas(nu){console.warn("missing createProcessCanvas implementation")}compileTrack({progressCallback:nu,targetImages:ru,basePercent:lu}){console.warn("missing compileTrack implementation")}}const Iae=async(ou,nu)=>{const ru=[];for(let lu=0;lu<ou.length;lu++){const cu=ou[lu],hu=new $F(cu.width,cu.height);await QE(),Op(()=>{const pu=Ky(cu.data,[cu.data.length],"float32").reshape([cu.height,cu.width]),{featurePoints:mu}=hu.detect(pu),Au=mu.filter(Eu=>Eu.maxima),bu=mu.filter(Eu=>!Eu.maxima),Cu=zF({points:Au}),wu=zF({points:bu});ru.push({maximaPoints:Au,minimaPoints:bu,maximaPointsCluster:Cu,minimaPointsCluster:wu,width:cu.width,height:cu.height,scale:cu.scale}),nu(lu)})}return ru},JF="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHp7Y29uc3RydWN0b3Iocyx0LG8pe3RoaXMuY3Vtc3VtPVtdO2ZvcihsZXQgZT0wO2U8bztlKyspe3RoaXMuY3Vtc3VtLnB1c2goW10pO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5jdW1zdW1bZV0ucHVzaCgwKX10aGlzLmN1bXN1bVswXVswXT1zWzBdO2ZvcihsZXQgZT0xO2U8dDtlKyspdGhpcy5jdW1zdW1bMF1bZV09dGhpcy5jdW1zdW1bMF1bZS0xXStzW2VdO2ZvcihsZXQgZT0xO2U8bztlKyspdGhpcy5jdW1zdW1bZV1bMF09dGhpcy5jdW1zdW1bZS0xXVswXStzW2UqdF07Zm9yKGxldCBlPTE7ZTxvO2UrKylmb3IobGV0IG49MTtuPHQ7bisrKXRoaXMuY3Vtc3VtW2VdW25dPXNbZSp0K25dK3RoaXMuY3Vtc3VtW2UtMV1bbl0rdGhpcy5jdW1zdW1bZV1bbi0xXS10aGlzLmN1bXN1bVtlLTFdW24tMV19cXVlcnkocyx0LG8sZSl7bGV0IG49dGhpcy5jdW1zdW1bZV1bb107cmV0dXJuIHQ+MCYmKG4tPXRoaXMuY3Vtc3VtW3QtMV1bb10pLHM+MCYmKG4tPXRoaXMuY3Vtc3VtW2VdW3MtMV0pLHM+MCYmdD4wJiYobis9dGhpcy5jdW1zdW1bdC0xXVtzLTFdKSxufX1jb25zdCBDPTEwLGI9MixNPTYsRj01LEk9Ljk1LEw9LjksTz0uMixaPTgsTj0yNCoyLzMsVT1yPT57Y29uc3R7ZGF0YTpzLHdpZHRoOnQsaGVpZ2h0Om8sc2NhbGU6ZX09cixuPVt0Km9dO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKW5baV09ITE7Y29uc3QgYT1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWFbaV09LTEsYVt0KihvLTEpK2ldPS0xO2ZvcihsZXQgaT0wO2k8bztpKyspYVtpKnRdPS0xLGFbaSp0K3QtMV09LTE7Zm9yKGxldCBpPTE7aTx0LTE7aSsrKWZvcihsZXQgcD0xO3A8by0xO3ArKyl7bGV0IGY9aSt0KnAsaD0wLGM9MDtmb3IobGV0IHU9LTE7dTw9MTt1KyspaCs9c1tmK3QqdSsxXS1zW2YrdCp1LTFdLGMrPXNbZit0K3VdLXNbZi10K3VdO2gvPTMqMjU2LGMvPTMqMjU2LGFbZl09TWF0aC5zcXJ0KChoKmgrYypjKS8yKX1jb25zdCBnPW5ldyBVaW50MzJBcnJheSgxZTMpO2ZvcihsZXQgaT0wO2k8MWUzO2krKylnW2ldPTA7Y29uc3QgZD1bLTEsMSwtdCx0XTtmb3IobGV0IGk9MTtpPHQtMTtpKyspZm9yKGxldCBwPTE7cDxvLTE7cCsrKXtsZXQgZj1pK3QqcCxoPSEwO2ZvcihsZXQgYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGFbZl08PWFbZitkW2NdXSl7aD0hMTticmVha31pZihoKXtsZXQgYz1NYXRoLmZsb29yKGFbZl0qMWUzKTtjPjk5OSYmKGM9OTk5KSxjPDAmJihjPTApLGdbY10rPTEsbltmXT0hMH19Y29uc3Qgdz0uMDIqdCpvO2xldCBqPTk5OSxFPTA7Zm9yKDtqPj0wJiYoRSs9Z1tqXSwhKEU+dykpOylqLS07Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmYVtpXSoxZTM8aiYmKG5baV09ITEpO2NvbnN0IGw9W107Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDtpKyspbFtpXT1zW2ldKnNbaV07Y29uc3QgUz1uZXcgeihzLHQsbyksRD1uZXcgeihsLHQsbyksaz1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgcD0wO3A8bztwKyspe2NvbnN0IGY9cCp0K2k7aWYoIW5bZl0pe2tbZl09MTtjb250aW51ZX1jb25zdCBoPVAoe2ltYWdlOnIsY3g6aSxjeTpwLHNkVGhyZXNoOkYsaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KTtpZihoPT09bnVsbCl7a1tmXT0xO2NvbnRpbnVlfWxldCBjPS0xO2ZvcihsZXQgdT0tQzt1PD1DO3UrKyl7Zm9yKGxldCBtPS1DO208PUM7bSsrKXtpZihtKm0rdSp1PD1iKmIpY29udGludWU7Y29uc3QgeD1SKHtpbWFnZTpyLGN4OmkrbSxjeTpwK3UsdmxlbjpoLHR4OmksdHk6cCxpbWFnZURhdGFDdW1zdW06UyxpbWFnZURhdGFTcXJDdW1zdW06RH0pO2lmKHghPT1udWxsJiZ4PmMmJihjPXgsYz5JKSlicmVha31pZihjPkkpYnJlYWt9a1tmXT1jfXJldHVybiBWKHtpbWFnZTpyLGZlYXR1cmVNYXA6ayx0ZW1wbGF0ZVNpemU6TSxzZWFyY2hTaXplOmIsb2NjU2l6ZTpOLG1heFNpbVRocmVzaDpMLG1pblNpbVRocmVzaDpPLHNkVGhyZXNoOlosaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KX0sVj1yPT57bGV0e2ltYWdlOnMsZmVhdHVyZU1hcDp0LHRlbXBsYXRlU2l6ZTpvLHNlYXJjaFNpemU6ZSxvY2NTaXplOm4sbWF4U2ltVGhyZXNoOmEsbWluU2ltVGhyZXNoOmcsc2RUaHJlc2g6ZCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an09cjtjb25zdHtkYXRhOkUsd2lkdGg6bCxoZWlnaHQ6UyxzY2FsZTpEfT1zO249TWF0aC5mbG9vcihNYXRoLm1pbihzLndpZHRoLHMuaGVpZ2h0KS8xMCk7Y29uc3Qgaz0obyoyKzEpKjMsQT1NYXRoLmZsb29yKGwvayksaT1NYXRoLmZsb29yKFMvayk7bGV0IHA9TWF0aC5mbG9vcihsL24pKk1hdGguZmxvb3IoUy9uKStBKmk7Y29uc3QgZj1bXSxoPW5ldyBGbG9hdDMyQXJyYXkoRS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8aC5sZW5ndGg7dSsrKWhbdV09dFt1XTtsZXQgYz0wO2Zvcig7YzxwOyl7bGV0IHU9YSxtPS0xLHg9LTE7Zm9yKGxldCB5PTA7eTxTO3krKylmb3IobGV0IFQ9MDtUPGw7VCsrKWhbeSpsK1RdPHUmJih1PWhbeSpsK1RdLG09VCx4PXkpO2lmKG09PT0tMSlicmVhaztjb25zdCB2PVAoe2ltYWdlOnMsY3g6bSxjeTp4LHNkVGhyZXNoOjAsaW1hZ2VEYXRhQ3Vtc3VtOncsaW1hZ2VEYXRhU3FyQ3Vtc3VtOmp9KTtpZih2PT09bnVsbCl7aFt4KmwrbV09MTtjb250aW51ZX1pZih2LyhvKjIrMSk8ZCl7aFt4KmwrbV09MTtjb250aW51ZX1sZXQgcT0xLF89LTE7Zm9yKGxldCB5PS1lO3k8PWU7eSsrKXtmb3IobGV0IFQ9LWU7VDw9ZTtUKyspe2lmKFQqVCt5Knk+ZSplfHxUPT09MCYmeT09PTApY29udGludWU7Y29uc3QgSD1SKHtpbWFnZTpzLHZsZW46dixjeDptK1QsY3k6eCt5LHR4Om0sdHk6eCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an0pO2lmKEghPT1udWxsJiYoSDxxJiYocT1ILHE8ZyYmcTx1KXx8SD5fJiYoXz1ILF8+Ljk5KSkpYnJlYWt9aWYocTxnJiZxPHV8fF8+Ljk5KWJyZWFrfWlmKHE8ZyYmcTx1fHxfPi45OSl7aFt4KmwrbV09MTtjb250aW51ZX1mLnB1c2goe3g6bSx5Onh9KSxjKz0xO2ZvcihsZXQgeT0tbjt5PD1uO3krKylmb3IobGV0IFQ9LW47VDw9bjtUKyspeCt5PDB8fHgreT49U3x8bStUPDB8fG0rVD49bHx8KGhbKHgreSkqbCsobStUKV09MSl9cmV0dXJuIGZ9LFA9KHtpbWFnZTpyLGN4OnMsY3k6dCxzZFRocmVzaDpvLGltYWdlRGF0YUN1bXN1bTplLGltYWdlRGF0YVNxckN1bXN1bTpufSk9PntpZihzLU08MHx8cytNPj1yLndpZHRofHx0LU08MHx8dCtNPj1yLmhlaWdodClyZXR1cm4gbnVsbDtjb25zdCBhPTIqTSsxLGc9YSphO2xldCBkPWUucXVlcnkocy1NLHQtTSxzK00sdCtNKTtkLz1nO2xldCB3PW4ucXVlcnkocy1NLHQtTSxzK00sdCtNKTtyZXR1cm4gdy09MipkKmUucXVlcnkocy1NLHQtTSxzK00sdCtNKSx3Kz1nKmQqZCx3L2c8bypvP251bGw6KHc9TWF0aC5zcXJ0KHcpLHcpfSxSPXI9Pntjb25zdHtpbWFnZTpzLGN4OnQsY3k6byx2bGVuOmUsdHg6bix0eTphLGltYWdlRGF0YUN1bXN1bTpnLGltYWdlRGF0YVNxckN1bXN1bTpkfT1yLHtkYXRhOncsd2lkdGg6aixoZWlnaHQ6RX09cyxsPU07aWYodC1sPDB8fHQrbD49anx8by1sPDB8fG8rbD49RSlyZXR1cm4gbnVsbDtjb25zdCBTPTIqbCsxO2xldCBEPWcucXVlcnkodC1sLG8tbCx0K2wsbytsKSxrPWQucXVlcnkodC1sLG8tbCx0K2wsbytsKSxBPTAsaT0oby1sKSpqKyh0LWwpLHA9KGEtbCkqaisobi1sKSxmPWotUztmb3IobGV0IG09MDttPFM7bSsrKXtmb3IobGV0IHg9MDt4PFM7eCsrKUErPXdbaV0qd1twXSxpKz0xLHArPTE7aSs9ZixwKz1mfWxldCBoPWcucXVlcnkobi1sLGEtbCxuK2wsYStsKTtoLz1TKlMsQS09aCpEO2xldCBjPWstRCpELyhTKlMpO3JldHVybiBjPT0wP251bGw6KGM9TWF0aC5zcXJ0KGMpLDEqQS8oZSpjKSl9LFc9KHIscyk9Pntjb25zdCB0PVtdO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCBlPXJbb10sbj1VKGUpLGE9e2RhdGE6ZS5kYXRhLHNjYWxlOmUuc2NhbGUsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQscG9pbnRzOm59O3QucHVzaChhKSxzKG8pfXJldHVybiB0fSxYPSh7aW1hZ2U6cixyYXRpbzpzfSk9Pntjb25zdCB0PU1hdGgucm91bmQoci53aWR0aCpzKSxvPU1hdGgucm91bmQoci5oZWlnaHQqcyksZT1uZXcgVWludDhBcnJheSh0Km8pO2ZvcihsZXQgbj0wO248dDtuKyspe2xldCBhPU1hdGgucm91bmQoMSpuL3MpLGc9TWF0aC5yb3VuZCgxKihuKzEpL3MpLTE7Zz49ci53aWR0aCYmKGc9ci53aWR0aC0xKTtmb3IobGV0IGQ9MDtkPG87ZCsrKXtsZXQgdz1NYXRoLnJvdW5kKDEqZC9zKSxqPU1hdGgucm91bmQoMSooZCsxKS9zKS0xO2o+PXIuaGVpZ2h0JiYoaj1yLmhlaWdodC0xKTtsZXQgRT0wLGw9MDtmb3IobGV0IFM9YTtTPD1nO1MrKylmb3IobGV0IEQ9dztEPD1qO0QrKylFKz0xKnIuZGF0YVtEKnIud2lkdGgrU10sbCs9MTtlW2QqdCtuXT1NYXRoLmZsb29yKEUvbCl9fXJldHVybntkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6b319LFk9cj0+e2NvbnN0IHM9TWF0aC5taW4oci53aWR0aCxyLmhlaWdodCksdD1bXSxvPVtdO3QucHVzaCgyNTYvcyksdC5wdXNoKDEyOC9zKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylvLnB1c2goT2JqZWN0LmFzc2lnbihYKHtpbWFnZTpyLHJhdGlvOnRbZV19KSx7c2NhbGU6dFtlXX0pKTtyZXR1cm4gb307b25tZXNzYWdlPXI9Pntjb25zdHtkYXRhOnN9PXI7aWYocy50eXBlPT09ImNvbXBpbGUiKXtjb25zdHt0YXJnZXRJbWFnZXM6dH09cyxvPTEwMC90Lmxlbmd0aDtsZXQgZT0wO2NvbnN0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2NvbnN0IGc9dFthXSxkPVkoZyksdz1vL2QubGVuZ3RoLGo9VyhkLEU9PntlKz13LHBvc3RNZXNzYWdlKHt0eXBlOiJwcm9ncmVzcyIscGVyY2VudDplfSl9KTtuLnB1c2goail9cG9zdE1lc3NhZ2Uoe3R5cGU6ImNvbXBpbGVEb25lIixsaXN0Om59KX19fSkoKTsK",eP=typeof window<"u"&&window.Blob&&new Blob([atob(JF)],{type:"text/javascript;charset=utf-8"});function Tae(ou){let nu;try{if(nu=eP&&(window.URL||window.webkitURL).createObjectURL(eP),!nu)throw"";const ru=new Worker(nu,{name:ou==null?void 0:ou.name});return ru.addEventListener("error",()=>{(window.URL||window.webkitURL).revokeObjectURL(nu)}),ru}catch{return new Worker("data:application/javascript;base64,"+JF,{name:ou==null?void 0:ou.name})}finally{nu&&(window.URL||window.webkitURL).revokeObjectURL(nu)}}class tP extends Sae{createProcessCanvas(nu){const ru=document.createElement("canvas");return ru.width=nu.width,ru.height=nu.height,ru}compileTrack({progressCallback:nu,targetImages:ru,basePercent:lu}){return new Promise((cu,hu)=>{const pu=new Tae;pu.onmessage=mu=>{mu.data.type==="progress"?nu(lu+mu.data.percent*lu/100):mu.data.type==="compileDone"&&cu(mu.data.list)},pu.postMessage({type:"compile",targetImages:ru})})}}class _ae{constructor(nu,ru){this.width=nu,this.height=ru,this.texShape=[ru,nu];const lu=document.createElement("canvas").getContext("2d");lu.canvas.width=nu,lu.canvas.height=ru,this.context=lu,this.program=this.buildProgram(nu,ru);const cu=vv();this.tempPixelHandle=cu.makeTensorInfo(this.texShape,"float32"),cu.texData.get(this.tempPixelHandle.dataId).usage=2}_loadInput(nu){return Op(()=>{let ru=gz(nu);return ru=ru.mean(2),ru})}loadInput(nu){const ru=this.context;if(ru.clearRect(0,0,this.context.canvas.width,this.context.canvas.height),nu.width===this.height&&nu.height===this.width){let cu=this.context.canvas.width/2,hu=this.context.canvas.height/2;ru.save(),ru.translate(cu,hu),ru.rotate(90*Math.PI/180),ru.drawImage(nu,-nu.width/2,-nu.height/2),ru.restore()}else this.context.drawImage(nu,0,0,nu.width,nu.height);const lu=vv();return lu.gpgpu.uploadPixelDataToTexture(lu.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(nu,ru){const lu=cp().getNumber("WEBGL_VERSION")===2?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`
	void main() {
	  ivec2 coords = getOutputCoords();
	  int texR = coords[0];
	  int texC = coords[1];
	  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${nu}.0, ${ru}.0);

	  vec4 values = ${lu}(A, uv);
	  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);
	}
      `}}_compileAndRun(nu,ru){const lu=vv().compileAndRun(nu,ru);return w0().makeTensorFromDataId(lu.dataId,lu.shape,lu.dtype)}_runWebGLProgram(nu,ru,lu){const cu=vv().runWebGLProgram(nu,ru,lu);return w0().makeTensorFromDataId(cu.dataId,cu.shape,cu.dtype)}}const nP=(ou,nu)=>{const ru=2*Math.PI*nu*ou;return ru/(ru+1)},iP=(ou,nu,ru)=>ou*nu+(1-ou)*ru;class Mae{constructor({minCutOff:nu,beta:ru}){this.minCutOff=nu,this.beta=ru,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(nu,ru){if(!this.initialized)return this.initialized=!0,this.xPrev=ru,this.dxPrev=ru.map(()=>0),this.tPrev=nu,ru;const{xPrev:lu,tPrev:cu,dxPrev:hu}=this,pu=nu-cu,mu=nP(pu,this.dCutOff),Au=[],bu=[],Cu=[];for(let wu=0;wu<ru.length;wu++){Au[wu]=(ru[wu]-lu[wu])/pu,bu[wu]=iP(mu,Au[wu],hu[wu]);const Eu=this.minCutOff+this.beta*Math.abs(bu[wu]),Tu=nP(pu,Eu);Cu[wu]=iP(Tu,ru[wu],lu[wu])}return this.xPrev=Cu,this.dxPrev=bu,this.tPrev=nu,Cu}}const I_={memory:MS,nextFrame:QE},Rae=.001,kae=1e3,Bae=5,Lae=5;class rP{constructor({inputWidth:nu,inputHeight:ru,onUpdate:lu=null,debugMode:cu=!1,maxTrack:hu=1,warmupTolerance:pu=null,missTolerance:mu=null,filterMinCF:Au=null,filterBeta:bu=null}){this.inputWidth=nu,this.inputHeight=ru,this.maxTrack=hu,this.filterMinCF=Au===null?Rae:Au,this.filterBeta=bu===null?kae:bu,this.warmupTolerance=pu===null?Bae:pu,this.missTolerance=mu===null?Lae:mu,this.cropDetector=new Roe(this.inputWidth,this.inputHeight,cu),this.inputLoader=new _ae(this.inputWidth,this.inputHeight),this.markerDimensions=null,this.onUpdate=lu,this.debugMode=cu,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const Cu=10,wu=1e5,Eu=45*Math.PI/180,Tu=this.inputHeight/2/Math.tan(Eu/2);this.projectionTransform=[[Tu,0,this.inputWidth/2],[0,Tu,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:Cu,far:wu}),this.worker=new Wse,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=Ru=>{Ru.data.type==="matchDone"&&this.workerMatchDone!==null&&this.workerMatchDone(Ru.data),Ru.data.type==="trackUpdateDone"&&this.workerTrackDone!==null&&this.workerTrackDone(Ru.data)}}showTFStats(){console.log(I_.memory().numTensors),console.table(I_.memory())}addImageTargets(nu){return new Promise(async(ru,lu)=>{const cu=await(await fetch(nu)).arrayBuffer(),hu=this.addImageTargetsFromBuffer(cu);ru(hu)})}addImageTargetsFromBuffer(nu){const ru=new tP().importData(nu),lu=[],cu=[],hu=[];for(let pu=0;pu<ru.length;pu++)cu.push(ru[pu].matchingData),lu.push(ru[pu].trackingData),hu.push([ru[pu].targetImage.width,ru[pu].targetImage.height]);return this.tracker=new eoe(hu,lu,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:cu}),this.markerDimensions=hu,{dimensions:hu,matchingDataList:cu,trackingDataList:lu}}dispose(){this.stopProcessVideo(),this.worker.postMessage({type:"dispose"})}dummyRun(nu){const ru=this.inputLoader.loadInput(nu);this.cropDetector.detect(ru),this.tracker.dummyRun(ru),ru.dispose()}getProjectionMatrix(){return this.projectionMatrix}getRotatedZ90Matrix(nu){return[-nu[1],nu[0],nu[2],nu[3],-nu[5],nu[4],nu[6],nu[7],-nu[9],nu[8],nu[10],nu[11],-nu[13],nu[12],nu[14],nu[15]]}getWorldMatrix(nu,ru){return this._glModelViewMatrix(nu,ru)}async _detectAndMatch(nu,ru){const{featurePoints:lu}=this.cropDetector.detectMoving(nu),{targetIndex:cu,modelViewTransform:hu}=await this._workerMatch(lu,ru);return{targetIndex:cu,modelViewTransform:hu}}async _trackAndUpdate(nu,ru,lu){const{worldCoords:cu,screenCoords:hu}=this.tracker.track(nu,ru,lu);return cu.length<4?null:await this._workerTrackUpdate(ru,{worldCoords:cu,screenCoords:hu})}processVideo(nu){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let ru=0;ru<this.markerDimensions.length;ru++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new Mae({minCutOff:this.filterMinCF,beta:this.filterBeta})});(async()=>{for(;this.processingVideo;){const ru=this.inputLoader.loadInput(nu);if(this.trackingStates.reduce((lu,cu)=>lu+(cu.isTracking?1:0),0)<this.maxTrack){const lu=[];for(let pu=0;pu<this.trackingStates.length;pu++)this.trackingStates[pu].isTracking!==!0&&(this.interestedTargetIndex!==-1&&this.interestedTargetIndex!==pu||lu.push(pu));const{targetIndex:cu,modelViewTransform:hu}=await this._detectAndMatch(ru,lu);cu!==-1&&(this.trackingStates[cu].isTracking=!0,this.trackingStates[cu].currentModelViewTransform=hu)}for(let lu=0;lu<this.trackingStates.length;lu++){const cu=this.trackingStates[lu];if(cu.isTracking){let hu=await this._trackAndUpdate(ru,cu.currentModelViewTransform,lu);hu===null?cu.isTracking=!1:cu.currentModelViewTransform=hu}if(cu.showing||cu.isTracking&&(cu.trackMiss=0,cu.trackCount+=1,cu.trackCount>this.warmupTolerance&&(cu.showing=!0,cu.trackingMatrix=null,cu.filter.reset())),cu.showing&&(cu.isTracking?cu.trackMiss=0:(cu.trackCount=0,cu.trackMiss+=1,cu.trackMiss>this.missTolerance&&(cu.showing=!1,cu.trackingMatrix=null,this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:lu,worldMatrix:null})))),cu.showing){const hu=this._glModelViewMatrix(cu.currentModelViewTransform,lu);cu.trackingMatrix=cu.filter.filter(Date.now(),hu);let pu=[];for(let mu=0;mu<cu.trackingMatrix.length;mu++)pu[mu]=cu.trackingMatrix[mu];nu.width===this.inputHeight&&nu.height===this.inputWidth&&(pu=this.getRotatedZ90Matrix(pu)),this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:lu,worldMatrix:pu})}}ru.dispose(),this.onUpdate&&this.onUpdate({type:"processDone"}),await I_.nextFrame()}})()}}stopProcessVideo(){this.processingVideo=!1}async detect(nu){const ru=this.inputLoader.loadInput(nu),{featurePoints:lu,debugExtra:cu}=await this.cropDetector.detect(ru);return ru.dispose(),{featurePoints:lu,debugExtra:cu}}async match(nu,ru){const{modelViewTransform:lu,debugExtra:cu}=await this._workerMatch(nu,[ru]);return{modelViewTransform:lu,debugExtra:cu}}async track(nu,ru,lu){const cu=this.inputLoader.loadInput(nu),hu=this.tracker.track(cu,ru,lu);return cu.dispose(),hu}async trackUpdate(nu,ru){return ru.worldCoords.length<4?null:await this._workerTrackUpdate(nu,ru)}_workerMatch(nu,ru){return new Promise(async(lu,cu)=>{this.workerMatchDone=hu=>{lu({targetIndex:hu.targetIndex,modelViewTransform:hu.modelViewTransform,debugExtra:hu.debugExtra})},this.worker.postMessage({type:"match",featurePoints:nu,targetIndexes:ru})})}_workerTrackUpdate(nu,ru){return new Promise(async(lu,cu)=>{this.workerTrackDone=mu=>{lu(mu.modelViewTransform)};const{worldCoords:hu,screenCoords:pu}=ru;this.worker.postMessage({type:"trackUpdate",modelViewTransform:nu,worldCoords:hu,screenCoords:pu})})}_glModelViewMatrix(nu,ru){const lu=this.markerDimensions[ru][1];return[nu[0][0],-nu[1][0],-nu[2][0],0,-nu[0][1],nu[1][1],nu[2][1],0,-nu[0][2],nu[1][2],nu[2][2],0,nu[0][1]*lu+nu[0][3],-(nu[1][1]*lu+nu[1][3]),-(nu[2][1]*lu+nu[2][3]),1]}_glProjectionMatrix({projectionTransform:nu,width:ru,height:lu,near:cu,far:hu}){const pu=[[2*nu[0][0]/ru,0,-(2*nu[0][2]/ru-1),0],[0,2*nu[1][1]/lu,-(2*nu[1][2]/lu-1),0],[0,0,-(hu+cu)/(hu-cu),-2*hu*cu/(hu-cu)],[0,0,-1,0]],mu=[];for(let Au=0;Au<4;Au++)for(let bu=0;bu<4;bu++)mu.push(pu[bu][Au]);return mu}}const Nae=`<div class="mindar-ui-overlay mindar-ui-loading">
  <div class="loader"/>
</div>
`,Dae=`<div class="mindar-ui-overlay mindar-ui-compatibility">
  <div class="content">
    <h1>Failed to launch :(</h1>
    <p>
      Looks like your device/browser is not compatible.
    </p>

    <br/>
    <br/>
    <p>
      Please try the following recommended browsers:
    </p>
    <p>
      For Android device - Chrome
    </p>
    <p>
      For iOS device - Safari
    </p>
  </div>
</div>
`,Fae=`<div class="mindar-ui-overlay mindar-ui-scanning">
  <div class="scanning">
    <div class="inner">
      <div class="scanline"/>
    </div>
  </div>
</div>
`,Pae=".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid white;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right,white 10px,transparent 10px) 0 0,linear-gradient(to right,white 10px,transparent 10px) 0 100%,linear-gradient(to left,white 10px,transparent 10px) 100% 0,linear-gradient(to left,white 10px,transparent 10px) 100% 100%,linear-gradient(to bottom,white 10px,transparent 10px) 0 0,linear-gradient(to bottom,white 10px,transparent 10px) 100% 0,linear-gradient(to top,white 10px,transparent 10px) 0 100%,linear-gradient(to top,white 10px,transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:white;animation:move 2s linear infinite}@keyframes move{0%,to{top:0%}50%{top:calc(100% - 10px)}}";class sP{constructor({uiLoading:nu,uiScanning:ru,uiError:lu}){const cu=document.createElement("style");cu.innerText=Pae,document.head.appendChild(cu),nu==="yes"?this.loadingModal=this._loadHTML(Nae):nu!=="no"&&(this.loadingModal=document.querySelector(nu)),lu==="yes"?this.compatibilityModal=this._loadHTML(Dae):lu!=="no"&&(this.compatibilityModal=document.querySelector(lu)),ru==="yes"?this.scanningMask=this._loadHTML(Fae):ru!=="no"&&(this.scanningMask=document.querySelector(ru)),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove("hidden")}hideLoading(){this.loadingModal&&this.loadingModal.classList.add("hidden")}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove("hidden")}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add("hidden")}showScanning(){this.scanningMask&&this.scanningMask.classList.remove("hidden")}hideScanning(){this.scanningMask&&this.scanningMask.classList.add("hidden")}_loadHTML(nu){const ru=document.createElement("template");ru.innerHTML=nu.trim();const lu=ru.content.firstChild;return document.getElementsByTagName("body")[0].appendChild(lu),lu}}window.MINDAR||(window.MINDAR={}),window.MINDAR.IMAGE={Controller:rP,Compiler:tP,UI:sP},AFRAME.registerSystem("mindar-image-system",{container:null,video:null,processingImage:!1,init:function(){this.anchorEntities=[]},tick:function(){},setup:function({imageTargetSrc:ou,maxTrack:nu,showStats:ru,uiLoading:lu,uiScanning:cu,uiError:hu,missTolerance:pu,warmupTolerance:mu,filterMinCF:Au,filterBeta:bu}){this.imageTargetSrc=ou,this.maxTrack=nu,this.filterMinCF=Au,this.filterBeta=bu,this.missTolerance=pu,this.warmupTolerance=mu,this.showStats=ru,this.ui=new sP({uiLoading:lu,uiScanning:cu,uiError:hu})},registerAnchor:function(ou,nu){this.anchorEntities.push({el:ou,targetIndex:nu})},start:function(){this.container=this.el.sceneEl.parentNode,this.showStats&&(this.mainStats=new Stats,this.mainStats.showPanel(0),this.mainStats.domElement.style.cssText="position:absolute;top:0px;left:0px;z-index:999",this.container.appendChild(this.mainStats.domElement)),this.ui.showLoading(),this._startVideo()},switchTarget:function(ou){this.controller.interestedTargetIndex=ou},stop:function(){this.pause(),this.video.srcObject.getTracks().forEach(function(ou){ou.stop()}),this.video.remove(),this.controller.dispose()},pause:function(ou=!1){ou||this.video.pause(),this.controller.stopProcessVideo()},unpause:function(){this.video.play(),this.controller.processVideo(this.video)},_startVideo:function(){if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){this.el.emit("arError",{error:"VIDEO_FAIL"}),this.ui.showCompatibility();return}navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"environment"}}).then(ou=>{this.video.addEventListener("loadedmetadata",()=>{this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight),this._startAR()}),this.video.srcObject=ou}).catch(ou=>{console.log("getUserMedia error",ou),this.el.emit("arError",{error:"VIDEO_FAIL"})})},_startAR:async function(){const ou=this.video;this.container,this.controller=new rP({inputWidth:ou.videoWidth,inputHeight:ou.videoHeight,maxTrack:this.maxTrack,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,missTolerance:this.missTolerance,warmupTolerance:this.warmupTolerance,onUpdate:ru=>{if(ru.type==="processDone")this.mainStats&&this.mainStats.update();else if(ru.type==="updateMatrix"){const{targetIndex:lu,worldMatrix:cu}=ru;for(let hu=0;hu<this.anchorEntities.length;hu++)this.anchorEntities[hu].targetIndex===lu&&this.anchorEntities[hu].el.updateWorldMatrix(cu);this.anchorEntities.reduce((hu,pu)=>hu||pu.el.el.object3D.visible,!1)?this.ui.hideScanning():this.ui.showScanning()}}}),this._resize(),window.addEventListener("resize",this._resize.bind(this));const{dimensions:nu}=await this.controller.addImageTargets(this.imageTargetSrc);for(let ru=0;ru<this.anchorEntities.length;ru++){const{el:lu,targetIndex:cu}=this.anchorEntities[ru];cu<nu.length&&lu.setupMarker(nu[cu])}await this.controller.dummyRun(this.video),this.el.emit("arReady"),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video)},_resize:function(){const ou=this.video,nu=this.container;let ru,lu;const cu=ou.videoWidth/ou.videoHeight,hu=nu.clientWidth/nu.clientHeight;cu>hu?(lu=nu.clientHeight,ru=lu*cu):(ru=nu.clientWidth,lu=ru/cu);const pu=this.controller.getProjectionMatrix(),mu=2*Math.atan(1/pu[5]/lu*nu.clientHeight)*180/Math.PI,Au=pu[14]/(pu[10]-1),bu=pu[14]/(pu[10]+1);pu[5]/pu[0];const Cu=nu.clientWidth/nu.clientHeight,wu=nu.getElementsByTagName("a-camera")[0].getObject3D("camera");wu.fov=mu,wu.aspect=Cu,wu.near=Au,wu.far=bu,wu.updateProjectionMatrix(),this.video.style.top=-(lu-nu.clientHeight)/2+"px",this.video.style.left=-(ru-nu.clientWidth)/2+"px",this.video.style.width=ru+"px",this.video.style.height=lu+"px"}}),AFRAME.registerComponent("mindar-image",{dependencies:["mindar-image-system"],schema:{imageTargetSrc:{type:"string"},maxTrack:{type:"int",default:1},filterMinCF:{type:"number",default:-1},filterBeta:{type:"number",default:-1},missTolerance:{type:"int",default:-1},warmupTolerance:{type:"int",default:-1},showStats:{type:"boolean",default:!1},autoStart:{type:"boolean",default:!0},uiLoading:{type:"string",default:"yes"},uiScanning:{type:"string",default:"yes"},uiError:{type:"string",default:"yes"}},init:function(){const ou=this.el.sceneEl.systems["mindar-image-system"];ou.setup({imageTargetSrc:this.data.imageTargetSrc,maxTrack:this.data.maxTrack,filterMinCF:this.data.filterMinCF===-1?null:this.data.filterMinCF,filterBeta:this.data.filterBeta===-1?null:this.data.filterBeta,missTolerance:this.data.missTolerance===-1?null:this.data.missTolerance,warmupTolerance:this.data.warmupTolerance===-1?null:this.data.warmupTolerance,showStats:this.data.showStats,uiLoading:this.data.uiLoading,uiScanning:this.data.uiScanning,uiError:this.data.uiError}),this.data.autoStart&&this.el.sceneEl.addEventListener("renderstart",()=>{ou.start()})},remove:function(){this.el.sceneEl.systems["mindar-image-system"].stop()}}),AFRAME.registerComponent("mindar-image-target",{dependencies:["mindar-image-system"],schema:{targetIndex:{type:"number"}},postMatrix:null,init:function(){this.el.sceneEl.systems["mindar-image-system"].registerAnchor(this,this.data.targetIndex),this.invisibleMatrix=new AFRAME.THREE.Matrix4().set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const ou=this.el.object3D;ou.visible=!1,ou.matrixAutoUpdate=!1,ou.matrix=this.invisibleMatrix},setupMarker([ou,nu]){const ru=new AFRAME.THREE.Vector3,lu=new AFRAME.THREE.Quaternion,cu=new AFRAME.THREE.Vector3;ru.x=ou/2,ru.y=ou/2+(nu-ou)/2,cu.x=ou,cu.y=ou,cu.z=ou,this.postMatrix=new AFRAME.THREE.Matrix4,this.postMatrix.compose(ru,lu,cu)},updateWorldMatrix(ou){if(this.el.emit("targetUpdate"),!this.el.object3D.visible&&ou!==null?this.el.emit("targetFound"):this.el.object3D.visible&&ou===null&&this.el.emit("targetLost"),this.el.object3D.visible=ou!==null,ou===null){this.el.object3D.matrix=this.invisibleMatrix;return}var nu=new AFRAME.THREE.Matrix4;nu.elements=ou,nu.multiply(this.postMatrix),this.el.object3D.matrix=nu}})})();typeof navigator<"u"&&!navigator.mediaDevices&&navigator.getUserMedia&&(navigator.mediaDevices={getUserMedia:iu=>new Promise((eu,tu)=>{navigator.getUserMedia(iu,eu,tu)})});const WebAR=({onTargetFound,onTargetLost,numTargets,config})=>{const[arConfig,setArConfig]=reactExports.useState(config||null),[loadingData,setLoadingData]=reactExports.useState(!0);reactExports.useEffect(()=>{const loadData=async()=>{var iu,eu;if(config){setArConfig(config),setLoadingData(!1);return}try{const response=await fetch("/src/data/data.js");if(response.ok){const text=await response.text(),match=text.match(/const arList = (\[[\s\S]*?\]);/);if(match){const arList=eval(match[1]),targets=arList.map((tu,su)=>({id:tu.id||(su+1).toString(),name:tu.name||`Target ${su+1}`,imageFile:null,imageUrl:tu.image||null,videoFile:null,videoUrl:tu.video||null,targetIndex:su})),mindFileUrl=(eu=(iu=arList[0])==null?void 0:iu.image)!=null&&eu.endsWith(".mind")?arList[0].image:"../uploads/image/targets.mind",loadedConfig={targets,targetsMindUrl:mindFileUrl,targetsMindFile:null,targetsMindFileUrl:null};setArConfig(loadedConfig),setLoadingData(!1);return}}}catch(tu){console.log("Could not load from data.js, trying localStorage:",tu)}const saved=localStorage.getItem("ar_config");if(saved)try{setArConfig(JSON.parse(saved))}catch(tu){console.error("Error loading AR config:",tu)}setLoadingData(!1)};loadData()},[config]);const targetCount=(arConfig==null?void 0:arConfig.targets.length)||numTargets||1,targetsMindUrl=(arConfig==null?void 0:arConfig.targetsMindUrl)||"../uploads/image/targets.mind",sceneRef=reactExports.useRef(null),videoRefs=reactExports.useRef(new Map),targetRefs=reactExports.useRef(new Map),mindarSystemRef=reactExports.useRef(null),[isStarted,setIsStarted]=reactExports.useState(!1),[isMuted,setIsMuted]=reactExports.useState(!1),[facingMode,setFacingMode]=reactExports.useState("environment"),[visibleTargets,setVisibleTargets]=reactExports.useState(new Set),[sceneReady,setSceneReady]=reactExports.useState(!1),[assetsReady,setAssetsReady]=reactExports.useState(!1),[fileExists,setFileExists]=reactExports.useState(!0),[compatibilityError,setCompatibilityError]=reactExports.useState(null),[compatibilityChecking,setCompatibilityChecking]=reactExports.useState(!0),[canUseCamera,setCanUseCamera]=reactExports.useState(!1),[diagnosticInfo,setDiagnosticInfo]=reactExports.useState(null),[showDiagnostics,setShowDiagnostics]=reactExports.useState(!1),checkCameraCompatibility=async()=>{setCompatibilityChecking(!0),setCompatibilityError(null),setDiagnosticInfo(null);try{const iu=navigator.userAgent||"",eu={userAgent:iu,isSecureContext:!!window.isSecureContext,protocol:location.protocol,hostname:location.hostname,hasGetUserMedia:!!(navigator.mediaDevices&&typeof navigator.mediaDevices.getUserMedia=="function")||!!navigator.getUserMedia,hasNavigator:!!navigator,hasMediaDevices:!!navigator.mediaDevices,inAppBrowser:/FBAN|FBAV|Instagram|Twitter|Line|Messenger|FB_IAB|FB4A|FBAV|WebView|wv/.test(iu),isMobile:/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(iu),isIOS:/iPad|iPhone|iPod/.test(iu),isAndroid:/Android/.test(iu),browserName:getBrowserName(iu)};if(setDiagnosticInfo(eu),!navigator){setCompatibilityError("Navigator not available. Please use a modern browser."),setCanUseCamera(!1);return}const tu=location.hostname==="localhost"||location.hostname==="127.0.0.1",su=location.protocol==="http:";if(!navigator.mediaDevices)if(tu&&su&&navigator.getUserMedia)console.log("Using legacy getUserMedia for HTTP localhost"),navigator.mediaDevices={getUserMedia:gu=>new Promise((yu,xu)=>{navigator.getUserMedia(gu,yu,xu)})};else{setCompatibilityError("MediaDevices API not supported. Please use HTTPS or a modern browser with camera support."),setCanUseCamera(!1);return}if(eu.inAppBrowser){setCompatibilityError("This page appears to be opened inside an in-app browser (Facebook, Instagram, etc.). Open this page in your system browser (Safari/Chrome) for camera access."),setCanUseCamera(!1);return}if(!eu.hasGetUserMedia){setCompatibilityError("Your browser does not support camera access. Recommended: Chrome on Android, Safari on iOS, or latest Chrome/Firefox on desktop."),setCanUseCamera(!1);return}const au=location.hostname.startsWith("192.168.")||location.hostname.startsWith("10.")||location.hostname.startsWith("172."),uu=!1;if(!eu.isSecureContext&&!tu&&!(au&&uu)){const gu=`${location.protocol}//${location.hostname}:${location.port}`;setCompatibilityError(`Camera requires HTTPS or special browser flags for HTTP. 

For Chrome, restart with:
chrome --unsafely-treat-insecure-origin-as-secure=${gu} --user-data-dir=/tmp/chrome-dev

Or use HTTPS/localhost instead.`),setCanUseCamera(!1);return}!eu.isSecureContext&&au&&uu&&console.warn("Running on insecure HTTP context. Camera access may be limited.");const du={video:{facingMode,width:{ideal:1280},height:{ideal:720}}};let fu;if(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)fu=await navigator.mediaDevices.getUserMedia(du);else if(navigator.getUserMedia)fu=await new Promise((gu,yu)=>{navigator.getUserMedia(du,gu,yu)});else throw new Error("No getUserMedia support");fu.getTracks().forEach(gu=>{var yu;console.log("Camera track:",gu.label,(yu=gu.getSettings)==null?void 0:yu.call(gu)),gu.stop()}),setCanUseCamera(!0)}catch(iu){const eu=iu;if(console.error("getUserMedia error:",eu),(eu==null?void 0:eu.name)==="NotAllowedError"||(eu==null?void 0:eu.name)==="SecurityError"||(eu==null?void 0:eu.name)==="PermissionDeniedError")setCompatibilityError("Camera permission denied. Please allow camera access and reload the page.");else if((eu==null?void 0:eu.name)==="NotFoundError")setCompatibilityError("No camera found on this device.");else if((eu==null?void 0:eu.name)==="OverconstrainedError")setCompatibilityError("Camera constraints not supported. Try a different device or browser.");else if((eu==null?void 0:eu.name)==="NotReadableError")setCompatibilityError("Camera is already in use by another application.");else if((eu==null?void 0:eu.name)==="AbortError")setCompatibilityError("Camera access was aborted.");else{const tu=eu instanceof Error?eu.message:String(eu);setCompatibilityError(`Camera error: ${tu}`)}setCanUseCamera(!1)}finally{setCompatibilityChecking(!1)}},getBrowserName=iu=>iu.includes("Chrome")?"Chrome":iu.includes("Firefox")?"Firefox":iu.includes("Safari")&&!iu.includes("Chrome")?"Safari":iu.includes("Edge")?"Edge":iu.includes("Opera")?"Opera":"Unknown";reactExports.useEffect(()=>{checkCameraCompatibility()},[]),reactExports.useEffect(()=>{canUseCamera&&checkCameraCompatibility()},[facingMode]),reactExports.useEffect(()=>{const iu=[],eu=()=>{for(let au=0;au<targetCount;au++){const uu=document.getElementById(`target-entity-${au}`);if(!uu){setTimeout(eu,100);return}targetRefs.current.set(au,uu);const du=()=>{console.log(`Target ${au} found`),setVisibleTargets(yu=>new Set(yu).add(au));const gu=videoRefs.current.get(au)||document.getElementById(`ar-video-${au}`);gu&&gu.paused&&gu.play().catch(yu=>console.error(`Error playing video for target ${au}:`,yu)),onTargetFound&&onTargetFound(au)},fu=()=>{console.log(`Target ${au} lost`),setVisibleTargets(yu=>{const xu=new Set(yu);return xu.delete(au),xu});const gu=videoRefs.current.get(au)||document.getElementById(`ar-video-${au}`);gu&&!gu.paused&&gu.pause(),onTargetLost&&onTargetLost(au)};uu.addEventListener("targetFound",du),uu.addEventListener("targetLost",fu),iu.push(()=>{uu.removeEventListener("targetFound",du),uu.removeEventListener("targetLost",fu)})}},tu=()=>{for(let au=0;au<targetCount;au++){const uu=document.getElementById(`ar-video-${au}`);uu&&videoRefs.current.set(au,uu)}},su=document.querySelector("a-scene");return su&&su.hasLoaded?(eu(),tu()):su?su.addEventListener("loaded",()=>{eu(),tu()},{once:!0}):setTimeout(()=>{eu(),tu()},500),()=>{iu.forEach(au=>au())}},[onTargetFound,onTargetLost,targetCount]),reactExports.useEffect(()=>{const iu=()=>{const eu=document.querySelector("a-scene");if(!eu){setTimeout(iu,100);return}const tu=()=>{console.log("A-Frame scene loaded"),fetch("/targets.mind",{method:"HEAD"}).then(su=>{if(!su.ok){console.error("targets.mind file not found"),setFileExists(!1),setAssetsReady(!0);return}setFileExists(!0);let au=0;const uu=30,du=()=>{var gu;const fu=eu.components["mindar-image-system"]||eu.systems["mindar-image-system"]||((gu=eu.systems)==null?void 0:gu.mindarImageSystem);fu?(console.log("MindAR system ready",fu),mindarSystemRef.current=fu,setSceneReady(!0),setAssetsReady(!0)):au<uu?(au++,setTimeout(du,200)):(console.warn("MindAR system not available after waiting. The file exists, but system may need manual start."),setSceneReady(!0),setAssetsReady(!0))};setTimeout(du,800)}).catch(su=>{console.error("Error checking targets.mind:",su),setFileExists(!1),setAssetsReady(!0)})};eu.hasLoaded?tu():eu.addEventListener("loaded",tu,{once:!0})};iu()},[]);const handleStart=async()=>{if(compatibilityChecking){alert("Checking device/browser compatibility. Please wait a moment and try again.");return}if(!canUseCamera){alert(compatibilityError||"Camera not available on this device/browser. See console for details.");return}try{const iu=document.querySelector("a-scene");if(!iu||!iu.hasLoaded){alert("Scene not loaded. Please refresh the page.");return}try{let tu;if(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)tu=await navigator.mediaDevices.getUserMedia({video:{facingMode}});else if(navigator.getUserMedia)tu=await new Promise((su,au)=>{navigator.getUserMedia({video:{facingMode}},su,au)});else throw new Error("No camera support");tu.getTracks().forEach(su=>su.stop())}catch(tu){console.error("Camera permission check failed:",tu),setCanUseCamera(!1);const su=tu;(su==null?void 0:su.name)==="NotAllowedError"?setCompatibilityError("Camera permission denied. Please allow camera access and reload the page."):setCompatibilityError("Camera access failed. Please check your camera and try again.");return}let eu=mindarSystemRef.current;if(!eu&&(iu.systems&&(eu=iu.systems["mindar-image-system"]||iu.systems["mindar-image"]||iu.systems.mindarImageSystem),!eu&&iu.systems)){const tu=iu.systems,su=Object.keys(tu);for(const au of su){const uu=tu[au];if(uu&&typeof uu.start=="function"&&(au.toLowerCase().includes("mindar")||au.toLowerCase().includes("image"))){eu=uu,console.log("Found MindAR system via search:",au),mindarSystemRef.current=eu;break}}}if(!eu){console.error("MindAR system not found. Scene systems:",iu.systems?Object.keys(iu.systems):"none"),console.error("Scene element:",iu),alert("Error: MindAR system not initialized. The targets.mind file exists, but the system could not be started. Please check the browser console and refresh the page.");return}console.log("Starting MindAR system:",eu),await eu.start(),setIsStarted(!0)}catch(iu){const eu=iu;console.error("Error starting AR:",eu),(eu==null?void 0:eu.name)==="NotAllowedError"||(eu==null?void 0:eu.name)==="SecurityError"||(eu==null?void 0:eu.name)==="PermissionDeniedError"?(setCompatibilityError("Camera permission denied while starting AR. Grant camera access in browser settings and reload the page."),setCanUseCamera(!1)):(eu==null?void 0:eu.name)==="NotFoundError"?(setCompatibilityError("Camera not found. Please check if your camera is connected and working."),setCanUseCamera(!1)):(eu==null?void 0:eu.name)==="NotReadableError"&&(setCompatibilityError("Camera is being used by another application. Please close other apps using the camera."),setCanUseCamera(!1));const tu=eu instanceof Error?eu.message:"Unknown error";alert(`Failed to start AR: ${tu}. Check browser console for details.`)}},handleStop=()=>{try{const iu=mindarSystemRef.current;if(iu&&typeof iu.stop=="function")iu.stop();else{const eu=document.querySelector("a-scene");if(eu&&eu.systems){const tu=eu.systems["mindar-image-system"]||eu.systems["mindar-image"];tu&&typeof tu.stop=="function"&&tu.stop()}}setIsStarted(!1),setVisibleTargets(new Set);for(let eu=0;eu<targetCount;eu++){const tu=videoRefs.current.get(eu)||document.getElementById(`ar-video-${eu}`);tu&&(tu.pause(),tu.currentTime=0)}}catch(iu){console.error("Error stopping AR:",iu)}},handleFlipCamera=async()=>{try{handleStop(),setFacingMode(iu=>iu==="environment"?"user":"environment"),await new Promise(iu=>setTimeout(iu,1e3)),await handleStart()}catch(iu){console.error("Error flipping camera:",iu),alert("Failed to flip camera. Please try again.")}},getVideoElements=()=>{const iu=[];for(let eu=0;eu<targetCount;eu++){const tu=videoRefs.current.get(eu)||document.getElementById(`ar-video-${eu}`);tu&&iu.push(tu)}return iu},toggleMute=()=>{const iu=getVideoElements(),eu=!isMuted;iu.forEach(tu=>{tu.muted=eu}),setIsMuted(eu)};return reactExports.useEffect(()=>{getVideoElements().forEach(eu=>{eu.muted=isMuted})},[isMuted,targetCount]),jsxRuntimeExports.jsxs("div",{ref:sceneRef,className:"relative w-full h-screen",children:[jsxRuntimeExports.jsxs("a-scene",{"mindar-image":`imageTargetSrc: ${targetsMindUrl}; filterMinCF: 0.0001; filterBeta: 0.001; facingMode: ${facingMode};`,"color-space":"sRGB",renderer:"colorManagement: true, physicallyCorrectLights","vr-mode-ui":"enabled: false","device-orientation-permission-ui":"enabled: false",children:[jsxRuntimeExports.jsx("a-assets",{children:Array.from({length:targetCount},(iu,eu)=>{const tu=arConfig==null?void 0:arConfig.targets[eu];let su=`/video${eu}.mp4`;return tu!=null&&tu.videoUrl&&(tu.videoUrl.startsWith("../uploads/")?su=tu.videoUrl.replace("../uploads/","/src/uploads/"):(tu.videoUrl.startsWith("/"),su=tu.videoUrl)),jsxRuntimeExports.jsx("video",{id:`ar-video-${eu}`,src:su,preload:"auto",crossOrigin:"anonymous",loop:!0,playsInline:!0,muted:isMuted?!0:void 0,"webkit-playsinline":"true"},`video-${eu}`)})}),jsxRuntimeExports.jsx("a-camera",{position:"0 0 0","look-controls":"enabled: false"}),Array.from({length:targetCount},(iu,eu)=>jsxRuntimeExports.jsx("a-entity",{id:`target-entity-${eu}`,"mindar-image-target":`targetIndex: ${eu}`,children:jsxRuntimeExports.jsx("a-video",{src:`#ar-video-${eu}`,position:"0 0 0",height:"1",width:"1.778",rotation:"0 0 0"})},`target-${eu}`))]}),jsxRuntimeExports.jsxs("div",{className:"absolute top-0 left-0 right-0 p-4 bg-gradient-to-b from-black/70 to-transparent z-10",children:[jsxRuntimeExports.jsx("h1",{className:"text-white text-2xl font-bold text-center",children:"WebAR Image Tracking"}),visibleTargets.size>0&&jsxRuntimeExports.jsx("div",{className:"text-center mt-2",children:jsxRuntimeExports.jsx("span",{className:"inline-block bg-green-500 text-white px-4 py-1 rounded-full text-sm font-semibold",children:visibleTargets.size===1?`Target ${Array.from(visibleTargets)[0]} Detected`:`${visibleTargets.size} Targets Detected: ${Array.from(visibleTargets).join(", ")}`})})]}),jsxRuntimeExports.jsx("div",{className:"absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/70 to-transparent z-10",children:jsxRuntimeExports.jsxs("div",{className:"flex flex-col gap-3",children:[jsxRuntimeExports.jsx("div",{className:"flex gap-3 justify-center",children:isStarted?jsxRuntimeExports.jsx("button",{onClick:handleStop,className:"flex-1 max-w-xs bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-6 rounded-lg transition-colors shadow-lg",children:"Stop AR"}):jsxRuntimeExports.jsx("button",{onClick:handleStart,className:"flex-1 max-w-xs bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-6 rounded-lg transition-colors shadow-lg",children:"Start AR"})}),jsxRuntimeExports.jsxs("div",{className:"flex gap-3 justify-center",children:[jsxRuntimeExports.jsx("button",{onClick:handleFlipCamera,disabled:!isStarted,className:"flex-1 max-w-[150px] bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-lg transition-colors shadow-lg",children:"Flip Camera"}),jsxRuntimeExports.jsx("button",{onClick:toggleMute,disabled:!isStarted,className:`flex-1 max-w-[150px] ${isMuted?"bg-yellow-600 hover:bg-yellow-700":"bg-blue-600 hover:bg-blue-700"} disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-lg transition-colors shadow-lg`,children:isMuted?"Unmute":"Mute"})]})]})}),(compatibilityChecking||compatibilityError)&&jsxRuntimeExports.jsx("div",{className:"absolute inset-0 flex items-center justify-center bg-black/80 z-50",children:jsxRuntimeExports.jsxs("div",{className:"bg-white p-8 rounded-lg shadow-xl max-w-md mx-4 text-center",children:[jsxRuntimeExports.jsx("h2",{className:"text-2xl font-bold mb-3 text-gray-800",children:compatibilityChecking?"Checking compatibility...":"Cannot access camera"}),jsxRuntimeExports.jsx("div",{className:"mb-4 text-gray-700 text-sm",children:compatibilityChecking?jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-center gap-3",children:[jsxRuntimeExports.jsx("div",{className:"animate-spin inline-block w-8 h-8 border-4 border-blue-200 border-t-blue-600 rounded-full"}),jsxRuntimeExports.jsx("span",{children:"Verifying camera support and permissions..."})]}):jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("p",{className:"mb-3",children:compatibilityError}),diagnosticInfo&&jsxRuntimeExports.jsxs("div",{className:"text-xs text-gray-600 bg-gray-50 p-2 rounded",children:[jsxRuntimeExports.jsxs("div",{children:["Browser: ",diagnosticInfo.browserName]}),jsxRuntimeExports.jsxs("div",{children:["Secure: ",diagnosticInfo.isSecureContext?"Yes":"No"]}),jsxRuntimeExports.jsxs("div",{children:["Protocol: ",diagnosticInfo.protocol]}),diagnosticInfo.isMobile&&jsxRuntimeExports.jsx("div",{children:"Mobile Device: Yes"})]})]})}),!compatibilityChecking&&jsxRuntimeExports.jsxs("div",{className:"flex flex-col gap-3",children:[jsxRuntimeExports.jsxs("div",{className:"flex gap-3",children:[jsxRuntimeExports.jsx("button",{onClick:checkCameraCompatibility,className:"flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded",children:"Retry"}),jsxRuntimeExports.jsx("a",{href:"/README_WEBAR.md",className:"flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-semibold py-2 px-3 rounded",children:"Help"})]}),jsxRuntimeExports.jsx("div",{className:"flex gap-3",children:jsxRuntimeExports.jsx("button",{onClick:()=>setShowDiagnostics(iu=>!iu),className:"flex-1 bg-gray-50 hover:bg-gray-100 text-gray-800 font-medium py-2 px-3 rounded border",children:"Diagnostics"})}),showDiagnostics&&diagnosticInfo&&jsxRuntimeExports.jsxs("div",{className:"text-left mt-3 bg-gray-100 p-3 rounded text-xs",children:[jsxRuntimeExports.jsx("div",{className:"mb-2 font-semibold",children:"Diagnostic info"}),jsxRuntimeExports.jsx("pre",{className:"whitespace-pre-wrap mb-2 text-[10px]",children:JSON.stringify(diagnosticInfo,null,2)}),jsxRuntimeExports.jsxs("div",{className:"flex gap-2",children:[jsxRuntimeExports.jsx("button",{onClick:async()=>{var iu;try{await((iu=navigator.clipboard)==null?void 0:iu.writeText(JSON.stringify(diagnosticInfo,null,2)))}catch(eu){console.error("Failed to copy to clipboard:",eu)}},className:"flex-1 bg-blue-600 hover:bg-blue-700 text-white font-medium py-1 px-2 rounded text-sm",children:"Copy"}),jsxRuntimeExports.jsx("button",{onClick:()=>window.open("https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia","_blank","noopener,noreferrer"),className:"flex-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-2 rounded text-sm",children:"Learn"})]})]})]})]})}),!assetsReady&&jsxRuntimeExports.jsx("div",{className:"absolute inset-0 flex items-center justify-center bg-black/80 z-50",children:jsxRuntimeExports.jsxs("div",{className:"bg-white p-8 rounded-lg shadow-xl max-w-md mx-4 text-center",children:[jsxRuntimeExports.jsx("h2",{className:"text-2xl font-bold mb-3 text-gray-800",children:"Loading WebAR..."}),jsxRuntimeExports.jsx("div",{className:"animate-spin inline-block w-8 h-8 border-4 border-blue-200 border-t-blue-600 rounded-full mb-4"}),jsxRuntimeExports.jsx("p",{className:"text-gray-600 text-sm",children:"Initializing A-Frame and MindAR"})]})}),!fileExists&&assetsReady&&jsxRuntimeExports.jsx("div",{className:"absolute inset-0 flex items-center justify-center bg-black/80 z-50",children:jsxRuntimeExports.jsxs("div",{className:"bg-white p-8 rounded-lg shadow-xl max-w-md mx-4",children:[jsxRuntimeExports.jsx("h2",{className:"text-2xl font-bold mb-4 text-gray-800",children:"Setup Required"}),jsxRuntimeExports.jsxs("div",{className:"space-y-4 text-left",children:[jsxRuntimeExports.jsxs("div",{className:"bg-red-50 p-3 rounded text-sm text-red-700",children:[jsxRuntimeExports.jsx("strong",{children:"targets.mind"})," file not found in /public folder"]}),jsxRuntimeExports.jsx("p",{className:"text-gray-700 text-sm",children:"To get started:"}),jsxRuntimeExports.jsxs("ol",{className:"list-decimal list-inside space-y-2 text-sm text-gray-700",children:[jsxRuntimeExports.jsxs("li",{children:["Go to ",jsxRuntimeExports.jsx("a",{href:"https://hiukim.github.io/mind-ar-js-doc/tools/compile",target:"_blank",rel:"noopener noreferrer",className:"text-blue-600 underline",children:"MindAR Compiler"})]}),jsxRuntimeExports.jsx("li",{children:"Upload a target image (JPG/PNG)"}),jsxRuntimeExports.jsx("li",{children:'Click "Start" to compile'}),jsxRuntimeExports.jsxs("li",{children:["Download ",jsxRuntimeExports.jsx("strong",{children:"targets.mind"})]}),jsxRuntimeExports.jsxs("li",{children:["Add to project's ",jsxRuntimeExports.jsx("strong",{children:"/public"})," folder"]}),jsxRuntimeExports.jsx("li",{children:"Refresh this page"})]}),jsxRuntimeExports.jsx("p",{className:"text-xs text-gray-500 mt-4",children:"Also add video0.mp4 to /public for video playback"})]})]})}),!isStarted&&sceneReady&&canUseCamera&&jsxRuntimeExports.jsx("div",{className:"absolute inset-0 flex items-center justify-center bg-black/50 z-20",children:jsxRuntimeExports.jsxs("div",{className:"bg-white p-6 rounded-lg shadow-xl max-w-md mx-4",children:[jsxRuntimeExports.jsx("h2",{className:"text-xl font-bold mb-3 text-gray-800",children:"Ready to Start AR"}),jsxRuntimeExports.jsxs("ul",{className:"space-y-2 text-gray-700 text-sm",children:[jsxRuntimeExports.jsx("li",{children:" Grant camera permissions when prompted"}),jsxRuntimeExports.jsx("li",{children:" Point camera at your target image"}),jsxRuntimeExports.jsx("li",{children:" Works best in well-lit environments"}),jsxRuntimeExports.jsx("li",{children:" Keep device steady while scanning"}),jsxRuntimeExports.jsx("li",{children:" Video plays automatically on detection"})]}),jsxRuntimeExports.jsx("button",{onClick:handleStart,className:"w-full mt-4 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-colors",children:"Start AR Now"})]})})]})};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var defaultAttributes={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const toKebabCase=iu=>iu.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase().trim(),createLucideIcon=(iu,eu)=>{const tu=reactExports.forwardRef(({color:su="currentColor",size:au=24,strokeWidth:uu=2,absoluteStrokeWidth:du,className:fu="",children:gu,...yu},xu)=>reactExports.createElement("svg",{ref:xu,...defaultAttributes,width:au,height:au,stroke:su,strokeWidth:du?Number(uu)*24/Number(au):uu,className:["lucide",`lucide-${toKebabCase(iu)}`,fu].join(" "),...yu},[...eu.map(([vu,Su])=>reactExports.createElement(vu,Su)),...Array.isArray(gu)?gu:[gu]]));return tu.displayName=`${iu}`,tu};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ArrowLeft=createLucideIcon("ArrowLeft",[["path",{d:"m12 19-7-7 7-7",key:"1l729n"}],["path",{d:"M19 12H5",key:"x3x0zl"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Download=createLucideIcon("Download",[["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["polyline",{points:"7 10 12 15 17 10",key:"2ggqvy"}],["line",{x1:"12",x2:"12",y1:"15",y2:"3",key:"1vk2je"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const FileText=createLucideIcon("FileText",[["path",{d:"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",key:"1rqfz7"}],["path",{d:"M14 2v4a2 2 0 0 0 2 2h4",key:"tnqrlb"}],["path",{d:"M10 9H8",key:"b1mrlr"}],["path",{d:"M16 13H8",key:"t4e002"}],["path",{d:"M16 17H8",key:"z1uh3a"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Image$1=createLucideIcon("Image",[["rect",{width:"18",height:"18",x:"3",y:"3",rx:"2",ry:"2",key:"1m3agn"}],["circle",{cx:"9",cy:"9",r:"2",key:"af1f0g"}],["path",{d:"m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21",key:"1xmnt7"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Loader=createLucideIcon("Loader",[["line",{x1:"12",x2:"12",y1:"2",y2:"6",key:"gza1u7"}],["line",{x1:"12",x2:"12",y1:"18",y2:"22",key:"1qhbu9"}],["line",{x1:"4.93",x2:"7.76",y1:"4.93",y2:"7.76",key:"xae44r"}],["line",{x1:"16.24",x2:"19.07",y1:"16.24",y2:"19.07",key:"bxnmvf"}],["line",{x1:"2",x2:"6",y1:"12",y2:"12",key:"89khin"}],["line",{x1:"18",x2:"22",y1:"12",y2:"12",key:"pb8tfm"}],["line",{x1:"4.93",x2:"7.76",y1:"19.07",y2:"16.24",key:"1uxjnu"}],["line",{x1:"16.24",x2:"19.07",y1:"7.76",y2:"4.93",key:"6duxfx"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Plus=createLucideIcon("Plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Settings2=createLucideIcon("Settings2",[["path",{d:"M20 7h-9",key:"3s1dr2"}],["path",{d:"M14 17H5",key:"gfn3mx"}],["circle",{cx:"17",cy:"17",r:"3",key:"18b49y"}],["circle",{cx:"7",cy:"7",r:"3",key:"dfmy0x"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Settings=createLucideIcon("Settings",[["path",{d:"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",key:"1qme2f"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Sparkles=createLucideIcon("Sparkles",[["path",{d:"m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z",key:"17u4zn"}],["path",{d:"M5 3v4",key:"bklmnn"}],["path",{d:"M19 17v4",key:"iiml17"}],["path",{d:"M3 5h4",key:"nem4j1"}],["path",{d:"M17 19h4",key:"lbex7p"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Trash2=createLucideIcon("Trash2",[["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",key:"4alrt4"}],["path",{d:"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",key:"v07s0e"}],["line",{x1:"10",x2:"10",y1:"11",y2:"17",key:"1uufr5"}],["line",{x1:"14",x2:"14",y1:"11",y2:"17",key:"xtxkd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Upload=createLucideIcon("Upload",[["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["polyline",{points:"17 8 12 3 7 8",key:"t8dd8p"}],["line",{x1:"12",x2:"12",y1:"3",y2:"15",key:"widbto"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Video=createLucideIcon("Video",[["path",{d:"m22 8-6 4 6 4V8Z",key:"50v9me"}],["rect",{width:"14",height:"12",x:"2",y:"6",rx:"2",ry:"2",key:"1rqjg6"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zap=createLucideIcon("Zap",[["polygon",{points:"13 2 3 14 12 14 11 22 21 10 12 10 13 2",key:"45s27k"}]]),STORAGE_KEY="ar_config",AdminPanel=({onClose,onConfigChange})=>{var iu;const[config,setConfig]=reactExports.useState({targets:[],targetsMindUrl:"../uploads/image/targets.mind",targetsMindFile:null,targetsMindFileUrl:null}),[activeTab,setActiveTab]=reactExports.useState("targets"),[uploading,setUploading]=reactExports.useState(!1),[uploadStatus,setUploadStatus]=reactExports.useState("");reactExports.useEffect(()=>{const loadDataFromFile=async()=>{var eu;try{const response=await fetch("/src/data/data.js");if(response.ok){const text=await response.text(),match=text.match(/const arList = (\[[\s\S]*?\]);/);if(match){const arList=eval(match[1]),targets=arList.map((tu,su)=>({id:tu.id||(su+1).toString(),name:tu.name||`Target ${su+1}`,imageFile:null,imageUrl:tu.image||null,videoFile:null,videoUrl:tu.video||null,targetIndex:su})),newConfig={targets,targetsMindUrl:((eu=arList[0])==null?void 0:eu.image)||"../uploads/image/targets.mind",targetsMindFile:null,targetsMindFileUrl:null};setConfig(newConfig),onConfigChange(newConfig);return}}}catch(tu){console.log("Could not load from data.js, trying localStorage:",tu)}const saved=localStorage.getItem(STORAGE_KEY);if(saved)try{const tu=JSON.parse(saved);setConfig(tu),onConfigChange(tu)}catch(tu){console.error("Error loading config:",tu)}};loadDataFromFile()},[]),reactExports.useEffect(()=>{var eu;try{const tu={...config,targets:config.targets.map(au=>{var uu,du,fu,gu;return{...au,imageFile:null,videoFile:null,imageUrl:(uu=au.imageFile)!=null&&uu.size&&au.imageFile.size>5e5||(du=au.imageUrl)!=null&&du.startsWith("blob:")?null:au.imageUrl,videoUrl:(fu=au.videoFile)!=null&&fu.size&&au.videoFile.size>1e6||(gu=au.videoUrl)!=null&&gu.startsWith("blob:")?null:au.videoUrl}}),targetsMindFile:null,targetsMindFileUrl:(eu=config.targetsMindFile)!=null&&eu.size&&config.targetsMindFile.size>5e5?null:config.targetsMindFileUrl},su=JSON.stringify(tu);if(su.length>4e6){console.warn("Config too large for localStorage, storing metadata only");const au={targets:config.targets.map(uu=>{var du,fu,gu,yu;return{id:uu.id,name:uu.name,targetIndex:uu.targetIndex,imageFileName:((du=uu.imageFile)==null?void 0:du.name)||null,imageFileSize:((fu=uu.imageFile)==null?void 0:fu.size)||null,videoFileName:((gu=uu.videoFile)==null?void 0:gu.name)||null,videoFileSize:((yu=uu.videoFile)==null?void 0:yu.size)||null}}),targetsMindUrl:config.targetsMindUrl};localStorage.setItem(STORAGE_KEY,JSON.stringify(au))}else localStorage.setItem(STORAGE_KEY,su);onConfigChange(config)}catch(tu){if(tu.name==="QuotaExceededError"){console.error("localStorage quota exceeded. Large files cannot be stored."),alert("Storage limit exceeded! Large video files cannot be saved to browser storage. Please use smaller files or a backend server for production.");try{const su={targets:config.targets.map(au=>{var uu,du,fu,gu;return{id:au.id,name:au.name,targetIndex:au.targetIndex,imageFileName:((uu=au.imageFile)==null?void 0:uu.name)||null,imageFileSize:((du=au.imageFile)==null?void 0:du.size)||null,videoFileName:((fu=au.videoFile)==null?void 0:fu.name)||null,videoFileSize:((gu=au.videoFile)==null?void 0:gu.size)||null}}),targetsMindUrl:config.targetsMindUrl};localStorage.setItem(STORAGE_KEY,JSON.stringify(su))}catch(su){console.error("Failed to save even metadata:",su)}}else console.error("Error saving to localStorage:",tu)}},[config]);const updateDataJs=eu=>{try{const tu=eu.map((au,uu)=>{const du=au.id||(uu+1).toString();let fu="../uploads/image/targets.mind";if(au.imageFile)if(au.imageFile.name.endsWith(".mind"))fu=`../uploads/image/target${du}.mind`;else{const yu=au.imageFile.name.split(".").pop()||"png";fu=`../uploads/image/target${du}.${yu}`}else au.imageUrl&&(fu=au.imageUrl);const gu=au.videoFile?`../uploads/video/video${uu}.mp4`:au.videoUrl||null;return{id:du,name:au.name||`Target ${du}`,image:fu,video:gu}}),su=`const arList = ${JSON.stringify(tu,null,4)};

export default arList;`;return localStorage.setItem("data_js_content",su),su}catch(tu){return console.error("Error updating data.js:",tu),null}},addTarget=()=>{const eu={id:Date.now().toString(),name:`Target ${config.targets.length+1}`,imageFile:null,imageUrl:null,videoFile:null,videoUrl:null,targetIndex:config.targets.length},tu=[...config.targets,eu];setConfig({...config,targets:tu}),updateDataJs(tu)},removeTarget=eu=>{const tu=config.targets.filter(su=>su.id!==eu);tu.forEach((su,au)=>{su.targetIndex=au}),setConfig({...config,targets:tu}),updateDataJs(tu)},updateTarget=(eu,tu)=>{const su=config.targets.map(au=>au.id===eu?{...au,...tu}:au);setConfig({...config,targets:su}),updateDataJs(su)},handleImageUpload=(eu,tu)=>{const su=new FileReader;su.onload=au=>{var du;const uu=(du=au.target)==null?void 0:du.result;updateTarget(eu,{imageFile:tu,imageUrl:uu})},su.readAsDataURL(tu)},handleVideoUpload=(eu,tu)=>{if(tu.size>5*1024*1024&&!window.confirm(`Warning: This video file is ${(tu.size/1048576).toFixed(2)} MB. Large files may not be saved to browser storage. Continue anyway?`))return;const su=URL.createObjectURL(tu),au=config.targets.map(uu=>uu.id===eu?{...uu,videoFile:tu,videoUrl:su}:uu);setConfig({...config,targets:au}),updateDataJs(au)},downloadTargetsInfo=()=>{const eu={targets:config.targets.map(uu=>({name:uu.name,targetIndex:uu.targetIndex,hasImage:!!uu.imageFile,hasVideo:!!uu.videoFile})),instructions:["1. Go to https://hiukim.github.io/mind-ar-js-doc/tools/compile","2. Upload all your target images (in order)",'3. Click "Start" to compile',"4. Download the targets.mind file","5. Place it in the /public folder","6. Upload videos to /public folder as video0.mp4, video1.mp4, etc."]},tu=new Blob([JSON.stringify(eu,null,2)],{type:"application/json"}),su=URL.createObjectURL(tu),au=document.createElement("a");au.href=su,au.download="ar-targets-config.json",au.click(),URL.revokeObjectURL(su)},exportConfig=()=>{const eu={...config,targets:config.targets.map(uu=>({...uu,imageFile:null,videoFile:null,imageUrl:uu.imageUrl,videoUrl:uu.videoUrl}))},tu=new Blob([JSON.stringify(eu,null,2)],{type:"application/json"}),su=URL.createObjectURL(tu),au=document.createElement("a");au.href=su,au.download="ar-config.json",au.click(),URL.revokeObjectURL(su)},importConfig=eu=>{const tu=new FileReader;tu.onload=su=>{var au;try{const uu=JSON.parse((au=su.target)==null?void 0:au.result);setConfig(uu)}catch(uu){alert("Error importing config: "+uu)}},tu.readAsText(eu)},downloadFile=(eu,tu)=>{const su=URL.createObjectURL(eu),au=document.createElement("a");au.href=su,au.download=tu,document.body.appendChild(au),au.click(),document.body.removeChild(au),URL.revokeObjectURL(su)},saveFilesToUploadFolder=async()=>{setUploading(!0),setUploadStatus("Preparing files...");const eu=[],tu=[],su=[];try{if("showDirectoryPicker"in window)try{setUploadStatus('Please select the "src" folder of your project...');const uu=await window.showDirectoryPicker({mode:"readwrite",startIn:"documents"});let du;try{du=await uu.getDirectoryHandle("uploads",{create:!0})}catch(xu){throw setUploadStatus(" Could not access/create uploads folder"),xu}const fu=await du.getDirectoryHandle("video",{create:!0}),gu=await du.getDirectoryHandle("image",{create:!0});let yu;try{yu=await uu.getDirectoryHandle("data",{create:!0})}catch(xu){console.error("Error accessing data folder:",xu)}for(let xu=0;xu<config.targets.length;xu++){const vu=config.targets[xu],Su=vu.id||(xu+1).toString();if(vu.imageFile){let Iu;if(vu.imageFile.name.endsWith(".mind"))Iu=`target${Su}.mind`,setUploadStatus(`Saving ${Iu} to image folder...`);else{const Mu=vu.imageFile.name.split(".").pop()||"png";Iu=`target${Su}.${Mu}`,setUploadStatus(`Saving image: ${Iu} to image folder...`)}try{const ku=await(await gu.getFileHandle(Iu,{create:!0})).createWritable();await ku.write(vu.imageFile),await ku.close(),eu.push(Iu),setUploadStatus(` ${Iu} saved to image folder`);const Bu=su.findIndex(_u=>_u.id===Su);Bu>=0?su[Bu].image=`../uploads/image/${Iu}`:su.push({id:Su,name:vu.name||`Target ${Su}`,image:`../uploads/image/${Iu}`,video:vu.videoFile?`../uploads/video/video${xu}.mp4`:null})}catch(Mu){console.error(`Error saving ${Iu}:`,Mu),tu.push(Iu)}}if(vu.videoFile){const Iu=`video${xu}.mp4`;setUploadStatus(`Saving video: ${Iu}...`);try{const ku=await(await fu.getFileHandle(Iu,{create:!0})).createWritable();await ku.write(vu.videoFile),await ku.close(),eu.push(Iu);const Bu=su.find(_u=>_u.id===Su);Bu?Bu.video=`../uploads/video/${Iu}`:su.push({id:Su,name:vu.name||`Target ${Su}`,image:null,video:`../uploads/video/${Iu}`})}catch(Mu){console.error(`Error saving ${Iu}:`,Mu),tu.push(Iu)}}}if(yu){setUploadStatus("Updating data.js...");try{let xu=localStorage.getItem("data_js_content");if(!xu){const Iu=config.targets.map((Mu,ku)=>{const Bu=Mu.id||(ku+1).toString();let _u=config.targetsMindUrl;if(Mu.imageFile)if(Mu.imageFile.name.endsWith(".mind"))_u=`../uploads/image/target${Bu}.mind`;else{const Du=Mu.imageFile.name.split(".").pop()||"png";_u=`../uploads/image/target${Bu}.${Du}`}else Mu.imageUrl&&(_u=Mu.imageUrl);const Lu=Mu.videoFile?`../uploads/video/video${ku}.mp4`:Mu.videoUrl||null;return{id:Bu,name:Mu.name||`Target ${Bu}`,image:_u,video:Lu}});xu=`const arList = ${JSON.stringify(Iu,null,4)};

export default arList;`}const Su=await(await yu.getFileHandle("data.js",{create:!0})).createWritable();await Su.write(xu),await Su.close(),eu.push("data.js updated")}catch(xu){console.error("Error updating data.js:",xu),tu.push("data.js")}}eu.length>0?(setUploadStatus(` Successfully saved ${eu.length} file(s) to uploads folder`),tu.length>0&&setUploadStatus(` Saved ${eu.length} file(s), ${tu.length} failed`),setTimeout(()=>setUploadStatus(""),5e3)):tu.length>0?(setUploadStatus(" Failed to save some files"),setTimeout(()=>setUploadStatus(""),5e3)):(setUploadStatus("No files to save"),setTimeout(()=>setUploadStatus(""),3e3))}catch(uu){if(uu.name==="AbortError")setUploadStatus("Save cancelled"),setTimeout(()=>setUploadStatus(""),3e3);else throw uu}else{setUploadStatus("Downloading files... (Please organize in src/uploads/video and src/uploads/image)"),config.targetsMindFile&&(downloadFile(config.targetsMindFile,"targets.mind"),eu.push("targets.mind"),await new Promise(gu=>setTimeout(gu,500)));for(let gu=0;gu<config.targets.length;gu++){const yu=config.targets[gu],xu=yu.id||(gu+1).toString();if(yu.imageFile){let vu;if(yu.imageFile.name.endsWith(".mind"))vu=`target${xu}.mind`;else{const Su=yu.imageFile.name.split(".").pop()||"png";vu=`target${xu}.${Su}`}downloadFile(yu.imageFile,vu),eu.push(vu),setUploadStatus(`Downloading ${vu} (save to src/uploads/image folder)...`),await new Promise(Su=>setTimeout(Su,300))}if(yu.videoFile){const vu=`video${gu}.mp4`;downloadFile(yu.videoFile,vu),eu.push(vu),await new Promise(Su=>setTimeout(Su,500))}}const uu=[];for(let gu=0;gu<config.targets.length;gu++){const yu=config.targets[gu],xu=yu.id||(gu+1).toString();let vu=config.targetsMindUrl;if(yu.imageFile)if(yu.imageFile.name.endsWith(".mind"))vu=`../uploads/image/target${xu}.mind`;else{const Iu=yu.imageFile.name.split(".").pop()||"png";vu=`../uploads/image/target${xu}.${Iu}`}else yu.imageUrl&&(vu=yu.imageUrl);const Su=yu.videoFile?`../uploads/video/video${gu}.mp4`:yu.videoUrl||null;uu.push({id:xu,name:yu.name||`Target ${xu}`,image:vu,video:Su})}const du=`const arList = ${JSON.stringify(uu,null,4)};

export default arList;`,fu=new Blob([du],{type:"application/javascript"});downloadFile(fu,"data.js"),eu.push("data.js"),localStorage.setItem("data_js_content",du),eu.length>0?(setUploadStatus(` Downloaded ${eu.length} file(s). Organize: imagessrc/uploads/image, videossrc/uploads/video, data.jssrc/data`),setTimeout(()=>setUploadStatus(""),8e3)):(setUploadStatus("No files to download"),setTimeout(()=>setUploadStatus(""),3e3))}}catch(au){console.error("Save error:",au),setUploadStatus(" Failed to save files. Trying download method...");try{for(let uu=0;uu<config.targets.length;uu++){const du=config.targets[uu],fu=du.id||(uu+1).toString();if(du.imageFile){let gu;if(du.imageFile.name.endsWith(".mind"))gu=`target${fu}.mind`;else{const yu=du.imageFile.name.split(".").pop()||"png";gu=`target${fu}.${yu}`}downloadFile(du.imageFile,gu),eu.push(gu),await new Promise(yu=>setTimeout(yu,300))}du.videoFile&&(downloadFile(du.videoFile,`video${uu}.mp4`),eu.push(`video${uu}.mp4`),await new Promise(gu=>setTimeout(gu,500)))}eu.length>0&&(setUploadStatus(" Downloaded files. Organize in src/uploads folders"),setTimeout(()=>setUploadStatus(""),7e3))}catch{setUploadStatus(" Failed to save/download files"),setTimeout(()=>setUploadStatus(""),5e3)}}finally{setUploading(!1)}};return jsxRuntimeExports.jsxs("div",{className:"w-full min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-100 pb-12",children:[jsxRuntimeExports.jsxs("div",{className:"relative bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 shadow-xl",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-black/10"}),jsxRuntimeExports.jsx("div",{className:"relative max-w-7xl mx-auto px-6 py-8",children:jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-4",children:[jsxRuntimeExports.jsxs("button",{onClick:onClose,className:"group flex items-center gap-2 bg-white/20 hover:bg-white/30 backdrop-blur-sm text-white px-4 py-2.5 rounded-xl transition-all duration-300 hover:scale-105 shadow-lg",children:[jsxRuntimeExports.jsx(ArrowLeft,{className:"w-5 h-5 group-hover:-translate-x-1 transition-transform"}),jsxRuntimeExports.jsx("span",{className:"font-semibold",children:"Back to AR"})]}),jsxRuntimeExports.jsx("div",{className:"h-12 w-px bg-white/30"}),jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsxs("h1",{className:"text-4xl font-bold text-white mb-1 flex items-center gap-3",children:[jsxRuntimeExports.jsx(Sparkles,{className:"w-8 h-8 text-yellow-300 animate-pulse"}),"AR Admin Panel"]}),jsxRuntimeExports.jsx("p",{className:"text-white/90 text-sm",children:"Manage your AR targets and content"})]})]}),jsxRuntimeExports.jsx("div",{className:"hidden md:flex items-center gap-3",children:jsxRuntimeExports.jsxs("div",{className:"bg-white/20 backdrop-blur-sm px-4 py-2 rounded-xl",children:[jsxRuntimeExports.jsx("div",{className:"text-white/80 text-xs",children:"Total Targets"}),jsxRuntimeExports.jsx("div",{className:"text-white text-2xl font-bold",children:config.targets.length})]})})]})})]}),jsxRuntimeExports.jsx("div",{className:"max-w-7xl mx-auto px-6 -mt-6 relative z-10 pb-12",children:jsxRuntimeExports.jsxs("div",{className:"bg-white rounded-2xl shadow-xl border border-gray-100",children:[jsxRuntimeExports.jsxs("div",{className:"flex bg-gray-50/50",children:[jsxRuntimeExports.jsxs("button",{onClick:()=>setActiveTab("targets"),className:`flex-1 px-6 py-4 font-semibold transition-all duration-300 relative ${activeTab==="targets"?"text-indigo-600 bg-white shadow-md":"text-gray-600 hover:text-gray-900 hover:bg-white/50"}`,children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-center gap-2",children:[jsxRuntimeExports.jsx(Zap,{className:`w-5 h-5 ${activeTab==="targets"?"text-indigo-600":"text-gray-400"}`}),jsxRuntimeExports.jsx("span",{children:"Manage Targets"}),jsxRuntimeExports.jsx("span",{className:`px-2 py-0.5 rounded-full text-xs font-bold ${activeTab==="targets"?"bg-indigo-100 text-indigo-600":"bg-gray-200 text-gray-600"}`,children:config.targets.length})]}),activeTab==="targets"&&jsxRuntimeExports.jsx("div",{className:"absolute bottom-0 left-0 right-0 h-1 bg-gradient-to-r from-indigo-600 to-purple-600"})]}),jsxRuntimeExports.jsxs("button",{onClick:()=>setActiveTab("mind"),className:`flex-1 px-6 py-4 font-semibold transition-all duration-300 relative ${activeTab==="mind"?"text-indigo-600 bg-white shadow-md":"text-gray-600 hover:text-gray-900 hover:bg-white/50"}`,children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-center gap-2",children:[jsxRuntimeExports.jsx(FileText,{className:`w-5 h-5 ${activeTab==="mind"?"text-indigo-600":"text-gray-400"}`}),jsxRuntimeExports.jsx("span",{children:"Setup Guide"})]}),activeTab==="mind"&&jsxRuntimeExports.jsx("div",{className:"absolute bottom-0 left-0 right-0 h-1 bg-gradient-to-r from-indigo-600 to-purple-600"})]})]}),jsxRuntimeExports.jsxs("div",{className:"p-8",children:[activeTab==="targets"&&jsxRuntimeExports.jsxs("div",{className:"space-y-8 animate-fadeIn",children:[jsxRuntimeExports.jsxs("div",{className:"flex flex-wrap justify-between items-center gap-4",children:[jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("h2",{className:"text-3xl font-bold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent",children:"AR Targets Management"}),jsxRuntimeExports.jsx("p",{className:"text-gray-600 mt-1",children:"Create and manage your AR tracking targets"})]}),jsxRuntimeExports.jsxs("div",{className:"flex flex-wrap gap-3",children:[jsxRuntimeExports.jsxs("button",{onClick:exportConfig,className:"group flex items-center gap-2 bg-gradient-to-r from-emerald-500 to-teal-600 hover:from-emerald-600 hover:to-teal-700 text-white px-5 py-2.5 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105",children:[jsxRuntimeExports.jsx(Download,{className:"w-4 h-4 group-hover:animate-bounce"}),jsxRuntimeExports.jsx("span",{className:"font-semibold",children:"Export"})]}),jsxRuntimeExports.jsxs("label",{className:"group flex items-center gap-2 bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white px-5 py-2.5 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 cursor-pointer",children:[jsxRuntimeExports.jsx(Upload,{className:"w-4 h-4 group-hover:animate-bounce"}),jsxRuntimeExports.jsx("span",{className:"font-semibold",children:"Import"}),jsxRuntimeExports.jsx("input",{type:"file",accept:".json",className:"hidden",onChange:eu=>{var su;const tu=(su=eu.target.files)==null?void 0:su[0];tu&&importConfig(tu)}})]}),jsxRuntimeExports.jsxs("button",{onClick:addTarget,className:"group flex items-center gap-2 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-6 py-2.5 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 font-semibold",children:[jsxRuntimeExports.jsx(Plus,{className:"w-5 h-5 group-hover:rotate-90 transition-transform duration-300"}),"Add Target"]}),jsxRuntimeExports.jsx("button",{onClick:saveFilesToUploadFolder,disabled:uploading,className:"group flex items-center gap-2 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 disabled:from-gray-400 disabled:to-gray-500 text-white px-6 py-2.5 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 font-semibold disabled:cursor-not-allowed",children:uploading?jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(Loader,{className:"w-5 h-5 animate-spin"}),jsxRuntimeExports.jsx("span",{children:"Saving..."})]}):jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(Download,{className:"w-5 h-5 group-hover:animate-bounce"}),jsxRuntimeExports.jsx("span",{children:"Save Files"})]})})]}),uploadStatus&&jsxRuntimeExports.jsx("div",{className:`mt-3 px-4 py-2 rounded-lg text-sm font-medium ${uploadStatus.includes("")?"bg-green-50 text-green-700 border border-green-200":uploadStatus.includes("")||uploadStatus.includes("Failed")?"bg-red-50 text-red-700 border border-red-200":"bg-blue-50 text-blue-700 border border-blue-200"}`,children:uploadStatus})]}),config.targets.length===0?jsxRuntimeExports.jsxs("div",{className:"text-center py-20 bg-gradient-to-br from-white to-indigo-50 rounded-2xl border-2 border-dashed border-indigo-200",children:[jsxRuntimeExports.jsx("div",{className:"inline-flex items-center justify-center w-24 h-24 bg-gradient-to-br from-indigo-100 to-purple-100 rounded-full mb-6",children:jsxRuntimeExports.jsx(Image$1,{className:"w-12 h-12 text-indigo-600"})}),jsxRuntimeExports.jsx("h3",{className:"text-2xl font-bold text-gray-800 mb-2",children:"No targets yet"}),jsxRuntimeExports.jsx("p",{className:"text-gray-600 mb-6 max-w-md mx-auto",children:"Start by adding your first AR target. Upload an image for tracking and a video to display."}),jsxRuntimeExports.jsxs("button",{onClick:addTarget,className:"group inline-flex items-center gap-2 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-8 py-4 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 font-semibold text-lg",children:[jsxRuntimeExports.jsx(Plus,{className:"w-6 h-6 group-hover:rotate-90 transition-transform duration-300"}),"Add Your First Target"]})]}):jsxRuntimeExports.jsx("div",{className:"grid gap-6 md:grid-cols-2 lg:grid-cols-3",children:config.targets.map((eu,tu)=>{var su,au,uu,du;return jsxRuntimeExports.jsxs("div",{className:"group relative bg-white rounded-2xl p-6 border border-gray-200 hover:border-indigo-300 hover:shadow-2xl transition-all duration-300 overflow-hidden",style:{animationDelay:`${tu*50}ms`},children:[jsxRuntimeExports.jsx("div",{className:"absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500"}),jsxRuntimeExports.jsxs("div",{className:"flex justify-between items-start mb-6",children:[jsxRuntimeExports.jsxs("div",{className:"flex-1",children:[jsxRuntimeExports.jsx("input",{type:"text",value:eu.name,onChange:fu=>updateTarget(eu.id,{name:fu.target.value}),className:"text-xl font-bold border-none outline-none bg-transparent text-gray-800 w-full placeholder-gray-400 focus:text-indigo-600 transition-colors",placeholder:"Target name"}),jsxRuntimeExports.jsx("div",{className:"flex items-center gap-2 mt-1",children:jsxRuntimeExports.jsxs("span",{className:"text-xs font-semibold px-2 py-0.5 bg-indigo-100 text-indigo-700 rounded-full",children:["Index: ",eu.targetIndex]})})]}),jsxRuntimeExports.jsx("button",{onClick:()=>removeTarget(eu.id),className:"p-2 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-all duration-200 group",children:jsxRuntimeExports.jsx(Trash2,{className:"w-5 h-5 group-hover:scale-110 transition-transform"})})]}),jsxRuntimeExports.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-5",children:[jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsxs("label",{className:"block text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2",children:[jsxRuntimeExports.jsx(Image$1,{className:"w-4 h-4 text-indigo-600"}),"Tracking Image"]}),jsxRuntimeExports.jsx("div",{className:"flex gap-2 flex-col",children:eu.imageUrl||eu.imageFile?jsxRuntimeExports.jsxs("div",{className:"flex-1",children:[jsxRuntimeExports.jsxs("div",{className:"relative group/image",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gradient-to-t from-black/50 to-transparent opacity-0 group-hover/image:opacity-100 transition-opacity rounded-xl"}),(su=eu.imageFile)!=null&&su.name.endsWith(".mind")||eu.imageUrl&&eu.imageUrl.endsWith(".mind")?jsxRuntimeExports.jsxs("div",{className:"w-full h-40 bg-gradient-to-br from-indigo-100 to-purple-100 rounded-xl border-2 border-indigo-300 shadow-md flex items-center justify-center flex-col p-4",children:[jsxRuntimeExports.jsx(FileText,{className:"w-12 h-12 text-indigo-600 mb-2"}),jsxRuntimeExports.jsx("span",{className:"text-sm font-semibold text-indigo-700",children:((au=eu.imageFile)==null?void 0:au.name)||((uu=eu.imageUrl)==null?void 0:uu.split("/").pop())||"targets.mind file"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-indigo-600 mt-1",children:".mind file"})]}):eu.imageFile?jsxRuntimeExports.jsx("img",{src:eu.imageUrl||URL.createObjectURL(eu.imageFile),alt:eu.name,className:"w-full h-40 object-cover rounded-xl border-2 border-gray-200 shadow-md"}):eu.imageUrl?jsxRuntimeExports.jsxs("div",{className:"w-full h-40 bg-gradient-to-br from-indigo-100 to-purple-100 rounded-xl border-2 border-indigo-300 shadow-md flex items-center justify-center flex-col p-4",children:[jsxRuntimeExports.jsx(Image$1,{className:"w-12 h-12 text-indigo-600 mb-2"}),jsxRuntimeExports.jsx("span",{className:"text-sm font-semibold text-indigo-700 truncate px-2",title:eu.imageUrl,children:eu.imageUrl.split("/").pop()||"Image selected"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-indigo-600 mt-1",children:"Image path configured"})]}):null,jsxRuntimeExports.jsx("button",{onClick:()=>updateTarget(eu.id,{imageFile:null,imageUrl:null}),className:"absolute top-2 right-2 bg-red-500 hover:bg-red-600 text-white rounded-full p-2 opacity-0 group-hover/image:opacity-100 transition-all duration-200 shadow-lg hover:scale-110",children:jsxRuntimeExports.jsx(Trash2,{className:"w-4 h-4"})})]}),eu.imageFile&&jsxRuntimeExports.jsxs("div",{className:"mt-2 px-3 py-1.5 bg-indigo-50 rounded-lg border border-indigo-200",children:[jsxRuntimeExports.jsxs("p",{className:"text-xs font-medium text-indigo-700 truncate",title:eu.imageFile.name,children:[" ",eu.imageFile.name]}),jsxRuntimeExports.jsxs("p",{className:"text-xs text-indigo-600 mt-0.5",children:[(eu.imageFile.size/1024).toFixed(2)," KB"]})]}),eu.imageUrl&&!eu.imageFile&&jsxRuntimeExports.jsxs("div",{className:"mt-2 px-3 py-1.5 bg-indigo-50 rounded-lg border border-indigo-200",children:[jsxRuntimeExports.jsxs("p",{className:"text-xs font-medium text-indigo-700 truncate",title:eu.imageUrl,children:[" ",eu.imageUrl.split("/").pop()||eu.imageUrl]}),jsxRuntimeExports.jsx("p",{className:"text-xs text-indigo-600 mt-0.5",children:"Path configured"})]})]}):jsxRuntimeExports.jsxs("label",{className:"flex-1 border-2 border-dashed border-indigo-300 rounded-xl p-6 text-center cursor-pointer hover:border-indigo-500 hover:bg-indigo-50/50 transition-all duration-300 group",children:[jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center",children:[jsxRuntimeExports.jsx("div",{className:"w-12 h-12 bg-gradient-to-br from-indigo-100 to-purple-100 rounded-full flex items-center justify-center mb-3 group-hover:scale-110 transition-transform",children:jsxRuntimeExports.jsx(Image$1,{className:"w-6 h-6 text-indigo-600"})}),jsxRuntimeExports.jsx("span",{className:"text-sm font-medium text-gray-700",children:"Upload Image"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-gray-500 mt-1",children:"JPG, PNG, or .mind file"})]}),jsxRuntimeExports.jsx("input",{type:"file",accept:"image/*,.mind",className:"hidden",onChange:fu=>{var yu;const gu=(yu=fu.target.files)==null?void 0:yu[0];gu&&handleImageUpload(eu.id,gu)}})]})}),jsxRuntimeExports.jsxs("p",{className:"text-xs text-gray-500 mt-2 flex items-center gap-1",children:[jsxRuntimeExports.jsx("span",{className:"w-1.5 h-1.5 bg-indigo-400 rounded-full"}),(du=eu.imageFile)!=null&&du.name.endsWith(".mind")?"targets.mind file uploaded successfully":"Use high-contrast images for best tracking"]})]}),jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsxs("label",{className:"block text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2",children:[jsxRuntimeExports.jsx(Video,{className:"w-4 h-4 text-purple-600"}),"AR Video Content"]}),jsxRuntimeExports.jsx("div",{className:"flex gap-2 flex-col",children:eu.videoUrl||eu.videoFile?jsxRuntimeExports.jsxs("div",{className:"flex-1",children:[jsxRuntimeExports.jsxs("div",{className:"relative group/video",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gradient-to-t from-black/50 to-transparent opacity-0 group-hover/video:opacity-100 transition-opacity rounded-xl"}),eu.videoFile?jsxRuntimeExports.jsx("video",{src:eu.videoUrl||URL.createObjectURL(eu.videoFile),className:"w-full h-40 object-cover rounded-xl border-2 border-gray-200 shadow-md",controls:!1,muted:!0,loop:!0}):eu.videoUrl?eu.videoUrl.startsWith("../")||eu.videoUrl.startsWith("/src/")?jsxRuntimeExports.jsxs("div",{className:"w-full h-40 bg-gradient-to-br from-purple-100 to-pink-100 rounded-xl border-2 border-purple-300 shadow-md flex items-center justify-center flex-col p-4",children:[jsxRuntimeExports.jsx(Video,{className:"w-12 h-12 text-purple-600 mb-2"}),jsxRuntimeExports.jsx("span",{className:"text-sm font-semibold text-purple-700 truncate px-2",title:eu.videoUrl,children:eu.videoUrl.split("/").pop()||"Video selected"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-purple-600 mt-1",children:"Video path configured"})]}):jsxRuntimeExports.jsxs("div",{className:"w-full h-40 bg-gradient-to-br from-purple-100 to-pink-100 rounded-xl border-2 border-purple-300 shadow-md flex items-center justify-center flex-col p-4",children:[jsxRuntimeExports.jsx(Video,{className:"w-12 h-12 text-purple-600 mb-2"}),jsxRuntimeExports.jsx("span",{className:"text-sm font-semibold text-purple-700 truncate px-2",title:eu.videoUrl,children:eu.videoUrl.split("/").pop()||"Video selected"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-purple-600 mt-1",children:"Video path configured"})]}):null,jsxRuntimeExports.jsxs("div",{className:"absolute top-2 right-2 flex gap-2 opacity-0 group-hover/video:opacity-100 transition-all duration-200",children:[eu.videoFile&&jsxRuntimeExports.jsx("a",{href:eu.videoUrl||URL.createObjectURL(eu.videoFile),download:`video${eu.targetIndex||0}.mp4`,className:"bg-blue-500 hover:bg-blue-600 text-white rounded-full p-2 shadow-lg hover:scale-110 transition-all duration-200",title:"Download",children:jsxRuntimeExports.jsx(Download,{className:"w-4 h-4"})}),jsxRuntimeExports.jsx("button",{onClick:()=>updateTarget(eu.id,{videoFile:null,videoUrl:null}),className:"bg-red-500 hover:bg-red-600 text-white rounded-full p-2 shadow-lg hover:scale-110 transition-all duration-200",children:jsxRuntimeExports.jsx(Trash2,{className:"w-4 h-4"})})]})]}),eu.videoFile&&jsxRuntimeExports.jsxs("div",{className:"mt-2 px-3 py-1.5 bg-purple-50 rounded-lg border border-purple-200",children:[jsxRuntimeExports.jsxs("p",{className:"text-xs font-medium text-purple-700 truncate",title:eu.videoFile.name,children:[" ",eu.videoFile.name]}),jsxRuntimeExports.jsxs("p",{className:"text-xs text-purple-600 mt-0.5",children:[(eu.videoFile.size/(1024*1024)).toFixed(2)," MB"]})]}),eu.videoUrl&&!eu.videoFile&&jsxRuntimeExports.jsxs("div",{className:"mt-2 px-3 py-1.5 bg-purple-50 rounded-lg border border-purple-200",children:[jsxRuntimeExports.jsxs("p",{className:"text-xs font-medium text-purple-700 truncate",title:eu.videoUrl,children:[" ",eu.videoUrl.split("/").pop()||eu.videoUrl]}),jsxRuntimeExports.jsx("p",{className:"text-xs text-purple-600 mt-0.5",children:"Path configured"})]})]}):jsxRuntimeExports.jsxs("label",{className:"flex-1 border-2 border-dashed border-purple-300 rounded-xl p-6 text-center cursor-pointer hover:border-purple-500 hover:bg-purple-50/50 transition-all duration-300 group",children:[jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center",children:[jsxRuntimeExports.jsx("div",{className:"w-12 h-12 bg-gradient-to-br from-purple-100 to-pink-100 rounded-full flex items-center justify-center mb-3 group-hover:scale-110 transition-transform",children:jsxRuntimeExports.jsx(Video,{className:"w-6 h-6 text-purple-600"})}),jsxRuntimeExports.jsx("span",{className:"text-sm font-medium text-gray-700",children:"Upload Video"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-gray-500 mt-1",children:"MP4, WebM"})]}),jsxRuntimeExports.jsx("input",{type:"file",accept:"video/*",className:"hidden",onChange:fu=>{var yu;const gu=(yu=fu.target.files)==null?void 0:yu[0];gu&&handleVideoUpload(eu.id,gu)}})]})}),jsxRuntimeExports.jsxs("p",{className:"text-xs text-gray-500 mt-2 flex items-center gap-1",children:[jsxRuntimeExports.jsx("span",{className:"w-1.5 h-1.5 bg-purple-400 rounded-full"}),"Saves as: ",jsxRuntimeExports.jsxs("code",{className:"bg-gray-100 px-1.5 py-0.5 rounded",children:["video",eu.targetIndex||0,".mp4"]})]})]})]})]},eu.id)})})]}),activeTab==="mind"&&jsxRuntimeExports.jsxs("div",{className:"space-y-8 animate-fadeIn",children:[jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("h2",{className:"text-3xl font-bold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent mb-2",children:"Setup Guide"}),jsxRuntimeExports.jsx("p",{className:"text-gray-600",children:"Follow these steps to compile and configure your AR targets"})]}),jsxRuntimeExports.jsxs("div",{className:"bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-2xl p-8 shadow-lg",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-3 mb-6",children:[jsxRuntimeExports.jsx("div",{className:"w-12 h-12 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-lg",children:jsxRuntimeExports.jsx(FileText,{className:"w-6 h-6 text-white"})}),jsxRuntimeExports.jsx("h3",{className:"text-2xl font-bold text-gray-800",children:"Step-by-Step Instructions"})]}),jsxRuntimeExports.jsx("ol",{className:"space-y-4",children:[{step:"Visit MindAR Compiler",link:"https://hiukim.github.io/mind-ar-js-doc/tools/compile",text:"Go to the MindAR Image Compiler"},{step:"Upload Images",text:"Upload all your target images in order (Target 0, Target 1, Target 2, etc.)"},{step:"Compile",text:'Click "Start" to compile all images into one targets.mind file'},{step:"Download",text:"Download the generated targets.mind file"},{step:"Place File",text:"Place the targets.mind file in your /public folder"},{step:"Upload Videos",text:"Upload your videos to /public folder as video0.mp4, video1.mp4, etc."}].map((eu,tu)=>jsxRuntimeExports.jsxs("li",{className:"flex gap-4",children:[jsxRuntimeExports.jsx("div",{className:"flex-shrink-0 w-8 h-8 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-full flex items-center justify-center font-bold shadow-md",children:tu+1}),jsxRuntimeExports.jsxs("div",{className:"flex-1 pt-1",children:[jsxRuntimeExports.jsxs("span",{className:"text-gray-800 font-medium",children:[eu.step,": "]}),eu.link?jsxRuntimeExports.jsx("a",{href:eu.link,target:"_blank",rel:"noopener noreferrer",className:"text-indigo-600 hover:text-indigo-700 underline font-semibold",children:eu.text}):jsxRuntimeExports.jsx("span",{className:"text-gray-700",children:eu.text})]})]},tu))})]}),jsxRuntimeExports.jsxs("div",{className:"bg-white border-2 border-gray-200 rounded-2xl p-8 shadow-lg",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-3 mb-6",children:[jsxRuntimeExports.jsx("div",{className:"w-12 h-12 bg-gradient-to-br from-gray-500 to-gray-700 rounded-xl flex items-center justify-center shadow-lg",children:jsxRuntimeExports.jsx(Settings2,{className:"w-6 h-6 text-white"})}),jsxRuntimeExports.jsx("h3",{className:"text-2xl font-bold text-gray-800",children:"Current Configuration"})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-4",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between p-4 bg-gradient-to-r from-gray-50 to-indigo-50 rounded-xl",children:[jsxRuntimeExports.jsx("span",{className:"text-gray-700 font-medium",children:"Number of Targets:"}),jsxRuntimeExports.jsx("span",{className:"px-4 py-2 bg-indigo-600 text-white rounded-lg font-bold text-lg shadow-md",children:config.targets.length})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-4",children:[jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("label",{className:"block text-sm font-semibold text-gray-700",children:"Upload targets.mind File:"}),config.targetsMindFileUrl?jsxRuntimeExports.jsx("div",{className:"relative p-4 bg-gradient-to-br from-indigo-50 to-purple-50 rounded-xl border-2 border-indigo-200",children:jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-3",children:[jsxRuntimeExports.jsx(FileText,{className:"w-8 h-8 text-indigo-600"}),jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("div",{className:"font-semibold text-gray-800",children:((iu=config.targetsMindFile)==null?void 0:iu.name)||"targets.mind"}),jsxRuntimeExports.jsx("div",{className:"text-xs text-gray-600",children:"File uploaded successfully"})]})]}),jsxRuntimeExports.jsx("button",{onClick:()=>setConfig({...config,targetsMindFile:null,targetsMindFileUrl:null,targetsMindUrl:"../uploads/image/targets.mind"}),className:"bg-red-500 hover:bg-red-600 text-white rounded-lg p-2 transition-colors",children:jsxRuntimeExports.jsx(Trash2,{className:"w-4 h-4"})})]})}):jsxRuntimeExports.jsxs("label",{className:"flex border-2 border-dashed border-indigo-300 rounded-xl p-6 text-center cursor-pointer hover:border-indigo-500 hover:bg-indigo-50/50 transition-all duration-300 group",children:[jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center w-full",children:[jsxRuntimeExports.jsx("div",{className:"w-12 h-12 bg-gradient-to-br from-indigo-100 to-purple-100 rounded-full flex items-center justify-center mb-3 group-hover:scale-110 transition-transform",children:jsxRuntimeExports.jsx(FileText,{className:"w-6 h-6 text-indigo-600"})}),jsxRuntimeExports.jsx("span",{className:"text-sm font-medium text-gray-700",children:"Upload targets.mind file"}),jsxRuntimeExports.jsx("span",{className:"text-xs text-gray-500 mt-1",children:"Click to upload .mind file"})]}),jsxRuntimeExports.jsx("input",{type:"file",accept:".mind",className:"hidden",onChange:eu=>{var su;const tu=(su=eu.target.files)==null?void 0:su[0];if(tu){const au=new FileReader;au.onload=uu=>{var fu;const du=(fu=uu.target)==null?void 0:fu.result;setConfig({...config,targetsMindFile:tu,targetsMindFileUrl:du,targetsMindUrl:tu.name})},au.readAsDataURL(tu)}}})]})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("label",{className:"block text-sm font-semibold text-gray-700",children:"Targets.mind URL (fallback):"}),jsxRuntimeExports.jsx("input",{type:"text",value:config.targetsMindUrl,onChange:eu=>setConfig({...config,targetsMindUrl:eu.target.value}),className:"w-full px-4 py-3 border-2 border-gray-300 rounded-xl focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 transition-all outline-none",placeholder:"/targets.mind"}),jsxRuntimeExports.jsx("p",{className:"text-xs text-gray-500",children:"Used if file is not uploaded"})]})]})]})]}),jsxRuntimeExports.jsxs("div",{className:"bg-gradient-to-br from-amber-50 to-yellow-50 border-2 border-amber-200 rounded-2xl p-8 shadow-lg",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-3 mb-4",children:[jsxRuntimeExports.jsx("div",{className:"w-10 h-10 bg-gradient-to-br from-amber-500 to-orange-600 rounded-lg flex items-center justify-center shadow-md",children:jsxRuntimeExports.jsx("span",{className:"text-2xl",children:""})}),jsxRuntimeExports.jsx("h3",{className:"text-xl font-bold text-amber-900",children:"Important Notes"})]}),jsxRuntimeExports.jsx("ul",{className:"space-y-3 text-amber-800",children:["The targets.mind file must contain all images in the same order as your targets","Video files must be named exactly as video0.mp4, video1.mp4, etc. (matching target indices)","For production, you'll need a backend server to handle file uploads","Currently, uploaded files are stored in browser localStorage (limited size)"].map((eu,tu)=>jsxRuntimeExports.jsxs("li",{className:"flex items-start gap-3",children:[jsxRuntimeExports.jsx("span",{className:"w-1.5 h-1.5 bg-amber-500 rounded-full mt-2 flex-shrink-0"}),jsxRuntimeExports.jsx("span",{children:eu})]},tu))})]}),jsxRuntimeExports.jsxs("button",{onClick:downloadTargetsInfo,className:"w-full bg-gradient-to-r from-emerald-500 to-teal-600 hover:from-emerald-600 hover:to-teal-700 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-[1.02] flex items-center justify-center gap-3 text-lg",children:[jsxRuntimeExports.jsx(Download,{className:"w-6 h-6"}),"Download Targets Info (JSON)"]})]})]})]})})]})};function App(){const[iu,eu]=reactExports.useState(!1),[tu,su]=reactExports.useState(null),au=fu=>{console.log(`Target ${fu} detected - video should play`)},uu=fu=>{console.log(`Target ${fu} lost - video should pause`)},du=fu=>{su(fu)};return jsxRuntimeExports.jsx("div",{className:`w-full ${iu?"h-screen overflow-y-auto":"h-screen overflow-hidden"} relative`,children:iu?jsxRuntimeExports.jsx(AdminPanel,{onClose:()=>eu(!1),onConfigChange:du}):jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(WebAR,{onTargetFound:au,onTargetLost:uu,config:tu||void 0}),jsxRuntimeExports.jsxs("button",{onClick:()=>eu(!0),className:"fixed top-4 right-4 z-50 bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full shadow-lg transition-colors flex items-center gap-2",title:"Open Admin Panel",children:[jsxRuntimeExports.jsx(Settings,{className:"w-5 h-5"}),jsxRuntimeExports.jsx("span",{className:"hidden md:inline",children:"Admin"})]})]})})}createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(reactExports.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
